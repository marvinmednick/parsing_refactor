{
  "filename": "etsi_test.pdf",
  "metadata": {
    "Author": "MTS",
    "CreationDate": "D:20210511095944+02'00'",
    "Creator": "ETSI Secretariat",
    "Keywords": "security, testing",
    "ModDate": "D:20210517140711+02'00'",
    "Producer": "Acrobat Distiller 10.0.0 (Windows)",
    "Subject": "TS 103 596-2 - V1.1.1",
    "Title": "TS 103 596-2 - V1.1.1 - Methods for Testing and Specification (MTS); Test Specification for CoAP; Part 2: Security Tests"
  },
  "sections": [
    {
      "section_title": "1  Scope",
      "section_text": "The present document provides general security considerations and guidelines about the Constrained Application \nProtocol (CoAP). The collective ideas presented in the present document are enriched with example Test Purposes \n(TPs) to outline possible implementations.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "2  References",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "2.1  Normative references",
      "section_text": "References are either specific (identified by date of publication and/or edition number or version number) or \nnon-specific. For specific references, only the cited version applies. For non-specific references, the latest version of the \nreferenced document (including any amendments) applies. \nReferenced documents which are not found to be publicly available in the expected location might be found at \nhttps://docbox.etsi.org/Reference/. \nNOTE:  While any hyperlinks included in this clause were valid at the time of publication, ETSI cannot guarantee \ntheir long term validity. \nThe following referenced documents are necessary for the application of the present document. \n[1]  IETF RFC 7252: \"The Constrained Application Protocol (CoAP)\". \n[2]  ETSI ES 203 119-4: \"Methods for Testing and Specification (MTS); The Test Description \nLanguage (TDL); Part 4: Structured Test Objective Specification (Extension)\". \n[3]  IETF RFC 8323: \"CoAP (Constrained Application Protocol) over TCP, TLS, and WebSockets\". \n[4]  ETSI TS 103 596-1: \"Methods for Testing and Specification (MTS); Test Specification for CoAP; \nPart 1: Conformance Tests\".",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          2
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "2.2  Informative references",
      "section_text": "References are either specific (identified by date of publication and/or edition number or version number) or \nnon-specific. For specific references, only the cited version applies. For non-specific references, the latest version of the \nreferenced document (including any amendments) applies. \nNOTE:  While any hyperlinks included in this clause were valid at the time of publication, ETSI cannot guarantee \ntheir long term validity. \nThe following referenced documents are not necessary for the application of the present document but they assist the \nuser with regard to a particular subject area. \n[i.1]  Eclipse IoT-Testware v.0.1.0. \nNOTE:  Available at https://projects.eclipse.org/projects/technology.iottestware. \n[i.2]  ETSI ES 202 951: \"Methods for Testing and Specification (MTS); Model-Based Testing (MBT); \nRequirements for Modelling Notations\". \n[i.3]  ETSI TS 103 646: \"Methods for Testing and Specification (MTS); Test specification for \nfoundational Security IoT-Profile\". \n[i.4]  IEC 62443-4-2: \"Security for industrial automation and control systems. Technical security \nrequirements for IACS components\". \n[i.5]  CVE-2018-14367. \nNOTE:  Available at https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-14367. \nETSI \n    6 ETSI TS 103 596-2 V1.1.1 (2021-05)\n[i.6]  CVE-2019-12101. \nNOTE:  Available at https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12101. \n[i.7]  ETSI TR 101 583: \"Methods for Testing and Specification (MTS); Security Testing; Basic \nTerminology\".",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          2
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3  Definition of terms, symbols and abbreviations",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.1  Terms",
      "section_text": "For the purposes of the present document, the following terms apply: \nblack-box testing: testing activity conducted without knowledge of the internal structure of the system under test \ngrey-box testing: testing activity conducted with a partial knowledge of the internal structure of a system under test \nSystem Under Test (SUT): real open system in which the implementation under test resides \nNOTE:  Definition of term from ETSI ES 202 951 [i.2]. \nwhite-box testing: testing based on an analysis of the internal structure of the component or system under test",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.2  Symbols",
      "section_text": "Void.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.3  Abbreviations",
      "section_text": "For the purposes of the present document, the following abbreviations apply: \nAUT  Authentication/Authorization \nCoAP  Constraint Application Protocol \nCON  CoAP Confirmable message \nCVE  Common Vulnerabilities and Exposures \nDoS   Denial of Service \nIP      Internet Protocol \nIUT  Implementation Under Test \nJSON  Java Script Object Notation \nMITM  Man-In-The-Middle \nPICS  Protocol Conformance Implementation Statement \nSEC  Security \nSQL  Standard Query Language \nSUT  System Under Test \nTDL  Test Description Language \nTDL-TO  Test Description Language - Test Objectives \nTP  Test Purpose \nTSS  Test Suite Structure \nUTF  Universal coded character set Transformation Format \nXOR  Exclusive Or \nETSI \n    7 ETSI TS 103 596-2 V1.1.1 (2021-05)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "4  Security Test Objectives",
      "section_text": "When talking about security test objectives it is meant that assets are worth protecting. This clause does not focus on \nhow to protect those assets but raising awareness when it comes to implementing the protocol, especially within an IoT \nenvironment. Of course, the following list does not claim to be complete. Prior to this, all environmental conditions, \nsuch as the domain and location, should be clarified beforehand. \nIntegrity in the present document is more related to data integrity. It should be possible to answer questions like: Is the \ntrustworthiness of the data given? Do the data have integrity? Were the data transmitted without manipulation?  \nAvailability refers to the requirement that the system available in general. DoS attacks should not lead to an unavailable \nsystem. It is not expected to get unusual setbacks for system performance because the system should operate at least \nwith basic functionalities. \nRobustness refers to the ability to be resilient against (unexpected) situations like receiving malformed data or \ncommunication flows with correct data. Robustness and Availability are closely related. In addition, performance \nconsiderations are related to robustness because of the mere amount of input data.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          4
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5  Security testing techniques (preliminary",
      "section_text": "consideration)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.1  Fuzz Testing",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.1.1  General Description",
      "section_text": "Fuzzing is an effective negative black box testing method of finding unknown vulnerabilities in software. A System \nUnder Test (SUT) is exposed via its interfaces to unexpected data. The idea is to send partially invalid data to get the \nsystem into an unexpected state. Inputs are generated randomly or systematically by mutating valid data or creating new \ndata according to specifications. Most of the input is rejected because of internal validation mechanisms of the system. \nThose rejected inputs are considered ineffective since their execution doesn't lead to the possibility of exposing \nweakness which reduces the overall effectiveness of a fuzzing campaign. Model-based security testing does target this \nissue by generating test cases according to the systems model.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          1
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.1.2  Example Approach",
      "section_text": "Figure 1: Fuzzing configuration \nOne possible application of the fuzzing approach can be found in the Eclipse IoT-Testware project [i.1] that implement \na fuzzing proxy. The Fuzzing Proxy is a MITM (Man-In-The-Middle) Fuzzer which is capable of proxying the network \ntraffic between two systems and altering this traffic on behalf of predefined rules. The Fuzzing Proxy does not generate \nany message on its own. To trigger the procedure, (more or less) valid templates need to be provided. \nThe approach follows a 5-step fuzzing workflow (see figure 2) that is described in the following.  \nETSI \n    8 ETSI TS 103 596-2 V1.1.1 (2021-05)\n \nFigure 2: Fuzzing workflow \nStep 1 Identify the SUT and step 2 Identify input fields are characterized together. The first step is to identify if the SUT \nis in the correct scope where objectives with fuzzing will be achieved. Identifying input fields and corresponding \nmutators for the fuzzing session is probably the most challenging part in the whole workflow. In the referred example \n(see Eclipse IoT-Testware [i.1]) interesting input fields can be chosen and corresponding mutators defined in the \nconfiguration file. The configuration file provided to the Fuzzing Proxy contains abstract fuzzing instructions which are \nused at runtime for manipulation of proxied messages. The configuration file is a plain JSON file following a specific \nschema. \nStep 3 is to choose a test data generator. As stated above, the fuzzing solution does not generate any test data but \nmanipulate given test data. That is why it needs a test data generator. This can be a simple client connecting to the SUT \nand sending request messages or other test solutions like the ones provided by the IoT-Testware. \nStep 4 is the actual fuzzing by means of manipulating the incoming test data. Concepts used here are mainly mutators \nand filter. Fuzzing Mutators are one of the basic concepts of the Fuzzing Proxy. It mutates (changes) the input based on \ndifferent rules. In other words, unary or binary operators are applied to change the incoming message. Unary Operators, \nlike NOT, as the name implies, are unary with respect to the number of parameters which they expect. An unary \noperator expects only one single parameter. It takes the value of the specified field (as the one and only parameter) and \napplies a fuzzing operation on it. Binary Operators on the other hand, like XOR, take two parameters, the value of the \nspecified field and either a fixed value or a generator as the second parameter. Next to mutators, filters are the second \nbuilding blocks on the path of building fuzzing rules. These fuzzing filters are conceptually very similar to Wireshark's \nDisplayFilters and serve pretty much the same purpose. As one might want to intercept more complex protocol \nbehaviours, altering each single message would be a bad idea. The concept of filters allows the user to pick only \nspecific messages for fuzzing, while other messages not matching any filter are simply passed through without being \nfuzzed. \nThe last step is to analyse the fuzzing logging. By having the log information, further evaluate potential flaws or precise \nprotocol violations can be checked.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          1
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.1.3  CoAP-specific Considerations",
      "section_text": "Regarding CoAP, different message fields can be considered for the fuzzing approach. The fixed-size 4-byte header can \nbe started with. Most of its fields are defined with fixed values or ranges. Exhausting non-defined or reserved values \nwithin the possible range opens various possibilities to expose potential vulnerabilities. The same applies to the \nfollowing fields Token and Option. Furthermore, it is essential to know the context of the application or device and put \nit into consideration. For example, if there is a database behind the CoAP server, SQL injections can be infiltrate into \nthe system via the CoAP payload. This might be far-fetched but also simple content transmitted within the payload can \ncause unwanted behaviour of the system. \nETSI \n    9 ETSI TS 103 596-2 V1.1.1 (2021-05)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          1
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.2  Penetration Testing",
      "section_text": "A penetration test is a special kind of test where an attack on a system or network is simulated by an attacker or attacker \nteam. The attacker attempts to break into the system and take control. In contrast to testing during development, no \nparts or artifacts of the system to be tested are checked and there are no functional tests. The system to be tested is often \nthe finished system as it is used in production environment. Penetration testing can be done as black-box test or white-\nbox test and all in between. A real-world attacker usually has no information about the system he wants to penetrate. \nThat is why a black box penetration test is the closest thing to a real attacker. But with additionally information's about \nthe SUT (e.g. white-box testing or grey-box testing) a penetration tester can reduce the effort of the complete \npenetration test or raise the quality of the result. \nThe approach of penetration testing often follows five phases: \n1)  Planning and reconnaissance \n2)  Scanning \n3)  Gaining access \n4)  Maintaining access \n5)  Analysis",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.3  Testing for vulnerabilities",
      "section_text": "Testing for vulnerabilities is an approach, where already known vulnerabilities from other systems are used to check the \nSUT. These vulnerabilities can be found in databases and bug reports in the internet, e.g. in CVE databases. There is \nalways a good chance, that common mistakes can be found in different implementations or that an implementation uses \nan older library where this error still exists.  \nAlready found vulnerabilities and exploits building upon this are fundamental for penetration testing, clause 5.2. \nClause 8 provides some examples of specific Test Purposes that refer to real world vulnerabilities that was found in \nsystems using CoAP protocol.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.4  Further approaches",
      "section_text": "The security testing methods and techniques continuously grow and evolve following new attack strategies and pattern. \nBasic security techniques as presented above are well-known e.g. from ETSI TR 101 583 [i.7]. New security testing \napproaches e.g. address spoofing and amplification attacks. For example, IP Address Spoofing Attacks in the context of \nCoAP have been discussed in section 11.4 of IETF RFC 7252 [1]. Security testers always need to be aware and check \nlatest results from research and practical experience reports. \nETSI \n    10 ETSI TS 103 596-2 V1.1.1 (2021-05)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          4
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6  Test Configurations",
      "section_text": "The test configurations are derived from the SUT access points and functional test configurations. For all test \nconfigurations presented in this clause, a sniffing tool like Wireshark is recommended, but not shown in figure 3. \n \n \n \nFigure 3: CoAP test configurations",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7  CoAP Security Test Purposes",
      "section_text": "7.0  Introduction  \nSeveral TPs can be derived from the security test objectives and testing techniques mentioned in clauses 4 and 5. Some \nimportant aspects for CoAP security testing include: \n•\n  Robustness (coverage criteria, test suite execution time, number of test cases to be executed, number of test \ndata):  \n-  data level: malformed token/data (e.g. CoAP length fields), encoding UTF-8; \nETSI \n    11 ETSI TS 103 596-2 V1.1.1 (2021-05)\n \nFigure 4: CoAP message format \n-  behaviour level: CoAP scenarios. \n•\n  DoS (availability). \n•\n  Penetration testing ideas: \n-  apply brute force attacks to request procedure: using CON message. \n•\n  Spoofing. \n•\n  Insecure protocol configurations: \n-  which parameters lead to insecure configurations of the protocol, e.g. fallback to insecure cryptographic \nprotocols, key length, etc. \nFurther ideas can be derived from TPs related to the IEC 62443-4-2 [i.4] security profile testing ETSI TS 103 646 [i.3], \nsee examples below. \nFollowing the CoAP TSS and TP naming conventions introduced in ETSI TS 103 596-1 [4], clause 4, security TPs are \nnumbered, starting at 001, within the main scope \"SEC\" (security). The identifiers for the second level scope needs to \nbe derived from the target security requirement or security test methods, e.g. \"AUT\" for Authentication/authorization \nand \"CVE\" for TPs derived from public vulnerability data bases.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.1  Authentication/authorization",
      "section_text": "Since CoAP do not introduce some session handling there are no e.g. user names, passwords or identification codes etc. \nto be managed. Nevertheless, CoAP messages may have some relationships to other activities using CoAP messages \nthese mechanisms include some input of control data that could be subject security consideration, e.g. in the context of \nresource discovery that is provided by the CoAP server. The following example is derived from a test purpose defined \nin ETSI TS 103 646 [i.3]: TP_CR_3_5_Input_validation_during_session. Invalid data to be provided by a CoAP client \nmay be generated by some fuzzer as introduced in clause 5. \nETSI \n    12 ETSI TS 103 596-2 V1.1.1 (2021-05)\nTP Id  TP_COAP_SERVER_SEC_AUT_001 \nTest Objective  Ensure that the IUT shall not accept invalid syntax, length and content input that is used as \ncontrol input. \nReference  IETF RFC 7252 [1], clause 7.2 \nPICS Selection    \nInitial Conditions \n \nwith {\n \n          the IUT being_in the initial_state and \n \n          the IUT stores dedicated resource data information and \n \n          the Evaluator provide the invalid_data\n \n}\n \nExpected Behaviour\n \nensure that {\n \n    when {\n        /* is done for every configuration interface / IUT or usage of different TP variant */  \n        repeat invalid_data times {  \n          the IUT receives resource discovery request \n          (Note 1: \"The following statement is repeated before a specified period, to be specified, terminates and the used \ninvalid data should be different to previous attempts.\" \n          } \n    } \n    then { \n            the IUT does not discover restricted resource data information  \n           (Note 2: \"external observations: no restart, no configuration changes\") \n           (Note 3: \"internal observations: no invalid data written into log file\") \n    } \n \n}\nFinal Conditions",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.2  Encryptions",
      "section_text": "Encryption is outside the definition of the CoAP protocol definition and not considered here. Further details may be \nfound in section 9 of IETF RFC 8323 [3].",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3  Specific protocol security considerations",
      "section_text": "CoAP specific security considerations have been already provided and discussed in section 11 of the protocol definition \nIETF RFC 7252 [1].",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "8  Vulnerability Test Samples",
      "section_text": "This clause contains Test Purposes inspirited from known vulnerabilities data bases as inspiration for test cases, such as \nusing associated weaknesses from CVE. \nETSI \n    13 ETSI TS 103 596-2 V1.1.1 (2021-05)\nSample TPs from CVEs [i.5] and [i.6] that were found in existing CoAP implementations are the following: \nTP Id  TP_COAP_SERVER_SEC_CVE_001 \nTest Objective  Ensure that the IUT do not crash by using an invalid Code in CoAP header \nReference  CVE-2018-14367 [i.5] \nPICS Selection    \nInitial Conditions \n \nwith {\n \n            the IUT being_in the initial_state\n \n}\n \nExpected Behaviour\n \nensure that {\n \n    when {\n \n            the IUT receive a request message containing \n \n   version indicating value 1,\n \n   msg_type indicating value 0, //Confirmable\n \n   token_length indicating value 0,\n \n   code indicating value NULL, //broken message\n \n   msg_id corresponding to MSG_ID1;\n \n    }\n \n    then {\n \n            the IUT is pingable\n \n    }\n \n}\nFinal Conditions \n  \n \nTP Id  TP_COAP_SERVER_SEC_CVE_002 \nTest Objective  Ensure that the IUT do not crash by using an invalid Uri-Path \nReference  CVE-2019-12101 [i.6] \nPICS Selection    \nInitial Conditions \n \nwith {\n \n            the IUT being_in the initial_state\n \n}\n \nExpected Behaviour\n \nensure that {\n \n    when {\n \n            the IUT receive a request message containing \n \n   version indicating value 1,\n \n   msg_type indicating value 0, //Confirmable\n \n   code indicating value 0.01, //GET request\n \n   msg_id corresponding to MSG_ID1,\n \n   uri_path corresponding to null;\n \n    }\n \n    then {\n \n            the IUT is pingable\n \n    }\n \n}\nFinal Conditions \n  \n \n \n \nETSI \n    14 ETSI TS 103 596-2 V1.1.1 (2021-05)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          8
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "Annex A (informative):",
      "section_text": "Sample security test catalogue",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "P",
          "Annex"
        ],
        [
          "A",
          "A"
        ]
      ],
      "type": "Annex"
    },
    {
      "section_title": "A.1  Introduction",
      "section_text": "Test purposes presented in the present document have been produced using the Test Description Language (TDL-TO) \naccording to ETSI ES 203 119-4 [2]. The TDL-TO library modules corresponding to the Test purpose catalogue are \ncontained in archive ts_10359602v010101p0.zip which accompanies the present document. \n   \nETSI \n    15 ETSI TS 103 596-2 V1.1.1 (2021-05)\nHistory \nDocument history \nV1.1.1  May 2021  Publication \n     \n     \n     \n     \n \nETSI",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          1
        ]
      ],
      "type": "AlphaNumeric"
    }
  ]
}
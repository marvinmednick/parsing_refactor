{
  "filename": "H264.pdf",
  "metadata": {
    "Title": "ITU-T Rec. H.264 (04/2017) Advanced video coding for generic audiovisual services",
    "Author": "ITU-T",
    "Subject": "SERIES H: AUDIOVISUAL AND MULTIMEDIA SYSTEMS - Infrastructure of audiovisual services – Coding of moving video",
    "Keywords": "H.264,H,264",
    "Creator": "Microsoft® Word 2016",
    "CreationDate": "D:20190905104631+02'00'",
    "ModDate": "D:20190905104631+02'00'",
    "Producer": "Microsoft® Word 2016"
  },
  "sections": [
    {
      "section_title": "1  Scope",
      "section_text": "This document specifies Recommendation ITU-T H.264 | International Standard ISO/IEC 14496-10 Advanced video \ncoding.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "2  Normative references",
      "section_text": "The following Recommendations and International Standards contain provisions which, through reference in this text, \nconstitute provisions of this Recommendation | International Standard. At the time of publication, the editions indicated \nwere  valid.  All  Recommendations  and  Standards  are  subject  to  revision,  and  parties  to  agreements  based  on  this \nRecommendation | International Standard are encouraged to investigate the possibility of applying the most recent edition \nof the Recommendations and Standards listed below. Members of IEC and ISO maintain registers of currently valid \nInternational Standards. The Telecommunication Standardization Bureau of the ITU maintains a list of currently valid \nITU-T Recommendations. \n–  Recommendation ITU-T T.35 (2000), Procedure for the allocation of ITU-T defined codes for non-standard \nfacilities. \n–  ISO/IEC 11578:1996, Information technology — Open Systems Interconnection — Remote Procedure Call \n(RPC). \n–  ISO 11664-1:2007, Colorimetry — Part 1: CIE standard colorimetric observers. \n–  ISO 12232:2006, Photography – Digital still cameras – Determination of exposure index, ISO speed \nratings, standard output sensitivity, and recommended exposure index. \n–  ISO/IEC 23001-11 (in force), Information Technology — MPEG Systems Technologies — Part 11: Energy-\nefficient media consumption (Green metadata).",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3  Definitions",
      "section_text": "For the purposes of this Recommendation | International Standard, the following definitions apply:",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.1  access unit: A set of NAL units that are consecutive in decoding order and contain exactly one primary coded",
      "section_text": "picture. In addition to the primary coded picture, an access unit may also contain one or more redundant coded \npictures, one auxiliary coded picture, or other NAL units not containing slices or slice data partitions of a coded \npicture. The decoding of an access unit always results in a decoded picture.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.2  AC transform coefficient: Any transform coefficient for which the frequency index in one or both dimensions",
      "section_text": "is non-zero. \n6  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.3  adaptive binary arithmetic decoding process: An entropy decoding process that derives the values of bins",
      "section_text": "from a bitstream produced by an adaptive binary arithmetic encoding process.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.4  adaptive binary arithmetic encoding process: An entropy encoding process, not normatively specified in this",
      "section_text": "Recommendation | International Standard, that codes a sequence of bins and produces a bitstream that can be \ndecoded using the adaptive binary arithmetic decoding process.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          4
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.5  alpha blending: A process not specified by this Recommendation | International Standard, in which an auxiliary",
      "section_text": "coded picture is used in combination with a primary coded picture and with other data not specified by this \nRecommendation | International Standard in the display process. In an alpha blending process, the samples of an \nauxiliary coded picture are interpreted as indications of the degree of opacity (or, equivalently, the degrees of \ntransparency) associated with the corresponding luma samples of the primary coded picture.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          5
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.6  arbitrary  slice  order  (ASO):  A  decoding  order  of  slices  in  which  the  macroblock  address  of  the  first",
      "section_text": "macroblock of some slice of a slice group may be less than the macroblock address of the first macroblock of \nsome other preceding slice of the same slice group or, in the case of a picture that is coded using three separate \ncolour planes, some other preceding slice of the same slice group within the same colour plane, or in which the \nslices of a slice group of a picture may be interleaved with the slices of one or more other slice groups of the \npicture or, in the case of a picture that is coded using three separate colour planes, with the slices of one or more \nother slice groups within the same colour plane.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          6
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.7  auxiliary coded picture: A picture that supplements the primary coded picture that may be used in combination",
      "section_text": "with  other  data  not  specified  by  this  Recommendation | International Standard  in  the  display  process.  An \nauxiliary coded picture has the same syntactic and semantic restrictions as a monochrome redundant coded \npicture. An auxiliary coded picture must contain the same number of macroblocks as the primary coded picture. \nAuxiliary coded pictures have no normative effect on the decoding process. See also primary coded picture and \nredundant coded picture.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          7
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.8  azimuth circle: circle on a sphere connecting all points with the same azimuth value.",
      "section_text": "NOTE – An azimuth circle is always a great circle like a longitude line on the earth.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          8
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.9  B slice: A slice that may be decoded using intra prediction or inter prediction using at most two motion vectors",
      "section_text": "and reference indices to predict the sample values of each block.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          9
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.10  bin: One bit of a bin string.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          10
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.11  binarization: A set of bin strings for all possible values of a syntax element.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          11
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.12  binarization process: A unique mapping process of all possible values of a syntax element onto a set of bin",
      "section_text": "strings.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          12
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.13  bin string: A string of bins. A bin string is an intermediate binary representation of values of syntax elements",
      "section_text": "from the binarization of the syntax element.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          13
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.14  bi-predictive slice: See B slice.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          14
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.15  bitstream: A sequence of bits that forms the representation of coded pictures and associated data forming one",
      "section_text": "or more coded video sequences. Bitstream is a collective term used to refer either to a NAL unit stream or a byte \nstream.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          15
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.16  block: An MxN (M-column by N-row) array of samples, or an MxN array of transform coefficients.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          16
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.17  bottom field: One of two fields that comprise a frame. Each row of a bottom field is spatially located immediately",
      "section_text": "below a corresponding row of a top field.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          17
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.18  bottom macroblock (of a macroblock pair): The macroblock within a macroblock pair that contains the",
      "section_text": "samples  in  the  bottom  row  of  samples  for  the  macroblock  pair.  For  a  field  macroblock  pair,  the  bottom \nmacroblock represents the samples from the region of the bottom field of the frame that lie within the spatial \nregion of the macroblock pair. For a frame macroblock pair, the bottom macroblock represents the samples of \nthe frame that lie within the bottom half of the spatial region of the macroblock pair.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          18
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.19  broken link: A location in a bitstream at which it is indicated that some subsequent pictures in decoding order",
      "section_text": "may contain serious visual artefacts due to unspecified operations performed in the generation of the bitstream.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          19
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.20  byte: A sequence of 8 bits, written and read with the most significant bit on the left and the least significant bit",
      "section_text": "on the right. When represented in a sequence of data bits, the most significant bit of a byte is first.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          20
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.21  byte-aligned: A position in a bitstream is byte-aligned when the position is an integer multiple of 8 bits from",
      "section_text": "the position of the first bit in the bitstream. A bit or byte or syntax element is said to be byte-aligned when the \nposition at which it appears in a bitstream is byte-aligned. \n    Rec. ITU-T H.264 (06/2019)  7",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          21
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.22  byte stream: An encapsulation of a NAL unit stream containing start code prefixes and NAL units as specified",
      "section_text": "in Annex B.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          22
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.23  can: A term used to refer to behaviour that is allowed, but not necessarily required.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          23
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.24  category: A number associated with each syntax element. The category is used to specify the allocation of syntax",
      "section_text": "elements to NAL units for slice data partitioning. It may also be used in a manner determined by the application \nto refer to classes of syntax elements in a manner not specified in this Recommendation | International Standard.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          24
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.25  chroma: An adjective specifying that a sample array or single sample is representing one of the two colour",
      "section_text": "difference signals related to the primary colours. The symbols used for a chroma array or sample are Cb and Cr. \nNOTE – The term chroma is used rather than the term chrominance in order to avoid the implication of the use of linear \nlight transfer characteristics that is often associated with the term chrominance.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          25
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.26  coded field: A coded representation of a field.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          26
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.27  coded frame: A coded representation of a frame.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          27
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.28  coded picture: A coded representation of a picture. A coded picture may be either a coded field or a coded",
      "section_text": "frame. Coded picture is a collective term referring to a primary coded picture or a redundant coded picture, but \nnot to both together.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          28
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.29  coded picture buffer (CPB): A first-in first-out buffer containing access units in decoding order specified in",
      "section_text": "the hypothetical reference decoder in Annex C.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          29
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.30  coded representation: A data element as represented in its coded form.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          30
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.31  coded slice data partition NAL unit: A NAL unit containing a slice data partition.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          31
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.32  coded slice NAL unit: A NAL unit containing a slice that is not a slice of an auxiliary coded picture.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          32
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.33  coded video sequence: A sequence of access units that consists, in decoding order, of an IDR access unit",
      "section_text": "followed by zero or more non-IDR access units including all subsequent access units up to but not including any \nsubsequent IDR access unit.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          33
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.34  component: An array or single sample from one of the three arrays (luma and two chroma) that make up a field",
      "section_text": "or frame in 4:2:0, 4:2:2, or 4:4:4 colour format or the array or a single sample of the array that make up a field \nor frame in monochrome format.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          34
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.35  complementary field pair: A collective term for a complementary reference field pair or a complementary non-",
      "section_text": "reference field pair.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          35
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.36  complementary non-reference field pair: Two non-reference fields that are in consecutive access units in",
      "section_text": "decoding order as two coded fields of opposite parity and share the same value of the frame_num syntax element, \nwhere the first field is not already a paired field.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          36
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.37  complementary reference field pair: Two reference fields that are in consecutive access units in decoding",
      "section_text": "order as two coded fields and share the same value of the frame_num syntax element, where the second field in \ndecoding order is not an IDR picture and does not include a memory_management_control_operation syntax \nelement equal to 5.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          37
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.38  constituent picture: part of a spatially frame-packed stereoscopic video picture that corresponds to one view, or",
      "section_text": "a picture itself when frame packing is not in use or the temporal interleaving frame packing arrangement is in \nuse.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          38
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.39  context variable: A variable specified for the adaptive binary arithmetic decoding process of a bin by an",
      "section_text": "equation containing recently decoded bins.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          39
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.40  DC transform coefficient: A transform coefficient for which the frequency index is zero in all dimensions.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          40
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.41  decoded picture: A decoded picture is derived by decoding a coded picture. A decoded picture is either a",
      "section_text": "decoded frame, or a decoded field. A decoded field is either a decoded top field or a decoded bottom field.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          41
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.42  decoded picture buffer (DPB): A buffer holding decoded pictures for reference, output reordering, or output",
      "section_text": "delay specified for the hypothetical reference decoder in Annex C.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          42
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.43  decoder: An embodiment of a decoding process.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          43
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.44  decoder under test (DUT): A decoder that is tested for conformance to this Recommendation | International",
      "section_text": "Standard by operating the hypothetical stream scheduler to deliver a conforming bitstream to the decoder and to \nthe hypothetical reference decoder and comparing the values and timing of the output of the two decoders.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          44
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.45  decoding order: The order in which syntax elements are processed by the decoding process.",
      "section_text": "8  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          45
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.46  decoding process: The process specified in this Recommendation | International Standard that reads a bitstream",
      "section_text": "and derives decoded pictures from it.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          46
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.47  direct prediction: An inter prediction for a block for which no motion vector is decoded. Two direct prediction",
      "section_text": "modes are specified that are referred to as spatial direct prediction and temporal prediction mode.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          47
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.48  display process: A process not specified in this Recommendation | International Standard having, as its input,",
      "section_text": "the cropped decoded pictures that are the output of the decoding process.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          48
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.49  elevation circle: circle on a sphere connecting all points with the same elevation value.",
      "section_text": "NOTE – An elevation circle is similar to a lattitude line on the earth. Except when the elevation value is zero, an elevation \ncircle is not a great circle like a longitude circle on the earth.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          49
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.50  emulation prevention byte: A byte equal to 0x03 that may be present within a NAL unit. The presence of",
      "section_text": "emulation prevention bytes ensures that no sequence of consecutive byte-aligned bytes in the NAL unit contains \na start code prefix.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          50
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.51  encoder: An embodiment of an encoding process.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          51
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.52  encoding process: A process, not specified in this Recommendation | International Standard, that produces a",
      "section_text": "bitstream conforming to this Recommendation | International Standard.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          52
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.53  field: An assembly of alternate rows of a frame. A frame is composed of two fields, a top field and a bottom field.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          53
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.54  field macroblock: A macroblock containing samples from a single field. All macroblocks of a coded field are",
      "section_text": "field macroblocks. When macroblock-adaptive frame/field decoding is in use, some macroblocks of a coded \nframe may be field macroblocks.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          54
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.55  field macroblock pair: A macroblock pair decoded as two field macroblocks.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          55
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.56  field scan: A specific sequential ordering of transform coefficients that differs from the zig-zag scan by scanning",
      "section_text": "columns more rapidly than rows. Field scan is used for transform coefficients in field macroblocks.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          56
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.57  flag: A variable that can take one of the two possible values 0 and 1.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          57
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.58  frame: A frame contains an array of luma samples in monochrome format or an array of luma samples and two",
      "section_text": "corresponding arrays of chroma samples in 4:2:0, 4:2:2, and 4:4:4 colour format. A frame consists of two fields, \na top field and a bottom field.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          58
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.59  frame  macroblock:  A  macroblock  representing  samples  from  the  two  fields  of  a  coded  frame.  When",
      "section_text": "macroblock-adaptive  frame/field  decoding  is  not  in  use,  all  macroblocks  of  a  coded  frame  are  frame \nmacroblocks. When macroblock-adaptive frame/field decoding is in use, some macroblocks of a coded frame \nmay be frame macroblocks.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          59
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.60  frame macroblock pair: A macroblock pair decoded as two frame macroblocks.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          60
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.61  frequency index: A one-dimensional or two-dimensional index associated with a transform coefficient prior to",
      "section_text": "an inverse transform part of the decoding process.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          61
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.62  global coordinate axes: coordinate axes associated with omnidirectional video that are associated with an",
      "section_text": "externally referenceable position and orientation. \nNOTE – The global coordinate axes  may  correspond to  the position and orientation of a device or rig used for \nomnidirectional audio/video acquisition as well as the position of an observer's head in the three-dimensional space of \nthe omnidirectional video rendering environment.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          62
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.63  great circle: intersection of a sphere and a plane that passes through the centre point of the sphere.",
      "section_text": "NOTE – A great circle is also known as an orthodrome or Riemannian circle.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          63
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.64  hypothetical  reference  decoder  (HRD):  A  hypothetical  decoder  model  that  specifies  constraints  on  the",
      "section_text": "variability of conforming NAL unit streams or conforming byte streams that an encoding process may produce.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          64
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.65  hypothetical stream scheduler (HSS): A hypothetical delivery mechanism for the timing and data flow of the",
      "section_text": "input of a bitstream into the hypothetical reference decoder. The HSS is used for checking the conformance of \na bitstream or a decoder.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          65
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.66  I slice: A slice that is not an SI slice that is decoded using intra prediction only.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          66
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.67  informative: A term used to refer to content provided in this Recommendation | International Standard that is",
      "section_text": "not an integral part of this Recommendation | International Standard. Informative content does not establish any \nmandatory requirements for conformance to this Recommendation | International Standard. \n    Rec. ITU-T H.264 (06/2019)  9",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          67
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.68  instantaneous decoding refresh (IDR) access unit: An access unit in which the primary coded picture is an",
      "section_text": "IDR picture.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          68
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.69  instantaneous decoding refresh (IDR) picture: A coded picture for which the variable IdrPicFlag is equal to 1.",
      "section_text": "An IDR picture causes the decoding process to mark all reference pictures as \"unused for reference\" immediately \nafter the decoding of the IDR picture. All coded pictures that follow an IDR picture in decoding order can be \ndecoded without inter prediction from any picture that precedes the IDR picture in decoding order. The first \npicture of each coded video sequence in decoding order is an IDR picture.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          69
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.70  inter coding: Coding of a block, macroblock, slice, or picture that uses inter prediction.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          70
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.71  inter prediction: A prediction derived from decoded samples of  reference pictures other than the current",
      "section_text": "decoded picture.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          71
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.72  interpretation sample value: A possibly-altered value corresponding to a decoded sample value of an auxiliary",
      "section_text": "coded picture that may be generated for use in the display process. Interpretation sample values are not used in \nthe decoding process and have no normative effect on the decoding process.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          72
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.73  intra coding: Coding of a block, macroblock, slice, or picture that uses intra prediction.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          73
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.74  intra prediction: A prediction derived from the decoded samples of the same decoded slice.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          74
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.75  intra slice: See I slice.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          75
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.76  inverse transform: A part of the decoding process by which a set of transform coefficients are converted into",
      "section_text": "spatial-domain values, or by which a set of transform coefficients are converted into DC transform coefficients.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          76
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.77  layer: One of a set of syntactical structures in a non-branching hierarchical relationship. Higher layers contain",
      "section_text": "lower layers. The coding layers are the coded video sequence, picture, slice, and macroblock layers.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          77
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.78  level: A defined set of constraints on the values that may be taken by the syntax elements and variables of this",
      "section_text": "Recommendation | International Standard. The same set of levels is defined for all profiles, with most aspects of \nthe definition of each level being in common across different profiles. Individual implementations may, within \nspecified constraints, support a different level for each supported profile. In a different context, a level is the \nvalue of a transform coefficient prior to scaling (see the definition of transform coefficient level).",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          78
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.79  list: A one-dimensional array of syntax elements or variables.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          79
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.80  list 0 (list 1) motion vector: A motion vector associated with a reference index pointing into reference picture",
      "section_text": "list 0 (list 1).",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          80
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.81  list 0 (list 1) prediction: Inter prediction of the content of a slice using a reference index pointing into reference",
      "section_text": "picture list 0 (list 1).",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          81
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.82  local coordinate axes: coordinate axes having a specified rotation relationship relative to the global coordinate",
      "section_text": "axes.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          82
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.83  luma: An adjective specifying that a sample array or single sample is representing the monochrome signal related",
      "section_text": "to the primary colours. The symbol or subscript used for luma is Y or L. \nNOTE – The term luma is used rather than the term luminance in order to avoid the implication of the use of linear light \ntransfer characteristics that is often associated with the term luminance. The symbol L is sometimes used instead of the \nsymbol Y to avoid confusion with the symbol y as used for vertical location.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          83
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.84  macroblock: A 16x16 block of luma samples and two corresponding blocks of chroma samples of a picture that",
      "section_text": "has three sample arrays, or a 16x16 block of samples of a monochrome picture or a picture that is coded using \nthree separate colour planes. The division of a slice or a macroblock pair into macroblocks is a partitioning.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          84
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.85  macroblock-adaptive frame/field decoding: A decoding process for coded frames in which some macroblocks",
      "section_text": "may be decoded as frame macroblocks and others may be decoded as field macroblocks.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          85
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.86  macroblock address: When macroblock-adaptive frame/field decoding is not in use, a macroblock address is",
      "section_text": "the index of a macroblock in a macroblock raster scan of the picture starting with zero for the top-left macroblock \nin a picture. When macroblock-adaptive frame/field decoding is in use, the macroblock address of the top \nmacroblock of a macroblock pair is two times the index of the macroblock pair in a macroblock pair raster scan \nof the picture, and the macroblock address of the bottom macroblock of a macroblock pair is the macroblock \naddress of the corresponding top macroblock plus 1. The macroblock address of the top macroblock of each \nmacroblock pair is an even number and the macroblock address of the bottom macroblock of each macroblock \npair is an odd number.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          86
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.87  macroblock location: The two-dimensional coordinates of a macroblock in a picture denoted by ( x, y ). For the",
      "section_text": "top left macroblock of the picture ( x, y ) is equal to ( 0, 0 ). x is incremented by 1 for each macroblock column \n10  Rec. ITU-T H.264 (06/2019) \n \nfrom left to right. When macroblock-adaptive frame/field decoding is not in use, y is incremented by 1 for each \nmacroblock row from top to bottom. When macroblock-adaptive frame/field decoding is in use, y is incremented \nby 2 for each macroblock pair row from top to bottom, and is incremented by an additional 1 when a macroblock \nis a bottom macroblock.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          87
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.88  macroblock pair: A pair of vertically contiguous macroblocks in a frame that is coupled for use in macroblock-",
      "section_text": "adaptive frame/field decoding. The division of a slice into macroblock pairs is a partitioning.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          88
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.89  macroblock partition: A block of luma samples and two corresponding blocks of chroma samples resulting",
      "section_text": "from a partitioning of a macroblock for inter prediction for a picture that has three sample arrays or a block of \nluma samples resulting from a partitioning of a macroblock for inter prediction for a monochrome picture or a \npicture that is coded using three separate colour planes.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          89
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.90  macroblock  to  slice  group  map:  A  means  of  mapping  macroblocks  of  a  picture  into  slice  groups.  The",
      "section_text": "macroblock to slice group map consists of a list of numbers, one for each coded macroblock, specifying the slice \ngroup to which each coded macroblock belongs.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          90
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.91  map unit to slice group map: A means of mapping slice group map units of a picture into slice groups. The",
      "section_text": "map unit to slice group map consists of a list of numbers, one for each slice group map unit, specifying the slice \ngroup to which each coded slice group map unit belongs.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          91
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.92  matrix: A two-dimensional array of syntax elements or variables.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          92
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.93  may: A term used to refer to behaviour that is allowed, but not necessarily required. In some places where the",
      "section_text": "optional nature of the described behaviour is intended to be emphasized, the phrase \"may or may not\" is used to \nprovide emphasis.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          93
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.94  memory management control operation: Seven operations that control reference picture marking.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          94
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.95  motion vector: A two-dimensional vector used for inter prediction that provides an offset from the coordinates",
      "section_text": "in the decoded picture to the coordinates in a reference picture.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          95
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.96  must: A term used in expressing an observation about a requirement or an implication of a requirement that is",
      "section_text": "specified  elsewhere  in  this  Recommendation | International  Standard.  This  term  is  used  exclusively  in  an \ninformative context.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          96
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.97  NAL unit: A syntax structure containing an indication of the type of data to follow and bytes containing that",
      "section_text": "data in the form of an RBSP interspersed as necessary with emulation prevention bytes.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          97
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.98  NAL unit stream: A sequence of NAL units.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          98
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.99  non-paired field: A collective term for a non-paired reference field or a non-paired non-reference field.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          99
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.100  non-paired  non-reference  field:  A  decoded  non-reference  field  that  is  not  part  of  a  complementary",
      "section_text": "non-reference field pair.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          100
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.101  non-paired reference field: A decoded reference field that is not part of a complementary reference field pair.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          101
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.102  non-reference field: A field coded with nal_ref_idc equal to 0.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          102
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.103  non-reference frame: A frame coded with nal_ref_idc equal to 0.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          103
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.104  non-reference picture: A picture coded with nal_ref_idc equal to 0. A non-reference picture is not used for",
      "section_text": "inter prediction of any other pictures.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          104
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.105  note: A term used to prefix informative remarks. This term is used exclusively in an informative context.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          105
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.106  omnidirectional  video:  video  content  in  a  format  that  enables  rendering  according  to  the  user's  viewing",
      "section_text": "orientation, e.g., if viewed using a head-mounted device, or according to a user's desired viewport, reflecting a \npotentially rotated viewing position.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          106
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.107  opposite parity: The opposite parity of top is bottom, and vice versa.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          107
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.108  output order: The order in which the decoded pictures are output from the decoded picture buffer.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          108
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.109  P slice: A slice that is not an SP slice that may be decoded using intra prediction or inter prediction using at",
      "section_text": "most one motion vector and reference index to predict the sample values of each block.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          109
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.110  packed region: region in a region-wise packed picture that is mapped to a projected region according to a region-",
      "section_text": "wise packing.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          110
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.111  parameter: A syntax element of a sequence parameter set or a picture parameter set. Parameter is also used as",
      "section_text": "part of the defined term quantization parameter. \n    Rec. ITU-T H.264 (06/2019)  11",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          111
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.112  parity: The parity of a field can be top or bottom.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          112
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.113  partitioning: The division of a set into subsets such that each element of the set is in exactly one of the subsets.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          113
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.114  picture: A collective term for a field or a frame.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          114
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.115  picture parameter set: A syntax structure containing syntax elements that apply to zero or more entire coded",
      "section_text": "pictures as determined by the pic_parameter_set_id syntax element found in each slice header.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          115
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.116  picture order count: A variable that is associated with each coded field and each field of a coded frame and has",
      "section_text": "a value that is non-decreasing with increasing field position in output order relative to the first output field of the \nprevious IDR picture in decoding order or relative to the first output field of the previous picture, in decoding \norder, that contains a memory management control operation that marks all reference pictures as \"unused for \nreference\".",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          116
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.117  prediction: An embodiment of the prediction process.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          117
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.118  prediction process: The use of a predictor to provide an estimate of the sample value or data element currently",
      "section_text": "being decoded.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          118
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.119  predictive slice: See P slice.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          119
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.120  predictor: A combination of specified values or previously decoded sample values or data elements used in the",
      "section_text": "decoding process of subsequent sample values or data elements.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          120
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.121  primary coded picture: The coded representation of a picture to be used by the decoding process for a bitstream",
      "section_text": "conforming  to  this  Recommendation | International Standard.  The  primary  coded  picture  contains  all \nmacroblocks of the picture. The only pictures that have a normative effect on the decoding process are primary \ncoded pictures. See also redundant coded picture.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          121
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.122  profile: A specified subset of the syntax of this Recommendation | International Standard.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          122
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.123  projected picture: picture that uses a projection format for omnidirectional video.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          123
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.124  projected region: region in a projected picture that is mapped to a packed region according to a region-wise",
      "section_text": "packing.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          124
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.125  projection: specified correspondence between the colour  samples of a  projected picture and azimuth and",
      "section_text": "elevation positions on a sphere.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          125
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.126  quantization parameter: A variable used by the decoding process for scaling of transform coefficient levels.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          126
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.127  random access: The act of starting the decoding process for a bitstream at a point other than the beginning of",
      "section_text": "the stream.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          127
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.128  raster scan: A mapping of a rectangular two-dimensional pattern to a one-dimensional pattern such that the first",
      "section_text": "entries in the one-dimensional pattern are from the first top row of the two-dimensional pattern scanned from \nleft to right, followed similarly by the second, third, etc., rows of the pattern (going down) each scanned from \nleft to right.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          128
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.129  raw  byte  sequence  payload  (RBSP):  A  syntax  structure  containing  an  integer  number  of  bytes  that  is",
      "section_text": "encapsulated in a NAL unit. An RBSP is either empty or has the form of a string of data bits containing syntax \nelements followed by an RBSP stop bit and followed by zero or more subsequent bits equal to 0.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          129
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.130  raw byte sequence payload (RBSP) stop bit: A bit equal to 1 present within a raw byte sequence payload",
      "section_text": "(RBSP) after a string of data bits. The location of the end of the string of data bits within an RBSP can be \nidentified by searching from the end of the RBSP for the RBSP stop bit, which is the last non-zero bit in the \nRBSP.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          130
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.131  recovery point: A point in the bitstream at which the recovery of an exact or an approximate representation of",
      "section_text": "the decoded pictures represented by the bitstream is achieved after a random access or broken link.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          131
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.132  redundant coded picture: A coded representation of a picture or a part of a picture. The content of a redundant",
      "section_text": "coded  picture  shall  not  be  used  by  the  decoding  process  for  a  bitstream  conforming  to  this \nRecommendation | International Standard. A redundant coded picture is not required to contain all macroblocks \nin the primary coded picture. Redundant coded pictures have no normative effect on the decoding process. See \nalso primary coded picture.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          132
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.133  reference field: A reference field may be used for inter prediction when P, SP, and B slices of a coded field or",
      "section_text": "field macroblocks of a coded frame are decoded. See also reference picture. \n12  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          133
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.134  reference frame: A reference frame may be used for inter prediction when P, SP, and B slices of a coded frame",
      "section_text": "are decoded. See also reference picture.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          134
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.135  reference index: An index into a reference picture list.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          135
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.136  reference picture: A picture with nal_ref_idc not equal to 0. A reference picture contains samples that may be",
      "section_text": "used for inter prediction in the decoding process of subsequent pictures in decoding order.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          136
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.137  reference picture list: A list of reference pictures that is used for inter prediction of a P, B, or SP slice. For the",
      "section_text": "decoding process of a P or SP slice, there is one reference picture list. For the decoding process of a B slice, \nthere are two reference picture lists.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          137
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.138  reference picture list 0: A reference picture list used for inter prediction of a P, B, or SP slice. All inter",
      "section_text": "prediction used for P and SP slices uses reference picture list 0. Reference picture list 0 is one of two reference \npicture lists used for inter prediction for a B slice, with the other being reference picture list 1.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          138
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.139  reference picture list 1: A reference picture list used for inter prediction of a B slice. Reference picture list 1 is",
      "section_text": "one of two reference picture lists used for inter prediction for a B slice, with the other being reference picture \nlist 0.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          139
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.140  reference  picture  marking:  Specifies,  in  the  bitstream,  how  the  decoded  pictures  are  marked  for  inter",
      "section_text": "prediction.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          140
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.141  region-wise packed picture: decoded picture that contains one or more packed regions.",
      "section_text": "NOTE – A packed picture may contain a region-wise packing of a projected picture.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          141
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.142  region-wise packing: transformation, resizing, and relocation of packed regions of a region-wise packed picture",
      "section_text": "to remap the packed regions to projected regions of a projected picture.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          142
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.143  reserved: The term reserved, when used in the clauses specifying some values of a particular syntax element, are",
      "section_text": "for  future  use  by  ITU-T  |  ISO/IEC.  These  values  shall  not  be  used  in  bitstreams  conforming  to  this \nRecommendation | International Standard,  but  may  be  used  in  future  extensions  of  this \nRecommendation | International Standard by ITU-T | ISO/IEC.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          143
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.144  residual: The decoded difference between a prediction of a sample or data element and its decoded value.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          144
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.145  run: A number of consecutive data elements represented in the decoding process. In one context, the number of",
      "section_text": "zero-valued transform coefficient levels preceding a non-zero transform coefficient level in the list of transform \ncoefficient levels generated by a zig-zag scan or a field scan. In other contexts, run refers to a number of \nmacroblocks.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          145
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.146  sample  aspect  ratio:  Specifies,  for  assisting  the  display  process,  which  is  not  specified  in  this",
      "section_text": "Recommendation | International  Standard,  the  ratio  between  the  intended  horizontal  distance  between  the \ncolumns and the intended vertical distance between the rows of the luma sample array in a frame. Sample aspect \nratio is expressed as h:v, where h is horizontal width and v is vertical height (in arbitrary units of spatial distance).",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          146
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.147  scaling: The process of multiplying transform coefficient levels by a factor, resulting in transform coefficients.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          147
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.148  sequence parameter set: A syntax structure containing syntax elements that apply to zero or more entire coded",
      "section_text": "video sequences as determined by the content of a seq_parameter_set_id syntax element found in the picture \nparameter set referred to by the pic_parameter_set_id syntax element found in each slice header.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          148
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.149  shall: A term used to express mandatory requirements for conformance to this Recommendation | International",
      "section_text": "Standard. When used to express a mandatory constraint on the values of syntax elements or on the results obtained \nby operation of the specified decoding process, it is the responsibility of the encoder to ensure that the constraint \nis fulfilled. When used in reference to operations performed by the decoding process, any decoding process that \nproduces  identical  results  to  the  decoding  process  described  herein  conforms  to  the  decoding  process \nrequirements of this Recommendation | International Standard.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          149
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.150  should: A term used to refer to behaviour of an implementation that is encouraged to be followed under",
      "section_text": "anticipated ordinary circumstances, but is not a mandatory requirement for conformance to this Recommendation \n| International Standard.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          150
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.151  SI slice: A slice that is coded using intra prediction only and using quantization of the prediction samples. An",
      "section_text": "SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          151
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.152  skipped macroblock: A macroblock for which no data is coded other than an indication that the macroblock is",
      "section_text": "to be decoded as \"skipped\". This indication may be common to several macroblocks.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          152
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.153  slice: An integer number of macroblocks or macroblock pairs ordered consecutively in the raster scan within a",
      "section_text": "particular slice group. For the primary coded picture, the division of each slice group into slices is a partitioning. \n    Rec. ITU-T H.264 (06/2019)  13 \n \nAlthough a slice contains macroblocks or macroblock pairs that are consecutive in the raster scan within a slice \ngroup, these macroblocks or macroblock pairs are not necessarily consecutive in the raster scan within the \npicture. The macroblock addresses are derived from the first macroblock address in a slice (as represented in \nthe slice header) and the macroblock to slice group map, and, when a picture is coded using three separate colour \nplanes, a colour plane identifier.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          153
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.154  slice data partition: A non-empty subset of the syntax elements of the slice data syntax structure for a slice. The",
      "section_text": "syntax elements of a slice data partition are associated with the same category.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          154
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.155  slice data partitioning: A method of partitioning selected syntax elements into syntax structures based on a",
      "section_text": "category associated with each syntax element.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          155
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.156  slice group: A subset of the macroblocks or macroblock pairs of a picture. The division of the picture into slice",
      "section_text": "groups is a partitioning of the picture. The partitioning is specified by the macroblock to slice group map.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          156
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.157  slice group map units: The units of the map unit to slice group map.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          157
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.158  slice header: A part of a coded slice containing the data elements pertaining to the first or all macroblocks",
      "section_text": "represented in the slice.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          158
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.159  source: Term used to describe the video material or some of its attributes before encoding.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          159
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.160  SP slice: A slice that may be coded using intra prediction or inter prediction with quantization of the prediction",
      "section_text": "samples using at most one motion vector and reference index to predict the sample values of each block. An SP \nslice can be coded such that its decoded samples can be constructed identically to another SP slice or an SI slice.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          160
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.161  sphere coordinates: azimuth and elevation angles identifying a location of a point on a sphere.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          161
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.162  sphere region: region on a sphere, specified either by four great circles or by two azimuth circles and two",
      "section_text": "elevation circles, or such a region on a rotated sphere after applying yaw, pitch, and roll rotations.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          162
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.163  start code prefix: A unique sequence of three bytes equal to 0x000001 embedded in the byte stream as a prefix",
      "section_text": "to each NAL unit. The location of a start code prefix can be used by a decoder to identify the beginning of a new \nNAL unit and the end of a previous NAL unit. Emulation of start code prefixes is prevented within NAL units by \nthe inclusion of emulation prevention bytes.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          163
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.164  string of data bits (SODB): A sequence of some number of bits representing syntax elements present within a",
      "section_text": "raw byte sequence payload prior to the raw byte sequence payload stop bit. Within an SODB, the left-most bit \nis considered to be the first and most significant bit, and the right-most bit is considered to be the last and least \nsignificant bit.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          164
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.165  sub-macroblock: One quarter of the samples of a macroblock, i.e., an 8x8 luma block and two corresponding",
      "section_text": "chroma blocks of which one corner is located at a corner of the macroblock for a picture that has three sample \narrays or an 8x8 luma block of which one corner is located at a corner of the macroblock for a monochrome \npicture or a picture that is coded using three separate colour planes.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          165
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.166  sub-macroblock partition: A block of luma samples and two corresponding blocks of chroma samples resulting",
      "section_text": "from a partitioning of a sub-macroblock for inter prediction for a picture that has three sample arrays or a block \nof luma samples resulting from a partitioning of a sub-macroblock for inter prediction for a monochrome picture \nor a picture that is coded using three separate colour planes.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          166
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.167  switching I slice: See SI slice.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          167
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.168  switching P slice: See SP slice.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          168
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.169  syntax element: An element of data represented in the bitstream.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          169
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.170  syntax structure: Zero or more syntax elements present together in the bitstream in a specified order.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          170
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.171  tilt angle: angle indicating the amount of tilt of a sphere region, measured as the amount of rotation of a sphere",
      "section_text": "region along the axis originating from the sphere origin passing through the centre point of the sphere region, \nwhere the angle value increases clockwise when looking from the origin towards the positive end of the axis.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          171
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.172  top field: One of two fields that comprise a frame. Each row of a top field is spatially located immediately above",
      "section_text": "the corresponding row of the bottom field.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          172
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.173  top macroblock (of a macroblock pair): The macroblock within a macroblock pair that contains the samples",
      "section_text": "in the top row of samples for the macroblock pair. For a field macroblock pair, the top macroblock represents \nthe samples from the region of the top field of the frame that lie within the spatial region of the macroblock pair. \nFor a frame macroblock pair, the top macroblock represents the samples of the frame that lie within the top half \nof the spatial region of the macroblock pair. \n14  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          173
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.174  transform coefficient: A scalar quantity, considered to be in a frequency domain, that is associated with a",
      "section_text": "particular one-dimensional or two-dimensional frequency index in an inverse transform part of the decoding \nprocess.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          174
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.175  transform  coefficient  level:  An  integer  quantity  representing  the  value  associated  with  a  particular",
      "section_text": "two-dimensional frequency index in the  decoding process prior to scaling for computation of a transform \ncoefficient value.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          175
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.176  universal unique identifier (UUID): An identifier that is unique with respect to the space of all universal unique",
      "section_text": "identifiers.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          176
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.177  unspecified: The term unspecified, when used in the clauses specifying some values of a particular syntax",
      "section_text": "element, indicates that the values have no specified meaning in this Recommendation | International Standard \nand will not have a specified meaning in the future as an integral part of this Recommendation | International \nStandard.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          177
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.178  variable length coding (VLC): A reversible procedure for entropy coding that assigns shorter bit strings to",
      "section_text": "symbols expected to be more frequent and longer bit strings to symbols expected to be less frequent.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          178
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.179  VCL NAL unit: A collective term for coded slice NAL units and coded slice data partition NAL units.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          179
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.180  viewport: region of omnidirectional video content suitable for display and viewing by the user.",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          180
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "3.181  zig-zag scan: A specific sequential ordering of transform coefficient levels from (approximately) the lowest",
      "section_text": "spatial frequency to the highest. Zig-zag scan is used for transform coefficient levels in frame macroblocks.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          3
        ],
        [
          "N",
          181
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "4  Abbreviations",
      "section_text": "For the purposes of this Recommendation | International Standard, the following abbreviations apply: \nCABAC  Context-based Adaptive Binary Arithmetic Coding \nCAVLC  Context-based Adaptive Variable Length Coding \nCBR  Constant Bit Rate \nCPB  Coded Picture Buffer \nDPB  Decoded Picture Buffer \nDUT  Decoder under test \nFIFO  First-In, First-Out \nHRD  Hypothetical Reference Decoder \nHSS  Hypothetical Stream Scheduler \nIDR  Instantaneous Decoding Refresh \nLSB  Least Significant Bit \nMB  Macroblock \nMBAFF  Macroblock-Adaptive Frame-Field Coding \nMSB  Most Significant Bit \nMVC  Multiview Video Coding \nMVCD  Multiview Video Coding with Depth \nNAL  Network Abstraction Layer \nRBSP  Raw Byte Sequence Payload \nSEI  Supplemental Enhancement Information \nSODB  String Of Data Bits \nSVC  Scalable Video Coding \nUUID  Universal Unique Identifier \nVBR  Variable Bit Rate \n    Rec. ITU-T H.264 (06/2019)  15 \n \nVCL  Video Coding Layer \nVLC  Variable Length Coding \nVUI  Video Usability Information",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          4
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5  Conventions",
      "section_text": "NOTE – The mathematical operators used in this Specification are similar to those used in the C programming language. However, \ninteger division and arithmetic shift operations are specifically defined. Numbering and counting conventions generally begin from \n0.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.1  Arithmetic operators",
      "section_text": "The following arithmetic operators are defined as follows: \n  Addition \n−  Subtraction (as a two-argument operator) or negation (as a unary prefix operator) \n*  Multiplication, including matrix multiplication \nx y  Exponentiation. Specifies x to the power of y. In other contexts, such notation is used for superscripting \nnot intended for interpretation as exponentiation. \n/  Integer division with truncation of the result toward zero. For example, 7/4 and −7/−4 are truncated to 1 \nand −7/4 and 7/−4 are truncated to −1. \n÷  Used to denote division in mathematical equations where no truncation or rounding is intended. \nx\n  Used to denote division in mathematical equations where no truncation or rounding is intended. \ny\ny\n f (i)   The summation of f( i ) with i taking all integer values from x up to and including y. \nix\nx % y  Modulus. Remainder of x divided by y, defined only for integers x and y with x >= 0 and y > 0.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.2  Logical operators",
      "section_text": "The following logical operators are defined as follows: \nx  &&  y  Boolean logical \"and\" of x and y. \nx  | |  y  Boolean logical \"or\" of x and y. \n!  Boolean logical \"not\". \nx ? y : z  If x is TRUE or not equal to 0, evaluates to the value of y; otherwise, evaluates to the value of z.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.3  Relational operators",
      "section_text": "The following relational operators are defined as follows: \n  Greater than. \n  Greater than or equal to. \n  Less than. \n  Less than or equal to. \n   Equal to. \n!  Not equal to. \nWhen a relational operator is applied to a syntax element or variable that has been assigned the value \"na\" (not applicable), \nthe value \"na\" is treated as a distinct value for the syntax element or variable. The value \"na\" is considered not to be equal \nto any other value.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.4  Bit-wise operators",
      "section_text": "The following bit-wise operators are defined as follows: \n16  Rec. ITU-T H.264 (06/2019) \n \n&  Bit-wise \"and\". When operating on integer arguments, operates on a two's complement representation of \nthe integer value. When operating on a binary argument that contains fewer bits than another argument, \nthe shorter argument is extended by adding more significant bits equal to 0. \n|  Bit-wise \"or\". When operating on integer arguments, operates on a two's complement representation of \nthe integer value. When operating on a binary argument that contains fewer bits than another argument, \nthe shorter argument is extended by adding more significant bits equal to 0. \n^  Bit-wise  \"exclusive  or\".  When  operating  on  integer  arguments,  operates  on  a  two's  complement \nrepresentation of the integer value. When operating on a binary argument that contains fewer bits than \nanother argument, the shorter argument is extended by adding more significant bits equal to 0. \nx >> y  Arithmetic right shift of a two's complement integer representation of x by y binary digits. This function \nis defined only for positive integer values of y. Bits shifted into the MSBs as a result of the right shift \nhave a value equal to the MSB of x prior to the shift operation. \nx << y  Arithmetic left shift of a two's complement integer representation of x by y binary digits. This function \nis defined only for positive integer values of y. Bits shifted into the LSBs as a result of the left shift have \na value equal to 0.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          4
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.5  Assignment operators",
      "section_text": "The following arithmetic operators are defined as follows: \n Assignment operator. \n  Increment, i.e., x is equivalent to x  x  1; when used in an array index, evaluates to the value of the \n   \nvariable prior to the increment operation. \n−−  Decrement, i.e., x−− is equivalent to x  x − 1; when used in an array index, evaluates to the value of the \n   \nvariable prior to the decrement operation. \n+=  Increment by amount specified, i.e., x += 3 is equivalent to x = x + 3, and x += (−3) is equivalent \nto x = x + (−3). \n−=  Decrement by amount specified, i.e., x −= 3 is equivalent to x = x − 3, and x −= (−3) is equivalent \nto x = x − (−3).",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          5
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.6  Range notation",
      "section_text": "The following notation is used to specify a range of values: \nx = y..z  x takes on integer values starting from y to z, inclusive, with x, y, and z being integer numbers.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          6
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.7  Mathematical functions",
      "section_text": "The following mathematical functions are defined as follows: \n x ; x  0\nAbs( x )       (5-1) \n x ; x  0\n\nAsin( x ): The trigonometric inverse sine function, operating on an argument x that is \nin the range of −1.0 to 1.0, inclusive, with an output value in the range of \n−π÷2 to π÷2, inclusive, in units of radians.     (5-2) \nAtan( x ): The trigonometric inverse tangent function, operating on an argument x, with \nan output value in the range of −π÷2 to π÷2, inclusive, in units of radians.  (5-3) \n  Atan(  y  ) ; x > 0\nx\n \n  Atan(  y  ) + π ; x < 0  &&  y  >=  0\nx\nAtan2( y, x ) = \n \n  Atan(  y  ) − π ; x < 0  &&  y  <  0   (5-4) \nx\n  π\n+ ; x = =  0  &&  y  >=  0\n \n2\n{ − π ; otherwise\n2\n    Rec. ITU-T H.264 (06/2019)  17 \n \nCeil( x )   the smallest integer greater than or equal to x.  (5-5) \nClip1 ( x ) = Clip3( 0, ( 1 << BitDepth  ) − 1, x )    (5-6) \nY Y\nClip1 ( x ) = Clip3( 0, ( 1 << BitDepth  ) − 1, x )    (5-7) \nC C\nx ; z  x\n\nClip3( x, y, z ) =      (5-8) \ny ; z  y\n\nz ; otherwise\n\nCos( x )  the trigonometric cosine function operating on an argument x in units of radians.  (5-9) \nFloor( x ) the greatest integer less than or equal to x.   (5-10) \n(a%(d /b))*b ; e  0\nInverseRasterScan( a, b, c, d, e ) =    (5-11) \n(a/(d /b))*c ; e 1\n\nLn( x ) returns the natural logarithm of x.    (5-12) \nLog2( x ) returns the base-2 logarithm of x.    (5-13) \nLog10( x ) returns the base-10 logarithm of x.    (5-14) \nMedian( x, y, z ) = x + y + z − Min( x, Min( y, z ) ) − Max( x, Max( y, z ) )  (5-15) \nx ; x  y\nMin( x, y ) =      (5-16) \ny ; x  y\n\nx ; x  y\nMax( x, y ) =      (5-17) \ny ; x  y\n\nRound( x ) = Sign( x ) * Floor( Abs( x ) + 0.5 )    (5-18) \n 1 ; x  0\nSign( x ) \n      (5-19) \n1 ; x  0\n\nSin( x ):  The trigonometric sine function operating on an argument x in units of radians.  (5-20) \nSqrt( x ):  Returns the square root of x.     (5-21) \nTan( x ):  The trigonometric tangent function operating on an argument x in units of radians.  (5-22)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          7
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.8  Order of operation precedence",
      "section_text": "When order of precedence in an expression is not indicated explicitly by use of parentheses, the following rules apply: \n–  operations of a higher precedence are evaluated before any operation of a lower precedence, \n–  operations of the same precedence are evaluated sequentially from left to right. \nTable 5-1 specifies the precedence of operations from highest to lowest; a higher position in the table indicates a higher \nprecedence. \nNOTE – For those operators that are also used in the C programming language, the order of precedence used in this Specification is \nthe same as used in the C programming language. \n18  Rec. ITU-T H.264 (06/2019) \n \nTable 5-1 – Operation precedence from highest (at top of table) to lowest (at bottom of table) \noperations (with operands x, y, and z) \n\"x++\", \"x− −\" \n\"!x\", \"−x\" (as a unary prefix operator) \nxy \nx\n\"x * y\", \"x / y\", \"x ÷ y\"\" \", \"x % y\" \ny\ny\n\"x + y\", \"x − y\" (as a two-argument operator), \"\nf (i)\n\" \nix\n\"x << y\", \"x >> y\" \n\"x < y\", \"x <= y\", \"x > y\", \"x >= y\" \n\"x = = y\", \"x != y\" \n\"x & y\" \n\"x | y\" \n\"x && y\" \n\"x | | y\" \n\"x ? y : z\" \n\"x = y\", \"x += y\", \"x −= y\"",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          8
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.9  Variables, syntax elements, and tables",
      "section_text": "Syntax elements in the bitstream are represented in bold type. Each syntax element is described by its name (all lower case \nletters with underscore characters), its one or two syntax categories, and one or two descriptors for its method of coded \nrepresentation. The decoding process behaves according to the value of the syntax element and to the values of previously \ndecoded syntax elements. When a value of a syntax element is used in the syntax tables or the text, it appears in regular \n(i.e., not bold) type. \nIn some cases the syntax tables may use the values of other variables derived from syntax elements values. Such variables \nappear in the syntax tables, or text, named by a mixture of lower case and upper case letter and without any underscore \ncharacters. Variables starting with an upper case letter are derived for the decoding of the current syntax structure and all \ndepending syntax structures. Variables starting with an upper case letter may be used in the decoding process for later \nsyntax structures without mentioning the originating syntax structure of the variable. Variables starting with a lower case \nletter are only used within the clause in which they are derived. \nIn some cases, \"mnemonic\" names for syntax element values or variable values are used interchangeably with their \nnumerical values. Sometimes \"mnemonic\" names are used without any associated numerical values. The association of \nvalues and names is specified in the text. The names are constructed from one or more groups of letters separated by an \nunderscore character. Each group starts with an upper case letter and may contain more upper case letters. \nNOTE – The syntax is described in a manner that closely follows the C-language syntactic constructs. \nFunctions that specify properties of the current position in the bitstream are referred to as syntax functions. These functions \nare specified in clause 7.2 and assume the existence of a bitstream pointer with an indication of the position of the next bit \nto be read by the decoding process from the bitstream. Syntax functions are described by their names, which are constructed \nas syntax element names and end with left and right round parentheses including zero or more variable names (for \ndefinition) or values (for usage), separated by commas (if more than one variable). \nFunctions that are not syntax functions (including mathematical functions specified in clause 5.7) are described by their \nnames, which start with an upper case letter, contain a mixture of lower and upper case letters without any underscore \ncharacter, and end with left and right parentheses including zero or more variable names (for definition) or values (for \nusage) separated by commas (if more than one variable). \nSubscripts or square parentheses are used for the indexing of arrays. In reference to a visual depiction of a matrix, the first \nsubscript is used as a row (vertical) index and the second subscript is used as a column (horizontal) index. The indexing \norder is reversed when using square parentheses rather than subscripts for indexing. Thus, an element of a matrix s at \nhorizontal position x and vertical position y may be denoted either as s[ x, y ] or as s . \nyx\n    Rec. ITU-T H.264 (06/2019)  19 \n \nBinary notation is indicated by enclosing the string of bit values by single quote marks. For example, '01000001' represents \nan eight-bit string having only its second and its last bits (counted from the most to the least significant bit) equal to 1. \nHexadecimal notation, indicated by prefixing the hexadecimal number by \"0x\", may be used instead of binary notation \nwhen the number of bits is an integer multiple of 4. For example, 0x41 represents an eight-bit string having only its second \nand its last bits (counted from the most to the least significant bit) equal to 1. \nNumerical values not enclosed in single quotes and not prefixed by \"0x\" are decimal values. \nA value equal to 0 represents a FALSE condition in a test statement. The value TRUE is represented by any value different \nfrom zero.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          9
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.10  Text description of logical operations",
      "section_text": "In the text, a statement of logical operations as would be described in pseudo-code as \nif( condition 0 ) \n  statement 0 \nelse if ( condition 1 ) \n  statement 1 \n… \nelse /* informative remark on remaining condition */ \n  statement n \nmay be described in the following manner: \n... as follows / ... the following applies: \n–  If condition 0, statement 0 \n–  Otherwise, if condition 1, statement 1 \n–  … \n–  Otherwise (informative remark on remaining condition), statement n \nEach \"If ... Otherwise, if ... Otherwise, ...\" statement in the text is introduced with \"... as follows\" or \"... the following \napplies\" immediately followed by \"If ... \". The last condition of the \"If ... Otherwise, if ... Otherwise, ...\" is always an \n\"Otherwise, ...\". Interleaved \"If ... Otherwise, if ... Otherwise, ...\" statements can be identified by matching \"... as follows\" \nor \"... the following applies\" with the ending \"Otherwise, ...\". \nIn the text, a statement of logical operations as would be described in pseudo-code as \nif( condition 0a  &&  condition 0b ) \n  statement 0 \nelse if ( condition 1a  | |  condition 1b ) \n  statement 1 \n… \nelse \n  statement n \nmay be described in the following manner: \n... as follows / ... the following applies: \n–  If all of the following conditions are true, statement 0 \n–  condition 0a \n–  condition 0b \n–  Otherwise, if any of the following conditions are true, statement 1 \n–  condition 1a \n–  condition 1b \n–  … \n–  Otherwise, statement n \n20  Rec. ITU-T H.264 (06/2019) \n \nIn the text, a statement of logical operations as would be described in pseudo-code as: \nif( condition 0 ) \n  statement 0 \nif ( condition 1 ) \n  statement 1 \nmay be described in the following manner: \nWhen condition 0, statement 0 \nWhen condition 1, statement 1",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          10
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "5.11  Processes",
      "section_text": "Processes are used to describe the decoding of syntax elements. A process has a separate specification and invoking. All \nsyntax elements and upper case variables that pertain to the current syntax structure and depending syntax structures are \navailable in the process specification and invoking. A process specification may also have a lower case variable explicitly \nspecified as the input. Each process specification has explicitly specified an output. The output is a variable that can either \nbe an upper case variable or a lower case variable. \nWhen invoking a process, the assignment of variables is specified as follows: \n–  If the variables at the invoking and the process specification do not have the same name, the variables are \nexplicitly assigned to lower case input or output variables of the process specification. \n–  Otherwise (the variables at the invoking and the process specification have the same name), assignment is \nimplied. \nIn the specification of a process, a specific macroblock may be referred to by the variable name having a value equal to \nthe address of the specific macroblock.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          5
        ],
        [
          "N",
          11
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6  Source, coded, decoded and output data formats, scanning processes, and neighbouring",
      "section_text": "relationships",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.1  Bitstream formats",
      "section_text": "This clause specifies the relationship between the NAL unit stream and byte stream, either of which are referred to as the \nbitstream. \nThe bitstream can be in one of two formats: the NAL unit stream format or the byte stream format. The NAL unit stream \nformat is conceptually the more \"basic\" type. It consists of a sequence of syntax structures called NAL units. This sequence \nis ordered in decoding order. There are constraints imposed on the decoding order (and contents) of the NAL units in the \nNAL unit stream. \nThe byte stream format can be constructed from the NAL unit stream format by ordering the NAL units in decoding order \nand prefixing each NAL unit with a start code prefix and zero or more zero-valued bytes to form a stream of bytes. The \nNAL unit stream format can be extracted from the byte stream format by searching for the location of the unique start code \nprefix pattern within this stream of bytes. Methods of framing the NAL units in a manner other than use of the byte stream \nformat are outside the scope of this Recommendation | International Standard. The byte stream format is specified in \nAnnex B.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.2  Source, decoded, and output picture formats",
      "section_text": "This clause specifies the relationship between source and decoded frames and fields that is given via the bitstream. \nThe video source that is represented by the bitstream is a sequence of either or both frames or fields (called collectively \npictures) in decoding order. \nThe source and decoded pictures (frames or fields) are each comprised of one or more sample arrays: \n–  Luma (Y) only (monochrome), with or without an auxiliary array. \n–  Luma and two Chroma (YCbCr or YCgCo), with or without an auxiliary array. \n–  Green, Blue and Red (GBR, also known as RGB), with or without an auxiliary array. \n–  Arrays representing other unspecified monochrome or tri-stimulus colour samplings (for example, YZX, \nalso known as XYZ), with or without an auxiliary array. \n    Rec. ITU-T H.264 (06/2019)  21 \n \nFor convenience of notation and terminology in this Specification, the variables and terms associated with these arrays are \nreferred to as luma (or L or Y) and chroma, where the two chroma arrays are referred to as Cb and Cr; regardless of the \nactual colour representation method in use. The actual colour representation method in use can be indicated in syntax that \nis specified in Annex E. The (monochrome) auxiliary arrays, which may or may not be present as auxiliary pictures in a \ncoded video sequence, are optional for decoding and can be used for such purposes as alpha blending. \nThe variables SubWidthC, and SubHeightC are specified in Table 6-1, depending on the chroma format sampling structure, \nwhich is specified through chroma_format_idc and separate_colour_plane_flag. An entry marked as \"-\" in Table 6-1 \ndenotes  an  undefined  value  for  SubWidthC  or  SubHeightC.  Other  values  of  chroma_format_idc,  SubWidthC,  and \nSubHeightC may be specified in the future by ITU-T | ISO/IEC. \nTable 6-1 – SubWidthC, and SubHeightC values derived from  \nchroma_format_idc and separate_colour_plane_flag \n \nchroma_format_idc  separate_colour_plane_flag  Chroma Format  SubWidthC  SubHeightC \n0  0  monochrome  -  - \n1  0  4:2:0  2  2 \n2  0  4:2:2  2  1 \n3  0  4:4:4  1  1 \n3  1  4:4:4  -  - \nIn monochrome sampling there is only one sample array, which is nominally considered the luma array. \nIn 4:2:0 sampling, each of the two chroma arrays has half the height and half the width of the luma array. \nIn 4:2:2 sampling, each of the two chroma arrays has the same height and half the width of the luma array. \nIn 4:4:4 sampling, depending on the value of separate_colour_plane_flag, the following applies: \n–  If separate_colour_plane_flag is equal to 0, each of the two chroma arrays has the same height and width as the luma \narray. \n–  Otherwise (separate_colour_plane_flag is equal to 1), the three colour planes are separately processed as monochrome \nsampled pictures. \nThe width and height of the luma sample arrays are each an integer multiple of 16. In coded video sequences using 4:2:0 \nchroma sampling, the width and height of chroma sample arrays are each an integer multiple of 8. In coded video sequences \nusing 4:2:2 sampling, the width of the chroma sample arrays is an integer multiple of 8 and the height is an integer multiple \nof 16. The height of a luma array that is coded as two separate fields or in macroblock-adaptive frame-field coding (see \nbelow) is an integer multiple of 32. In coded video sequences using 4:2:0 chroma sampling, the height of each chroma \narray that is coded as two separate fields or in macroblock-adaptive frame-field coding (see below) is an integer multiple \nof 16. The width or height of pictures output from the decoding process need not be an integer multiple of 16 and can be \nspecified using a cropping rectangle. \nThe syntax for the luma and (when present) chroma arrays are ordered such when data for all three colour components is \npresent, the data for the luma array is first, followed by any data for the Cb array, followed by any data for the Cr array, \nunless otherwise specified. \nThe width of fields coded referring to a specific sequence parameter set is the same as that of frames coded referring to the \nsame sequence parameter set (see below). The height of fields coded referring to a specific sequence parameter set is half \nthat of frames coded referring to the same sequence parameter set (see below). \nThe number of bits necessary for the representation of each of the samples in the luma and chroma arrays in a video \nsequence is in the range of 8 to 14, and the number of bits used in the luma array may differ from the number of bits used \nin the chroma arrays. \nWhen the value of chroma_format_idc is equal to 1, the nominal vertical and horizontal relative locations of luma and \nchroma samples in frames are shown in Figure 6-1. Alternative chroma sample relative locations may be indicated in video \nusability information (see Annex E). \n22  Rec. ITU-T H.264 (06/2019) \n \nFrame\nLocation of luma sample\nLocation of chroma sample\nH.264(09)_F6-1  \nFigure 6-1 – Nominal vertical and horizontal locations of 4:2:0 luma and chroma samples in a frame \nA frame consists of two fields as described below. A coded picture may represent a coded frame or an individual coded \nfield.  A  coded  video  sequence  conforming  to  this  Recommendation | International  Standard  may  contain  arbitrary \ncombinations of coded frames and coded fields. The decoding process is also specified in a manner that allows smaller \nregions of a coded frame to be coded either as a frame or field region, by use of macroblock-adaptive frame-field coding. \nSource and decoded fields are one of two types: top field or bottom field. When two fields are output at the same time, or \nare combined to be used as a reference frame (see below), the two fields (which shall be of opposite parity) are interleaved. \nThe first (i.e., top), third, fifth, etc., rows of a decoded frame are the top field rows. The second, fourth, sixth, etc., rows of \na decoded frame are the bottom field rows. A top field consists of only the top field rows of a decoded frame. When the \ntop field or bottom field of a decoded frame is used as a reference field (see below) only the even rows (for a top field) or \nthe odd rows (for a bottom field) of the decoded frame are used. \nWhen the value of chroma_format_idc is equal to 1, the nominal vertical and horizontal relative locations of luma and \nchroma samples in top and bottom fields are shown in Figure 6-2. The nominal vertical sampling relative locations of the \nchroma samples in a top field are specified as shifted up by one-quarter luma sample height relative to the field-sampling \ngrid. The vertical sampling locations of the chroma samples in a bottom field are specified as shifted down by one-quarter \nluma sample height relative to the field-sampling grid. Alternative chroma sample relative locations may be indicated in \nthe video usability information (see Annex E). \nNOTE – The shifting of the chroma samples is in order for these samples to align vertically to the usual location relative to the full-\nframe sampling grid as shown in Figure 6-1. \n    Rec. ITU-T H.264 (06/2019)  23 \n \nTop Bottom\nfield field\nLocation of luma sample\nLocation of chroma sample\nH.264(09)_F6-2  \nFigure 6-2 – Nominal vertical and horizontal sampling locations of 4:2:0 samples in top and bottom fields \nWhen the value of chroma_format_idc is equal to 2, the chroma samples are co-sited with the corresponding luma samples \nand the nominal locations in a frame and in fields are as shown in Figures 6-3 and 6-4, respectively. \nFrame\nH.264(09)_F6-3\nLocation of luma sample\nLocation of chroma sample\n \nFigure 6-3 – Nominal vertical and horizontal locations of 4:2:2 luma and chroma samples in a frame \n \n24  Rec. ITU-T H.264 (06/2019) \n \nTop Bottom\nfield field\nLocation of luma sample\nLocation of chroma sample H.264(09)_F6-4  \nFigure 6-4 – Nominal vertical and horizontal sampling locations of 4:2:2 samples top and bottom fields \nWhen the value of chroma_format_idc is equal to 3, all array samples are co-sited for all cases of frames and fields and \nthe nominal locations in a frame and in fields are as shown in Figures 6-5 and 6-6, respectively. \nFrame\nH.264(09)_F6-5\nLocation of luma sample\nLocation of chroma sample\n \nFigure 6-5 – Nominal vertical and horizontal locations of 4:4:4 luma and chroma samples in a frame \nTop Bottom\nfield field\nLocation of luma sample\nLocation of chroma sample\nH.264(09)_F6-6  \nFigure 6-6 – Nominal vertical and horizontal sampling locations of 4:4:4 samples top and bottom fields \n    Rec. ITU-T H.264 (06/2019)  25 \n \nThe samples are processed in units of macroblocks. The luma array for each macroblock is 16 samples in both width and \nheight. The variables MbWidthC and MbHeightC, which specify the width and height, respectively, of the chroma arrays \nfor each macroblock, are derived as follows: \n–  If chroma_format_idc is equal to 0 (monochrome) or separate_colour_plane_flag is equal to 1, MbWidthC and \nMbHeightC are both equal to 0. \n–  Otherwise, MbWidthC and MbHeightC are derived as \nMbWidthC = 16 / SubWidthC    (6-1) \nMbHeightC = 16 / SubHeightC    (6-2)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.3  Spatial subdivision of pictures and slices",
      "section_text": "This clause specifies how a picture is partitioned into slices and macroblocks. Pictures are divided into slices. A slice is a \nsequence of macroblocks, or, when macroblock-adaptive frame/field decoding is in use, a sequence of macroblock pairs. \nEach macroblock is comprised of one 16x16 luma array and, when the chroma sampling format is not equal to 4:0:0 and \nseparate_colour_plane_flag is equal to 0, two corresponding chroma sample arrays. When separate_colour_plane_flag is \nequal to 1, each macroblock is comprised of one 16x16 luma or chroma sample array.  When  macroblock-adaptive \nframe/field decoding is not in use, each macroblock represents a spatial rectangular region of the picture. For example, a \npicture may be divided into two slices as shown in Figure 6-7. \nWhen a picture is coded using three separate colour planes (separate_colour_plane_flag is equal to 1), a slice contains only \nmacroblocks of one colour component being identified by the corresponding value of colour_plane_id, and each colour \ncomponent array of a picture consists of slices having the same colour_plane_id value. Coded slices with different values \nof colour_plane_id within an access unit can be interleaved with each other under the constraint that for each value of \ncolour_plane_id, the coded slice NAL units with that value colour_plane_id shall be in the order of increasing macroblock \naddress for the first macroblock of each coded slice NAL unit. \nNOTE – When separate_colour_plane_flag is equal to 0, each macroblock of a picture is contained in exactly one slice. When \nseparate_colour_plane_flag is equal to 1, each macroblock of a colour component is contained in exactly one slice (i.e., information \nfor each macroblock of a picture is present in exactly three slices and these three slices have different values of colour_plane_id). \n \nFigure 6-7 – A picture with 11 by 9 macroblocks that is partitioned into two slices \nWhen macroblock-adaptive frame/field decoding is in use, the picture is partitioned into slices containing an integer \nnumber of macroblock pairs as shown in Figure 6-8. Each macroblock pair consists of two macroblocks. \n26  Rec. ITU-T H.264 (06/2019) \n \nA macroblock pair\nH.264(09)_F6-8 \nFigure 6-8 – Partitioning of the decoded frame into macroblock pairs",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4  Inverse scanning processes and derivation processes for neighbours",
      "section_text": "This clause specifies inverse scanning processes; i.e., the mapping of indices to locations, and derivation processes for \nneighbours.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.1  Inverse macroblock scanning process",
      "section_text": "Input to this process is a macroblock address mbAddr. \nOutput of this process is the location ( x, y ) of the upper-left luma sample for the macroblock with address mbAddr relative \nto the upper-left sample of the picture. \nThe inverse macroblock scanning process is specified as follows: \n–  If MbaffFrameFlag is equal to 0, \nx = InverseRasterScan( mbAddr, 16, 16, PicWidthInSamples , 0 )   (6-3) \nL\ny = InverseRasterScan( mbAddr, 16, 16, PicWidthInSamples , 1 )   (6-4) \nL\n–  Otherwise (MbaffFrameFlag is equal to 1), the following ordered steps are specified: \n1.  The luma location ( xO, yO ) is derived by \nxO = InverseRasterScan( mbAddr / 2, 16, 32, PicWidthInSamples , 0 )   (6-5) \nL\nyO = InverseRasterScan( mbAddr / 2, 16, 32, PicWidthInSamples , 1 )   (6-6) \nL\n2.  Depending on the current macroblock the following applies: \n–  If the current macroblock is a frame macroblock \nx = xO    (6-7) \ny = yO + ( mbAddr % 2 ) * 16    (6-8) \n–  Otherwise (the current macroblock is a field macroblock), \nx = xO    (6-9) \ny = yO + ( mbAddr % 2 )    (6-10)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.2  Inverse macroblock partition and sub-macroblock partition scanning process",
      "section_text": "Macroblocks or sub-macroblocks may be partitioned, and the partitions are scanned for inter prediction as shown in \nFigure 6-9. The outer rectangles refer to the samples in a macroblock or sub-macroblock, respectively. The rectangles refer \nto the partitions. The number in each rectangle specifies the index of the inverse macroblock partition scan or inverse sub-\nmacroblock partition scan. \n    Rec. ITU-T H.264 (06/2019)  27 \n \nThe functions MbPartWidth( ), MbPartHeight( ), SubMbPartWidth( ), and SubMbPartHeight( ) describing the width and \nheight  of  macroblock  partitions  and  sub-macroblock  partitions  are  specified  in  Tables 7-13,  7-14,  7-17,  and  7-18. \nMbPartWidth( ) and MbPartHeight( ) are set to appropriate values for each macroblock, depending on the macroblock \ntype. SubMbPartWidth( ) and SubMbPartHeight( ) are set to appropriate values for each sub-macroblock of a macroblock \nwith mb_type equal to P_8x8, P_8x8ref0, or B_8x8, depending on the sub-macroblock type. \n1 macroblock partition of 2 macroblock partitions of 2 macroblock partitions of 4 sub-macroblocks of\n16*16 luma samples and 16*8 luma samples and 8*16 luma samples and 8*8 luma samples and\nassociated chroma samples associated chroma samples associated chroma samples associated chroma samples\n0 0 1\nMacroblock 0 0 1\npartitions 1 2 3\n1 sub-macroblock partition 2 sub-macroblock partitions 2 sub-macroblock partitions 4 sub-macroblock partitions\nof 8*8 luma samples and of 8*4 luma samples and  of 4*8 luma samples and of 4*4 luma samples and\nassociated chroma samples associated chroma samples associated chroma samples associated chroma samples\n0 0 1\nSub-macroblock\n0 0 1\npartitions\n1 2 3\n \nFigure 6-9 – Macroblock partitions, sub-macroblock partitions, macroblock partition scans, \nand sub-macroblock partition scans",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.2.1  Inverse macroblock partition scanning process",
      "section_text": "Input to this process is the index of a macroblock partition mbPartIdx. \nOutput of this process is the location ( x, y ) of the upper-left luma sample for the macroblock partition mbPartIdx relative \nto the upper-left sample of the macroblock. \nThe inverse macroblock partition scanning process is specified by \nx = InverseRasterScan( mbPartIdx, MbPartWidth( mb_type ), MbPartHeight( mb_type ), 16, 0 )  (6-11) \ny = InverseRasterScan( mbPartIdx, MbPartWidth( mb_type ), MbPartHeight( mb_type ), 16, 1 )    (6-12)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          2
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.2.2  Inverse sub-macroblock partition scanning process",
      "section_text": "Inputs to this process are the index of a macroblock partition mbPartIdx and the index of a sub-macroblock partition \nsubMbPartIdx. \nOutput of this process is the location ( x, y ) of the upper-left luma sample for the sub-macroblock partition subMbPartIdx \nrelative to the upper-left sample of the sub-macroblock. \nThe inverse sub-macroblock partition scanning process is specified as follows: \n–  If mb_type is equal to P_8x8, P_8x8ref0, or B_8x8, \nx = InverseRasterScan( subMbPartIdx, SubMbPartWidth( sub_mb_type[ mbPartIdx ] ),  \n                                               SubMbPartHeight( sub_mb_type[ mbPartIdx ] ), 8, 0 )   (6-13) \ny = InverseRasterScan( subMbPartIdx, SubMbPartWidth( sub_mb_type[ mbPartIdx ] ),  \n                                               SubMbPartHeight( sub_mb_type[ mbPartIdx ] ), 8, 1 )   (6-14) \n–  Otherwise (mb_type is not equal to P_8x8, P_8x8ref0, or B_8x8), \nx = InverseRasterScan( subMbPartIdx, 4, 4, 8, 0 )    (6-15) \n28  Rec. ITU-T H.264 (06/2019) \n \ny = InverseRasterScan( subMbPartIdx, 4, 4, 8, 1 )    (6-16)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          2
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.3  Inverse 4x4 luma block scanning process",
      "section_text": "Input to this process is the index of a 4x4 luma block luma4x4BlkIdx. \nOutput  of  this  process  is  the  location  ( x, y )  of  the  upper-left  luma  sample  for  the  4x4  luma  block  with  index \nluma4x4BlkIdx relative to the upper-left luma sample of the macroblock. \nFigure 6-10 shows the scan for the 4x4 luma blocks. \n0 1 4 5\n2 3 6 7\n8 9 12 13\n10 11 14 15\n \nFigure 6-10 – Scan for 4x4 luma blocks \nThe inverse 4x4 luma block scanning process is specified by \nx = InverseRasterScan( luma4x4BlkIdx / 4, 8, 8, 16, 0 ) + \n      InverseRasterScan( luma4x4BlkIdx % 4, 4, 4, 8, 0 )   (6-17) \ny = InverseRasterScan( luma4x4BlkIdx / 4, 8, 8, 16, 1 ) + \n      InverseRasterScan( luma4x4BlkIdx % 4, 4, 4, 8, 1 )   (6-18)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.4  Inverse 4x4 Cb or Cr block scanning process for ChromaArrayType equal to 3",
      "section_text": "This process is only invoked when ChromaArrayType is equal to 3. \nThe inverse 4x4 chroma block scanning process is identical to inverse 4x4 luma block scanning process as specified in \nclause 6.4.3  when  substituting  the  term  \"luma\"  with  the  term  \"Cb\"  or  the  term  \"Cr\",  and  substituting  the  term \n\"luma4x4BlkIdx\" with the term \"cb4x4BlkIdx\" or the term \"cr4x4BlkIdx\" in all places in clause 6.4.3.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          4
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.5  Inverse 8x8 luma block scanning process",
      "section_text": "Input to this process is the index of an 8x8 luma block luma8x8BlkIdx. \nOutput  of  this  process  is  the  location  ( x, y )  of  the  upper-left  luma  sample  for  the  8x8  luma  block  with  index \nluma8x8BlkIdx relative to the upper-left luma sample of the macroblock. \nFigure 6-11 shows the scan for the 8x8 luma blocks. \n0 1\n2 3\n \nFigure 6-11 – Scan for 8x8 luma blocks \nThe inverse 8x8 luma block scanning process is specified by: \nx = InverseRasterScan( luma8x8BlkIdx, 8, 8, 16, 0 )    (6-19) \ny = InverseRasterScan( luma8x8BlkIdx, 8, 8, 16, 1 )   (6-20) \n    Rec. ITU-T H.264 (06/2019)  29",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          5
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.6  Inverse 8x8 Cb or Cr block scanning process for ChromaArrayType equal to 3",
      "section_text": "This process is only invoked when ChromaArrayType is equal to 3. \nThe inverse 8x8 chroma block scanning process is identical to inverse 8x8 luma block scanning process as specified in \nclause 6.4.5  when  substituting  the  term  \"luma\"  with  the  term  \"Cb\"  or  the  term  \"Cr\",  and  substituting  the  term \n\"luma8x8BlkIdx\" with the term \"cb8x8BlkIdx\" or the term \"cr8x8BlkIdx\" in all places in clause 6.4.5.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          6
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.7  Inverse 4x4 chroma block scanning process",
      "section_text": "Input to this process is the index of a 4x4 chroma block chroma4x4BlkIdx. \nOutput  of  this  process  is  the  location  ( x, y )  of  the  upper-left  chroma  sample  for  a  4x4  chroma  block  with  index \nchroma4x4BlkIdx relative to the upper-left chroma sample of the macroblock. \nThe inverse 4x4 chroma block scanning process is specified by \nx = InverseRasterScan( chroma4x4BlkIdx, 4, 4, 8, 0 )  (6-21) \ny = InverseRasterScan( chroma4x4BlkIdx, 4, 4, 8, 1 )  (6-22)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          7
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.8  Derivation process of the availability for macroblock addresses",
      "section_text": "Input to this process is a macroblock address mbAddr. \nOutput of this process is the availability of the macroblock mbAddr. \nNOTE – The meaning of availability is determined when this process is invoked. \nThe macroblock is marked as available, unless any of the following conditions are true, in which case the macroblock is \nmarked as not available: \n–  mbAddr < 0, \n–  mbAddr > CurrMbAddr, \n–  the macroblock with address mbAddr belongs to a different slice than the macroblock with address CurrMbAddr.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          8
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.9  Derivation process for neighbouring macroblock addresses and their availability",
      "section_text": "This process can only be invoked when MbaffFrameFlag is equal to 0. \nThe outputs of this process are: \n–  mbAddrA: the address and availability status of the macroblock to the left of the current macroblock, \n–  mbAddrB: the address and availability status of the macroblock above the current macroblock, \n–  mbAddrC: the address and availability status of the macroblock above-right of the current macroblock, \n–  mbAddrD: the address and availability status of the macroblock above-left of the current macroblock. \nFigure 6-12 shows the relative spatial locations of the macroblocks with mbAddrA, mbAddrB, mbAddrC, and mbAddrD \nrelative to the current macroblock with CurrMbAddr. \n \n30  Rec. ITU-T H.264 (06/2019) \n \nmbAddrD  mbAddrB  mbAddrC \nmbAddrA  CurrMbAddr   \n     \nFigure 6-12 – Neighbouring macroblocks for a given macroblock \nInput to the process in clause 6.4.8 is mbAddrA = CurrMbAddr − 1 and the output is whether the macroblock mbAddrA \nis available. In addition, mbAddrA is marked as not available when CurrMbAddr % PicWidthInMbs is equal to 0. \nInput  to  the  process  in  clause 6.4.8  is  mbAddrB = CurrMbAddr − PicWidthInMbs  and  the  output  is  whether  the \nmacroblock mbAddrB is available. \nInput to the process in clause 6.4.8 is mbAddrC = CurrMbAddr − PicWidthInMbs + 1 and the output is whether the \nmacroblock  mbAddrC  is  available.  In  addition,  mbAddrC  is  marked  as  not  available  when \n( CurrMbAddr + 1 ) % PicWidthInMbs is equal to 0. \nInput to the process in clause 6.4.8 is mbAddrD = CurrMbAddr − PicWidthInMbs − 1 and the output is whether the \nmacroblock  mbAddrD  is  available.  In  addition,  mbAddrD  is  marked  as  not  available  when \nCurrMbAddr % PicWidthInMbs is equal to 0.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          9
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.10  Derivation process for neighbouring macroblock addresses and their availability in MBAFF frames",
      "section_text": "This process can only be invoked when MbaffFrameFlag is equal to 1. \nThe outputs of this process are: \n–  mbAddrA: the address and availability status of the top macroblock of the macroblock pair to the left of the current \nmacroblock pair, \n–  mbAddrB: the address and availability status of  the top  macroblock of the  macroblock pair above the current \nmacroblock pair, \n–  mbAddrC: the address and availability status of the top macroblock of the macroblock pair above-right of the current \nmacroblock pair, \n–  mbAddrD: the address and availability status of the top macroblock of the macroblock pair above-left of the current \nmacroblock pair. \nFigure 6-13 shows the relative spatial locations of the macroblocks with mbAddrA, mbAddrB, mbAddrC, and mbAddrD \nrelative to the current macroblock with CurrMbAddr. \nmbAddrA, mbAddrB, mbAddrC, and mbAddrD have identical values regardless whether the current macroblock is the top \nor the bottom macroblock of a macroblock pair. \n \n    Rec. ITU-T H.264 (06/2019)  31 \n \nmbAddrD  mbAddrB  mbAddrC \n     \nmbAddrA  CurrMbAddr or   \n  CurrMbAddr   \nFigure 6-13 – Neighbouring macroblocks for a given macroblock in MBAFF frames \nInput to the process in clause 6.4.8 is mbAddrA = 2 * ( CurrMbAddr / 2 − 1 ) and the output is whether the macroblock \nmbAddrA is available. In addition, mbAddrA is marked as not available when ( CurrMbAddr / 2 ) % PicWidthInMbs is \nequal to 0. \nInput to the process in clause 6.4.8 is mbAddrB = 2 * ( CurrMbAddr / 2 − PicWidthInMbs ) and the output is whether the \nmacroblock mbAddrB is available. \nInput to the process in clause 6.4.8 is mbAddrC = 2 * ( CurrMbAddr / 2 − PicWidthInMbs + 1 ) and the output is whether \nthe  macroblock  mbAddrC  is  available.  In  addition,  mbAddrC  is  marked  as  not  available  when \n( CurrMbAddr / 2 + 1) % PicWidthInMbs is equal to 0. \nInput to the process in clause 6.4.8 is mbAddrD = 2 * ( CurrMbAddr / 2 − PicWidthInMbs − 1 ) and the output is whether \nthe  macroblock  mbAddrD  is  available.  In  addition,  mbAddrD  is  marked  as  not  available  when \n( CurrMbAddr / 2 ) % PicWidthInMbs is equal to 0.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          10
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.11  Derivation processes for neighbouring macroblocks, blocks, and partitions",
      "section_text": "Clause 6.4.11.1 specifies the derivation process for neighbouring macroblocks. \nClause 6.4.11.2 specifies the derivation process for neighbouring 8x8 luma blocks. \nClause 6.4.11.3 specifies the derivation process for neighbouring 8x8 chroma blocks for ChromaArrayType equal to 3. \nClause 6.4.11.4 specifies the derivation process for neighbouring 4x4 luma blocks. \nClause 6.4.11.5 specifies the derivation process for neighbouring 4x4 chroma blocks. \nClause 6.4.11.6 specifies the derivation process for neighbouring 4x4 chroma blocks for ChromaArrayType equal to 3. \nClause 6.4.11.7 specifies the derivation process for neighbouring partitions. \nTable 6-2 specifies the values for the difference of luma location ( xD, yD ) for the input and the replacement for N in \nmbAddrN,  mbPartIdxN,  subMbPartIdxN,  luma8x8BlkIdxN,  cb8x8BlkIdxN,  cr8x8BlkIdxN,  luma4x4BlkIdxN, \ncb4x4BlkIdxN, cr4x4BlkIdxN, and chroma4x4BlkIdxN for the output. These input and output assignments are used in \nclauses 6.4.11.1 to 6.4.11.7. The variable predPartWidth is specified when Table 6-2 is referred to. \nTable 6-2 – Specification of input and output assignments for clauses 6.4.11.1 to 6.4.11.7 \n \nN  xD  yD \nA  −1  0 \nB  0  −1 \nC  predPartWidth  −1 \nD  −1  −1 \n \nFigure 6-14 illustrates the relative location of the neighbouring macroblocks, blocks, or partitions A, B, C, and D to the \ncurrent macroblock, partition, or block, when the current macroblock, partition, or block is in frame coding mode. \n32  Rec. ITU-T H.264 (06/2019) \n \nD B C\nCurrent\nA\nMacroblock\nor Partition\nor Block\n \nFigure 6-14 – Determination of the neighbouring macroblock, blocks, and partitions (informative)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          11
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.11.1  Derivation process for neighbouring macroblocks",
      "section_text": "Outputs of this process are: \n–  mbAddrA: the address of the macroblock to the left of the current macroblock and its availability status, \n–  mbAddrB: the address of the macroblock above the current macroblock and its availability status. \nmbAddrN (with N being A or B) is derived as specified by the following ordered steps: \n1.  The difference of luma location ( xD, yD ) is set according to Table 6-2. \n2.  The derivation process for neighbouring locations as specified in clause 6.4.12 is invoked for luma locations with \n( xN, yN ) equal to ( xD, yD ), and the output is assigned to mbAddrN.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          11
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.11.2  Derivation process for neighbouring 8x8 luma block",
      "section_text": "Input to this process is an 8x8 luma block index luma8x8BlkIdx. \nThe luma8x8BlkIdx specifies the 8x8 luma blocks of a macroblock in a raster scan. \nOutputs of this process are: \n–  mbAddrA: either equal to CurrMbAddr or the address of the macroblock to the left of the current macroblock and its \navailability status, \n–  luma8x8BlkIdxA: the index of the 8x8 luma block to the left of the 8x8 block with index luma8x8BlkIdx and its \navailability status, \n–  mbAddrB: either equal to CurrMbAddr or the address of the macroblock above the current macroblock and its \navailability status, \n–  luma8x8BlkIdxB: the index of the 8x8 luma block above the 8x8 block with index luma8x8BlkIdx and its availability \nstatus. \nmbAddrN and luma8x8BlkIdxN (with N being A or B) are derived as specified by the following ordered steps: \n1.  The difference of luma location ( xD, yD ) is set according to Table 6-2. \n2.  The luma location ( xN, yN ) is specified by \nxN = ( luma8x8BlkIdx % 2 ) * 8 + xD    (6-23) \nyN = ( luma8x8BlkIdx / 2 ) * 8 + yD    (6-24) \n3.  The derivation process for neighbouring locations as specified in clause 6.4.12 is invoked for luma locations with \n( xN, yN ) as the input and the output is assigned to mbAddrN and ( xW, yW ). \n4.  The variable luma8x8BlkIdxN is derived as follows: \n–  If mbAddrN is not available, luma8x8BlkIdxN is marked as not available. \n–  Otherwise (mbAddrN is available), the  derivation process for 8x8 luma block indices as specified in \nclause 6.4.13.3 is invoked  with  the luma location ( xW, yW ) as the input and the output  is assigned \nto luma8x8BlkIdxN. \n    Rec. ITU-T H.264 (06/2019)  33",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          11
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.11.3  Derivation process for neighbouring 8x8 chroma blocks for ChromaArrayType equal to 3",
      "section_text": "This process is only invoked when ChromaArrayType is equal to 3. \nThe derivation process for neighbouring 8x8 chroma block is identical to the derivation process for neighbouring 8x8 luma \nblock as specified in clause 6.4.11.2 when substituting the term \"luma\" with the term \"Cb\" or the term \"Cr\", and substituting \nthe term \"luma8x8BlkIdx\" with the term \"cb8x8BlkIdx\" or the term \"cr8x8BlkIdx\" in all places in clause 6.4.11.2.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          11
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.11.4  Derivation process for neighbouring 4x4 luma blocks",
      "section_text": "Input to this process is a 4x4 luma block index luma4x4BlkIdx. \nOutputs of this process are: \n–  mbAddrA: either equal to CurrMbAddr or the address of the macroblock to the left of the current macroblock and its \navailability status, \n–  luma4x4BlkIdxA: the index of the 4x4 luma block to the left of the 4x4 block with index luma4x4BlkIdx and its \navailability status, \n–  mbAddrB: either equal to CurrMbAddr or the address of the macroblock above the current macroblock and its \navailability status, \n–  luma4x4BlkIdxB: the index of the 4x4 luma block above the 4x4 block with index luma4x4BlkIdx and its availability \nstatus. \nmbAddrN and luma4x4BlkIdxN (with N being A or B) are derived as specified by the following ordered steps: \n1.  The difference of luma location ( xD, yD ) is set according to Table 6-2. \n2.  The inverse 4x4 luma block scanning process as specified in clause 6.4.3 is invoked with luma4x4BlkIdx as the \ninput and ( x, y ) as the output. \n3.  The luma location ( xN, yN ) is specified by: \nxN = x + xD    (6-25) \nyN = y + yD    (6-26) \n4.  The derivation process for neighbouring locations as specified in clause 6.4.12 is invoked for luma locations with \n( xN, yN ) as the input and the output is assigned to mbAddrN and ( xW, yW ). \n5.  The variable luma4x4BlkIdxN is derived as follows: \n–  If mbAddrN is not available, luma4x4BlkIdxN is marked as not available. \n–  Otherwise (mbAddrN is available), the  derivation process for 4x4 luma block indices  as specified in \nclause 6.4.13.1 is invoked  with  the luma location ( xW, yW ) as the input and the output is assigned \nto luma4x4BlkIdxN.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          11
        ],
        [
          "N",
          4
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.11.5  Derivation process for neighbouring 4x4 chroma blocks",
      "section_text": "This clause is only invoked when ChromaArrayType is equal to 1 or 2. \nInput to this process is a 4x4 chroma block index chroma4x4BlkIdx. \nOutputs of this process are: \n–  mbAddrA (either equal to CurrMbAddr or the address of the macroblock to the left of the current macroblock) and \nits availability status, \n–  chroma4x4BlkIdxA  (the  index  of  the  4x4  chroma  block  to  the  left  of  the  4x4  chroma  block  with  index \nchroma4x4BlkIdx) and its availability status, \n–  mbAddrB (either equal to CurrMbAddr or the address of the macroblock above the current macroblock) and its \navailability status, \n–  chroma4x4BlkIdxB (the index of the 4x4 chroma block above the 4x4 chroma block with index chroma4x4BlkIdx) \nand its availability status. \nmbAddrN and chroma4x4BlkIdxN (with N being A or B) are derived as specified by the following ordered steps: \n1.  The difference of chroma location ( xD, yD ) is set according to Table 6-2. \n2.  The inverse 4x4 chroma block scanning process as specified in clause 6.4.7 is invoked with chroma4x4BlkIdx as \nthe input and ( x, y ) as the output. \n34  Rec. ITU-T H.264 (06/2019) \n \n3.  The chroma location ( xN, yN ) is specified by \nxN = x + xD    (6-27) \nyN = y + yD    (6-28) \n4.  The derivation process for neighbouring locations as specified in clause 6.4.12 is invoked for chroma locations \nwith ( xN, yN ) as the input and the output is assigned to mbAddrN and ( xW, yW ). \n5.  The variable chroma4x4BlkIdxN is derived as follows: \n–  If mbAddrN is not available, chroma4x4BlkIdxN is marked as not available. \n–  Otherwise (mbAddrN is available), the derivation process for 4x4 chroma block indices as specified in \nclause 6.4.13.2 is invoked with the chroma location ( xW, yW ) as the input and the output is assigned to \nchroma4x4BlkIdxN.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          11
        ],
        [
          "N",
          5
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.11.6  Derivation process for neighbouring 4x4 chroma blocks for ChromaArrayType equal to 3",
      "section_text": "This process is only invoked when ChromaArrayType is equal to 3. \nThe derivation process for neighbouring 4x4 chroma block in 4:4:4 chroma format is identical to the derivation process \nfor neighbouring 4x4 luma block as specified in clause 6.4.11.4 when substituting the term \"luma\" with the term \"Cb\" or \nthe term \"Cr\", and substituting the term \"luma4x4BlkIdx\" with the term \"cb4x4BlkIdx\" or the term \"cr4x4BlkIdx\" in all \nplaces in clause 6.4.11.4.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          11
        ],
        [
          "N",
          6
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.11.7  Derivation process for neighbouring partitions",
      "section_text": "Inputs to this process are: \n–  a macroblock partition index mbPartIdx \n–  a current sub-macroblock type currSubMbType \n–  a sub-macroblock partition index subMbPartIdx \nOutputs of this process are: \n–  mbAddrA\\mbPartIdxA\\subMbPartIdxA: specifying the macroblock or sub-macroblock partition to the left of the \ncurrent macroblock and its availability status, or the sub-macroblock partition CurrMbAddr\\mbPartIdx\\subMbPartIdx \nand its availability status, \n–  mbAddrB\\mbPartIdxB\\subMbPartIdxB: specifying the macroblock or sub-macroblock partition above the current \nmacroblock and its availability status, or the sub-macroblock partition CurrMbAddr\\mbPartIdx\\subMbPartIdx and its \navailability status, \n–  mbAddrC\\mbPartIdxC\\subMbPartIdxC: specifying the macroblock or sub-macroblock partition to the right-above of \nthe  current  macroblock  and  its  availability  status,  or  the  sub-macroblock  partition \nCurrMbAddr\\mbPartIdx\\subMbPartIdx and its availability status, \n–  mbAddrD\\mbPartIdxD\\subMbPartIdxD: specifying the macroblock or sub-macroblock partition to the left-above of \nthe  current  macroblock  and  its  availability  status,  or  the  sub-macroblock  partition \nCurrMbAddr\\mbPartIdx\\subMbPartIdx and its availability status. \nmbAddrN, mbPartIdxN, and subMbPartIdxN (with N being A, B, C, or D) are derived as specified by the following ordered \nsteps: \n1.  The inverse macroblock partition scanning process as described in clause 6.4.2.1 is invoked with mbPartIdx as \nthe input and ( x, y ) as the output. \n2.  The location of the upper-left luma sample inside a macroblock partition ( xS, yS ) is derived as follows: \n–  If mb_type is equal to P_8x8, P_8x8ref0 or B_8x8, the inverse sub-macroblock partition scanning process \nas described in clause 6.4.2.2 is invoked with subMbPartIdx as the input and ( xS, yS ) as the output. \n–  Otherwise, ( xS, yS ) are set to ( 0, 0 ). \n3.  The variable predPartWidth in Table 6-2 is specified as follows: \n–  If mb_type is equal to P_Skip, B_Skip, or B_Direct_16x16, predPartWidth = 16. \n–  Otherwise, if mb_type is equal to B_8x8, the following applies: \n    Rec. ITU-T H.264 (06/2019)  35 \n \n–  If currSubMbType is equal to B_Direct_8x8, predPartWidth = 16. \nNOTE 1 – When currSubMbType is equal to B_Direct_8x8 and direct_spatial_mv_pred_flag is equal to 1, \nthe predicted motion vector is the predicted motion vector for the complete macroblock. \n–  Otherwise, predPartWidth = SubMbPartWidth( sub_mb_type[ mbPartIdx ] ). \n–  Otherwise,  if  mb_type  is  equal  to  P_8x8  or  P_8x8ref0, \npredPartWidth = SubMbPartWidth( sub_mb_type[ mbPartIdx ] ). \n–  Otherwise, predPartWidth = MbPartWidth( mb_type ). \n4.  The difference of luma location ( xD, yD ) is set according to Table 6-2. \n5.  The neighbouring luma location ( xN, yN ) is specified by \nxN = x + xS + xD    (6-29) \nyN = y + yS + yD    (6-30) \n6.  The derivation process for neighbouring locations as specified in clause 6.4.12 is invoked for luma locations with \n( xN, yN ) as the input and the output is assigned to mbAddrN and ( xW, yW ). \n7.  Depending on mbAddrN, the following applies: \n–  If  mbAddrN  is  not  available,  the  macroblock  or  sub-macroblock  partition \nmbAddrN\\mbPartIdxN\\subMbPartIdxN is marked as not available. \n–  Otherwise (mbAddrN is available), the following ordered steps are specified: \na.  Let  mbTypeN  be  the  syntax  element  mb_type  of  the  macroblock  with  macroblock  address \nmbAddrN and, when mbTypeN is equal to P_8x8, P_8x8ref0, or B_8x8, let subMbTypeN be the \nsyntax element list sub_mb_type of the macroblock with macroblock address mbAddrN. \nb.  The  derivation  process  for  macroblock  and  sub-macroblock  partition  indices  as  specified  in \nclause 6.4.13.4 is invoked with the luma location ( xW, yW ), the macroblock type mbTypeN, and, \nwhen  mbTypeN  is  equal  to  P_8x8,  P_8x8ref0,  or  B_8x8,  the  list  of  sub-macroblock  types \nsubMbTypeN as the inputs and the outputs are the macroblock partition index mbPartIdxN and the \nsub-macroblock partition index subMbPartIdxN. \nc.  When the partition given by mbPartIdxN and subMbPartIdxN is not yet decoded, the macroblock \npartition  mbPartIdxN  and  the  sub-macroblock  partition  subMbPartIdxN  are  marked  as  not \navailable. \nNOTE 2 – The latter condition is, for example, the case when mbPartIdx = 2, subMbPartIdx = 3, xD = 4, yD = −1, \ni.e., when neighbour C of the last 4x4 luma block of the third sub-macroblock is requested.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          11
        ],
        [
          "N",
          7
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.12  Derivation process for neighbouring locations",
      "section_text": "Input to this process is a luma or chroma location ( xN, yN ) expressed relative to the upper left corner of the current \nmacroblock. \nOutputs of this process are: \n–  mbAddrN: either equal to CurrMbAddr or to the address of neighbouring macroblock that contains (xN, yN) and its \navailability status, \n–  ( xW, yW ): the location (xN, yN) expressed relative to the upper-left corner of the macroblock mbAddrN (rather than \nrelative to the upper-left corner of the current macroblock). \nLet  maxW and  maxH be variables specifying  maximum  values of the location components xN,  xW, and  yN,  yW, \nrespectively. maxW and maxH are derived as follows: \n–  If this process is invoked for neighbouring luma locations, \nmaxW = maxH = 16    (6-31) \n–  Otherwise (this process is invoked for neighbouring chroma locations), \nmaxW = MbWidthC    (6-32) \nmaxH = MbHeightC    (6-33) \n36  Rec. ITU-T H.264 (06/2019) \n \nDepending on the variable MbaffFrameFlag, the neighbouring locations are derived as follows: \n–  If MbaffFrameFlag is equal to 0, the specification for neighbouring locations in fields and non-MBAFF frames as \ndescribed in clause 6.4.12.1 is applied. \n–  Otherwise (MbaffFrameFlag is equal to 1), the specification for neighbouring locations in MBAFF frames as described \nin clause 6.4.12.2 is applied.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          12
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.12.1  Specification for neighbouring locations in fields and non-MBAFF frames",
      "section_text": "The specifications in this clause are applied when MbaffFrameFlag is equal to 0. \nThe derivation process for neighbouring macroblock addresses and their availability in  clause 6.4.9 is invoked with \nmbAddrA, mbAddrB, mbAddrC, and mbAddrD as well as their availability status as the output. \nTable 6-3 specifies mbAddrN depending on ( xN, yN ). \nTable 6-3 – Specification of mbAddrN \nxN  yN  mbAddrN \n< 0  < 0  mbAddrD \n< 0  0..maxH − 1  mbAddrA \n0..maxW − 1  < 0  mbAddrB \n0..maxW − 1  0..maxH − 1  CurrMbAddr \n> maxW − 1  < 0  mbAddrC \n> maxW − 1  0..maxH − 1  not available \n  > maxH − 1  not available \n \nThe neighbouring location ( xW, yW ) relative to the upper-left corner of the macroblock mbAddrN is derived as \nxW = ( xN + maxW ) % maxW    (6-34) \nyW = ( yN + maxH ) % maxH    (6-35)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          12
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.12.2  Specification for neighbouring locations in MBAFF frames",
      "section_text": "The specifications in this clause are applied when MbaffFrameFlag is equal to 1. \nThe derivation process for neighbouring macroblock addresses and their availability in clause 6.4.10 is invoked with \nmbAddrA, mbAddrB, mbAddrC, and mbAddrD as well as their availability status as the output. \nThe variable currMbFrameFlag is derived as follows: \n–  If the macroblock with address CurrMbAddr is a frame macroblock, currMbFrameFlag is set equal to 1. \n–  Otherwise (the macroblock with address CurrMbAddr is a field macroblock), currMbFrameFlag is set equal to 0. \nThe variable mbIsTopMbFlag is derived as follows: \n–  If  the  macroblock  with  address  CurrMbAddr  is  a  top  macroblock  (i.e.,  CurrMbAddr % 2  is  equal  to 0), \nmbIsTopMbFlag is set equal to 1. \n–  Otherwise (the macroblock with address CurrMbAddr is a bottom macroblock, i.e., CurrMbAddr % 2 is equal to 1), \nmbIsTopMbFlag is set equal to 0. \nTable 6-4 specifies the macroblock addresses mbAddrN and yM in two ordered steps: \n1.  Specification of a macroblock address mbAddrX depending on ( xN, yN ) and the variables currMbFrameFlag \nand mbIsTopMbFlag: \n2.  Depending on the availability of mbAddrX, the following applies: \n–  If mbAddrX is not available, mbAddrN is marked as not available. \n    Rec. ITU-T H.264 (06/2019)  37 \n \n–  Otherwise (mbAddrX is available), mbAddrN is marked as available and Table 6-4 specifies mbAddrN and \nyM depending on ( xN, yN ), currMbFrameFlag, mbIsTopMbFlag, and the variable mbAddrXFrameFlag, \nwhich is derived as follows: \n–  If the macroblock mbAddrX is a frame macroblock, mbAddrXFrameFlag is set equal to 1. \n–  Otherwise (the macroblock mbAddrX is a field macroblock), mbAddrXFrameFlag is set equal to 0. \nUnspecified values (na) of the above flags in Table 6-4 indicate that the value of the corresponding flag is not relevant for \nthe current table rows. \nTable 6-4 – Specification of mbAddrN and yM \n \ng  \na n\n  F l a g   a g m e F l d i t i o\nm e b F l r a o n\nF r a p M   X X F a l   c   N\nb o d r d r n d r\nM T d d o d\ni\ns A A t A\n  N   N r r b I b b d i b   M\nu m m m d m\nx y c a y\n1  mbAddrD      mbAddrD + 1  yN \n1    mbAddrA  yN \n1 \n0  mbAddrA \n0    mbAddrA + 1  ( yN + maxH ) >> 1 \n< 0  < 0 \n1    mbAddrD + 1  2*yN \n1  mbAddrD \n0    mbAddrD  yN \n0 \n0  mbAddrD      mbAddrD + 1  yN \n1    mbAddrA  yN \n1  mbAddrA  yN % 2 = = 0  mbAddrA  yN >> 1 \n0 \nyN % 2 != 0  mbAddrA + 1  yN >> 1 \n1 \n1    mbAddrA + 1  yN \n0  mbAddrA  yN % 2 = = 0  mbAddrA  ( yN + maxH ) >> 1 \n0 \nyN % 2 != 0  mbAddrA + 1  ( yN + maxH ) >> 1 \n< 0  0..maxH − 1 \nyN < ( maxH / 2 )  mbAddrA  yN <<1  \n1 \n1  mbAddrA  yN >= ( maxH / 2 ) mbAddrA + 1  ( yN <<1 ) − maxH \n0    mbAddrA  yN \n0 \nyN < ( maxH / 2 )  mbAddrA  ( yN <<1 ) + 1 \n1 \n0  mbAddrA  yN >= ( maxH / 2 ) mbAddrA + 1  ( yN <<1 ) + 1 − maxH \n0    mbAddrA + 1  yN \n1  mbAddrB      mbAddrB + 1  yN \n1 \n0  CurrMbAddr     CurrMbAddr − 1 yN \n1    mbAddrB + 1  2 * yN \n0..maxW − 1 < 0 \n1  mbAddrB \n0    mbAddrB  yN \n0 \n0  mbAddrB      mbAddrB + 1  yN \n0..maxW − 1 0..maxH − 1     CurrMbAddr     CurrMbAddr  yN \n1  mbAddrC      mbAddrC + 1  yN \n1 \n0  not available     not available  na \n1    mbAddrC + 1  2 * yN \n> maxW − 1  <0 \n1  mbAddrC \n0    mbAddrC  yN \n0 \n0  mbAddrC      mbAddrC + 1  yN \n> maxW − 1  0..maxH − 1     not available     not available  na \n  > maxH − 1      not available     not available  na \n \nThe neighbouring luma location ( xW, yW ) relative to the upper-left corner of the macroblock mbAddrN is derived as \nxW = ( xN + maxW ) % maxW    (6-36) \nyW = ( yM + maxH ) % maxH    (6-37) \n38  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          12
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.13  Derivation processes for block and partition indices",
      "section_text": "Clause 6.4.13.1 specifies the derivation process for 4x4 luma block indices. \nClause 6.4.13.2 specifies the derivation process for 4x4 chroma block indices. \nClause 6.4.13.3 specifies the derivation process for 8x8 luma block indices. \nClause 6.4.13.4 specifies the derivation process for macroblock and sub-macroblock partition indices.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          13
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.13.1  Derivation process for 4x4 luma block indices",
      "section_text": "Input to this process is a luma location ( xP, yP ) relative to the upper-left luma sample of a macroblock. \nOutput of this process is a 4x4 luma block index luma4x4BlkIdx. \nThe 4x4 luma block index luma4x4BlkIdx is derived by \nluma4x4BlkIdx = 8 * ( yP / 8 ) + 4 * ( xP / 8 ) + 2 * ( ( yP % 8 ) / 4 ) + ( ( xP % 8 ) / 4 )  (6-38)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          13
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.13.2  Derivation process for 4x4 chroma block indices",
      "section_text": "This clause is only invoked when ChromaArrayType is equal to 1 or 2. \nInput to this process is a chroma location ( xP, yP ) relative to the upper-left chroma sample of a macroblock. \nOutput of this process is a 4x4 chroma block index chroma4x4BlkIdx. \nThe 4x4 chroma block index chroma4x4BlkIdx is derived by \nchroma4x4BlkIdx = 2 * ( yP / 4 ) + ( xP / 4 )    (6-39)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          13
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.13.3  Derivation process for 8x8 luma block indices",
      "section_text": "Input to this process is a luma location ( xP, yP ) relative to the upper-left luma sample of a macroblock. \nOutputs of this process is an 8x8 luma block index luma8x8BlkIdx. \nThe 8x8 luma block index luma8x8BlkIdx is derived by \nluma8x8BlkIdx = 2 * ( yP / 8 ) + ( xP / 8 )    (6-40)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          13
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "6.4.13.4  Derivation process for macroblock and sub-macroblock partition indices",
      "section_text": "Inputs to this process are: \n–  a luma location ( xP, yP ) relative to the upper-left luma sample of a macroblock, \n–  a macroblock type mbType, \n–  when mbType is equal to P_8x8, P_8x8ref0, or B_8x8, a list of sub-macroblock types subMbType with 4 elements. \nOutputs of this process are: \n–  a macroblock partition index mbPartIdx, \n–  a sub-macroblock partition index subMbPartIdx. \nThe macroblock partition index mbPartIdx is derived as follows: \n–  If mbType specifies an I macroblock type, mbPartIdx is set equal to 0. \n–  Otherwise (mbType does not specify an I macroblock type), mbPartIdx is derived by \nmbPartIdx = ( 16 / MbPartWidth( mbType ) ) * ( yP / MbPartHeight( mbType ) ) + \n                                                                              ( xP / MbPartWidth( mbType ) )  (6-41) \nThe sub-macroblock partition index subMbPartIdx is derived as follows: \n–  If mbType is not equal to P_8x8, P_8x8ref0, B_8x8, B_Skip, or B_Direct_16x16, subMbPartIdx is set equal to 0. \n–  Otherwise, if mbType is equal to B_Skip or B_Direct_16x16, subMbPartIdx is derived by \nsubMbPartIdx = 2 * ( ( yP % 8 ) / 4 ) + ( ( xP % 8 ) / 4 )  (6-42) \n    Rec. ITU-T H.264 (06/2019)  39 \n \n–  Otherwise (mbType is equal to P_8x8, P_8x8ref0, or B_8x8), subMbPartIdx is derived by \nsubMbPartIdx = ( 8 / SubMbPartWidth( subMbType[ mbPartIdx ] ) ) *  \n                                ( ( yP % 8 ) / SubMbPartHeight( subMbType[ mbPartIdx ] ) ) + \n                                 ( ( xP % 8 ) / SubMbPartWidth( subMbType[ mbPartIdx ] ) )  (6-43)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          6
        ],
        [
          "N",
          4
        ],
        [
          "N",
          13
        ],
        [
          "N",
          4
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7  Syntax and semantics",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.1  Method of specifying syntax in tabular form",
      "section_text": "The syntax tables specify a superset of the syntax of all allowed bitstreams. Additional constraints on the syntax may be \nspecified, either directly or indirectly, in other clauses. \nNOTE – An actual decoder should implement means for identifying entry points into the bitstream and means to identify and handle \nnon-conforming bitstreams. The methods for identifying and handling errors and other such situations are not specified here. \nThe following table lists examples of pseudo code used to describe the syntax. When syntax_element appears, it specifies \nthat a syntax element is parsed from the bitstream and the bitstream pointer is advanced to the next position beyond the \nsyntax element in the bitstream parsing process. \n \n  C  Descriptor \n/* A statement can be a syntax element with an associated syntax category and     \ndescriptor or can be an expression used to specify conditions for the existence, \ntype, and quantity of syntax elements, as in the following two examples */ \nsyntax_element  3  ue(v) \nconditioning statement     \n     \n/* A group of statements enclosed in curly brackets is a compound statement and     \nis treated functionally as a single statement. */ \n{     \n  statement     \n  statement     \n  …     \n}     \n     \n/* A \"while\" structure specifies a test of whether a condition is true, and if true,     \nspecifies evaluation of a statement (or compound statement) repeatedly until the \ncondition is no longer true */ \nwhile( condition )     \n  statement     \n     \n/* A \"do … while\" structure specifies evaluation of a statement once, followed by     \na test of whether a condition is true, and if true, specifies repeated evaluation of \nthe statement until the condition is no longer true */ \ndo     \n  statement     \nwhile( condition )     \n     \n/* An \"if … else\" structure specifies a test of whether a condition is true, and if     \nthe condition is true, specifies evaluation of a primary statement, otherwise, \nspecifies evaluation of an alternative statement. The \"else\" part of the structure \nand the associated alternative statement is omitted if no alternative statement \nevaluation is needed */ \nif( condition )     \n  primary statement     \nelse     \n  alternative statement     \n     \n40  Rec. ITU-T H.264 (06/2019) \n \n/* A \"for\" structure specifies evaluation of an initial statement, followed by a test     \nof a condition, and if the condition is true, specifies repeated evaluation of a \nprimary statement followed by a subsequent statement until the condition is no \nlonger true. */ \nfor( initial statement; condition; subsequent statement )     \n  primary statement",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.2  Specification of syntax functions, categories, and descriptors",
      "section_text": "The functions presented here are used in the syntactical description. These functions assume the existence of a bitstream \npointer with an indication of the position of the next bit to be read by the decoding process from the bitstream. \nbyte_aligned( ) is specified as follows: \n–  If the current position in the bitstream is on a byte boundary, i.e., the next bit in the bitstream is the first bit in a \nbyte, the return value of byte_aligned( ) is equal to TRUE. \n–  Otherwise, the return value of byte_aligned( ) is equal to FALSE. \nmore_data_in_byte_stream( ), which is used only in the byte stream NAL unit syntax structure specified in Annex B, is \nspecified as follows: \n–  If more data follow in the byte stream, the return value of more_data_in_byte_stream( ) is equal to TRUE. \n–  Otherwise, the return value of more_data_in_byte_stream( ) is equal to FALSE. \nmore_rbsp_data( ) is specified as follows: \n–  If there is no more data in the RBSP, the return value of more_rbsp_data( ) is equal to FALSE. \n–  Otherwise, the RBSP data is searched for the last (least significant, right-most) bit equal to 1 that is present in the \nRBSP. Given the position of this bit, which is the first bit (rbsp_stop_one_bit) of the rbsp_trailing_bits( ) syntax \nstructure, the following applies: \n–  If  there  is  more  data  in  an  RBSP  before  the  rbsp_trailing_bits( )  syntax  structure,  the  return  value  of \nmore_rbsp_data( ) is equal to TRUE. \n–  Otherwise, the return value of more_rbsp_data( ) is equal to FALSE. \nThe method for enabling determination of whether there is more data in the RBSP is specified by the application (or \nin Annex B for applications that use the byte stream format). \nmore_rbsp_trailing_data( ) is specified as follows: \n–  If there is more data in an RBSP, the return value of more_rbsp_trailing_data( ) is equal to TRUE. \n–  Otherwise, the return value of more_rbsp_trailing_data( ) is equal to FALSE. \nnext_bits( n ) provides the next bits in the bitstream for comparison purposes, without advancing the bitstream pointer. \nProvides a look at the next n bits in the bitstream with n being its argument. When used within the byte stream as specified \nin Annex B, next_bits( n ) returns a value of 0 if fewer than n bits remain within the byte stream. \nread_bits( n ) reads the next n bits from the bitstream and advances the bitstream pointer by n bit positions. When n is \nequal to 0, read_bits( n ) is specified to return a value equal to 0 and to not advance the bitstream pointer. \nCategories (labelled in the table as C) specify the partitioning of slice data into at most three slice data partitions. Slice \ndata partition A contains all syntax elements of category 2. Slice data partition B contains all syntax elements of category 3. \nSlice data partition C contains all syntax elements of category 4. The meaning of other category values is not specified. \nFor some syntax elements, two category values, separated by a vertical bar, are used. In these cases, the category value to \nbe applied is further specified in the text. For syntax structures used within other syntax structures, the categories of all \nsyntax elements found within the included syntax structure are listed, separated by a vertical bar. A syntax element or \nsyntax structure with category marked as \"All\" is present within all syntax structures that include that syntax element or \nsyntax structure. For syntax structures used within other syntax structures, a numeric category value provided in a syntax \ntable at the location of the inclusion of a syntax structure containing a syntax element with category marked as \"All\" is \nconsidered to apply to the syntax elements with category \"All\". \n    Rec. ITU-T H.264 (06/2019)  41 \n \nThe following descriptors specify the parsing process of each syntax element. For some syntax elements, two descriptors, \nseparated by a vertical bar, are used. In these cases, the left descriptors apply when entropy_coding_mode_flag is equal \nto 0 and the right descriptor applies when entropy_coding_mode_flag is equal to 1. \n–  ae(v):  context-adaptive  arithmetic  entropy-coded  syntax  element.  The  parsing  process  for  this  descriptor  is \nspecified in clause 9.3. \n–  b(8): byte having any pattern of bit string (8 bits). The parsing process for this descriptor is specified by the return \nvalue of the function read_bits( 8 ). \n–  ce(v): context-adaptive variable-length entropy-coded syntax element with the left bit first. The parsing process \nfor this descriptor is specified in clause 9.2. \n–  f(n): fixed-pattern bit string using n bits written (from left to right) with the left bit first. The parsing process for \nthis descriptor is specified by the return value of the function read_bits( n ). \n–  i(n): signed integer using n bits. When n is \"v\" in the syntax table, the number of bits varies in a manner dependent \non the value of other syntax elements. The parsing process for this descriptor is specified by the return value of \nthe function read_bits( n ) interpreted as a two's complement integer representation with most significant bit \nwritten first. \n–  me(v): mapped Exp-Golomb-coded syntax element with the left bit first. The parsing process for this descriptor \nis specified in clause 9.1. \n–  se(v): signed integer Exp-Golomb-coded syntax element with the left bit first. The parsing process for this \ndescriptor is specified in clause 9.1. \n–  te(v): truncated Exp-Golomb-coded syntax element with left bit first. The parsing process for this descriptor is \nspecified in clause 9.1. \n–  u(n): unsigned integer using n bits. When n is \"v\" in the syntax table, the number of bits varies in a manner \ndependent on the value of other syntax elements. The parsing process for this descriptor is specified by the return \nvalue of the  function read_bits( n ) interpreted as a binary representation of an unsigned integer  with  most \nsignificant bit written first. \n–  ue(v): unsigned integer Exp-Golomb-coded syntax element with the left bit first. The parsing process for this \ndescriptor is specified in clause 9.1. \n42  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3  Syntax in tabular form",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.1  NAL unit syntax",
      "section_text": "nal_unit( NumBytesInNALunit ) {  C  Descriptor \n  forbidden_zero_bit  All  f(1) \n  nal_ref_idc  All  u(2) \n  nal_unit_type  All  u(5) \n  NumBytesInRBSP = 0     \n  nalUnitHeaderBytes = 1     \n  if( nal_unit_type  = =  14  | |  nal_unit_type  = =  20  | |     \n    nal_unit_type  = =  21 ) { \n    if( nal_unit_type ! =  21 )     \n      svc_extension_flag  All  u(1) \n    else     \n      avc_3d_extension_flag  All  u(1) \n    if( svc_extension_flag ) {     \n      nal_unit_header_svc_extension( ) /* specified in Annex G */  All   \n      nalUnitHeaderBytes += 3     \n    } else if( avc_3d_extension_flag ) {     \n      nal_unit_header_3davc_extension( ) /* specified in Annex J */     \n      nalUnitHeaderBytes += 2     \n    } else {     \n      nal_unit_header_mvc_extension( ) /* specified in Annex H */  All   \n      nalUnitHeaderBytes += 3     \n    }     \n  }     \n  for( i = nalUnitHeaderBytes; i < NumBytesInNALunit; i++ ) {     \n    if( i + 2 < NumBytesInNALunit && next_bits( 24 )  = =  0x000003 ) {     \n      rbsp_byte[ NumBytesInRBSP++ ]  All  b(8) \n      rbsp_byte[ NumBytesInRBSP++ ]  All  b(8) \n      i += 2     \n      emulation_prevention_three_byte  /* equal to 0x03 */  All  f(8) \n    } else     \n      rbsp_byte[ NumBytesInRBSP++ ]  All  b(8) \n  }     \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2  Raw byte sequence payloads and RBSP trailing bits syntax",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.1  Sequence parameter set RBSP syntax",
      "section_text": "seq_parameter_set_rbsp( ) {  C  Descriptor \n  seq_parameter_set_data( )  0   \n  rbsp_trailing_bits( )  0   \n}     \n \n    Rec. ITU-T H.264 (06/2019)  43",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.1.1 Sequence parameter set data syntax",
      "section_text": "seq_parameter_set_data( ) {  C  Descriptor \n  profile_idc  0  u(8) \n  constraint_set0_flag  0  u(1) \n  constraint_set1_flag  0  u(1) \n  constraint_set2_flag  0  u(1) \n  constraint_set3_flag  0  u(1) \n  constraint_set4_flag  0  u(1) \n  constraint_set5_flag  0  u(1) \n  reserved_zero_2bits  /* equal to 0 */  0  u(2) \n  level_idc  0  u(8) \n  seq_parameter_set_id  0  ue(v) \n  if( profile_idc  = =  100  | |  profile_idc  = =  110  | |     \n    profile_idc  = =  122  | |  profile_idc  = =  244  | |  profile_idc  = =  44  | | \n    profile_idc  = =  83  | |  profile_idc  = =  86  | |  profile_idc  = =  118  | | \n    profile_idc  = =  128  | |  profile_idc  = =  138  | |  profile_idc  = =  139  | | \n    profile_idc  = =  134  | |  profile_idc  = =  135 ) { \n    chroma_format_idc  0  ue(v) \n    if( chroma_format_idc  = =  3 )     \n      separate_colour_plane_flag  0  u(1) \n    bit_depth_luma_minus8  0  ue(v) \n    bit_depth_chroma_minus8  0  ue(v) \n    qpprime_y_zero_transform_bypass_flag  0  u(1) \n    seq_scaling_matrix_present_flag  0  u(1) \n    if( seq_scaling_matrix_present_flag )     \n      for( i = 0; i < ( ( chroma_format_idc  !=  3 ) ? 8 : 12 ); i++ ) {     \n        seq_scaling_list_present_flag[ i ]  0  u(1) \n        if( seq_scaling_list_present_flag[ i ] )     \n          if( i < 6 )      \n            scaling_list( ScalingList4x4[ i ], 16,   0   \n                       UseDefaultScalingMatrix4x4Flag[ i ] ) \n          else     \n            scaling_list( ScalingList8x8[ i − 6 ], 64,  0   \n                       UseDefaultScalingMatrix8x8Flag[ i − 6 ] ) \n      }     \n  }     \n44  Rec. ITU-T H.264 (06/2019) \n \n  log2_max_frame_num_minus4  0  ue(v) \n  pic_order_cnt_type  0  ue(v) \n  if( pic_order_cnt_type  = =  0 )     \n    log2_max_pic_order_cnt_lsb_minus4  0  ue(v) \n  else if( pic_order_cnt_type  = =  1 ) {     \n    delta_pic_order_always_zero_flag  0  u(1) \n    offset_for_non_ref_pic  0  se(v) \n    offset_for_top_to_bottom_field  0  se(v) \n    num_ref_frames_in_pic_order_cnt_cycle  0  ue(v) \n    for( i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++ )     \n      offset_for_ref_frame[ i ]  0  se(v) \n  }     \n  max_num_ref_frames  0  ue(v) \n  gaps_in_frame_num_value_allowed_flag  0  u(1) \n  pic_width_in_mbs_minus1  0  ue(v) \n  pic_height_in_map_units_minus1  0  ue(v) \n  frame_mbs_only_flag  0  u(1) \n  if( !frame_mbs_only_flag )     \n    mb_adaptive_frame_field_flag  0  u(1) \n  direct_8x8_inference_flag  0  u(1) \n  frame_cropping_flag  0  u(1) \n  if( frame_cropping_flag ) {     \n    frame_crop_left_offset  0  ue(v) \n    frame_crop_right_offset  0  ue(v) \n    frame_crop_top_offset  0  ue(v) \n    frame_crop_bottom_offset  0  ue(v) \n  }     \n  vui_parameters_present_flag  0  u(1) \n  if( vui_parameters_present_flag )     \n    vui_parameters( )  0   \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          1
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.1.2 Sequence parameter set extension RBSP syntax",
      "section_text": "seq_parameter_set_extension_rbsp( ) {  C  Descriptor \n  seq_parameter_set_id  10  ue(v) \n  aux_format_idc  10  ue(v) \n  if( aux_format_idc  !=  0 ) {     \n    bit_depth_aux_minus8  10  ue(v) \n    alpha_incr_flag  10  u(1) \n    alpha_opaque_value  10  u(v) \n    alpha_transparent_value  10  u(v) \n  }     \n  additional_extension_flag  10  u(1) \n  rbsp_trailing_bits( )  10   \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          1
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.1.3 Subset sequence parameter set RBSP syntax",
      "section_text": "subset_seq_parameter_set_rbsp( ) {  C  Descriptor \n  seq_parameter_set_data( )  0   \n  if( profile_idc  = =  83  | |  profile_idc  = =  86 ) {     \n    seq_parameter_set_svc_extension( )  /* specified in Annex G */  0   \n    svc_vui_parameters_present_flag  0  u(1) \n    if( svc_vui_parameters_present_flag  = =  1 )     \n      svc_vui_parameters_extension( )  /* specified in Annex G */  0   \n  } else if( profile_idc  = =  118  | |  profile_idc  = =  128  | |     \n    profile_idc  = =  134  ) { \n    bit_equal_to_one  /* equal to 1 */  0  f(1) \n    seq_parameter_set_mvc_extension( )  /* specified in Annex H */  0   \n    mvc_vui_parameters_present_flag  0  u(1) \n    if( mvc_vui_parameters_present_flag  = =  1 )     \n      mvc_vui_parameters_extension( )  /* specified in Annex H */  0   \n  } else if( profile_idc  = =  138 | |  profile_idc  = =  135 ) {     \n    bit_equal_to_one  /* equal to 1 */  0  f(1) \n    seq_parameter_set_mvcd_extension( )  /* specified in Annex I */     \n  } else if( profile_idc  = =  139 ) {     \n    bit_equal_to_one  /* equal to 1 */  0  f(1) \n    seq_parameter_set_mvcd_extension( )  /* specified in Annex I */  0   \n    seq_parameter_set_3davc_extension( ) /* specified in Annex J */  0   \n  }     \n  additional_extension2_flag  0  u(1) \n  if( additional_extension2_flag  = =  1 )     \n    while( more_rbsp_data( ) )     \n      additional_extension2_data_flag  0  u(1) \n  rbsp_trailing_bits( )  0   \n}     \n \n46  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          1
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.2  Picture parameter set RBSP syntax",
      "section_text": "pic_parameter_set_rbsp( ) {  C  Descriptor \n  pic_parameter_set_id  1  ue(v) \n  seq_parameter_set_id  1  ue(v) \n  entropy_coding_mode_flag  1  u(1) \n  bottom_field_pic_order_in_frame_present_flag  1  u(1) \n  num_slice_groups_minus1  1  ue(v) \n  if( num_slice_groups_minus1 > 0 ) {     \n    slice_group_map_type  1  ue(v) \n    if( slice_group_map_type  = =  0 )     \n      for( iGroup = 0; iGroup <= num_slice_groups_minus1; iGroup++ )     \n        run_length_minus1[ iGroup ]  1  ue(v) \n    else if( slice_group_map_type  = =  2 )     \n      for( iGroup = 0; iGroup < num_slice_groups_minus1; iGroup++ ) {     \n        top_left[ iGroup ]  1  ue(v) \n        bottom_right[ iGroup ]  1  ue(v) \n      }     \n    else if(  slice_group_map_type  = =  3  | |       \n          slice_group_map_type  = =  4  | |   \n          slice_group_map_type  = =  5 ) { \n      slice_group_change_direction_flag  1  u(1) \n      slice_group_change_rate_minus1  1  ue(v) \n    } else if( slice_group_map_type  = =  6 ) {     \n      pic_size_in_map_units_minus1  1  ue(v) \n      for( i = 0; i <= pic_size_in_map_units_minus1; i++ )     \n        slice_group_id[ i ]  1  u(v) \n    }     \n  }     \n  num_ref_idx_l0_default_active_minus1  1  ue(v) \n  num_ref_idx_l1_default_active_minus1  1  ue(v) \n  weighted_pred_flag  1  u(1) \n  weighted_bipred_idc  1  u(2) \n  pic_init_qp_minus26  1  se(v) \n  pic_init_qs_minus26  1  se(v) \n  chroma_qp_index_offset  1  se(v) \n  deblocking_filter_control_present_flag  1  u(1) \n  constrained_intra_pred_flag  1  u(1) \n  redundant_pic_cnt_present_flag  1  u(1) \n  if( more_rbsp_data( ) ) {     \n    transform_8x8_mode_flag  1  u(1) \n    pic_scaling_matrix_present_flag  1  u(1) \n    if( pic_scaling_matrix_present_flag )     \n      for( i = 0; i < 6 +     \n          ( ( chroma_format_idc  !=  3 ) ? 2 : 6 ) * transform_8x8_mode_flag; \n          i++ ) { \n        pic_scaling_list_present_flag[ i ]  1  u(1) \n        if( pic_scaling_list_present_flag[ i ] )     \n          if( i < 6 )      \n    Rec. ITU-T H.264 (06/2019)  47 \n \n            scaling_list( ScalingList4x4[ i ], 16,   1   \n                       UseDefaultScalingMatrix4x4Flag[ i ] ) \n          else     \n            scaling_list( ScalingList8x8[ i − 6 ], 64,  1   \n                       UseDefaultScalingMatrix8x8Flag[ i − 6 ] ) \n      }     \n    second_chroma_qp_index_offset  1  se(v) \n  }     \n  rbsp_trailing_bits( )  1   \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.3  Supplemental enhancement information RBSP syntax",
      "section_text": "sei_rbsp( ) {  C  Descriptor \ndo     \nsei_message( )  5   \nwhile( more_rbsp_data( ) )     \nrbsp_trailing_bits( )  5   \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.3.1 Supplemental enhancement information message syntax",
      "section_text": "sei_message( ) {  C  Descriptor \npayloadType = 0     \nwhile( next_bits( 8 )  = =  0xFF ) {     \nff_byte  /* equal to 0xFF */  5  f(8) \npayloadType += 255     \n}     \nlast_payload_type_byte  5  u(8) \npayloadType += last_payload_type_byte     \npayloadSize = 0     \nwhile( next_bits( 8 )  = =  0xFF ) {     \nff_byte  /* equal to 0xFF */  5  f(8) \npayloadSize += 255     \n}     \nlast_payload_size_byte  5  u(8) \npayloadSize += last_payload_size_byte     \nsei_payload( payloadType, payloadSize )  5   \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          3
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.4  Access unit delimiter RBSP syntax",
      "section_text": "access_unit_delimiter_rbsp( ) {  C  Descriptor \n  primary_pic_type  6  u(3) \n  rbsp_trailing_bits( )  6   \n}     \n48  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          4
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.5  End of sequence RBSP syntax",
      "section_text": "end_of_seq_rbsp( ) {  C  Descriptor \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          5
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.6  End of stream RBSP syntax",
      "section_text": "end_of_stream_rbsp( ) {  C  Descriptor \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          6
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.7  Filler data RBSP syntax",
      "section_text": "filler_data_rbsp( ) {  C  Descriptor \n  while( next_bits( 8 )  = =  0xFF )     \n    ff_byte  /* equal to 0xFF */  9  f(8) \n  rbsp_trailing_bits( )  9   \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          7
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.8  Slice layer without partitioning RBSP syntax",
      "section_text": "slice_layer_without_partitioning_rbsp( ) {  C  Descriptor \n  slice_header( )  2   \n  slice_data( )  /* all categories of slice_data( ) syntax */  2 | 3 | 4   \n  rbsp_slice_trailing_bits( )  2   \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          8
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.9  Slice data partition RBSP syntax",
      "section_text": "",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          9
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.9.1 Slice data partition A RBSP syntax",
      "section_text": "slice_data_partition_a_layer_rbsp( ) {  C  Descriptor \n  slice_header( )  2   \n  slice_id  All  ue(v) \n  slice_data( )  /* only category 2 parts of slice_data( ) syntax */  2   \n  rbsp_slice_trailing_bits( )  2   \n}     \n \n    Rec. ITU-T H.264 (06/2019)  49",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          9
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.9.2 Slice data partition B RBSP syntax",
      "section_text": "slice_data_partition_b_layer_rbsp( ) {  C  Descriptor \n  slice_id  All  ue(v) \n  if( separate_colour_plane_flag  = =  1 )     \n    colour_plane_id  All  u(2) \n  if( redundant_pic_cnt_present_flag )     \n    redundant_pic_cnt  All  ue(v) \n  slice_data( )  /* only category 3 parts of slice_data( ) syntax */  3   \n  rbsp_slice_trailing_bits( )  3   \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          9
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.9.3 Slice data partition C RBSP syntax",
      "section_text": "slice_data_partition_c_layer_rbsp( ) {  C  Descriptor \n  slice_id  All  ue(v) \n  if( separate_colour_plane_flag  = =  1 )     \n    colour_plane_id  All  u(2) \n  if( redundant_pic_cnt_present_flag )     \n    redundant_pic_cnt  All  ue(v) \n  slice_data( )  /* only category 4 parts of slice_data( ) syntax */  4   \n  rbsp_slice_trailing_bits( )  4   \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          9
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.10  RBSP slice trailing bits syntax",
      "section_text": "rbsp_slice_trailing_bits( ) {  C  Descriptor \n  rbsp_trailing_bits( )  All   \n  if( entropy_coding_mode_flag )     \n    while( more_rbsp_trailing_data( ) )     \n      cabac_zero_word  /* equal to 0x0000 */  All  f(16) \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          10
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.11  RBSP trailing bits syntax",
      "section_text": "rbsp_trailing_bits( ) {  C  Descriptor \n  rbsp_stop_one_bit  /* equal to 1 */  All  f(1) \n  while( !byte_aligned( ) )     \n    rbsp_alignment_zero_bit  /* equal to 0 */  All  f(1) \n}     \n \n50  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          11
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.12  Prefix NAL unit RBSP syntax",
      "section_text": "prefix_nal_unit_rbsp( ) {  C  Descriptor \n  if( svc_extension_flag )     \n    prefix_nal_unit_svc( )  /* specified in Annex G */  2   \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          12
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.2.13  Slice layer extension RBSP syntax",
      "section_text": "slice_layer_extension_rbsp( ) {  C  Descriptor \n  if( svc_extension_flag ) {     \n    slice_header_in_scalable_extension( )  /* specified in Annex G */  2   \n    if( !slice_skip_flag )     \n      slice_data_in_scalable_extension( )  /* specified in Annex G */  2 | 3 | 4   \n  } else if( avc_3d_extension_flag ) {     \n    slice_header_in_3davc_extension( )  /* specified in Annex J */  2   \n    slice_data_in_3davc_extension( )  /* specified in Annex J */  2 | 3 | 4   \n  } else {     \n    slice_header( )  2   \n    slice_data( )  2 | 3 | 4   \n  }     \n  rbsp_slice_trailing_bits( )  2   \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ],
        [
          "N",
          13
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.3  Slice header syntax",
      "section_text": "slice_header( ) {  C  Descriptor \n  first_mb_in_slice  2  ue(v) \n  slice_type  2  ue(v) \n  pic_parameter_set_id  2  ue(v) \n  if( separate_colour_plane_flag  = =  1 )     \n    colour_plane_id  2  u(2) \n  frame_num  2  u(v) \n  if( !frame_mbs_only_flag ) {     \n    field_pic_flag  2  u(1) \n    if( field_pic_flag )     \n      bottom_field_flag  2  u(1) \n  }     \n  if( IdrPicFlag )     \n    idr_pic_id  2  ue(v) \n  if( pic_order_cnt_type  = =  0 ) {     \n    pic_order_cnt_lsb  2  u(v) \n    if( bottom_field_pic_order_in_frame_present_flag &&  !field_pic_flag )     \n      delta_pic_order_cnt_bottom  2  se(v) \n  }     \n  if( pic_order_cnt_type = = 1 && !delta_pic_order_always_zero_flag ) {     \n    delta_pic_order_cnt[ 0 ]  2  se(v) \n    Rec. ITU-T H.264 (06/2019)  51 \n \n    if( bottom_field_pic_order_in_frame_present_flag  &&  !field_pic_flag )     \n      delta_pic_order_cnt[ 1 ]  2  se(v) \n  }     \n  if( redundant_pic_cnt_present_flag )     \n    redundant_pic_cnt  2  ue(v) \n  if( slice_type  = =  B )     \n    direct_spatial_mv_pred_flag  2  u(1) \n  if( slice_type  = =  P  | |  slice_type  = =  SP  | |  slice_type  = =  B ) {     \n    num_ref_idx_active_override_flag  2  u(1) \n    if( num_ref_idx_active_override_flag ) {     \n      num_ref_idx_l0_active_minus1  2  ue(v) \n      if( slice_type  = =  B )     \n        num_ref_idx_l1_active_minus1  2  ue(v) \n    }     \n  }     \n  if( nal_unit_type  = =  20  | |  nal_unit_type  = =  21 )     \n    ref_pic_list_mvc_modification( )  /* specified in Annex H */  2   \n  else     \n    ref_pic_list_modification( )  2   \n  if( ( weighted_pred_flag  &&  ( slice_type  = =  P  | |  slice_type  = =  SP ) )  | |     \n    ( weighted_bipred_idc  = =  1  &&  slice_type  = =  B ) ) \n    pred_weight_table( )  2   \n  if( nal_ref_idc != 0 )     \n    dec_ref_pic_marking( )  2   \n  if( entropy_coding_mode_flag  &&  slice_type  !=  I  &&  slice_type  !=  SI )     \n    cabac_init_idc  2  ue(v) \n  slice_qp_delta  2  se(v) \n  if( slice_type  = =  SP  | |  slice_type  = =  SI ) {     \n    if( slice_type  = =  SP )     \n      sp_for_switch_flag  2  u(1) \n    slice_qs_delta  2  se(v) \n  }     \n  if( deblocking_filter_control_present_flag ) {     \n    disable_deblocking_filter_idc  2  ue(v) \n    if( disable_deblocking_filter_idc  !=  1 ) {     \n      slice_alpha_c0_offset_div2  2  se(v) \n      slice_beta_offset_div2  2  se(v) \n    }     \n  }     \n  if( num_slice_groups_minus1 > 0  &&     \n    slice_group_map_type >= 3  &&  slice_group_map_type <= 5) \n    slice_group_change_cycle  2  u(v) \n}     \n \n52  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.3.1  Reference picture list modification syntax",
      "section_text": "ref_pic_list_modification( ) {  C  Descriptor \n  if( slice_type % 5  !=  2  &&  slice_type % 5  !=  4 ) {      \n    ref_pic_list_modification_flag_l0  2  u(1) \n    if( ref_pic_list_modification_flag_l0 )     \n      do {     \n        modification_of_pic_nums_idc  2  ue(v) \n        if( modification_of_pic_nums_idc  = =  0  | |     \n          modification_of_pic_nums_idc  = =  1 ) \n          abs_diff_pic_num_minus1  2  ue(v) \n        else if( modification_of_pic_nums_idc  = =  2 )     \n          long_term_pic_num  2  ue(v) \n      } while( modification_of_pic_nums_idc  !=  3 )     \n  }     \n  if( slice_type % 5  = =  1 ) {      \n    ref_pic_list_modification_flag_l1  2  u(1) \n    if( ref_pic_list_modification_flag_l1 )     \n      do {     \n        modification_of_pic_nums_idc  2  ue(v) \n        if( modification_of_pic_nums_idc  = =  0  | |     \n          modification_of_pic_nums_idc  = =  1 ) \n          abs_diff_pic_num_minus1  2  ue(v) \n        else if( modification_of_pic_nums_idc  = =  2 )     \n          long_term_pic_num  2  ue(v) \n      } while( modification_of_pic_nums_idc  !=  3 )     \n  }     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  53",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          3
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.3.2  Prediction weight table syntax",
      "section_text": "pred_weight_table( ) {  C  Descriptor \n  luma_log2_weight_denom  2  ue(v) \n  if( ChromaArrayType  !=  0 )     \n    chroma_log2_weight_denom  2  ue(v) \n  for( i = 0; i <= num_ref_idx_l0_active_minus1; i++ ) {     \n    luma_weight_l0_flag  2  u(1) \n    if( luma_weight_l0_flag ) {     \n      luma_weight_l0[ i ]  2  se(v) \n      luma_offset_l0[ i ]  2  se(v) \n    }     \n    if( ChromaArrayType  !=  0 ) {     \n      chroma_weight_l0_flag  2  u(1) \n      if( chroma_weight_l0_flag )     \n        for( j =0; j < 2; j++ ) {     \n          chroma_weight_l0[ i ][ j ]  2  se(v) \n          chroma_offset_l0[ i ][ j ]  2  se(v) \n        }     \n    }     \n  }     \n  if( slice_type % 5  = =  1 )      \n    for( i = 0; i <= num_ref_idx_l1_active_minus1; i++ ) {     \n      luma_weight_l1_flag  2  u(1) \n      if( luma_weight_l1_flag ) {     \n        luma_weight_l1[ i ]  2  se(v) \n        luma_offset_l1[ i ]  2  se(v) \n      }     \n      if( ChromaArrayType  !=  0 ) {     \n        chroma_weight_l1_flag  2  u(1) \n        if( chroma_weight_l1_flag )     \n          for( j = 0; j < 2; j++ ) {     \n            chroma_weight_l1[ i ][ j ]  2  se(v) \n            chroma_offset_l1[ i ][ j ]  2  se(v) \n          }     \n      }     \n    }     \n}     \n \n54  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.3.3  Decoded reference picture marking syntax",
      "section_text": "dec_ref_pic_marking( ) {  C  Descriptor \n  if( IdrPicFlag ) {      \n    no_output_of_prior_pics_flag  2 | 5  u(1) \n    long_term_reference_flag  2 | 5  u(1) \n  } else {     \n    adaptive_ref_pic_marking_mode_flag  2 | 5  u(1) \n    if( adaptive_ref_pic_marking_mode_flag )     \n      do {     \n        memory_management_control_operation  2 | 5  ue(v) \n        if( memory_management_control_operation  = =  1  | |     \n          memory_management_control_operation  = =  3 ) \n          difference_of_pic_nums_minus1  2 | 5  ue(v) \n        if(memory_management_control_operation  = =  2  )     \n          long_term_pic_num  2 | 5  ue(v) \n         if( memory_management_control_operation  = =  3  | |     \n          memory_management_control_operation  = =  6 ) \n          long_term_frame_idx  2 | 5  ue(v) \n        if( memory_management_control_operation  = =  4 )     \n          max_long_term_frame_idx_plus1  2 | 5  ue(v) \n      } while( memory_management_control_operation  !=  0 )     \n  }     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  55",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          3
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.4  Slice data syntax",
      "section_text": "slice_data( ) {  C  Descriptor \n  if( entropy_coding_mode_flag )     \n    while( !byte_aligned( ) )     \n      cabac_alignment_one_bit  2  f(1) \n  CurrMbAddr = first_mb_in_slice * ( 1 + MbaffFrameFlag )     \n  moreDataFlag = 1     \n  prevMbSkipped = 0     \n  do {     \n    if( slice_type  !=  I  &&  slice_type  !=  SI )     \n      if( !entropy_coding_mode_flag ) {     \n        mb_skip_run  2  ue(v) \n        prevMbSkipped = ( mb_skip_run > 0 )     \n        for( i=0; i<mb_skip_run; i++ )     \n          CurrMbAddr = NextMbAddress( CurrMbAddr )     \n        if( mb_skip_run > 0 )     \n          moreDataFlag = more_rbsp_data( )     \n      } else {     \n        mb_skip_flag  2  ae(v) \n        moreDataFlag = !mb_skip_flag     \n      }     \n    if( moreDataFlag ) {     \n      if( MbaffFrameFlag && ( CurrMbAddr % 2  = =  0  | |     \n        ( CurrMbAddr % 2  = =  1  &&  prevMbSkipped ) ) ) \n        mb_field_decoding_flag  2  u(1) | ae(v) \n      macroblock_layer( )  2 | 3 | 4   \n    }     \n    if( !entropy_coding_mode_flag )     \n      moreDataFlag = more_rbsp_data( )     \n    else {     \n      if( slice_type  !=  I  &&  slice_type  !=  SI )     \n        prevMbSkipped = mb_skip_flag     \n      if( MbaffFrameFlag  &&  CurrMbAddr % 2  = =  0 )     \n        moreDataFlag = 1     \n      else {     \n        end_of_slice_flag  2  ae(v) \n        moreDataFlag = !end_of_slice_flag     \n      }     \n    }     \n    CurrMbAddr = NextMbAddress( CurrMbAddr )     \n  } while( moreDataFlag )     \n}     \n \n56  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          4
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.5  Macroblock layer syntax",
      "section_text": "macroblock_layer( ) {  C  Descriptor \n  mb_type  2  ue(v) | ae(v) \n  if( mb_type  = =  I_PCM ) {     \n    while( !byte_aligned( ) )     \n      pcm_alignment_zero_bit  3  f(1) \n    for( i = 0; i < 256; i++ )     \n      pcm_sample_luma[ i ]  3  u(v) \n    for( i = 0; i < 2 * MbWidthC * MbHeightC; i++ )     \n      pcm_sample_chroma[ i ]  3  u(v) \n  } else {     \n    noSubMbPartSizeLessThan8x8Flag = 1     \n    if( mb_type  !=  I_NxN  &&     \n      MbPartPredMode( mb_type, 0 )  !=  Intra_16x16  && \n      NumMbPart( mb_type )  = =  4 ) { \n      sub_mb_pred( mb_type )  2   \n      for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n        if( sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8 ) {     \n          if( NumSubMbPart( sub_mb_type[ mbPartIdx ] )  >  1 )     \n            noSubMbPartSizeLessThan8x8Flag = 0     \n        } else if( !direct_8x8_inference_flag )     \n          noSubMbPartSizeLessThan8x8Flag = 0     \n    } else {     \n      if( transform_8x8_mode_flag  &&  mb_type  = =  I_NxN )     \n        transform_size_8x8_flag  2  u(1) | ae(v) \n      mb_pred( mb_type )  2   \n    }     \n    if( MbPartPredMode( mb_type, 0 )  !=  Intra_16x16 ) {     \n      coded_block_pattern  2  me(v) | ae(v) \n      if( CodedBlockPatternLuma > 0  &&     \n         transform_8x8_mode_flag  &&  mb_type  !=  I_NxN  && \n         noSubMbPartSizeLessThan8x8Flag  && \n         ( mb_type  !=  B_Direct_16x16  | |  direct_8x8_inference_flag ) ) \n        transform_size_8x8_flag  2  u(1) | ae(v) \n    }     \n    if( CodedBlockPatternLuma > 0  | |  CodedBlockPatternChroma > 0  | |     \n      MbPartPredMode( mb_type, 0 )  = =  Intra_16x16 ) { \n      mb_qp_delta  2  se(v) | ae(v) \n      residual( 0, 15 )  3 | 4   \n    }     \n  }     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  57",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          5
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.5.1  Macroblock prediction syntax",
      "section_text": "mb_pred( mb_type ) {  C  Descriptor \n  if( MbPartPredMode( mb_type, 0 )  = =  Intra_4x4  | |       \n    MbPartPredMode( mb_type, 0 )  = =  Intra_8x8  | |   \n    MbPartPredMode( mb_type, 0 )  = =  Intra_16x16 ) { \n    if( MbPartPredMode( mb_type, 0 )  = =  Intra_4x4 )     \n      for( luma4x4BlkIdx=0; luma4x4BlkIdx<16; luma4x4BlkIdx++ ) {     \n        prev_intra4x4_pred_mode_flag[ luma4x4BlkIdx ]  2  u(1) | ae(v) \n        if( !prev_intra4x4_pred_mode_flag[ luma4x4BlkIdx ] )     \n          rem_intra4x4_pred_mode[ luma4x4BlkIdx ]  2  u(3) | ae(v) \n      }     \n    if( MbPartPredMode( mb_type, 0 )  = =  Intra_8x8 )     \n      for( luma8x8BlkIdx=0; luma8x8BlkIdx<4; luma8x8BlkIdx++ ) {     \n        prev_intra8x8_pred_mode_flag[ luma8x8BlkIdx ]  2  u(1) | ae(v) \n        if( !prev_intra8x8_pred_mode_flag[ luma8x8BlkIdx ] )     \n          rem_intra8x8_pred_mode[ luma8x8BlkIdx ]  2  u(3) | ae(v) \n      }     \n    if( ChromaArrayType  = =  1  | |  ChromaArrayType  = =  2 )     \n      intra_chroma_pred_mode  2  ue(v) | ae(v) \n  } else if( MbPartPredMode( mb_type, 0 )  !=  Direct ) {     \n    for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++ )     \n      if( ( num_ref_idx_l0_active_minus1 > 0  | |     \n          mb_field_decoding_flag  !=  field_pic_flag ) &&   \n        MbPartPredMode( mb_type, mbPartIdx )  !=  Pred_L1 ) \n        ref_idx_l0[ mbPartIdx ]  2  te(v) | ae(v) \n    for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++ )     \n      if( ( num_ref_idx_l1_active_minus1  >  0  | |     \n          mb_field_decoding_flag  !=  field_pic_flag ) &&   \n        MbPartPredMode( mb_type, mbPartIdx )  !=  Pred_L0 ) \n        ref_idx_l1[ mbPartIdx ]  2  te(v) | ae(v) \n    for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++ )     \n      if( MbPartPredMode ( mb_type, mbPartIdx )  !=  Pred_L1 )     \n        for( compIdx = 0; compIdx < 2; compIdx++ )     \n          mvd_l0[ mbPartIdx ][ 0 ][ compIdx ]  2  se(v) | ae(v) \n    for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++ )     \n      if( MbPartPredMode( mb_type, mbPartIdx )  !=  Pred_L0 )     \n        for( compIdx = 0; compIdx < 2; compIdx++ )     \n          mvd_l1[ mbPartIdx ][ 0 ][ compIdx ]  2  se(v) | ae(v) \n  }     \n}     \n \n58  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          5
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.5.2  Sub-macroblock prediction syntax",
      "section_text": "sub_mb_pred( mb_type ) {  C  Descriptor \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n    sub_mb_type[ mbPartIdx ]  2  ue(v) | ae(v) \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n    if( ( num_ref_idx_l0_active_minus1  >  0  | |       \n        mb_field_decoding_flag  !=  field_pic_flag ) && \n      mb_type  !=  P_8x8ref0  && \n      sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8  && \n      SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L1 ) \n      ref_idx_l0[ mbPartIdx ]  2  te(v) | ae(v) \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n    if( ( num_ref_idx_l1_active_minus1  >  0  | |       \n        mb_field_decoding_flag  !=  field_pic_flag ) && \n        sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8  && \n        SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L0 ) \n      ref_idx_l1[ mbPartIdx ]  2  te(v) | ae(v) \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n    if( sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8  &&     \n      SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L1 ) \n      for( subMbPartIdx = 0;      \n           subMbPartIdx < NumSubMbPart( sub_mb_type[ mbPartIdx ] ); \n           subMbPartIdx++ ) \n        for( compIdx = 0; compIdx < 2; compIdx++ )     \n          mvd_l0[ mbPartIdx ][ subMbPartIdx ][ compIdx ]  2  se(v) | ae(v) \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n    if( sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8  &&     \n      SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L0 ) \n      for( subMbPartIdx = 0;      \n           subMbPartIdx < NumSubMbPart( sub_mb_type[ mbPartIdx ] ); \n           subMbPartIdx++ ) \n        for( compIdx = 0; compIdx < 2; compIdx++ )     \n          mvd_l1[ mbPartIdx ][ subMbPartIdx ][ compIdx ]  2  se(v) | ae(v) \n}     \n \n    Rec. ITU-T H.264 (06/2019)  59",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          5
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.5.3.2 Residual block CAVLC syntax",
      "section_text": "residual_block_cavlc( coeffLevel, startIdx, endIdx, maxNumCoeff ) {  C  Descriptor \n  for( i = 0; i < maxNumCoeff; i++ )     \n    coeffLevel[ i ] = 0     \n  coeff_token  3 | 4  ce(v) \n  if( TotalCoeff( coeff_token ) > 0 ) {     \n    if( TotalCoeff( coeff_token ) > 10  &&  TrailingOnes( coeff_token ) < 3 )     \n      suffixLength = 1     \n    else     \n      suffixLength = 0     \n    for( i = 0; i < TotalCoeff( coeff_token ); i++ )     \n      if( i < TrailingOnes( coeff_token ) ) {     \n        trailing_ones_sign_flag  3 | 4  u(1) \n        levelVal[ i ] = 1 − 2 * trailing_ones_sign_flag     \n      } else {     \n    Rec. ITU-T H.264 (06/2019)  61 \n \n        level_prefix  3 | 4  ce(v) \n        levelCode = ( Min( 15, level_prefix ) << suffixLength )     \n        if( suffixLength > 0  | |  level_prefix >= 14 ) {     \n          level_suffix  3 | 4  u(v) \n          levelCode += level_suffix     \n        }     \n        if( level_prefix  > =  15  &&  suffixLength  = =  0 )     \n          levelCode += 15     \n        if( level_prefix  > =  16 )     \n          levelCode += ( 1 << ( level_prefix − 3 ) ) − 4096     \n        if( i  = =  TrailingOnes( coeff_token )  &&       \n           TrailingOnes( coeff_token ) < 3 ) \n          levelCode += 2     \n        if( levelCode % 2  = =  0 )     \n          levelVal[ i ] = ( levelCode + 2 ) >> 1     \n        else     \n          levelVal[ i ] = ( −levelCode − 1 ) >> 1     \n        if( suffixLength  = =  0 )     \n          suffixLength = 1     \n        if( Abs( levelVal[ i ] )  >  ( 3 << ( suffixLength − 1 ) )  &&       \n           suffixLength < 6 ) \n          suffixLength++     \n      }     \n    if( TotalCoeff( coeff_token ) < endIdx − startIdx + 1 ) {     \n      total_zeros  3 | 4  ce(v) \n      zerosLeft = total_zeros     \n    } else     \n      zerosLeft = 0     \n    for( i = 0; i < TotalCoeff( coeff_token ) − 1; i++ ) {     \n      if( zerosLeft > 0 ) {     \n        run_before  3 | 4  ce(v) \n        runVal[ i ] = run_before     \n      } else     \n        runVal[ i ] = 0     \n      zerosLeft = zerosLeft − runVal[ i ]     \n    }     \n    runVal[ TotalCoeff( coeff_token ) − 1 ] = zerosLeft     \n    coeffNum = −1     \n    for( i = TotalCoeff( coeff_token ) − 1; i >= 0; i− − ) {     \n      coeffNum += runVal[ i ] + 1     \n      coeffLevel[ startIdx + coeffNum ] = levelVal[ i ]      \n    }     \n  }     \n}     \n \n62  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          5
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.3.5.3.3 Residual block CABAC syntax",
      "section_text": "residual_block_cabac( coeffLevel, startIdx, endIdx, maxNumCoeff ) {  C  Descriptor \n  if( maxNumCoeff  !=  64  | |  ChromaArrayType  = =  3 )     \n    coded_block_flag  3 | 4  ae(v) \n  for( i = 0; i < maxNumCoeff; i++ )     \n    coeffLevel[ i ] = 0     \n  if( coded_block_flag ) {     \n    numCoeff = endIdx + 1     \n    i = startIdx     \n    while( i < numCoeff − 1 )  {     \n      significant_coeff_flag[ i ]  3 | 4  ae(v) \n      if( significant_coeff_flag[ i ] ) {     \n        last_significant_coeff_flag[ i ]  3 | 4  ae(v) \n        if( last_significant_coeff_flag[ i ] )      \n          numCoeff = i + 1     \n      }      \n      i++     \n    }     \n    coeff_abs_level_minus1[ numCoeff − 1 ]  3 | 4  ae(v) \n    coeff_sign_flag[ numCoeff − 1 ]  3 | 4  ae(v) \n    coeffLevel[ numCoeff − 1 ] =      \n      ( coeff_abs_level_minus1[ numCoeff − 1 ] + 1 ) * \n      ( 1 − 2 * coeff_sign_flag[ numCoeff − 1 ] ) \n    for( i = numCoeff − 2; i >= startIdx; i− − )     \n      if( significant_coeff_flag[ i ] ) {     \n        coeff_abs_level_minus1[ i ]  3 | 4  ae(v) \n        coeff_sign_flag[ i ]  3 | 4  ae(v) \n        coeffLevel[ i ] = ( coeff_abs_level_minus1[ i ] + 1 ) *     \n                      ( 1 − 2 * coeff_sign_flag[ i ] ) \n      }     \n  }     \n}",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          3
        ],
        [
          "N",
          5
        ],
        [
          "N",
          3
        ],
        [
          "N",
          3
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.4  Semantics",
      "section_text": "Semantics associated with the syntax structures and with the syntax elements within these structures are specified in this \nclause. When the semantics of a syntax element are specified using a table or a set of tables, any values that are not specified \nin the table(s) shall not be present in the bitstream unless otherwise specified in this Recommendation | International \nStandard.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          4
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "7.4.1  NAL unit semantics",
      "section_text": "NOTE 1 – The VCL is specified to efficiently represent the content of the video data. The NAL is specified to format that data and \nprovide header information in a manner appropriate for conveyance on a variety of communication channels or storage media. All \ndata are contained in NAL units, each of which contains an integer number of bytes. A NAL unit specifies a generic format for use \nin both packet-oriented and bitstream systems. The format of NAL units for both packet-oriented transport and byte stream is \nidentical except that each NAL unit can be preceded by a start code prefix and extra padding bytes in the byte stream format. \nNumBytesInNALunit specifies the size of the NAL unit in bytes. This value is required for decoding of the NAL unit. \nSome form of demarcation of NAL unit boundaries is necessary to enable inference of NumBytesInNALunit. One such \ndemarcation method is specified in Annex B for the byte stream format. Other methods of demarcation may be specified \noutside of this Recommendation | International Standard. \nforbidden_zero_bit shall be equal to 0. \n    Rec. ITU-T H.264 (06/2019)  63 \n \nnal_ref_idc not equal to 0 specifies that the content of the NAL unit contains a sequence parameter set, a sequence \nparameter set extension, a subset sequence parameter set, a picture parameter set, a slice of a reference picture, a slice data \npartition of a reference picture, or a prefix NAL unit preceding a slice of a reference picture. \nFor coded video sequences conforming to one or more of the profiles specified in Annex A that are decoded using the \ndecoding process specified in clauses 2 to 9, nal_ref_idc equal to 0 for a NAL unit containing a slice or slice data partition \nindicates that the slice or slice data partition is part of a non-reference picture. \nnal_ref_idc shall not be equal to 0 for sequence parameter set or sequence parameter set extension or subset sequence \nparameter set or picture parameter set NAL units. When nal_ref_idc is equal to 0 for one NAL unit with nal_unit_type in \nthe range of 1 to 4, inclusive, of a particular picture, it shall be equal to 0 for all NAL units with nal_unit_type in the range \nof 1 to 4, inclusive, of the picture. \nnal_ref_idc shall not be equal to 0 for NAL units with nal_unit_type equal to 5. \nnal_ref_idc shall be equal to 0 for all NAL units having nal_unit_type equal to 6, 9, 10, 11, or 12. \nnal_unit_type specifies the type of RBSP data structure contained in the NAL unit as specified in Table 7-1. \nThe column marked \"C\" in Table 7-1 lists the categories of the syntax elements that may be present in the NAL unit. In \naddition, syntax elements with syntax category \"All\" may be present, as determined by the syntax and semantics of the \nRBSP data structure. The presence or absence of any syntax elements of a particular listed category is determined from the \nsyntax and semantics of the associated RBSP data structure. nal_unit_type shall not be equal to 3 or 4 unless at least one \nsyntax element is present in the RBSP data structure having a syntax element category value equal to the value of \nnal_unit_type and not categorized as \"All\". \nFor coded video sequences conforming to one or more of the profiles specified in Annex A that are decoded using the \ndecoding process specified in clauses 2-9, VCL and non-VCL NAL units are specified in Table 7-1 in the column labelled \n\"Annex A NAL unit type class\". For coded video sequences conforming to one or more of the profiles specified in Annex G \nthat are decoded using the decoding process specified in Annex G and for coded video sequences conforming to one or \nmore of the profiles specified in Annex H that are decoded using the decoding process specified in Annex H, VCL and \nnon-VCL NAL units are specified in Table 7-1 in the column labelled \"Annex G and Annex H NAL unit type class\". The \nentry \"suffix dependent\" for nal_unit_type equal to 14 is specified as follows: \n–  If the NAL unit directly following in decoding order a NAL unit with nal_unit_type equal to 14 is a NAL unit with \nnal_unit_type equal to 1 or 5, the NAL unit with nal_unit_type equal to 14 is a VCL NAL unit. \n–  Otherwise (the NAL unit directly following in decoding order a NAL unit with nal_unit_type equal to 14 is a NAL \nunit with nal_unit_type not equal to 1 or 5), the NAL unit with nal_unit_type equal to 14 is a non-VCL NAL unit. \nDecoders shall ignore (remove from the bitstream and discard) the NAL unit with nal_unit_type equal to 14 and the \nNAL unit directly following (in decoding order) the NAL unit with nal_unit_type equal to 14. \n64  Rec. ITU-T H.264 (06/2019) \n \nTable 7-1 – NAL unit type codes, syntax element categories, and NAL unit type classes \nnal_unit_type  Content of NAL unit and RBSP  C  Annex A  Annex G  Annex I \nsyntax structure    and  and \n  Annex H  Annex J \nNAL unit  NAL unit  NAL unit \ntype class  type class  type class \n0  Unspecified    non-VCL  non-VCL  non-VCL \n1  Coded slice of a non-IDR picture  2, 3, 4  VCL  VCL  VCL \nslice_layer_without_partitioning_rbsp( ) \n2  Coded slice data partition A   2  VCL  not applicable  not applicable \nslice_data_partition_a_layer_rbsp( ) \n3  Coded slice data partition B   3  VCL  not applicable  not applicable \nslice_data_partition_b_layer_rbsp( ) \n4  Coded slice data partition C   4  VCL  not applicable  not applicable \nslice_data_partition_c_layer_rbsp( ) \n5  Coded slice of an IDR picture  2, 3  VCL  VCL  VCL \nslice_layer_without_partitioning_rbsp( ) \n6  Supplemental enhancement information  5  non-VCL  non-VCL  non-VCL \n(SEI) \nsei_rbsp( ) \n7  Sequence parameter set  0  non-VCL  non-VCL  non-VCL \nseq_parameter_set_rbsp( )",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          7
        ],
        [
          "N",
          4
        ],
        [
          "N",
          1
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "8  Picture parameter set  1  non-VCL  non-VCL  non-VCL",
      "section_text": "pic_parameter_set_rbsp( )",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          8
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "9  Access unit delimiter  6  non-VCL  non-VCL  non-VCL",
      "section_text": "access_unit_delimiter_rbsp( )",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          9
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "10  End of sequence  7  non-VCL  non-VCL  non-VCL",
      "section_text": "end_of_seq_rbsp( )",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          10
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "11  End of stream  8  non-VCL  non-VCL  non-VCL",
      "section_text": "end_of_stream_rbsp( )",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          11
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "12  Filler data  9  non-VCL  non-VCL  non-VCL",
      "section_text": "filler_data_rbsp( )",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          12
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "13  Sequence parameter set extension  10  non-VCL  non-VCL  non-VCL",
      "section_text": "seq_parameter_set_extension_rbsp( )",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          13
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "14  Prefix NAL unit  2  non-VCL  suffix  suffix",
      "section_text": "prefix_nal_unit_rbsp( )  dependent  dependent",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          14
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "15  Subset sequence parameter set  0  non-VCL  non-VCL  non-VCL",
      "section_text": "subset_seq_parameter_set_rbsp( )",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          15
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "16  Depth parameter set  11  non-VCL  non-VCL  non-VCL",
      "section_text": "depth_parameter_set_rbsp( ) \n17..18  Reserved    non-VCL  non-VCL  non-VCL \n19  Coded slice of an auxiliary coded  2, 3, 4  non-VCL  non-VCL  non-VCL \npicture without partitioning \nslice_layer_without_partitioning_rbsp( ) \n20  Coded slice extension  2, 3, 4  non-VCL  VCL  VCL \nslice_layer_extension_rbsp( ) \n21  Coded slice extension for a depth view  2, 3, 4  non-VCL  non-VCL  VCL \ncomponent or a 3D-AVC texture view \ncomponent  \nslice_layer_extension_rbsp( ) \n22..23  Reserved    non-VCL  non-VCL  VCL \n24..31  Unspecified    non-VCL  non-VCL  non-VCL \n \n \nWhen NAL units with nal_unit_type equal to 13 or 19 are present in a coded video sequence, decoders shall either perform \nthe (optional) decoding process specified for these NAL units or shall ignore (remove from the bitstream and discard) the \ncontents of these NAL units. \nDecoders that conform to one or more of the profiles specified in Annex A rather than the profiles specified in Annexes G \nor H shall ignore (remove from the bitstream and discard) the contents of all NAL units with nal_unit_type equal to 14, \n15, or 20. \n    Rec. ITU-T H.264 (06/2019)  65 \n \nNAL units that use nal_unit_type equal to 0 or in the range of 24..31, inclusive, shall not affect the decoding process \nspecified in this Recommendation | International Standard. \nNOTE 2 – NAL unit types 0 and 24..31 may be used as determined by the application. No decoding process for these values of \nnal_unit_type is specified in this Recommendation | International Standard. Since different applications might use NAL unit types \n0 and 24..31 for different purposes, particular care must be exercised in the design of encoders that generate NAL units with \nnal_unit_type equal to 0 or in the range of 24 to 31, inclusive, and in the design of decoders that interpret the content of NAL units \nwith nal_unit_type equal to 0 or in the range of 24 to 31, inclusive. \nDecoders shall ignore (remove from the bitstream and discard) the contents of all NAL units that use reserved values of \nnal_unit_type. \nNOTE 3 – This requirement allows future definition of compatible extensions to this Recommendation | International Standard. \nNOTE 4 – In previous editions of this Recommendation | International Standard, the NAL unit types 13..15 and 19..20 (or a subset \nof these NAL unit types) were reserved and no decoding process for NAL units having these values of nal_unit_type was specified. \nIn later editions of this Recommendation | International Standard, currently reserved values of nal_unit_type might become non-\nreserved and a decoding process for these values of nal_unit_type might be specified. Encoders should take into consideration that \nthe values of nal_unit_type that were reserved in previous editions of this Recommendation | International Standard might be ignored \nby decoders. \nIn the text, coded slice NAL unit collectively refers to a coded slice of a non-IDR picture NAL unit or to a coded slice of \nan IDR picture NAL unit. The variable IdrPicFlag is specified as \nIdrPicFlag = ( ( nal_unit_type  = =  5 )  ?  1  :  0 )    (7-1) \nWhen the value of nal_unit_type is equal to 5 for a NAL unit containing a slice of a particular picture, the picture shall not \ncontain NAL units with nal_unit_type in the range of 1 to 4, inclusive. For coded video sequences conforming to one or \nmore of the profiles specified in Annex A that are decoded using the decoding process specified in clauses 2 to 9, such a \npicture is referred to as an IDR picture. \nNOTE 5 – Slice data partitioning cannot be used for IDR pictures. \nsvc_extension_flag  indicates  whether  a  nal_unit_header_svc_extension( )  or  nal_unit_header_mvc_extension( )  will \nfollow next in the syntax structure. \nWhen svc_extension_flag is not present, the value of svc_extension_flag is inferred to be equal to 0. \nThe value of svc_extension_flag shall be equal to 1 for coded video sequences conforming to one or more profiles specified \nin Annex G. Decoders conforming to one or more profiles specified in Annex G shall ignore (remove from the bitstream \nand discard) NAL units for which nal_unit_type is equal to 14 or 20 and for which svc_extension_flag is equal to 0. \nThe value of svc_extension_flag shall be equal to 0 for coded video sequences conforming to one or more profiles specified \nin Annex H. Decoders conforming to one or more profiles specified in Annex H shall ignore (remove from the bitstream \nand discard) NAL units for which nal_unit_type is equal to 14 or 20 and for which svc_extension_flag is equal to 1. \nThe value of svc_extension_flag shall be equal to 0 for coded video sequences conforming to one or more profiles specified \nin Annex I. Decoders conforming to one or more profiles specified in Annex I shall ignore (remove from the bitstream and \ndiscard) NAL units for which nal_unit_type is equal to 14, 20, or 21 and for which svc_extension_flag is equal to 1. \nThe value of svc_extension_flag shall be equal to 0 for coded video sequences conforming to one or more profiles specified \nin Annex J. Decoders conforming to one or more profiles specified in Annex J shall ignore (remove from the bitstream \nand discard) NAL units for which nal_unit_type is equal to 14 or 20 and for which svc_extension_flag is equal to 1. \navc_3d_extension_flag  indicates  for  NAL  units  having  nal_unit_type  equal  to  21  whether  a \nnal_unit_header_mvc_extension( ) or nal_unit_header_3davc_extension( ) will follow next in the syntax structure. \nWhen avc_3d_extension_flag is not present, the value of avc_3d_extension_flag is inferred to be equal to 0. \nThe value of DepthFlag is specified as follows. \nDepthFlag = ( nal_unit_type  ! =  21 ) ? 0 : ( avc_3d_extension_flag ? depth_flag : 1 )  (7-2) \nThe value of avc_3d_extension_flag shall be equal to 0 for coded video sequences conforming to one or more profiles \nspecified in Annex I. Decoders conforming to one or more profiles specified in Annex I shall ignore (remove from the \nbitstream and discard) NAL units for which nal_unit_type is equal to  21 and for which avc_3d_extension_flag is equal \nto 1. \nrbsp_byte[ i ] is the i-th byte of an RBSP. An RBSP is specified as an ordered sequence of bytes as follows. \nThe RBSP contains an SODB as follows: \n–  If the SODB is empty (i.e., zero bits in length), the RBSP is also empty. \n–  Otherwise, the RBSP contains the SODB as follows: \n66  Rec. ITU-T H.264 (06/2019) \n \n1)  The first byte of the RBSP contains the (most significant, left-most) eight bits of the SODB; the next byte of the \nRBSP contains the next eight bits of the SODB, etc., until fewer than eight bits of the SODB remain. \n2)  rbsp_trailing_bits( ) are present after the SODB as follows: \ni)  The first (most significant, left-most) bits of the final RBSP byte contains the remaining bits of the SODB \n(if any). \nii)  The next bit consists of a single rbsp_stop_one_bit equal to 1. \niii)  When the rbsp_stop_one_bit is not the last bit of a byte-aligned byte, one or more rbsp_alignment_zero_bit \nis present to result in byte alignment. \n3)  One or more cabac_zero_word 16-bit syntax elements equal to 0x0000 may be present in some RBSPs after the \nrbsp_trailing_bits( ) at the end of the RBSP. \nSyntax structures having these RBSP properties are denoted in the syntax tables using an \"_rbsp\" suffix. These structures \nshall be carried within NAL units as the content of the rbsp_byte[ i ] data bytes. The association of the RBSP syntax \nstructures to the NAL units shall be as specified in Table 7-1. \nNOTE 6 – When the boundaries of the RBSP are known, the decoder can extract the SODB from the RBSP by concatenating the \nbits of the bytes of the RBSP and discarding the rbsp_stop_one_bit, which is the last (least significant, right-most) bit equal to 1, \nand discarding any following (less significant, farther to the right) bits that follow it, which are equal to 0. The data necessary for \nthe decoding process is contained in the SODB part of the RBSP. \nemulation_prevention_three_byte is a byte equal to 0x03. When an emulation_prevention_three_byte is present in the \nNAL unit, it shall be discarded by the decoding process. \nThe last byte of the NAL unit shall not be equal to 0x00. \nWithin the NAL unit, the following three-byte sequences shall not occur at any byte-aligned position: \n–  0x000000 \n–  0x000001 \n–  0x000002 \nWithin the NAL unit, any four-byte sequence that starts with 0x000003 other than the following sequences shall not occur \nat any byte-aligned position: \n–  0x00000300 \n–  0x00000301 \n–  0x00000302 \n–  0x00000303 \nNOTE 7 – When nal_unit_type is equal to 0, particular care must be exercised in the design of encoders to avoid the presence of the \nabove-listed  three-byte  and  four-byte  patterns  at  the  beginning  of  the  NAL  unit  syntax  structure,  as  the  syntax  element \nemulation_prevention_three_byte cannot be the third byte of a NAL unit. \n7.4.1.1  Encapsulation of an SODB within an RBSP (informative) \nThis clause does not form an integral part of this Recommendation | International Standard. \nThe  form  of  encapsulation  of  an  SODB  within  an  RBSP  and  the  use  of  the  emulation_prevention_three_byte  for \nencapsulation of an RBSP within a NAL unit is specified for the following purposes: \n–  to prevent the emulation of start codes within NAL units while allowing any arbitrary SODB to be represented within \na NAL unit, \n–  to enable identification of the end of the SODB within the NAL unit by searching the RBSP for the rbsp_stop_one_bit \nstarting at the end of the RBSP, \n–  to enable a NAL unit to have a size larger than that of the SODB under some circumstances (using one or more \ncabac_zero_word). \nThe encoder can produce a NAL unit from an RBSP by the following procedure: \n1.  The RBSP data is searched for byte-aligned bits of the following binary patterns: \n  '00000000 00000000 000000xx'  (where xx represents any 2 bit pattern: 00, 01, 10, or 11), \nand a byte equal to 0x03 is inserted to replace these bit patterns with the patterns: \n  '00000000 00000000 00000011 000000xx', \nand finally, when the last byte of the RBSP data is equal to 0x00 (which can only occur when the RBSP ends in \na cabac_zero_word), a final byte equal to 0x03 is appended to the end of the data. The last zero byte of a \n    Rec. ITU-T H.264 (06/2019)  67 \n \nbyte-aligned  three-byte  sequence  0x000000  in  the  RBSP  (which  is  replaced  by  the  four-byte  sequence \n0x00000300) is taken into account when searching the RBSP data for the next occurrence of byte-aligned bits \nwith the binary patterns specified above. \n2.  The resulting sequence of bytes is then prefixed as follows: \n–  If nal_unit_type is not equal to 14 or 20, the sequence of bytes is prefixed with the first byte of the NAL unit \ncontaining the syntax elements forbidden_zero_bit, nal_ref_idc, and nal_unit_type, where nal_unit_type \nindicates the type of RBSP data structure the NAL unit contains. \n–  Otherwise (nal_unit_type is equal to 14 or 20), the sequence of bytes is prefixed with the first four bytes of \nthe  NAL  unit,  where  the  first  byte  contains  the  syntax  elements  forbidden_zero_bit,  nal_ref_idc,  and \nnal_unit_type and the following three bytes contain the syntax structure nal_unit_header_svc_extension( ). \nThe  syntax  element  nal_unit_type  in  the  first  byte  indicates  the  presence  of  the  syntax  structure \nnal_unit_header_svc_extension( ) in the following three bytes and the type of RBSP data structure the NAL \nunit contains. \nThe process specified above results in the construction of the entire NAL unit. \nThis process can allow any SODB to be represented in a NAL unit while ensuring that \n–  no byte-aligned start code prefix is emulated within the NAL unit, \n–  no sequence of 8 zero-valued bits followed by a start code prefix, regardless of byte-alignment, is emulated within \nthe NAL unit. \n7.4.1.2  Order of NAL units and association to coded pictures, access units, and video sequences \nThis clause specifies constraints on the order of NAL units in the bitstream. \nAny order of NAL units in the bitstream obeying these constraints is referred to in the text as the decoding order of NAL \nunits. Within a NAL unit, the syntax in clauses 7.3, D.1, and E.1 specifies the decoding order of syntax elements. Decoders \nshall be capable of receiving NAL units and their syntax elements in decoding order. \n7.4.1.2.1 Order of sequence and picture parameter set RBSPs and their activation \nThis clause specifies the activation process of picture and sequence parameter sets for coded video sequences that conform \nto one or more of the profiles specified in Annex A and are decoded using the decoding process specified in clauses 2 to 9. \nNOTE 1 – The sequence and picture parameter set mechanism decouples the transmission of infrequently changing information \nfrom the transmission of coded macroblock data. Sequence and picture parameter sets may, in some applications, be conveyed \"out-\nof-band\" using a reliable transport mechanism. \nA picture parameter set RBSP includes parameters that can be referred to by the coded slice NAL units or coded slice data \npartition A NAL units of one or more coded pictures. Each picture parameter set RBSP is initially considered not active at \nthe start of the operation of the decoding process. At most one picture parameter set RBSP is considered active at any given \nmoment during the operation of the decoding process, and the activation of any particular picture parameter set RBSP \nresults in the deactivation of the previously-active picture parameter set RBSP (if any). \nWhen a picture parameter set RBSP (with a particular value of pic_parameter_set_id) is not active and it is referred to by \na coded slice NAL unit or coded slice data partition A NAL unit (using that value of pic_parameter_set_id), it is activated. \nThis picture parameter set RBSP is called the active picture parameter set RBSP until it is deactivated by the activation of \nanother picture parameter set RBSP. A picture parameter set RBSP, with that particular value of pic_parameter_set_id, \nshall be available to the decoding process prior to its activation. \nAny picture parameter set NAL unit containing the value of pic_parameter_set_id for the active picture parameter set \nRBSP for a coded picture shall have the same content as that of the active picture parameter set RBSP for the coded picture \nunless it follows the last VCL NAL unit of the coded picture and precedes the first VCL NAL unit of another coded picture. \nWhen a picture parameter set NAL unit with a particular value of pic_parameter_set_id is received, its content replaces \nthe content of the previous picture parameter set NAL unit, in decoding order, with the same value of pic_parameter_set_id \n(when  a  previous  picture  parameter  set  NAL  unit  with  the  same  value  of  pic_parameter_set_id  was  present  in  the \nbitstream). \nNOTE 2 – A decoder must be capable of simultaneously storing the contents of the picture parameter sets for all values of \npic_parameter_set_id. The content of the picture parameter set with a particular value of pic_parameter_set_id is overwritten when \na new picture parameter set NAL unit with the same value of pic_parameter_set_id is received. \nA sequence parameter set RBSP includes parameters that can be referred to by one or more picture parameter set RBSPs \nor one or more SEI NAL units containing a buffering period SEI message. Each sequence parameter set RBSP is initially \nconsidered not active at the start of the operation of the decoding process. At most one sequence parameter set RBSP is \nconsidered active at any given moment during the operation of the decoding process, and the activation of any particular \nsequence parameter set RBSP results in the deactivation of the previously-active sequence parameter set RBSP (if any). \n68  Rec. ITU-T H.264 (06/2019) \n \nWhen a sequence parameter set RBSP (with a particular value of seq_parameter_set_id) is not already active and it is \nreferred to by activation of a picture parameter set RBSP (using that value of seq_parameter_set_id) or is referred to by an \nSEI NAL unit containing a buffering period SEI message (using that value of seq_parameter_set_id), it is activated. This \nsequence parameter set RBSP is called the active sequence parameter set RBSP until it is deactivated by the activation of \nanother sequence parameter set RBSP. A sequence parameter set RBSP, with that particular value of seq_parameter_set_id, \nshall be available to the decoding process prior to its activation. An activated sequence parameter set RBSP shall remain \nactive for the entire coded video sequence. \nNOTE 3 – Because an IDR access unit begins a new coded video sequence and an activated sequence parameter set RBSP must \nremain active for the entire coded video sequence, a sequence parameter set RBSP can only be activated by a buffering period SEI \nmessage when the buffering period SEI message is part of an IDR access unit. \nAny sequence parameter set NAL unit containing the value of seq_parameter_set_id for the active sequence parameter set \nRBSP for a coded video sequence shall have the same content as that of the active sequence parameter set RBSP for the \ncoded video sequence unless it follows the last access unit of the coded video sequence and precedes the first VCL NAL \nunit and the first SEI NAL unit containing a buffering period SEI message (when present) of another coded video sequence. \nNOTE 4 – If picture parameter set RBSP or sequence parameter set RBSP are conveyed within the bitstream, these constraints \nimpose an order constraint on the NAL units that contain the picture parameter set RBSP or sequence parameter set RBSP, \nrespectively. Otherwise (picture parameter set RBSP or sequence parameter set RBSP are conveyed by other means not specified in \nthis Recommendation | International Standard), they must be available to the decoding process in a timely fashion such that these \nconstraints are obeyed. \nWhen a sequence parameter set NAL unit with a particular value of seq_parameter_set_id is received, its content replaces \nthe  content  of  the  previous  sequence  parameter  set  NAL  unit,  in  decoding  order,  with  the  same  value  of \nseq_parameter_set_id (when a previous sequence parameter set NAL unit with the same value of seq_parameter_set_id \nwas present in the bitstream). \nNOTE 5 – A decoder must be capable of simultaneously storing the contents of the sequence parameter sets for all values of \nseq_parameter_set_id. The content of the sequence parameter set with a particular value of seq_parameter_set_id is overwritten \nwhen a new sequence parameter set NAL unit with the same value of seq_parameter_set_id is received. \nWhen present, a sequence parameter set extension RBSP includes parameters having a similar function to those of a \nsequence parameter set RBSP. For purposes of establishing constraints on the syntax elements of the sequence parameter \nset extension RBSP and for purposes of determining activation of a sequence parameter set extension RBSP, the sequence \nparameter set extension RBSP shall be considered part of the preceding sequence parameter set RBSP with the same value \nof seq_parameter_set_id. When a sequence parameter set RBSP is present that is not followed by a sequence parameter \nset extension RBSP with the same value of seq_parameter_set_id prior to the activation of the sequence parameter set \nRBSP, the sequence parameter set extension RBSP and its syntax elements shall be considered not present for the active \nsequence parameter set RBSP. \nAll constraints that are expressed on the relationship between the values of the syntax elements (and the values of variables \nderived from those syntax elements) in sequence parameter sets and picture parameter sets and other syntax elements are \nexpressions of constraints that apply only to the active sequence parameter set and the active picture parameter set. If any \nsequence parameter set RBSP is present that is not activated in the bitstream, its syntax elements shall have values that \nwould conform to the specified constraints if it were activated by reference in an otherwise-conforming bitstream. If any \npicture parameter set RBSP is present that is not ever activated in the bitstream, its syntax elements shall have values that \nwould conform to the specified constraints if it were activated by reference in an otherwise-conforming bitstream. \nDuring operation of the decoding process (see clause 8), the values of parameters of the active picture parameter set and \nthe active sequence parameter set shall be considered in effect. For interpretation of SEI messages, the values of the \nparameters of the picture parameter set and sequence parameter set that are active for the operation of the decoding process \nfor the VCL NAL units of the primary coded picture in the same access unit shall be considered in effect unless otherwise \nspecified in the SEI message semantics. \n7.4.1.2.2 Order of access units and association to coded video sequences \nA bitstream conforming to this Recommendation | International Standard consists of one or more coded video sequences. \nA coded video sequence consists of one or more access units. For coded video sequences that conform to one or more of \nthe profiles specified in Annex A and are decoded using the decoding process specified in clauses 2 to 9, the order of NAL \nunits and coded pictures and their association to access units is described in clause 7.4.1.2.3. \nThe first access unit of each coded video sequence is an IDR access unit. All subsequent access units in the coded video \nsequence are non-IDR access units. \nIt is a requirement of bitstream conformance that, when two consecutive access units in decoding order within a coded \nvideo sequence both contain non-reference pictures, the value of picture order count for each coded field or field of a coded \nframe in the first such access unit shall be less than or equal to the value of picture order count for each coded field or field \nof a coded frame in the second such access unit. \n    Rec. ITU-T H.264 (06/2019)  69 \n \nIt is a requirement of bitstream conformance that, when present, an access unit following an access unit that contains an \nend of sequence NAL unit shall be an IDR access unit. \nIt is a requirement of bitstream conformance that, when an SEI NAL unit contains data that pertain to more than one access \nunit (for example, when the SEI NAL unit has a coded video sequence as its scope), it shall be contained in the first access \nunit to which it applies. \nIt is a requirement of bitstream conformance that, when an end of stream NAL unit is present in an access unit, this access \nunit shall be the last access unit in the bitstream and the end of stream NAL unit shall be the last NAL unit in that access \nunit. \n7.4.1.2.3 Order of NAL units and coded pictures and association to access units \nThis clause specifies the order of NAL units and coded pictures and association to access unit for coded video sequences \nthat conform to one or more of the profiles specified in Annex A and are decoded using the decoding process specified in \nclauses 2 to 9. \nNOTE 1 – Some bitstreams that conform to profiles specified in Annexes G or H may violate the NAL unit order specified in this \nclause. Conditions under which such a violation of the NAL unit order occurs are specified in clauses G.7.4.1.2.3 and H.7.4.1.2.3. \nAn access unit consists of one primary coded picture, zero or more corresponding redundant coded pictures, and zero or \nmore non-VCL NAL units. The association of VCL NAL units to primary or redundant coded pictures is described in \nclause 7.4.1.2.5. \nThe first access unit in the bitstream starts with the first NAL unit of the bitstream. \nThe first of any of the following NAL units after the last VCL NAL unit of a primary coded picture specifies the start of a \nnew access unit: \n–  access unit delimiter NAL unit (when present), \n–  sequence parameter set NAL unit (when present), \n–  picture parameter set NAL unit (when present), \n–  SEI NAL unit (when present), \n–  NAL units with nal_unit_type in the range of 14 to 18, inclusive (when present), \n–  first VCL NAL unit of a primary coded picture (always present). \nThe constraints for the detection of the first VCL NAL unit of a primary coded picture are specified in clause 7.4.1.2.4. \nThe following constraints shall be obeyed by the order of the coded pictures and non-VCL NAL units within an access \nunit: \n–  When an access unit delimiter NAL unit is present, it shall be the first NAL unit. There shall be at most one access \nunit delimiter NAL unit in any access unit. \n–  When any SEI NAL units are present, they shall precede the primary coded picture. \n–  When an SEI NAL unit containing a buffering period SEI message is present, the buffering period SEI message shall \nbe the first SEI message payload of the first SEI NAL unit in the access unit. \n–  The primary coded picture shall precede the corresponding redundant coded pictures. \n–  When  redundant  coded  pictures  are  present,  they  shall  be  ordered  in  ascending  order  of  the  value  of \nredundant_pic_cnt. \n–  When a sequence parameter set extension NAL unit is present, it shall be the next NAL unit after a sequence parameter \nset NAL unit having the same value of seq_parameter_set_id as in the sequence parameter set extension NAL unit. \n–  When one or more coded slice of an auxiliary coded picture without partitioning NAL units is present, they shall \nfollow the primary coded picture and all redundant coded pictures (if any). \n–  When an end of sequence NAL unit is present, it shall follow the primary coded picture and all redundant coded \npictures (if any) and all coded slice of an auxiliary coded picture without partitioning NAL units (if any). \n–  When an end of stream NAL unit is present, it shall be the last NAL unit. \n–  NAL units having nal_unit_type equal to 0, 12, or in the range of 20 to 31, inclusive, shall not precede the first VCL \nNAL unit of the primary coded picture. \n70  Rec. ITU-T H.264 (06/2019) \n \nNOTE 2 – Sequence parameter set NAL units or picture parameter set NAL units may be present in an access unit, but cannot follow \nthe last VCL NAL unit of the primary coded picture within the access unit, as this condition would specify the start of a new access \nunit. \nNOTE 3 – When a NAL unit having nal_unit_type equal to 7 or 8 is present in an access unit, it may or may not be referred to in \nthe coded pictures of the access unit in which it is present, and may be referred to in coded pictures of subsequent access units. \nThe structure of access units not containing any NAL units with nal_unit_type equal to 0, 7, 8, or in the range of 12 to 18, \ninclusive, or in the range of 20 to 31, inclusive, is shown in Figure 7-1. \nstart\nAccess unit delimiter\nSEI\nPrimary coded picture\nRedundant coded picture\nAuxiliary coded picture\nEnd of sequence\nEnd of stream\nend  \nFigure 7-1 – Structure of an access unit not containing any NAL units with nal_unit_type equal to 0, 7, 8,  \nor in the range of 12 to 18, inclusive, or in the range of 20 to 31, inclusive \n7.4.1.2.4 Detection of the first VCL NAL unit of a primary coded picture \nThis clause specifies constraints on VCL NAL unit syntax that are sufficient to enable the detection of the first VCL NAL \nunit of each primary coded picture for coded video sequences that conform to one or more of the profiles specified in",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "N",
          16
        ]
      ],
      "type": "Numeric"
    },
    {
      "section_title": "Annex A and are decoded using the decoding process specified in clauses 2 to 9.",
      "section_text": "Any coded slice NAL unit or coded slice data partition A NAL unit of the primary coded picture of the current access unit \nshall be different from any coded slice NAL unit or coded slice data partition A NAL unit of the primary coded picture of \nthe previous access unit in one or more of the following ways: \n–  frame_num differs in value. The value of frame_num used to test this condition is the value of frame_num that appears \nin the syntax of the slice header, regardless of whether that value is inferred to have been equal to 0 for subsequent \nuse in the decoding process due to the presence of memory_management_control_operation equal to 5. \nNOTE 1 – A consequence of the above statement is that a primary coded picture having frame_num equal to 1 cannot \ncontain a memory_management_control_operation equal to 5 unless some other condition listed below is fulfilled for the \nnext primary coded picture that follows after it (if any). \n–  pic_parameter_set_id differs in value. \n    Rec. ITU-T H.264 (06/2019)  71 \n \n–  field_pic_flag differs in value. \n–  bottom_field_flag is present in both and differs in value. \n–  nal_ref_idc differs in value with one of the nal_ref_idc values being equal to 0. \n–  pic_order_cnt_type is equal to 0 for both and either pic_order_cnt_lsb differs in value, or delta_pic_order_cnt_bottom \ndiffers in value. \n–  pic_order_cnt_type  is  equal  to 1  for  both  and  either  delta_pic_order_cnt[ 0 ]  differs  in  value,  or \ndelta_pic_order_cnt[ 1 ] differs in value. \n–  IdrPicFlag differs in value. \n–  IdrPicFlag is equal to 1 for both and idr_pic_id differs in value. \nNOTE 2 – Some of the VCL NAL units in redundant coded pictures or some non-VCL NAL units (e.g., an access unit delimiter \nNAL unit) may also be used for the detection of the boundary between access units, and may therefore aid in the detection of the \nstart of a new primary coded picture. \n7.4.1.2.5 Order of VCL NAL units and association to coded pictures \nThis clause specifies the order of VCL NAL units and association to coded pictures for coded video sequences that conform \nto one or more of the profiles specified in Annex A and are decoded using the decoding process specified in clauses 2 to 9. \nEach VCL NAL unit is part of a coded picture. \nThe order of the VCL NAL units within a coded IDR picture is constrained as follows: \n–  If arbitrary slice order is allowed as specified in Annex A, coded slice of an IDR picture NAL units may have any \norder relative to each other. \n–  Otherwise (arbitrary slice order is not allowed), the following applies: \n–  If separate_colour_plane_flag is equal to 0, coded slice of an IDR picture NAL units of a slice group shall not \nbe interleaved with coded slice of an IDR picture NAL units of another slice group and the order of coded slice \nof an IDR picture NAL units within a slice group shall be in the order of increasing macroblock address for the \nfirst macroblock of each coded slice of an IDR picture NAL unit of the particular slice group. \n–  Otherwise (separate_colour_plane_flag is equal to 1), coded slice of an IDR picture NAL units of a slice group \nfor a particular value of colour_plane_id shall not be interleaved with coded slice of an IDR picture NAL units \nof another slice group with the same value of colour_plane_id and the order of coded slices of IDR picture NAL \nunits within a slice group for a particular value of colour_plane_id shall be in the order of increasing macroblock \naddress for the first macroblock of each coded slice of an IDR picture NAL unit of the particular slice group \nhaving the particular value of colour_plane_id. \nNOTE 1 – When separate_colour_plane_flag is equal to 1, the relative ordering of coded slices having different values \nof colour_plane_id is not constrained. \nThe order of the VCL NAL units within a coded non-IDR picture is constrained as follows: \n–  If arbitrary slice order is allowed as specified in Annex A, coded slice of a non-IDR picture NAL units or coded slice \ndata partition A NAL units may have any order relative to each other. A coded slice data partition A NAL unit with a \nparticular value of slice_id shall precede any present coded slice data partition B NAL unit with the same value of \nslice_id. A coded slice data partition A NAL unit with a particular value of slice_id shall precede any present coded \nslice data partition C NAL unit with the same value of slice_id. When a coded slice data partition B NAL unit with a \nparticular value of slice_id is present, it shall precede any present coded slice data partition C NAL unit with the same \nvalue of slice_id. \n–  Otherwise (arbitrary slice order is not allowed), the following applies: \n–  If separate_colour_plane_flag is equal to 0, coded slice of a non-IDR picture NAL units or coded slice data \npartition NAL units of a slice group shall not be interleaved with coded slice of a non-IDR picture NAL units \nor coded slice data partition NAL units of another slice group and the order of coded slice of a non-IDR picture \nNAL units or coded slice data partition A NAL units within a slice group shall be in the order of increasing \nmacroblock address for the first macroblock of each coded slice of a non-IDR picture NAL unit or coded slice \ndata partition A NAL unit of the particular slice group. A coded slice data partition A NAL unit with a particular \nvalue of slice_id shall immediately precede any present coded slice data partition B NAL unit with the same \nvalue of slice_id. A coded slice data partition A NAL unit with a particular value of slice_id shall immediately \nprecede any present coded slice data partition C NAL unit with the same value of slice_id, when a coded slice \ndata partition B NAL unit with the same value of slice_id is not present. When a coded slice data partition B \nNAL unit with a particular value of slice_id is present, it shall immediately precede any present coded slice data \npartition C NAL unit with the same value of slice_id. \n72  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (separate_colour_plane_flag is equal to 1), coded slice of a non-IDR picture NAL units or coded slice \ndata partition NAL units of a slice group for a particular value of colour_plane_id shall not be interleaved with \ncoded slice of a non-IDR picture NAL units or coded slice data partition NAL units of another slice group with \nthe same value of colour_plane_id and the order of coded slice of a non-IDR picture NAL units or coded slice \ndata partition A NAL units within a slice group for particular value of colour_plane_id shall be in the order of \nincreasing macroblock address for the first macroblock of each coded slice of a non-IDR picture NAL unit or \ncoded slice data partition A NAL unit of the particular slice group having the particular value of colour_plane_id. \nA coded slice data partition A NAL unit associated with a particular value of slice_id and colour_plane_id shall \nimmediately precede any present coded slice data partition B NAL unit with the same value of slice_id and \ncolour_plane_id. A coded slice data partition A NAL unit associated with a particular value of slice_id and \ncolour_plane_id shall immediately precede any present coded slice data partition C NAL unit with the same \nvalue of slice_id and colour_plane_id, when a coded slice data partition B NAL unit with the same value of \nslice_id and colour_plane_id is not present. When a coded slice data partition B NAL unit with a particular \nvalue of slice_id and colour_plane_id is present, it shall immediately precede any present coded slice data \npartition C NAL unit with the same value of slice_id and colour_plane_id. \nNOTE 2 – When separate_colour_plane_flag is equal to 1, the relative ordering of coded slices having different values \nof colour_plane_id is not constrained. \nNAL units having nal_unit_type equal to 12 may be present in the access unit but shall not precede the first VCL NAL \nunit of the primary coded picture within the access unit. \nNAL units having nal_unit_type equal to 0 or in the range of 24 to 31, inclusive, which are unspecified, may be present in \nthe access unit but shall not precede the first VCL NAL unit of the primary coded picture within the access unit. \nNAL units having nal_unit_type in the range of 20 to 23, inclusive, shall not precede the first VCL NAL unit of the primary \ncoded picture within the access unit. \n7.4.2  Raw byte sequence payloads and RBSP trailing bits semantics \n7.4.2.1  Sequence parameter set RBSP semantics \n7.4.2.1.1 Sequence parameter set data semantics \nprofile_idc and level_idc indicate the profile and level to which the coded video sequence conforms. \nconstraint_set0_flag equal to 1 indicates that the coded video sequence obeys all constraints specified in clause A.2.1. \nconstraint_set0_flag equal to 0 indicates that the coded video sequence may or may not obey all constraints specified in \nclause A.2.1. \nconstraint_set1_flag equal to 1 indicates that the coded video sequence obeys all constraints specified in clause A.2.2. \nconstraint_set1_flag equal to 0 indicates that the coded video sequence may or may not obey all constraints specified in \nclause A.2.2. \nconstraint_set2_flag equal to 1 indicates that the coded video sequence obeys all constraints specified in clause A.2.3. \nconstraint_set2_flag equal to 0 indicates that the coded video sequence may or may not obey all constraints specified in \nclause A.2.3. \nNOTE 1 – When one or more than one of constraint_set0_flag, constraint_set1_flag, or constraint_set2_flag are equal to 1, the coded \nvideo sequence must obey the constraints of all of the indicated subclauses of clause A.2. When profile_idc is equal to 44, 100, 110, \n122, or 244, the values of constraint_set0_flag, constraint_set1_flag, and constraint_set2_flag must all be equal to 0. \nconstraint_set3_flag is specified as follows: \n–  If profile_idc is equal to 66, 77, or 88 and level_idc is equal to 11, constraint_set3_flag equal to 1 indicates that the \ncoded video sequence obeys all constraints specified in Annex A for level 1b and constraint_set3_flag equal to 0 \nindicates that the coded video sequence obeys all constraints specified in Annex A for level 1.1. \n–  Otherwise,  if  profile_idc  is  equal  to 100 or 110,  constraint_set3_flag  equal  to  1  indicates  that  the  coded  video \nsequence obeys all constraints specified in Annex A for the High 10 Intra profile, and constraint_set3_flag equal to \n0 indicates that the coded video sequence may or may not obey these corresponding constraints. \n–  Otherwise, if profile_idc is equal to 122, constraint_set3_flag equal to 1 indicates that the coded video sequence obeys \nall constraints specified in Annex A for the High 4:2:2 Intra profile, and constraint_set3_flag equal to 0 indicates that \nthe coded video sequence may or may not obey these corresponding constraints. \n–  Otherwise, if profile_idc is equal to 44, constraint_set3_flag shall be equal to 1. When profile_idc is equal to 44, the \nvalue of 0 for constraint_set3_flag is forbidden. \n–  Otherwise, if profile_idc is equal to 244, constraint_set3_flag equal to 1 indicates that the coded video sequence obeys \nall constraints specified in Annex A for the High 4:4:4 Intra profile, and constraint_set3_flag equal to 0 indicates that \nthe coded video sequence may or may not obey these corresponding constraints. \n    Rec. ITU-T H.264 (06/2019)  73 \n \n–  Otherwise (profile_idc is equal to 66, 77, or 88 and level_idc is not equal to 11, or profile_idc is not equal to 66, 77, \n88, 100, 110, 122, 244, or 44), the value of 1 for constraint_set3_flag is reserved for future use by ITU-T | ISO/IEC. \nconstraint_set3_flag shall be equal to 0 for coded video sequences with profile_idc equal to 66, 77, or 88 and level_idc \nnot equal to 11 and for coded video sequences with profile_idc not equal to 66, 77, 88, 100, 110, 122, 244, or 44 in \nbitstreams  conforming  to  this  Recommendation  |  International  Standard.  Decoders  shall  ignore  the  value  of \nconstraint_set3_flag when profile_idc is equal to 66, 77, or 88 and level_idc is not equal to 11 or when profile_idc is \nnot equal to 66, 77, 88, 100, 110, 122, 244, or 44. \nconstraint_set4_flag is specified as follows: \n–  If  profile_idc  is  equal  to  77,  88,  100,  or  110,  constraint_set4_flag  equal  to  1  indicates  that  the  value  of \nframe_mbs_only_flag is equal to 1. constraint_set4_flag equal to 0 indicates that the value of frame_mbs_only_flag \nmay or may not be equal to 1. \n–  Otherwise, if profile_idc is equal to 118, 128, or 134, constraint_set4_flag equal to 1 indicates that the coded video \nsequence obeys all constraints specified in clause H.10.1.1. constraint_set4_flag equal to 0 indicates that the coded \nvideo sequence may or may not obey the constraints specified in clause H.10.1.1. \n–  Otherwise (profile_idc is not equal to 77, 88, 100, 110, 118, 128, or 134), the value of 1 for constraint_set4_flag is \nreserved for future use by ITU-T | ISO/IEC. constraint_set4_flag shall be equal to 0 for coded video sequences with \nprofile_idc not equal to 77, 88, 100, 110, 118, 128, or 134 in bitstreams conforming to this Recommendation | \nInternational Standard. Decoders shall ignore the value of constraint_set4_flag when profile_idc is not equal to 77, \n88, 100, 110, 118, 128, or 134. \nconstraint_set5_flag is specified as follows: \n–  If profile_idc is equal to 77, 88, or 100, constraint_set5_flag equal to 1 indicates that B slice types are not present in \nthe coded video sequence. constraint_set5_flag equal to 0 indicates that B slice types may or may not be present in the \ncoded video sequence. \n–  Otherwise, if profile_idc is equal to 118, constraint_set5_flag equal to 1 indicates that the coded video sequence obeys \nall constraints specified in clause H.10.1.2 and constraint_set5_flag equal to 0 indicates that the coded video sequence \nmay or may not obey all constraints specified in clause H.10.1.2. \n–  Otherwise (profile_idc is not equal to 77, 88, 100, or 118), the value of 1 for constraint_set5_flag is reserved for future \nuse by ITU-T | ISO/IEC. constraint_set5_flag shall be equal to 0 when profile_idc is not equal to 77, 88, 100, or 118 \nin  bitstreams  conforming  to  this  Recommendation | International  Standard.  Decoders  shall  ignore  the  value  of \nconstraint_set5_flag when profile_idc is not equal to 77, 88, 100, or 118. \nNOTE 2 – For a coded video sequence conforming to both  the Multiview High and Stereo High profiles,  a corresponding \ncombination would use profile_idc equal to 118 and constraint_set5_flag equal to 1. \nreserved_zero_2bits shall be equal to 0. Other values of reserved_zero_2bits may be specified in the future by ITU-T | \nISO/IEC. Decoders shall ignore the value of reserved_zero_2bits. \nseq_parameter_set_id identifies the sequence parameter set that is referred to by the picture parameter set. The value of \nseq_parameter_set_id shall be in the range of 0 to 31, inclusive. \nNOTE 3 – When feasible, encoders should use distinct values of seq_parameter_set_id when the values of other sequence parameter \nset  syntax  elements  differ  rather  than  changing  the  values  of  the  syntax  elements  associated  with  a  specific  value  of \nseq_parameter_set_id. \nchroma_format_idc specifies the chroma sampling relative to the luma sampling as specified in clause 6.2. The value of \nchroma_format_idc shall be in the range of 0 to 3, inclusive. When chroma_format_idc is not present, it shall be inferred \nto be equal to 1 (4:2:0 chroma format). \nseparate_colour_plane_flag equal to 1 specifies that the three colour components of the 4:4:4 chroma format are coded \nseparately. separate_colour_plane_flag equal to 0 specifies that the colour components are not coded separately. When \nseparate_colour_plane_flag is not present, it shall be inferred to be equal to 0. When separate_colour_plane_flag is equal \nto 1, the primary coded picture consists of three separate components, each of which consists of coded samples of one \ncolour plane (Y, Cb or Cr) that each use the monochrome coding syntax. In this case, each colour plane is associated with \na specific colour_plane_id value. \nNOTE 4 – There is no dependency in decoding processes between the colour planes having different colour_plane_id values. For \nexample, the decoding process of a monochrome picture with one value of colour_plane_id does not use any data from monochrome \npictures having different values of colour_plane_id for inter prediction. \nDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows: \n–  If separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc. \n–  Otherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0. \n74  Rec. ITU-T H.264 (06/2019) \n \nbit_depth_luma_minus8 specifies the bit depth of the samples of the luma array and the value of the luma quantization \nparameter range offset QpBdOffset , as specified by \nY\nBitDepth  = 8 + bit_depth_luma_minus8    (7-3) \nY\nQpBdOffset  = 6 * bit_depth_luma_minus8    (7-4) \nY\nWhen bit_depth_luma_minus8 is not present, it shall be inferred to be equal to 0. bit_depth_luma_minus8 shall be in the \nrange of 0 to 6, inclusive. \nbit_depth_chroma_minus8 specifies the bit depth of the samples of the chroma arrays and the value of the chroma \nquantization parameter range offset QpBdOffset , as specified by \nC\nBitDepth  = 8 + bit_depth_chroma_minus8    (7-5) \nC\nQpBdOffset  = 6 * bit_depth_chroma_minus8    (7-6) \nC\nWhen bit_depth_chroma_minus8 is not present, it shall be inferred to be equal to 0. bit_depth_chroma_minus8 shall be in \nthe range of 0 to 6, inclusive. \nNOTE 5 – The value of bit_depth_chroma_minus8 is not used in the decoding process when ChromaArrayType is equal to 0. In \nparticular, when separate_colour_plane_flag is equal to 1, each colour plane is decoded as a distinct monochrome picture using the \nluma component decoding process (except for the selection of scaling matrices) and the luma bit depth is used for all three colour \ncomponents. \nThe variable RawMbBits is derived as \nRawMbBits = 256 * BitDepth  + 2 * MbWidthC * MbHeightC * BitDepth   (7-7) \nY C\nqpprime_y_zero_transform_bypass_flag equal to 1 specifies that, when QP′  is equal to 0, a transform bypass operation \nY\nfor the transform coefficient decoding process and picture construction process prior to deblocking filter  process as \nspecified in clause 8.5 shall be applied. qpprime_y_zero_transform_bypass_flag equal to 0 specifies that the transform \ncoefficient decoding process and picture construction process prior to deblocking filter process shall not use the transform \nbypass operation. When qpprime_y_zero_transform_bypass_flag is not present, it shall be inferred to be equal to 0. \nseq_scaling_matrix_present_flag  equal  to 1  specifies  that  the  flags  seq_scaling_list_present_flag[ i ]  for  i = 0..7  or \ni = 0..11 are present. seq_scaling_matrix_present_flag equal to 0 specifies that these flags are not present and the sequence-\nlevel scaling list specified by Flat_4x4_16 shall be inferred for i = 0..5 and the sequence-level scaling list specified by \nFlat_8x8_16 shall be inferred for i = 6..11. When seq_scaling_matrix_present_flag is not present, it shall be inferred to be \nequal to 0. \nThe scaling lists Flat_4x4_16 and Flat_8x8_16 are specified as follows: \nFlat_4x4_16[ k ] = 16,     with k = 0..15,    (7-8) \nFlat_8x8_16[ k ] = 16,     with k = 0..63.    (7-9) \nseq_scaling_list_present_flag[ i ] equal to 1 specifies that the syntax structure for scaling list i is present in the sequence \nparameter set. seq_scaling_list_present_flag[ i ] equal to 0 specifies that the syntax structure for scaling list i is not present \nin the sequence parameter set and the scaling list fall-back rule set A specified in Table 7-2 shall be used to infer the \nsequence-level scaling list for index i. \n    Rec. ITU-T H.264 (06/2019)  75 \n \nTable 7-2 – Assignment of mnemonic names to scaling list indices and specification of fall-back rule \nValue of  Mnemonic name  Block  MB  Component  Scaling list  Scaling list  Default \nscaling list  size  prediction  fall-back rule  fall-back rule  scaling list \nindex  type  set A  set B \n0  Sl_4x4_Intra_Y  4x4  Intra  Y  default  sequence-level  Default_4x4_Intra \nscaling list  scaling list \n1  Sl_4x4_Intra_Cb  4x4  Intra  Cb  scaling list  scaling list  Default_4x4_Intra \nfor i = 0  for i = 0 \n2  Sl_4x4_Intra_Cr  4x4  Intra  Cr  scaling list  scaling list  Default_4x4_Intra \nfor i = 1  for i = 1 \n3  Sl_4x4_Inter_Y  4x4  Inter  Y  default  sequence-level  Default_4x4_Inter \nscaling list  scaling list \n4  Sl_4x4_Inter_Cb  4x4  Inter  Cb  scaling list  scaling list  Default_4x4_Inter \nfor i = 3  for i = 3 \n5  Sl_4x4_Inter_Cr  4x4  Inter  Cr  scaling list  scaling list  Default_4x4_Inter \nfor i = 4  for i = 4 \n6  Sl_8x8_Intra_Y  8x8  Intra  Y  default  sequence-level  Default_8x8_Intra \nscaling list  scaling list \n7  Sl_8x8_Inter_Y  8x8  Inter  Y  default  sequence-level  Default_8x8_Inter \nscaling list  scaling list \n8  Sl_8x8_Intra_Cb  8x8  Intra  Cb  scaling list  scaling list  Default_8x8_Intra \nfor i = 6  for i = 6 \n9  Sl_8x8_Inter_Cb  8x8  Inter  Cb  scaling list  scaling list  Default_8x8_Inter \nfor i = 7  for i = 7 \n10  Sl_8x8_Intra_Cr  8x8  Intra  Cr  scaling list  scaling list  Default_8x8_Intra \nfor i = 8  for i = 8 \n11  Sl_8x8_Inter_Cr  8x8  Inter  Cr  scaling list  scaling list  Default_8x8_Inter \nfor i = 9  for i = 9 \n \nTable 7-3 specifies the default scaling lists Default_4x4_Intra and Default_4x4_Inter.  Table 7-4 specifies the default \nscaling lists Default_8x8_Intra and Default_8x8_Inter. \nTable 7-3 – Specification of default scaling lists Default_4x4_Intra and Default_4x4_Inter \nidx  0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15 \nDefault_4x4_Intra[ idx ]  6  13  13  20  20  20  28  28  28  28  32  32  32  37  37  42 \nDefault_4x4_Inter[ idx ]  10  14  14  20  20  20  24  24  24  24  27  27  27  30  30  34 \n \n76  Rec. ITU-T H.264 (06/2019) \n \nTable 7-4 – Specification of default scaling lists Default_8x8_Intra and Default_8x8_Inter \nidx  0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15 \nDefault_8x8_Intra[ idx ]  6  10  10  13  11  13  16  16  16  16  18  18  18  18  18  23 \nDefault_8x8_Inter[ idx ]  9  13  13  15  13  15  17  17  17  17  19  19  19  19  19  21 \nTable 7-4 (continued) – Specification of default scaling lists Default_8x8_Intra and Default_8x8_Inter \nidx  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31 \nDefault_8x8_Intra[ idx ]  23  23  23  23  23  25  25  25  25  25  25  25  27  27  27  27 \nDefault_8x8_Inter[ idx ]  21  21  21  21  21  22  22  22  22  22  22  22  24  24  24  24 \nTable 7-4 (continued) – Specification of default scaling lists Default_8x8_Intra and Default_8x8_Inter \nidx  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47 \nDefault_8x8_Intra[ idx ]  27  27  27  27  29  29  29  29  29  29  29  31  31  31  31  31 \nDefault_8x8_Inter[ idx ]  24  24  24  24  25  25  25  25  25  25  25  27  27  27  27  27 \nTable 7-4 (concluded) – Specification of default scaling lists Default_8x8_Intra and Default_8x8_Inter \nidx  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63 \nDefault_8x8_Intra[ idx ]  31  33  33  33  33  33  36  36  36  36  38  38  38  40  40  42 \nDefault_8x8_Inter[ idx ]  27  28  28  28  28  28  30  30  30  30  32  32  32  33  33  35 \n \nlog2_max_frame_num_minus4 specifies the value of the variable MaxFrameNum that is used in frame_num related \nderivations as follows: \nMaxFrameNum = 2( log2_max_frame_num_minus4 + 4 )    (7-10) \nThe value of log2_max_frame_num_minus4 shall be in the range of 0 to 12, inclusive. \npic_order_cnt_type specifies the method to decode picture order count (as specified in  clause 8.2.1). The value of \npic_order_cnt_type shall be in the range of 0 to 2, inclusive. \npic_order_cnt_type shall not be equal to 2 in a coded video sequence that contains any of the following: \n–  an access unit containing a non-reference frame followed immediately by an access unit containing a non-reference \npicture, \n–  two access units each containing a field with the two fields together forming a complementary non-reference field \npair followed immediately by an access unit containing a non-reference picture, \n–  an access unit containing a non-reference field followed immediately by an access unit containing another non-\nreference picture that does not form a complementary non-reference field pair with the first of the two access units. \nlog2_max_pic_order_cnt_lsb_minus4 specifies the value of the variable MaxPicOrderCntLsb that is used in the decoding \nprocess for picture order count as specified in clause 8.2.1 as follows: \nMaxPicOrderCntLsb = 2( log2_max_pic_order_cnt_lsb_minus4 + 4 )  (7-11) \nThe value of log2_max_pic_order_cnt_lsb_minus4 shall be in the range of 0 to 12, inclusive. \ndelta_pic_order_always_zero_flag equal to 1 specifies that delta_pic_order_cnt[ 0 ] and delta_pic_order_cnt[ 1 ] are not \npresent in the slice headers of the sequence and shall be inferred to be equal to 0. delta_pic_order_always_zero_flag equal \nto 0 specifies that delta_pic_order_cnt[ 0 ] is present in the slice headers of the sequence and delta_pic_order_cnt[ 1 ] may \nbe present in the slice headers of the sequence. \n    Rec. ITU-T H.264 (06/2019)  77 \n \noffset_for_non_ref_pic is used to calculate the picture order count of a non-reference picture as specified in clause 8.2.1. \nThe value of offset_for_non_ref_pic shall be in the range of −231 + 1 to 231 − 1, inclusive. \noffset_for_top_to_bottom_field is used to calculate the picture order count of a bottom field as specified in clause 8.2.1. \nThe value of offset_for_top_to_bottom_field shall be in the range of −231 + 1 to 231 − 1, inclusive. \nnum_ref_frames_in_pic_order_cnt_cycle  is  used  in  the  decoding  process  for  picture  order  count  as  specified  in \nclause 8.2.1. The value of num_ref_frames_in_pic_order_cnt_cycle shall be in the range of 0 to 255, inclusive. \noffset_for_ref_frame[ i ] is an element of a list of num_ref_frames_in_pic_order_cnt_cycle values used in the decoding \nprocess for picture order count as specified in clause 8.2.1. The value of offset_for_ref_frame[ i ] shall be in the range of \n−231 + 1 to 231 − 1, inclusive. \nWhen pic_order_cnt_type is equal to 1, the variable ExpectedDeltaPerPicOrderCntCycle is derived by \nExpectedDeltaPerPicOrderCntCycle = 0 \nfor( i = 0;  i < num_ref_frames_in_pic_order_cnt_cycle;  i++ ) \n  ExpectedDeltaPerPicOrderCntCycle += offset_for_ref_frame[ i ]  (7-12) \nmax_num_ref_frames specifies the maximum number of short-term and long-term reference frames, complementary \nreference field pairs, and non-paired reference fields that may be used by the decoding process for inter prediction of any \npicture in the coded video sequence. max_num_ref_frames also determines the size of the sliding window operation as \nspecified in clause 8.2.5.3. The value of max_num_ref_frames shall be in the range of 0 to MaxDpbFrames (as specified \nin clause A.3.1 or A.3.2), inclusive. \ngaps_in_frame_num_value_allowed_flag specifies the allowed values of frame_num as specified in clause 7.4.3 and the \ndecoding process in case of an inferred gap between values of frame_num as specified in clause 8.2.5.2. \npic_width_in_mbs_minus1 plus 1 specifies the width of each decoded picture in units of macroblocks. \nThe variable for the picture width in units of macroblocks is derived as \nPicWidthInMbs = pic_width_in_mbs_minus1 + 1    (7-13) \nThe variable for picture width for the luma component is derived as \nPicWidthInSamples  = PicWidthInMbs * 16    (7-14) \nL\nThe variable for picture width for the chroma components is derived as \nPicWidthInSamples  = PicWidthInMbs * MbWidthC  (7-15) \nC\npic_height_in_map_units_minus1 plus 1 specifies the height in slice group map units of a decoded frame or field. \nThe variables PicHeightInMapUnits and PicSizeInMapUnits are derived as \nPicHeightInMapUnits = pic_height_in_map_units_minus1 + 1  (7-16) \nPicSizeInMapUnits = PicWidthInMbs * PicHeightInMapUnits  (7-17) \nframe_mbs_only_flag equal to 0 specifies that coded pictures of the coded video sequence may either be coded fields or \ncoded frames. frame_mbs_only_flag equal to 1 specifies that every coded picture of the coded video sequence is a coded \nframe containing only frame macroblocks. \nThe allowed range of values for pic_width_in_mbs_minus1, pic_height_in_map_units_minus1, and frame_mbs_only_flag \nis specified by constraints in Annex A. \nDepending on frame_mbs_only_flag, semantics are assigned to pic_height_in_map_units_minus1 as follows: \n–  If frame_mbs_only_flag is equal to 0, pic_height_in_map_units_minus1 plus 1 is the height of a field in units of \nmacroblocks. \n–  Otherwise (frame_mbs_only_flag is equal to 1), pic_height_in_map_units_minus1 plus 1 is the height of a frame in \nunits of macroblocks. \nThe variable FrameHeightInMbs is derived as \nFrameHeightInMbs = ( 2 − frame_mbs_only_flag ) * PicHeightInMapUnits  (7-18) \n78  Rec. ITU-T H.264 (06/2019) \n \nmb_adaptive_frame_field_flag equal to 0 specifies no switching between frame and field macroblocks within a picture. \nmb_adaptive_frame_field_flag equal to 1 specifies the possible use of switching between frame and field macroblocks \nwithin frames. When mb_adaptive_frame_field_flag is not present, it shall be inferred to be equal to 0. \ndirect_8x8_inference_flag specifies the method used in the derivation process for luma motion vectors for B_Skip, \nB_Direct_16x16  and  B_Direct_8x8  as  specified  in  clause 8.4.1.2.  When  frame_mbs_only_flag  is  equal  to 0, \ndirect_8x8_inference_flag shall be equal to 1. \nframe_cropping_flag equal to 1 specifies that the frame cropping offset parameters follow next in the sequence parameter \nset. frame_cropping_flag equal to 0 specifies that the frame cropping offset parameters are not present. \nframe_crop_left_offset,  frame_crop_right_offset,  frame_crop_top_offset,  frame_crop_bottom_offset  specify  the \nsamples of the pictures in the coded video sequence that are output from the decoding process, in terms of a rectangular \nregion specified in frame coordinates for output. \nThe variables CropUnitX and CropUnitY are derived as follows: \n–  If ChromaArrayType is equal to 0, CropUnitX and CropUnitY are derived as: \nCropUnitX = 1    (7-19) \nCropUnitY = 2 − frame_mbs_only_flag    (7-20) \n–  Otherwise (ChromaArrayType is equal to 1, 2, or 3), CropUnitX and CropUnitY are derived as: \nCropUnitX = SubWidthC    (7-21) \nCropUnitY = SubHeightC * ( 2 − frame_mbs_only_flag )  (7-22) \nThe  frame  cropping  rectangle  contains  luma  samples  with  horizontal  frame  coordinates  from \nCropUnitX * frame_crop_left_offset to PicWidthInSamples  − ( CropUnitX * frame_crop_right_offset + 1 ) and vertical \nL\nframe  coordinates  from  CropUnitY * frame_crop_top_offset  to  ( 16 * FrameHeightInMbs ) − \n( CropUnitY * frame_crop_bottom_offset + 1 ), inclusive. The value of frame_crop_left_offset shall be in the range of 0 \nto  ( PicWidthInSamples  / CropUnitX ) − ( frame_crop_right_offset + 1 ),  inclusive;  and  the  value  of \nL\nframe_crop_top_offset  shall  be  in  the  range  of  0  to  ( 16 * FrameHeightInMbs / CropUnitY ) − \n( frame_crop_bottom_offset + 1 ), inclusive. \nWhen  frame_cropping_flag  is  equal  to  0,  the  values  of  frame_crop_left_offset,  frame_crop_right_offset, \nframe_crop_top_offset, and frame_crop_bottom_offset shall be inferred to be equal to 0. \nWhen ChromaArrayType is not equal to 0, the corresponding specified samples of the two chroma arrays are the samples \nhaving frame coordinates ( x / SubWidthC, y / SubHeightC ), where ( x, y ) are the frame coordinates of the specified luma \nsamples. \nFor decoded fields, the specified samples of the decoded field are the samples that fall within the rectangle specified in \nframe coordinates. \nvui_parameters_present_flag equal to 1 specifies that the vui_parameters( ) syntax structure as specified in Annex E is \npresent.  vui_parameters_present_flag  equal  to 0  specifies  that  the  vui_parameters( )  syntax  structure  as  specified  in \nAnnex E is not present. \n7.4.2.1.1.1  Scaling list semantics \ndelta_scale is used to derive the j-th element of the scaling list for j in the range of 0 to sizeOfScalingList − 1, inclusive. \nThe value of delta_scale shall be in the range of −128 to +127, inclusive. \nWhen useDefaultScalingMatrixFlag is derived to be equal to 1, the scaling list shall be inferred to be equal to the default \nscaling list as specified in Table 7-2. \n7.4.2.1.2 Sequence parameter set extension RBSP semantics \nseq_parameter_set_id identifies the sequence parameter set associated with the sequence parameter set extension. The \nvalue of seq_parameter_set_id shall be in the range of 0 to 31, inclusive. \naux_format_idc equal to 0 indicates that there are no auxiliary coded pictures in the coded video sequence. aux_format_idc \nequal to 1 indicates that exactly one auxiliary coded picture is present in each access unit of the coded video sequence, and \nthat for alpha blending purposes the decoded samples of the associated primary coded picture in each access unit should \nbe multiplied by the interpretation sample values of the auxiliary coded picture in the access unit in the display process \nafter output from the decoding process. aux_format_idc equal to 2 indicates that exactly one auxiliary coded picture exists \nin each access unit of the coded video sequence, and that for alpha blending purposes the decoded samples of the associated \nprimary coded picture in each access unit should not be multiplied by the interpretation sample values of the auxiliary \ncoded picture in the access unit in the display process after output from the decoding process. aux_format_idc equal to 3 \n    Rec. ITU-T H.264 (06/2019)  79 \n \nindicates that exactly one auxiliary coded picture exists in each access unit of the coded video sequence, and that the usage \nof the auxiliary coded pictures is unspecified. The value of aux_format_idc shall be in the range of 0 to 3, inclusive. Values \ngreater than 3 for aux_format_idc are reserved to indicate the presence of exactly one auxiliary coded picture in each access \nunit of the coded video sequence for purposes to be specified in the future by ITU-T | ISO/IEC. When aux_format_idc is \nnot present, it shall be inferred to be equal to 0. \nNOTE 1 – Decoders are not required to decode auxiliary coded pictures. \nbit_depth_aux_minus8  specifies  the  bit  depth  of  the  samples  of  the  sample  array  of  the  auxiliary  coded  picture. \nbit_depth_aux_minus8 shall be in the range of 0 to 4, inclusive. \nalpha_incr_flag equal to 0 indicates that the interpretation sample value for each decoded auxiliary coded picture sample \nvalue is equal to the decoded auxiliary coded picture sample value for purposes of alpha blending. alpha_incr_flag equal \nto 1 indicates that, for purposes of alpha blending, after decoding the auxiliary coded picture samples, any auxiliary coded \npicture sample value that is greater than Min(alpha_opaque_value, alpha_transparent_value) should be increased by one \nto obtain the interpretation sample value for the auxiliary coded picture sample, and any auxiliary coded picture sample \nvalue that is less than or equal to Min(alpha_opaque_value, alpha_transparent_value) should be used without alteration as \nthe interpretation sample value for the decoded auxiliary coded picture sample value. \nalpha_opaque_value  specifies  the  interpretation  sample  value  of  an  auxiliary  coded  picture  sample  for  which  the \nassociated luma and chroma samples of the same access unit are considered opaque for purposes of alpha blending. The \nnumber of bits used for the representation of the alpha_opaque_value syntax element is bit_depth_aux_minus8 + 9 bits. \nalpha_transparent_value specifies the interpretation sample value of an auxiliary coded picture sample for which the \nassociated luma and chroma samples of the same access unit are considered transparent for purposes of alpha blending. \nThe number of bits used for the representation of the alpha_transparent_value syntax element is bit_depth_aux_minus8 + 9 \nbits. \nWhen  alpha_incr_flag  is  equal  to  1,  alpha_transparent_value  shall  not  be  equal  to  alpha_opaque_value  and \nLog2( Abs( alpha_opaque_value − alpha_transparent_value ) )  shall  have  an  integer  value.  A  value  of \nalpha_transparent_value that is equal to alpha_opaque_value indicates that the auxiliary coded picture is not intended for \nalpha blending purposes. \nNOTE 2 – For alpha blending purposes, alpha_opaque_value may be greater than alpha_transparent_value, or it may be less than \nalpha_transparent_value.  Interpretation  sample  values  should  be  clipped  to  the  range  of  alpha_opaque_value  to \nalpha_transparent_value, inclusive. \nThe decoding of the sequence parameter set extension and the decoding of auxiliary coded pictures is not required for \nconformance with this Recommendation | International Standard. \nThe syntax of each coded slice of an auxiliary coded picture shall obey the same constraints as a coded slice of a redundant \npicture, with the following differences of constraints: \na)  In regard to whether the primary coded picture is an IDR picture, the following applies: \n–  If the primary coded picture is an IDR picture, the auxiliary coded slice syntax shall correspond to that of a \nslice having nal_unit_type equal to 5 (a slice of an IDR picture). \n–  Otherwise (the primary coded picture is not an IDR picture), the auxiliary coded slice syntax shall correspond \nto that of a slice having nal_unit_type equal to 1 (a slice of a non-IDR picture). \nb)  The slices of an auxiliary coded picture (when present) shall contain all macroblocks corresponding to those of \nthe primary coded picture. \nc)  redundant_pic_cnt shall be equal to 0 in all auxiliary coded slices. \nThe (optional) decoding process for the decoding of auxiliary coded pictures is the same as if the auxiliary coded pictures \nwere primary coded pictures in a separate coded video stream that differs from the primary coded pictures in the current \ncoded video stream in the following ways: \n–  The IDR or non-IDR status of each auxiliary coded picture shall be inferred to be the same as the IDR or non-IDR \nstatus of the primary picture in the same access unit, rather than being inferred from the value of nal_unit_type. \n–  The value of chroma_format_idc and the value of ChromaArrayType shall be inferred to be equal to 0 for the decoding \nof the auxiliary coded pictures. \n–  The value of bit_depth_luma_minus8 shall be inferred to be equal to bit_depth_aux_minus8 for the decoding of the \nauxiliary coded pictures. \nNOTE 3 – Alpha blending composition is normally performed with a background picture B, a foreground picture F, and a decoded \nauxiliary coded picture A, all of the same size. Assume for purposes of example illustration that the chroma resolution of B and F \nhave been upsampled to the same resolution as the luma. Denote corresponding samples of B, F and A by b, f and a, respectively. \nDenote luma and chroma samples by subscripts Y, Cb and Cr. \n80  Rec. ITU-T H.264 (06/2019) \n \nDefine the variables alphaRange, alphaFwt and alphaBwt as follows: \n  alphaRange = Abs( alpha_opaque_value − alpha_transparent_value ) \n  alphaFwt = Abs( a − alpha_transparent_value ) \n  alphaBwt = Abs( a − alpha_opaque_value ) \nThen, in alpha blending composition, samples d of the displayed picture D may be calculated as \n  d  = ( alphaFwt * f  + alphaBwt * b  + alphaRange / 2 ) / alphaRange \nY Y Y\n  d  = ( alphaFwt * f  + alphaBwt * b  + alphaRange / 2 ) / alphaRange \nCb Cb Cb\n  d  = ( alphaFwt * f  + alphaBwt * b  + alphaRange / 2 ) / alphaRange \nCr Cr Cr\nThe samples of pictures D, F and B could also represent red, green, and blue component values (see clause E.2.1). Here we have \nassumed Y, Cb and Cr component values. Each component, e.g., Y, is assumed for purposes of example illustration above to have \nthe same bit depth in each of the pictures D, F and B. However, different components, e.g., Y and Cb, need not have the same bit \ndepth in this example. \nWhen aux_format_idc is equal to 1, F would be the decoded picture obtained from the decoded luma and chroma, and A would be \nthe  decoded picture  obtained  from  the  decoded  auxiliary  coded  picture. In  this  case,  the  indicated  example  alpha  blending \ncomposition involves multiplying the samples of F by factors obtained from the samples of A. \nA picture format that is useful for editing or direct viewing, and that is commonly used, is called pre-multiplied-black video. If the \nforeground picture was F, then the pre-multiplied-black video S is given by \n  s   = ( alphaFwt * f  ) / alphaRange \nY Y\n  s  = ( alphaFwt * f  ) / alphaRange \nCb Cb\n  s  = ( alphaFwt * f  ) / alphaRange \nCr Cr\nPre-multiplied-black video has the characteristic that the picture S will appear correct if displayed against a black background. For \na non-black background B, the composition of the displayed picture D may be calculated as \n  d   = s  + ( alphaBwt * b  + alphaRange / 2 ) / alphaRange \nY Y Y\n  d  = s  + ( alphaBwt * b  + alphaRange / 2 ) / alphaRange \nCb Cb Cb\n  d  = s  + ( alphaBwt * b  + alphaRange / 2 ) / alphaRange \nCr Cr Cr\nWhen aux_format_idc is equal to 2, S would be the decoded picture obtained from the decoded luma and chroma, and A would \nagain be the decoded picture obtained from the decoded auxiliary coded picture. In this case, alpha blending composition does not \ninvolve multiplication of the samples of S by factors obtained from the samples of A. \nadditional_extension_flag equal to 0 indicates that no additional data follows within the sequence parameter set extension \nsyntax structure prior to the RBSP trailing bits. The value of additional_extension_flag shall be equal to 0. The value of 1 \nfor additional_extension_flag is reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore all data that follows \nthe value of 1 for additional_extension_flag in a sequence parameter set extension NAL unit. \n7.4.2.1.3 Subset sequence parameter set RBSP semantics \nsvc_vui_parameters_present_flag equal to 0 specifies that the syntax structure svc_vui_parameters_extension( ) is not \npresent. svc_vui_parameters_present_flag equal to 1 specifies that the syntax structure svc_vui_parameters_extension( ) \nis present. \nbit_equal_to_one shall be equal to 1. \nmvc_vui_parameters_present_flag equal to 0 specifies that the syntax structure mvc_vui_parameters_extension( ) is not \npresent. mvc_vui_parameters_present_flag equal to 1 specifies that the syntax structure mvc_vui_parameters_extension( ) \nis present. \nadditional_extension2_flag equal to 0 specifies that no additional_extension2_data_flag syntax elements are present in \nthe subset sequence parameter set RBSP syntax structure. additional_extension2_flag shall be equal to 0 in bitstreams \nconforming to this Recommendation | International Standard. The value of 1 for additional_extension2_flag is reserved for \nfuture use by ITU-T | ISO/IEC. Decoders shall ignore all data that follow the value 1 for additional_extension2_flag in a \nsubset sequence parameter set NAL unit. \nadditional_extension2_data_flag  may  have  any  value.  It  shall  not  affect  the  conformance  to  profiles  specified  in \nAnnex A, G, H, or I. \n7.4.2.2  Picture parameter set RBSP semantics \npic_parameter_set_id  identifies  the  picture  parameter  set  that  is  referred  to  in  the  slice  header.  The  value  of \npic_parameter_set_id shall be in the range of 0 to 255, inclusive. \nseq_parameter_set_id refers to the active sequence parameter set. The value of seq_parameter_set_id shall be in the range \nof 0 to 31, inclusive. \nentropy_coding_mode_flag selects the entropy decoding method to be applied for the syntax elements for which two \ndescriptors appear in the syntax tables as follows: \n    Rec. ITU-T H.264 (06/2019)  81 \n \n–  If entropy_coding_mode_flag is equal to 0, the method specified by the left descriptor in the syntax table is applied \n(Exp-Golomb coded, see clause 9.1 or CAVLC, see clause 9.2). \n–  Otherwise (entropy_coding_mode_flag is equal to 1), the method specified by the right descriptor in the syntax table \nis applied (CABAC, see clause 9.3). \nbottom_field_pic_order_in_frame_present_flag  equal  to  1  specifies  that  the  syntax  elements \ndelta_pic_order_cnt_bottom  (when  pic_order_cnt_type  is  equal  to  0)  or  delta_pic_order_cnt[ 1 ]  (when \npic_order_cnt_type is equal to 1), which are related to picture order counts for the bottom field of a coded frame, are \npresent in the slice headers for coded frames as specified in clause 7.3.3. bottom_field_pic_order_in_frame_present_flag \nequal to 0 specifies that the syntax elements delta_pic_order_cnt_bottom and delta_pic_order_cnt[ 1 ] are not present in \nthe slice headers. \nnum_slice_groups_minus1 plus 1 specifies the number of slice groups for a picture. When num_slice_groups_minus1 is \nequal to 0, all slices of the picture belong to the same slice group. The allowed range of num_slice_groups_minus1 is \nspecified in Annex A. \nslice_group_map_type specifies how the mapping of slice group map units to slice groups is coded. The value of \nslice_group_map_type shall be in the range of 0 to 6, inclusive. \nslice_group_map_type equal to 0 specifies interleaved slice groups. \nslice_group_map_type equal to 1 specifies a dispersed slice group mapping. \nslice_group_map_type equal to 2 specifies one or more \"foreground\" slice groups and a \"leftover\" slice group. \nslice_group_map_type values equal to 3, 4, and 5 specify changing slice groups. When num_slice_groups_minus1 is not \nequal to 1, slice_group_map_type shall not be equal to 3, 4, or 5. \nslice_group_map_type equal to 6 specifies an explicit assignment of a slice group to each slice group map unit. \nSlice group map units are specified as follows: \n–  If frame_mbs_only_flag is equal to 0 and mb_adaptive_frame_field_flag is equal to 1 and the coded picture is a frame, \nthe slice group map units are macroblock pair units. \n–   Otherwise, if frame_mbs_only_flag is equal to 1 or the coded picture is a field, the slice group map units are units of \nmacroblocks. \n–   Otherwise (frame_mbs_only_flag is equal to 0 and mb_adaptive_frame_field_flag is equal to 0 and the coded picture \nis a frame), the slice group map units are units of two macroblocks that are vertically contiguous as in a frame \nmacroblock pair of an MBAFF frame. \nrun_length_minus1[ i ] is used to specify the number of consecutive slice group map units to be assigned to the i-th slice \ngroup in raster scan order of slice group map units. The value of run_length_minus1[ i ] shall be in the range of 0 to \nPicSizeInMapUnits − 1, inclusive. \ntop_left[ i ] and bottom_right[ i ] specify the top-left and bottom-right corners of a rectangle, respectively. top_left[ i ] \nand bottom_right[ i ] are slice group map unit positions in a raster scan of the picture for the slice group map units. For \neach rectangle i, all of the following constraints shall be obeyed by the values of the syntax elements top_left[ i ] and \nbottom_right[ i ]: \n–  top_left[ i ] shall be less than or equal to bottom_right[ i ] and bottom_right[ i ] shall be less than PicSizeInMapUnits. \n–  ( top_left[ i ] % PicWidthInMbs ) shall be less than or equal to the value of ( bottom_right[ i ] % PicWidthInMbs ). \nslice_group_change_direction_flag  is  used  with  slice_group_map_type  to  specify  the  refined  map  type  when \nslice_group_map_type is 3, 4, or 5. \nslice_group_change_rate_minus1  is  used  to  specify  the  variable  SliceGroupChangeRate.  SliceGroupChangeRate \nspecifies the multiple in number of slice group map units by which the size of a slice group can change from one picture \nto the next. The value of slice_group_change_rate_minus1 shall be in the range of 0 to PicSizeInMapUnits − 1, inclusive. \nThe SliceGroupChangeRate variable is specified as follows: \nSliceGroupChangeRate = slice_group_change_rate_minus1 + 1  (7-23) \npic_size_in_map_units_minus1  is  used  to  specify  the  number  of  slice  group  map  units  in  the  picture. \npic_size_in_map_units_minus1 shall be equal to PicSizeInMapUnits − 1. \nslice_group_id[ i ]  identifies  a  slice  group of  the  i-th  slice  group  map  unit  in  raster  scan  order. The  length  of  the \nslice_group_id[ i ] syntax element is Ceil( Log2( num_slice_groups_minus1 + 1 ) ) bits. The value of slice_group_id[ i ] \nshall be in the range of 0 to num_slice_groups_minus1, inclusive. \n82  Rec. ITU-T H.264 (06/2019) \n \nnum_ref_idx_l0_default_active_minus1 specifies how num_ref_idx_l0_active_minus1 is inferred for P, SP, and B slices \nwith num_ref_idx_active_override_flag equal to 0. The value of num_ref_idx_l0_default_active_minus1 shall be in the \nrange of 0 to 31, inclusive. \nnum_ref_idx_l1_default_active_minus1  specifies  how  num_ref_idx_l1_active_minus1  is  inferred  for  B  slices  with \nnum_ref_idx_active_override_flag equal to 0. The value of num_ref_idx_l1_default_active_minus1 shall be in the range \nof 0 to 31, inclusive. \nweighted_pred_flag  equal  to 0  specifies  that  the  default  weighted  prediction  shall  be  applied  to  P  and  SP  slices. \nweighted_pred_flag equal to 1 specifies that explicit weighted prediction shall be applied to P and SP slices. \nweighted_bipred_idc  equal  to 0  specifies  that  the  default  weighted  prediction  shall  be  applied  to  B  slices. \nweighted_bipred_idc equal to 1 specifies that explicit weighted prediction shall be applied to B slices. weighted_bipred_idc \nequal to 2 specifies that implicit weighted prediction shall be applied to B slices. The value of weighted_bipred_idc shall \nbe in the range of 0 to 2, inclusive. \npic_init_qp_minus26 specifies the initial value minus 26 of SliceQP  for each slice. The initial value is modified at the \nY\nslice layer  when a  non-zero  value of  slice_qp_delta is decoded, and is  modified  further  when a non-zero  value of \nmb_qp_delta  is  decoded  at  the  macroblock  layer.  The  value  of  pic_init_qp_minus26  shall  be  in  the  range  of \n−(26 + QpBdOffset  ) to +25, inclusive. \nY\npic_init_qs_minus26 specifies the initial value minus 26 of SliceQS  for all macroblocks in SP or SI slices. The initial \nY\nvalue is modified at the slice layer when a non-zero value of slice_qs_delta is decoded. The value of pic_init_qs_minus26 \nshall be in the range of −26 to +25, inclusive. \nchroma_qp_index_offset specifies the offset that shall be added to QP  and QS  for addressing the table of QP  values \nY Y C\nfor the Cb chroma component. The value of chroma_qp_index_offset shall be in the range of −12 to +12, inclusive. \ndeblocking_filter_control_present_flag equal to 1 specifies that a set of syntax elements controlling the characteristics \nof the deblocking filter is present in the slice header. deblocking_filter_control_present_flag equal to 0 specifies that the \nset of syntax elements controlling the characteristics of the deblocking filter is not present in the slice headers and their \ninferred values are in effect. \nconstrained_intra_pred_flag equal to 0 specifies that intra prediction allows usage of residual data and decoded samples \nof neighbouring macroblocks coded using Inter macroblock prediction modes for the prediction of macroblocks coded \nusing Intra macroblock prediction modes. constrained_intra_pred_flag equal to 1 specifies constrained intra prediction, in \nwhich case prediction of macroblocks coded using Intra macroblock prediction modes only uses residual data and decoded \nsamples from I or SI macroblock types. \nredundant_pic_cnt_present_flag equal to 0 specifies that the redundant_pic_cnt syntax element is not present in slice \nheaders, coded slice data partition B NAL units, and coded slice data partition C NAL units that refer (either directly or by \nassociation  with  a  corresponding  coded  slice  data  partition  A  NAL  unit)  to  the  picture  parameter  set. \nredundant_pic_cnt_present_flag equal to 1 specifies that the redundant_pic_cnt syntax element is present in all slice \nheaders, coded slice data partition B NAL units, and coded slice data partition C NAL units that refer (either directly or by \nassociation with a corresponding coded slice data partition A NAL unit) to the picture parameter set. \ntransform_8x8_mode_flag equal to 1 specifies that the 8x8 transform decoding process may be in use (see clause 8.5). \ntransform_8x8_mode_flag  equal  to 0  specifies  that  the  8x8  transform  decoding  process  is  not  in  use.  When \ntransform_8x8_mode_flag is not present, it shall be inferred to be 0. \npic_scaling_matrix_present_flag equal to 1 specifies that parameters are present to modify the scaling lists specified in \nthe sequence parameter set. pic_scaling_matrix_present_flag equal to 0 specifies that the scaling lists used for the picture \nshall be inferred to be equal to those specified by the sequence parameter set. When pic_scaling_matrix_present_flag is \nnot present, it shall be inferred to be equal to 0. \npic_scaling_list_present_flag[ i ] equal to 1 specifies that the scaling list syntax structure is present to specify the scaling \nlist for index i. pic_scaling_list_present_flag[ i ] equal to 0 specifies that the syntax structure for scaling list i is not present \nin the picture parameter set and that depending on the value of seq_scaling_matrix_present_flag, the following applies: \n–  If seq_scaling_matrix_present_flag is equal to 0, the scaling list fall-back rule set A as specified in Table 7-2 shall be \nused to derive the picture-level scaling list for index i. \n–  Otherwise  (seq_scaling_matrix_present_flag  is  equal  to 1),  the  scaling  list  fall-back  rule  set  B  as  specified \nin Table 7-2 shall be used to derive the picture-level scaling list for index i. \nsecond_chroma_qp_index_offset specifies the offset that shall be added to QP  and QS  for addressing the table of QP  \nY Y C\nvalues for the Cr chroma component. The value of second_chroma_qp_index_offset shall be in the range of −12 to +12, \ninclusive. \nWhen second_chroma_qp_index_offset is not present, it shall be inferred to be equal to chroma_qp_index_offset. \n    Rec. ITU-T H.264 (06/2019)  83 \n \nNOTE  –  When  ChromaArrayType  is  equal  to  0,  the  values  of  bit_depth_chroma_minus8,  chroma_qp_index_offset  and \nsecond_chroma_qp_index_offset are not used in the decoding process. In particular, when separate_colour_plane_flag is equal to 1, \neach colour plane is decoded as a distinct monochrome picture using the luma component decoding process (except for the selection \nof scaling matrices), including the application of the luma quantization parameter derivation process without application of an offset \nfor the decoding of the pictures having colour_plane_id not equal to 0. \n7.4.2.3  Supplemental enhancement information RBSP semantics \nSupplemental Enhancement Information (SEI) contains information that is not necessary to decode the samples of coded \npictures from VCL NAL units. \n7.4.2.3.1 Supplemental enhancement information message semantics \nAn SEI RBSP contains one or more SEI messages. Each SEI message consists of the variables specifying the type \npayloadType and size payloadSize of the SEI payload. SEI payloads are specified in Annex D. The derived SEI payload \nsize payloadSize is specified in bytes and shall be equal to the number of RBSP bytes in the SEI payload. \nNOTE –  The NAL unit byte sequence containing the SEI message  might include one or more emulation prevention bytes \n(represented by emulation_prevention_three_byte syntax elements). Since the payload size of an SEI message is specified in RBSP \nbytes, the quantity of emulation prevention bytes is not included in the size payloadSize of an SEI payload. \nff_byte is a byte equal to 0xFF identifying a need for a longer representation of the syntax structure that it is used within. \nlast_payload_type_byte is the last byte of the payload type of an SEI message. \nlast_payload_size_byte is the last byte of the payload size of an SEI message. \n7.4.2.4  Access unit delimiter RBSP semantics \nThe access unit delimiter may be used to indicate the type of slices present in a primary coded picture and to simplify the \ndetection of the boundary between access units. There is no normative decoding process associated with the access unit \ndelimiter. \nprimary_pic_type indicates that the slice_type values for all slices of the primary coded picture are members of the set \nlisted in Table 7-5 for the given value of primary_pic_type. \nNOTE – The value of primary_pic_type applies to the slice_type values in all slice headers of the primary coded picture, including \nthe slice_type syntax elements in all NAL units with nal_unit_type equal to 1, 2, or 5. \nTable 7-5 – Meaning of primary_pic_type \nprimary_pic_type  slice_type values that may be present in the primary coded picture \n0  2, 7 \n1  0, 2, 5, 7 \n2  0, 1, 2, 5, 6, 7 \n3  4, 9 \n4  3, 4, 8, 9 \n5  2, 4, 7, 9 \n6  0, 2, 3, 4, 5, 7, 8, 9 \n7  0, 1, 2, 3, 4, 5, 6, 7, 8, 9 \n \n7.4.2.5  End of sequence RBSP semantics \nThe end of sequence RBSP specifies that the next subsequent access unit in the bitstream in decoding order (if any) shall \nbe an IDR access unit. The syntax content of the SODB and RBSP for the end of sequence RBSP are empty. No normative \ndecoding process is specified for an end of sequence RBSP. \n7.4.2.6  End of stream RBSP semantics \nThe end of stream RBSP indicates that no additional NAL units shall be present in the bitstream that are subsequent to the \nend of stream RBSP in decoding order. The syntax content of the SODB and RBSP for the end of stream RBSP are empty. \nNo normative decoding process is specified for an end of stream RBSP. \nNOTE – When an end of stream NAL unit is present, the bitstream is considered to end (for purposes of the scope of this \nRecommendation | International Standard). In some system environments, another bitstream may follow after the bitstream that has \nended, either immediately or at some time thereafter, possibly within the same communication channel. Under such circumstances, \nthe scope of this Recommendation | International Standard applies only to the processing of each of these individual bitstreams. No \n84  Rec. ITU-T H.264 (06/2019) \n \nrequirements are specified herein regarding the transition between such bitstreams (e.g., in regard to timing, buffering operation, \netc.). \n7.4.2.7  Filler data RBSP semantics \nThe filler data RBSP contains zero or more bytes. No normative decoding process is specified for a filler data RBSP. \nff_byte is a byte. It is a requirement of bitstream conformance that the value of ff_byte shall be equal to 0xFF. \n7.4.2.8  Slice layer without partitioning RBSP semantics \nThe slice layer without partitioning RBSP consists of a slice header and slice data. \n7.4.2.9  Slice data partition RBSP semantics \n7.4.2.9.1 Slice data partition A RBSP semantics \nWhen slice data partitioning is in use, the coded data for a single slice is divided into three separate partitions. Slice data \npartition A contains all syntax elements of category 2. \nCategory 2 syntax elements include all syntax elements in the slice header and slice data syntax structures other than the \nsyntax elements in the residual( ) syntax structure. \nslice_id identifies the slice associated with the slice data partition. The value of slice_id is constrained as follows: \n–  If separate_colour_plane_flag is equal to 0, the following applies: \n–  If arbitrary slice order is not allowed as specified in Annex A, the first slice of a coded picture, in decoding order, \nshall have slice_id equal to 0 and the value of slice_id shall be incremented by one for each subsequent slice of \nthe coded picture in decoding order. \n–  Otherwise (arbitrary slice order is allowed), each slice shall have a unique slice_id value within the set of slices \nof the coded picture. \n–  Otherwise (separate_colour_plane_flag is equal to 1), the following applies: \n–  If arbitrary slice order is not allowed as specified in Annex A, the first slice of a coded picture having each value \nof  colour_plane_id,  in  decoding  order,  shall  have  slice_id  equal  to 0  and  the  value  of  slice_id  shall  be \nincremented by one for each subsequent slice of the coded picture having the same value of colour_plane_id, in \ndecoding order. \n–  Otherwise (arbitrary slice order is allowed) each slice shall have a unique slice_id value within each set of slices \nof the coded picture that have the same value of colour_plane_id. \nThe range of slice_id is specified as follows: \n–  If MbaffFrameFlag is equal to 0, slice_id shall be in the range of 0 to PicSizeInMbs − 1, inclusive. \n–  Otherwise (MbaffFrameFlag is equal to 1), slice_id shall be in the range of 0 to PicSizeInMbs / 2 − 1, inclusive. \n7.4.2.9.2 Slice data partition B RBSP semantics \nWhen slice data partitioning is in use, the coded data for a single slice is divided into one to three separate partitions. Slice \ndata partition B contains all syntax elements of category 3. \nCategory 3 syntax elements include all syntax elements in the residual( ) syntax structure and in syntax structures used \nwithin that syntax structure for collective macroblock types I and SI as specified in Table 7-10. \nslice_id has the same semantics as specified in clause 7.4.2.9.1. \ncolour_plane_id specifies the colour plane associated with the current slice RBSP when separate_colour_plane_flag is \nequal to 1. The value of colour_plane_id shall be in the range of 0 to 2, inclusive. colour_plane_id equal to 0, 1, and 2 \ncorrespond to the Y, Cb, and Cr planes, respectively. \nNOTE – There is no dependency between the decoding processes of pictures having different values of colour_plane_id. \nredundant_pic_cnt shall be equal to 0 for coded slices and coded slice data partitions belonging to the primary coded \npicture. The redundant_pic_cnt shall be greater than 0 for coded slices and coded slice data partitions in redundant coded \npictures. When redundant_pic_cnt is not present, its value shall be inferred to be equal to 0. The value of redundant_pic_cnt \nshall be in the range of 0 to 127, inclusive. \nThe presence of a slice data partition B RBSP is specified as follows: \n    Rec. ITU-T H.264 (06/2019)  85 \n \n–  If the syntax elements of a slice data partition A RBSP indicate the presence of any syntax elements of category 3 in \nthe slice data for a slice, a slice data partition B RBSP shall be present having the same value of slice_id and \nredundant_pic_cnt as in the slice data partition A RBSP. \n–  Otherwise (the syntax elements of a slice data partition A RBSP do not indicate the presence of any syntax elements \nof category 3 in the slice data for a slice), no slice data partition B RBSP shall be present having the same value of \nslice_id and redundant_pic_cnt as in the slice data partition A RBSP. \n7.4.2.9.3 Slice data partition C RBSP semantics \nWhen slice data partitioning is in use, the coded data for a single slice is divided into three separate partitions. Slice data \npartition C contains all syntax elements of category 4. \nCategory 4 syntax elements include all syntax elements in the residual( ) syntax structure and in syntax structures used \nwithin that syntax structure for collective macroblock types P and B as specified in Table 7-10. \nslice_id has the same semantics as specified in clause 7.4.2.9.1. \ncolour_plane_id has the same semantics as specified in clause 7.4.2.9.2. \nredundant_pic_cnt has the same semantics as specified in clause 7.4.2.9.2. \nThe presence of a slice data partition C RBSP is specified as follows: \n–  If the syntax elements of a slice data partition A RBSP indicate the presence of any syntax elements of category 4 in \nthe slice data for a slice, a slice data partition C RBSP shall be present having the same value of slice_id and \nredundant_pic_cnt as in the slice data partition A RBSP. \n–  Otherwise (the syntax elements of a slice data partition A RBSP do not indicate the presence of any syntax elements \nof category 4 in the slice data for a slice), no slice data partition C RBSP shall be present having the same value of \nslice_id and redundant_pic_cnt as in the slice data partition A RBSP. \n7.4.2.10  RBSP slice trailing bits semantics \ncabac_zero_word is a byte-aligned sequence of two bytes equal to 0x0000. \nLet NumBytesInVclNALunits be the sum of the values of NumBytesInNALunit for all VCL NAL units of a coded picture. \nLet  BinCountsInNALunits  be  the  number  of  times  that  the  parsing  process  function  DecodeBin( ),  specified  in \nclause 9.3.3.2,  is  invoked  to  decode  the  contents  of  all  VCL  NAL  units  of  a  coded  picture.  When \nentropy_coding_mode_flag is equal to 1, it is a requirement of bitstream conformance that BinCountsInNALunits shall \nnot exceed ( 32 ÷ 3 ) * NumBytesInVclNALunits + ( RawMbBits * PicSizeInMbs ) ÷ 32. \nNOTE – The constraint on the maximum number of bins resulting from decoding the contents of the slice layer NAL units can be \nmet  by  inserting  a  number  of  cabac_zero_word  syntax  elements  to  increase  the  value  of  NumBytesInVclNALunits.  Each \ncabac_zero_word is represented in a NAL unit by the three-byte sequence 0x000003 (as a result of the constraints on NAL unit \ncontents that result in requiring inclusion of an emulation_prevention_three_byte for each cabac_zero_word). \n7.4.2.11  RBSP trailing bits semantics \nrbsp_stop_one_bit shall be equal to 1. \nrbsp_alignment_zero_bit shall be equal to 0. \n7.4.2.12  Prefix NAL unit RBSP semantics \nThe content of the prefix NAL unit RBSP is dependent on the value of svc_extension_flag. \n7.4.2.13  Slice layer extension RBSP semantics \nThe content of the slice layer extension RBSP is dependent on the value of svc_extension_flag. \nCoded slice extension NAL units with svc_extension_flag equal to 1 are also referred to as coded slice in scalable extension \nNAL units and coded slice extension NAL units with svc_extension_flag equal to 0 are also referred to as coded slice \nMVC extension NAL units. \n7.4.3  Slice header semantics \nWhen  present,  the  value  of  the  slice  header  syntax  elements  pic_parameter_set_id,  frame_num,  field_pic_flag, \nbottom_field_flag,  idr_pic_id,  pic_order_cnt_lsb,  delta_pic_order_cnt_bottom,  delta_pic_order_cnt[ 0 ], \ndelta_pic_order_cnt[ 1 ], sp_for_switch_flag, and slice_group_change_cycle shall be the same in all slice headers of a \ncoded picture. \n86  Rec. ITU-T H.264 (06/2019) \n \nfirst_mb_in_slice specifies the address of the first macroblock in the slice. When arbitrary slice order is not allowed as \nspecified in Annex A, the value of first_mb_in_slice is constrained as follows: \n–  If  separate_colour_plane_flag  is  equal  to  0,  the  value  of  first_mb_in_slice  shall  not  be  less  than  the  value  of \nfirst_mb_in_slice for any other slice of the current picture that precedes the current slice in decoding order. \n–  Otherwise (separate_colour_plane_flag is equal to 1), the value of first_mb_in_slice shall not be less than the value \nof first_mb_in_slice for any other slice of the current picture that precedes the current slice in decoding order and has \nthe same value of colour_plane_id. \nThe first macroblock address of the slice is derived as follows: \n–  If MbaffFrameFlag is equal to 0, first_mb_in_slice is the macroblock address of the first macroblock in the slice, and \nfirst_mb_in_slice shall be in the range of 0 to PicSizeInMbs − 1, inclusive. \n–  Otherwise (MbaffFrameFlag is equal to 1), first_mb_in_slice * 2 is the macroblock address of the first macroblock in \nthe slice, which is the top macroblock of the first macroblock pair in the slice, and first_mb_in_slice shall be in the \nrange of 0 to PicSizeInMbs / 2 − 1, inclusive. \nslice_type specifies the coding type of the slice according to Table 7-6. \nTable 7-6 – Name association to slice_type \nslice_type  Name of slice_type \n0  P (P slice) \n1  B (B slice) \n2  I (I slice) \n3  SP (SP slice) \n4  SI (SI slice) \n5  P (P slice) \n6  B (B slice) \n7  I (I slice) \n8  SP (SP slice) \n9  SI (SI slice) \n \nWhen slice_type has a value in the range 5..9, it is a requirement of bitstream conformance that all other slices of the \ncurrent coded picture shall have a value of slice_type equal to the current value of slice_type or equal to the current value \nof slice_type minus 5. \nNOTE 1 – Values of slice_type in the range 5..9 can be used by an encoder to indicate that all slices of a picture have the same value \nof (slice_type % 5). Values of slice_type in the range 5..9 are otherwise equivalent to corresponding values in the range 0..4. \nWhen nal_unit_type is equal to 5 (IDR picture), slice_type shall be equal to 2, 4, 7, or 9. \nWhen max_num_ref_frames is equal to 0, slice_type shall be equal to 2, 4, 7, or 9. \npic_parameter_set_id specifies the picture parameter set in use. The value of pic_parameter_set_id shall be in the range \nof 0 to 255, inclusive. \ncolour_plane_id specifies the colour plane associated with the current slice RBSP when separate_colour_plane_flag is \nequal to 1. The value of colour_plane_id shall be in the range of 0 to 2, inclusive. colour_plane_id equal to 0, 1, and 2 \ncorrespond to the Y, Cb, and Cr planes, respectively. \nNOTE 2 – There is no dependency between the decoding processes of pictures having different values of colour_plane_id. \nframe_num is used as an identifier for pictures and shall be represented by log2_max_frame_num_minus4 + 4 bits in the \nbitstream. frame_num is constrained as follows: \nThe variable PrevRefFrameNum is derived as follows: \n–  If the current picture is an IDR picture, PrevRefFrameNum is set equal to 0. \n–  Otherwise (the current picture is not an IDR picture), PrevRefFrameNum is set as follows: \n–  If the decoding process for gaps in frame_num specified in clause 8.2.5.2 was invoked by the decoding process \nfor an access unit that contained a non-reference picture that followed the previous access unit in decoding order \nthat contained a reference picture, PrevRefFrameNum is set equal to the value of frame_num for the last of the \n    Rec. ITU-T H.264 (06/2019)  87 \n \n\"non-existing\"  reference  frames  inferred  by  the  decoding  process  for  gaps  in  frame_num  specified  in \nclause 8.2.5.2. \n–  Otherwise, PrevRefFrameNum is set equal to the value of frame_num for the previous access unit in decoding \norder that contained a reference picture. \nThe value of frame_num is constrained as follows: \n–  If the current picture is an IDR picture, frame_num shall be equal to 0. \n–  Otherwise (the current picture is not an IDR picture), referring to the primary coded picture in the previous access \nunit in decoding order that contains a reference picture as the preceding reference picture, the value of frame_num \nfor the current picture shall not be equal to PrevRefFrameNum unless all of the following three conditions are true: \na)  The current picture and the preceding reference picture belong to consecutive access units in decoding order. \nb)  The current picture and the preceding reference picture are reference fields having opposite parity. \nc)  One or more of the following conditions is true: \n–  The preceding reference picture is an IDR picture, \n–  The preceding reference picture includes a memory_management_control_operation syntax element equal \nto 5, \nNOTE 3  –  When  the  preceding  reference  picture  includes  a  memory_management_control_operation  syntax \nelement equal to 5, PrevRefFrameNum is equal to 0. \n–  There is a primary coded picture that precedes the preceding reference picture and the primary coded picture \nthat precedes the preceding reference picture does not have frame_num equal to PrevRefFrameNum, \n–  There is a primary coded picture that precedes the preceding reference picture and the primary coded picture \nthat precedes the preceding reference picture is not a reference picture. \nWhen the value of frame_num is not equal to PrevRefFrameNum, it is a requirement of bitstream conformance that the \nfollowing constraints shall be obeyed: \na)  There shall not be any previous field or frame in decoding order that is currently marked as \"used for short-term \nreference\"  that  has  a  value  of  frame_num  equal  to  any  value  taken  on  by  the  variable \nUnusedShortTermFrameNum in the following: \nUnusedShortTermFrameNum = ( PrevRefFrameNum + 1 ) % MaxFrameNum \nwhile( UnusedShortTermFrameNum  !=  frame_num )   (7-24) \n  UnusedShortTermFrameNum = ( UnusedShortTermFrameNum + 1 ) % MaxFrameNum \nb)  The value of frame_num is constrained as follows: \n–  If gaps_in_frame_num_value_allowed_flag is equal to 0, the value of frame_num for the current picture \nshall be equal to ( PrevRefFrameNum + 1 ) % MaxFrameNum. \n–  Otherwise (gaps_in_frame_num_value_allowed_flag is equal to 1), the following applies: \n–  If frame_num is greater than PrevRefFrameNum, there shall not be any non-reference pictures in the \nbitstream that follow the previous reference picture and precede the current picture in decoding order \nin which either of the following conditions is true: \n–  The value of frame_num for the non-reference picture is less than PrevRefFrameNum, \n–  The value of frame_num for the non-reference picture is greater than the value of frame_num for \nthe current picture. \n–  Otherwise (frame_num is less than PrevRefFrameNum), there shall not be any non-reference pictures \nin the bitstream that follow the previous reference picture and precede the current picture in decoding \norder in which both of the following conditions are true: \n–  The value of frame_num for the non-reference picture is less than PrevRefFrameNum, \n–  The value of frame_num for the non-reference picture is greater than the value of frame_num for \nthe current picture. \nA picture including a memory_management_control_operation equal to 5 shall have frame_num constraints as described \nabove and, after the decoding of the current picture and the processing of the memory management control operations, the \npicture shall be inferred to have had frame_num equal to 0 for all subsequent use in the decoding process, except as \nspecified in clause 7.4.1.2.4. \nNOTE 4 – When the primary coded picture is not an IDR picture and does not contain memory_management_control_operation \nsyntax element equal to 5, the value of frame_num of a corresponding redundant coded picture is the same as the value of frame_num \n88  Rec. ITU-T H.264 (06/2019) \n \nin the primary coded picture. Alternatively, the redundant coded picture includes a memory_management_control_operation syntax \nelement equal to 5 and the corresponding primary coded picture is an IDR picture. \nfield_pic_flag equal to 1 specifies that the slice is a slice of a coded field. field_pic_flag equal to 0 specifies that the slice \nis a slice of a coded frame. When field_pic_flag is not present it shall be inferred to be equal to 0. \nThe variable MbaffFrameFlag is derived as \nMbaffFrameFlag = ( mb_adaptive_frame_field_flag  &&  !field_pic_flag )  (7-25) \nThe variable for the picture height in units of macroblocks is derived as \nPicHeightInMbs = FrameHeightInMbs / ( 1 + field_pic_flag )  (7-26) \nThe variable for picture height for the luma component is derived as \nPicHeightInSamples  = PicHeightInMbs * 16    (7-27) \nL\nThe variable for picture height for the chroma component is derived as \nPicHeightInSamples  = PicHeightInMbs * MbHeightC  (7-28) \nC\nThe variable PicSizeInMbs for the current picture is derived as \nPicSizeInMbs = PicWidthInMbs * PicHeightInMbs    (7-29) \nThe variable MaxPicNum is derived as follows: \n–  If field_pic_flag is equal to 0, MaxPicNum is set equal to MaxFrameNum. \n–  Otherwise (field_pic_flag is equal to 1), MaxPicNum is set equal to 2*MaxFrameNum. \nThe variable CurrPicNum is derived as follows: \n–  If field_pic_flag is equal to 0, CurrPicNum is set equal to frame_num. \n–  Otherwise (field_pic_flag is equal to 1), CurrPicNum is set equal to 2 * frame_num + 1. \nbottom_field_flag equal to 1 specifies that the slice is part of a coded bottom field. bottom_field_flag equal to 0 specifies \nthat the picture is a coded top field. When this syntax element is not present for the current slice, it shall be inferred to be \nequal to 0. \nidr_pic_id identifies an IDR picture. The values of idr_pic_id in all the slices of an IDR picture shall remain unchanged. \nWhen two consecutive access units in decoding order are both IDR access units, the value of idr_pic_id in the slices of the \nfirst such IDR access unit shall differ from the idr_pic_id in the second such IDR access unit. The value of idr_pic_id shall \nbe in the range of 0 to 65535, inclusive. \nNOTE 5 – It is not prohibited for multiple IDR pictures in a bitstream to have the same value of idr_pic_id unless such pictures \noccur in two consecutive access units in decoding order. \npic_order_cnt_lsb specifies the picture order count modulo MaxPicOrderCntLsb for the top field of a coded frame or for \na coded field. The length of the pic_order_cnt_lsb syntax element is log2_max_pic_order_cnt_lsb_minus4 + 4 bits. The \nvalue of the pic_order_cnt_lsb shall be in the range of 0 to MaxPicOrderCntLsb − 1, inclusive. \ndelta_pic_order_cnt_bottom specifies the picture order count difference between the bottom field and the top field of a \ncoded frame as follows: \n–  If  the  current  picture  includes  a  memory_management_control_operation  equal  to  5,  the  value  of \ndelta_pic_order_cnt_bottom shall be in the range of ( 1 − MaxPicOrderCntLsb ) to 231 − 1, inclusive. \n–  Otherwise (the current picture does not include a memory_management_control_operation equal to 5), the value of \ndelta_pic_order_cnt_bottom shall be in the range of −231 + 1 to 231 − 1, inclusive. \nWhen this syntax element is not present in the bitstream for the current slice, it shall be inferred to be equal to 0. \ndelta_pic_order_cnt[ 0 ] specifies the picture order count difference from the expected picture order count for the top \nfield of a coded frame or for a coded field as specified in clause 8.2.1. The value of delta_pic_order_cnt[ 0 ] shall be in the \nrange of −231 + 1 to 231 − 1, inclusive. When this syntax element is not present in the bitstream for the current slice, it shall \nbe inferred to be equal to 0. \ndelta_pic_order_cnt[ 1 ] specifies the picture order count difference from the expected picture order count for the bottom \nfield of a coded frame specified in clause 8.2.1. The value of delta_pic_order_cnt[ 1 ] shall be in the range of −231 + 1 \n    Rec. ITU-T H.264 (06/2019)  89 \n \nto 231 − 1, inclusive. When this syntax element is not present in the bitstream for the current slice, it shall be inferred to be \nequal to 0. \nredundant_pic_cnt shall be equal to 0 for slices and slice data partitions belonging to the primary coded picture. The \nvalue of redundant_pic_cnt shall be greater than 0 for coded slices or coded slice data partitions of a redundant coded \npicture. When redundant_pic_cnt is not present in the bitstream, its value shall be inferred to be equal to 0. The value of \nredundant_pic_cnt shall be in the range of 0 to 127, inclusive. \nNOTE 6 – Any area of the decoded primary picture and the corresponding area that would result from application of the decoding \nprocess specified in clause 8 for any redundant picture in the same access unit should be visually similar in appearance. \nThe value of pic_parameter_set_id in a coded slice or coded slice data partition of a redundant coded picture shall be such \nthat the value of bottom_field_pic_order_in_frame_present_flag in the picture parameter set in use in a redundant coded \npicture is equal to the value of bottom_field_pic_order_in_frame_present_flag in the picture parameter set in use in the \ncorresponding primary coded picture. \nWhen present in the primary coded picture and any redundant coded picture, the following syntax elements shall have the \nsame value: field_pic_flag, bottom_field_flag, and idr_pic_id. \nWhen the value of nal_ref_idc in one VCL NAL unit of an access unit is equal to 0, the value of nal_ref_idc in all other \nVCL NAL units of the same access unit shall be equal to 0. \nNOTE 7 – The above constraint also has the following implications. If the value of nal_ref_idc for the VCL NAL units of the primary \ncoded picture is equal to 0, the value of nal_ref_idc for the VCL NAL units of any corresponding redundant coded picture are equal \nto 0; otherwise (the value of nal_ref_idc for the VCL NAL units of the primary coded picture is greater than 0), the value of \nnal_ref_idc for the VCL NAL units of any corresponding redundant coded picture are also greater than 0. \nThe marking status of reference pictures and the value of frame_num after the decoded reference picture marking process \nas specified in clause 8.2.5 is invoked for the primary coded picture or any redundant coded picture of the same access unit \nshall be identical regardless whether the primary coded picture or any redundant coded picture (instead of the primary \ncoded picture) of the access unit would be decoded. \nNOTE 8 – The above constraint also has the following implications. \nWhen the primary coded picture is an IDR picture and a redundant coded picture corresponding to the primary coded picture is an \nIDR picture, the contents of the dec_ref_pic_marking( ) syntax structure must be identical in all slice headers of the primary coded \npicture and the redundant coded picture corresponding to the primary coded picture. \nWhen the primary coded picture is an IDR picture and a redundant coded picture corresponding to the primary coded picture is not \nan IDR picture, all slice headers of the redundant picture must contain a dec_ref_pic_marking syntax( ) structure including a \nmemory_management_control_operation syntax element equal to 5, and the following applies: \n–  If the value of long_term_reference_flag in the primary coded picture is equal to 0, the dec_ref_pic_marking syntax structure \nof the redundant coded picture must not include a memory_management_control_operation syntax element equal to 6. \n–  Otherwise (the value of long_term_reference_flag in the primary coded picture is equal to 1), the dec_ref_pic_marking syntax \nstructure of the redundant coded picture must include memory_management_control_operation syntax elements equal to 5, 4, \nand  6  in  decoding  order,  and  the  value  of  max_long_term_frame_idx_plus1  must  be  equal  to 1,  and  the  value  of \nlong_term_frame_idx must be equal to 0. \nThe values of TopFieldOrderCnt and BottomFieldOrderCnt (if applicable) that result after completion of the decoding \nprocess for any redundant coded picture or the primary coded picture of the same access unit shall be identical regardless \nwhether the primary coded picture or any redundant coded picture (instead of the primary coded picture) of the access unit \nwould be decoded. \nThere is no required decoding process for a coded slice or coded slice data partition of a redundant coded picture. When \nthe redundant_pic_cnt in the slice header of a coded slice is greater than 0, the decoder may discard the coded slice. \nHowever, a coded slice or coded slice data partition of any redundant coded picture shall obey the same constraints as a \ncoded slice or coded slice data partition of a primary picture. \nNOTE 9 – When some of the samples in the decoded primary picture cannot be correctly decoded due to errors or losses in \ntransmission of the sequence and one or more coded slices of a redundant coded picture can be correctly decoded, the decoder should \nreplace the samples of the decoded primary picture with the corresponding samples of the decoded slice or decoded slices of the \nredundant coded picture. When slices of more than one redundant coded picture cover the relevant region of the primary coded \npicture, the slice or slices of the redundant coded picture having the lowest value of redundant_pic_cnt should be used. \nSlices and slice data partitions having the same value of redundant_pic_cnt belong to the same coded picture. If the value \nof redundant_pic_cnt is equal to 0, they belong to the primary coded picture; otherwise (the value of redundant_pic_cnt is \ngreater than 0), they belong to the same redundant coded picture. Decoded slices within the same redundant coded picture \nneed not cover the entire picture area and shall not overlap. \ndirect_spatial_mv_pred_flag specifies the method used in the decoding process to derive motion vectors and reference \nindices for inter prediction as follows: \n90  Rec. ITU-T H.264 (06/2019) \n \n–  If  direct_spatial_mv_pred_flag  is  equal  to 1,  the  derivation  process  for  luma  motion  vectors  for  B_Skip, \nB_Direct_16x16,  and  B_Direct_8x8  in  clause 8.4.1.2  shall  use  spatial  direct  mode  prediction  as  specified  in \nclause 8.4.1.2.2. \n–  Otherwise (direct_spatial_mv_pred_flag is equal to 0), the derivation process for luma motion vectors for B_Skip, \nB_Direct_16x16,  and  B_Direct_8x8  in  clause 8.4.1.2  shall  use  temporal  direct  mode  prediction  as  specified  in \nclause 8.4.1.2.3. \nnum_ref_idx_active_override_flag equal to 1 specifies that the syntax element num_ref_idx_l0_active_minus1 is present \nfor  P,  SP,  and  B  slices  and  that  the  syntax  element  num_ref_idx_l1_active_minus1  is  present  for  B  slices. \nnum_ref_idx_active_override_flag  equal  to 0  specifies  that  the  syntax  elements  num_ref_idx_l0_active_minus1  and \nnum_ref_idx_l1_active_minus1 are not present. \nWhen  the  current  slice  is  a  P,  SP,  or  B  slice  and  field_pic_flag  is  equal  to 0  and  the  value  of \nnum_ref_idx_l0_default_active_minus1 in the picture parameter set exceeds 15, num_ref_idx_active_override_flag shall \nbe equal to 1. \nWhen the current slice is a B slice and field_pic_flag is equal to 0 and the value of num_ref_idx_l1_default_active_minus1 \nin the picture parameter set exceeds 15, num_ref_idx_active_override_flag shall be equal to 1. \nnum_ref_idx_l0_active_minus1 specifies the maximum reference index for reference picture list 0 that shall be used to \ndecode the slice. \nWhen  the  current  slice  is  a  P,  SP,  or  B  slice  and  num_ref_idx_l0_active_minus1  is  not  present, \nnum_ref_idx_l0_active_minus1 shall be inferred to be equal to num_ref_idx_l0_default_active_minus1. \nThe range of num_ref_idx_l0_active_minus1 is specified as follows: \n–  If field_pic_flag is equal to 0, num_ref_idx_l0_active_minus1 shall be in the range of 0 to 15, inclusive. When \nMbaffFrameFlag is equal to 1, num_ref_idx_l0_active_minus1 is the maximum index value for the decoding of frame \nmacroblocks  and  2 * num_ref_idx_l0_active_minus1 + 1  is  the  maximum  index  value  for  the  decoding  of  field \nmacroblocks. \n–  Otherwise (field_pic_flag is equal to 1), num_ref_idx_l0_active_minus1 shall be in the range of 0 to 31, inclusive. \nnum_ref_idx_l1_active_minus1 specifies the maximum reference index for reference picture list 1 that shall be used to \ndecode the slice. \nWhen the current slice is a B slice and num_ref_idx_l1_active_minus1 is not present, num_ref_idx_l1_active_minus1 shall \nbe inferred to be equal to num_ref_idx_l1_default_active_minus1. \nThe  range  of  num_ref_idx_l1_active_minus1  is  constrained  as  specified  in  the  semantics  for \nnum_ref_idx_l0_active_minus1 with l0 and list 0 replaced by l1 and list 1, respectively. \ncabac_init_idc specifies the index for determining the initialization table used in the initialization process for context \nvariables. The value of cabac_init_idc shall be in the range of 0 to 2, inclusive. \nslice_qp_delta specifies the initial value of QP  to be used for all the macroblocks in the slice until modified by the value \nY\nof mb_qp_delta in the macroblock layer. The initial QP  quantization parameter for the slice is computed as \nY\nSliceQP  = 26 + pic_init_qp_minus26 + slice_qp_delta  (7-30) \nY\nThe value of slice_qp_delta shall be limited such that SliceQP  is in the range of −QpBdOffset  to +51, inclusive. \nY Y\nsp_for_switch_flag specifies the decoding process to be used to decode P macroblocks in an SP slice as follows: \n–  If sp_for_switch_flag is equal to 0, the P macroblocks in the SP slice shall be decoded using the SP decoding process \nfor non-switching pictures as specified in clause 8.6.1. \n–  Otherwise (sp_for_switch_flag is equal to 1), the P macroblocks in the SP slice shall be decoded using the SP and SI \ndecoding process for switching pictures as specified in clause 8.6.2. \nslice_qs_delta specifies the value of QS  for all the macroblocks in SP and SI slices. The QS  quantization parameter for \nY Y\nthe slice is computed as \nQS  = 26 + pic_init_qs_minus26 + slice_qs_delta    (7-31) \nY\nThe value of slice_qs_delta shall be limited such that QS  is in the range of 0 to 51, inclusive. This value of QS  is used \nY Y\nfor the decoding of all macroblocks in SI slices with mb_type equal to SI and all macroblocks in SP slices that are coded \nin an Inter macroblock prediction mode. \n    Rec. ITU-T H.264 (06/2019)  91 \n \ndisable_deblocking_filter_idc specifies whether the operation of the deblocking filter shall be disabled across some block \nedges of the slice and specifies for which edges the filtering is disabled. When disable_deblocking_filter_idc is not present \nin the slice header, the value of disable_deblocking_filter_idc shall be inferred to be equal to 0. \nThe value of disable_deblocking_filter_idc shall be in the range of 0 to 2, inclusive. \nslice_alpha_c0_offset_div2 specifies the offset used in accessing the α and t  deblocking filter tables for filtering \nC0\noperations controlled by the macroblocks within the slice. From this value, the offset that shall be applied when addressing \nthese tables shall be computed as \nFilterOffsetA = slice_alpha_c0_offset_div2 << 1    (7-32) \nThe value of slice_alpha_c0_offset_div2 shall be in the range of −6 to +6, inclusive. When slice_alpha_c0_offset_div2 is \nnot present in the slice header, the value of slice_alpha_c0_offset_div2 shall be inferred to be equal to 0. \nslice_beta_offset_div2 specifies the offset used in accessing the β deblocking filter table for filtering operations controlled \nby the macroblocks within the slice. From this value, the offset that is applied when addressing the β table of the deblocking \nfilter shall be computed as \nFilterOffsetB = slice_beta_offset_div2 << 1    (7-33) \nThe value of slice_beta_offset_div2 shall be in the range of −6 to +6, inclusive. When slice_beta_offset_div2 is not present \nin the slice header the value of slice_beta_offset_div2 shall be inferred to be equal to 0. \nslice_group_change_cycle  is  used  to  derive  the  number  of  slice  group  map  units  in  slice  group  0  when \nslice_group_map_type is equal to 3, 4, or 5, as specified by \nMapUnitsInSliceGroup0 = Min( slice_group_change_cycle * SliceGroupChangeRate, \n                                                     PicSizeInMapUnits )   (7-34) \nThe value of slice_group_change_cycle is represented in the bitstream by the following number of bits \nCeil( Log2( PicSizeInMapUnits ÷ SliceGroupChangeRate + 1 ) )  (7-35) \nThe value of slice_group_change_cycle shall be in the range of 0 to Ceil( PicSizeInMapUnits÷SliceGroupChangeRate ), \ninclusive. \n7.4.3.1  Reference picture list modification semantics \nThe syntax elements  modification_of_pic_nums_idc, abs_diff_pic_num_minus1, and long_term_pic_num specify  the \nchange from the initial reference picture lists to the reference picture lists to be used for decoding the slice. \nref_pic_list_modification_flag_l0 equal to 1 specifies that the syntax element modification_of_pic_nums_idc is present \nfor specifying reference picture list 0. ref_pic_list_modification_flag_l0 equal to 0 specifies that this syntax element is not \npresent. \nWhen ref_pic_list_modification_flag_l0 is equal to 1, the number of times that modification_of_pic_nums_idc is not equal \nto 3 following ref_pic_list_modification_flag_l0 shall not exceed num_ref_idx_l0_active_minus1 + 1. \nWhen  RefPicList0[ num_ref_idx_l0_active_minus1 ]  in  the  initial  reference  picture  list  produced  as  specified  in \nclause 8.2.4.2  is  equal  to  \"no  reference  picture\",  ref_pic_list_modification_flag_l0  shall  be  equal  to 1  and \nmodification_of_pic_nums_idc shall not be equal to 3 until RefPicList0[ num_ref_idx_l0_active_minus1 ] in the modified \nlist produced as specified in clause 8.2.4.3 is not equal to \"no reference picture\". \nref_pic_list_modification_flag_l1 equal to 1 specifies that the syntax element modification_of_pic_nums_idc is present \nfor specifying reference picture list 1. ref_pic_list_modification_flag_l1 equal to 0 specifies that this syntax element is not \npresent. \nWhen ref_pic_list_modification_flag_l1 is equal to 1, the number of times that modification_of_pic_nums_idc is not equal \nto 3 following ref_pic_list_modification_flag_l1 shall not exceed num_ref_idx_l1_active_minus1 + 1. \nWhen decoding a slice with slice_type equal to 1 or 6 and RefPicList1[ num_ref_idx_l1_active_minus1 ] in the initial \nreference  picture  list  produced  as  specified  in  clause 8.2.4.2  is  equal  to  \"no  reference  picture\", \nref_pic_list_modification_flag_l1 shall be equal to 1 and modification_of_pic_nums_idc shall not be equal to 3 until \nRefPicList1[ num_ref_idx_l1_active_minus1 ] in the modified list produced as specified in clause 8.2.4.3 is not equal to \n\"no reference picture\". \nmodification_of_pic_nums_idc together with abs_diff_pic_num_minus1 or long_term_pic_num specifies which of the \nreference pictures are re-mapped. The values of modification_of_pic_nums_idc are specified in Table 7-7. The value of \n92  Rec. ITU-T H.264 (06/2019) \n \nthe  first  modification_of_pic_nums_idc  that  follows  immediately  after  ref_pic_list_modification_flag_l0  or \nref_pic_list_modification_flag_l1 shall not be equal to 3. \nTable 7-7 – modification_of_pic_nums_idc operations for modification of reference picture lists \n \nmodification_of_pic_nums_idc  modification specified \n0  abs_diff_pic_num_minus1 is present and corresponds to a difference to \nsubtract from a picture number prediction value \n1  abs_diff_pic_num_minus1 is present and corresponds to a difference to add \nto a picture number prediction value \n2  long_term_pic_num is present and specifies the long-term picture number \nfor a reference picture \n3  End loop for modification of the initial reference picture list \nabs_diff_pic_num_minus1 plus 1 specifies the absolute difference between the picture number of the picture being moved \nto the current index in the list and the picture number prediction value. abs_diff_pic_num_minus1 shall be in the range of \n0  to  MaxPicNum  −  1.  The  allowed  values  of  abs_diff_pic_num_minus1  are  further  restricted  as  specified  in \nclause 8.2.4.3.1. \nlong_term_pic_num specifies the long-term picture number of the picture being moved to the current index in the list. \nWhen decoding a coded frame, long_term_pic_num shall be equal to a LongTermPicNum assigned to one of the reference \nframes or complementary reference field pairs marked as \"used for long-term reference\". When decoding a coded field, \nlong_term_pic_num shall be equal to a LongTermPicNum assigned to one of the reference fields marked as \"used for long-\nterm reference\". \n7.4.3.2  Prediction weight table semantics \nluma_log2_weight_denom is the base 2 logarithm of the denominator for all luma weighting factors. The value of \nluma_log2_weight_denom shall be in the range of 0 to 7, inclusive. \nchroma_log2_weight_denom is the base 2 logarithm of the denominator for all chroma weighting factors. The value of \nchroma_log2_weight_denom shall be in the range of 0 to 7, inclusive. \nluma_weight_l0_flag equal to 1 specifies that weighting factors for the luma component of list 0 prediction are present. \nluma_weight_l0_flag equal to 0 specifies that these weighting factors are not present. \nluma_weight_l0[ i ] is the weighting factor applied to the luma prediction value for list 0 prediction using RefPicList0[ i ]. \nWhen luma_weight_l0_flag is equal to 1, the value of luma_weight_l0[ i ] shall be in the range of −128 to 127, inclusive. \nWhen luma_weight_l0_flag is equal to 0, luma_weight_l0[ i ] shall be inferred to be equal to 2luma_log2_weight_denom for \nRefPicList0[ i ]. \nluma_offset_l0[ i ] is the additive offset applied to the luma prediction value for list 0 prediction using RefPicList0[ i ]. \nThe value of luma_offset_l0[ i ] shall be in the range of −128 to 127, inclusive. When luma_weight_l0_flag is equal to 0, \nluma_offset_l0[ i ] shall be inferred as equal to 0 for RefPicList0[ i ]. \nchroma_weight_l0_flag equal to 1 specifies that weighting factors for the chroma prediction values of list 0 prediction \nare present. chroma_weight_l0_flag equal to 0 specifies that these weighting factors are not present. \nchroma_weight_l0[ i ][ j ] is the weighting factor applied to the chroma prediction values for list 0 prediction using \nRefPicList0[ i ] with j equal to 0 for Cb and j equal to 1 for Cr. When chroma_weight_l0_flag is equal to 1, the value of \nchroma_weight_l0[ i ][ j ] shall be in the range of −128 to 127, inclusive. When chroma_weight_l0_flag is equal to 0, \nchroma_weight_l0[ i ][ j ] shall be inferred to be equal to 2chroma_log2_weight_denom for RefPicList0[ i ]. \nchroma_offset_l0[ i ][ j ]  is  the  additive  offset  applied  to  the  chroma  prediction  values  for  list  0  prediction  using \nRefPicList0[ i ] with j equal to 0 for Cb and j equal to 1 for Cr. The value of chroma_offset_l0[ i ][ j ] shall be in the range \nof −128 to 127, inclusive. When chroma_weight_l0_flag is equal to 0, chroma_offset_l0[ i ][ j ] shall be inferred to be \nequal to 0 for RefPicList0[ i ]. \nluma_weight_l1_flag,  luma_weight_l1,  luma_offset_l1,  chroma_weight_l1_flag,  chroma_weight_l1, \nchroma_offset_l1  have  the  same  semantics  as  luma_weight_l0_flag,  luma_weight_l0,  luma_offset_l0, \nchroma_weight_l0_flag, chroma_weight_l0, chroma_offset_l0, respectively, with l0, list 0, and List0 replaced by l1, list 1, \nand List1, respectively. \n    Rec. ITU-T H.264 (06/2019)  93 \n \n7.4.3.3  Decoded reference picture marking semantics \nThe  syntax  elements  no_output_of_prior_pics_flag,  long_term_reference_flag,  adaptive_ref_pic_marking_mode_flag, \nmemory_management_control_operation, difference_of_pic_nums_minus1, long_term_frame_idx, long_term_pic_num, \nand max_long_term_frame_idx_plus1 specify marking of the reference pictures. \nThe marking of a reference picture can be \"unused for reference\", \"used for short-term reference\", or \"used for long-term \nreference\", but only one among these three. When a reference picture is referred to as being marked as \"used for reference\", \nthis collectively refers to the picture being marked as \"used for short-term reference\" or \"used for long-term reference\" \n(but not both). A reference picture that is marked as \"used for short-term reference\" is referred to as a short-term reference \npicture. A reference picture that is marked as \"used for long-term reference\" is referred to as a long-term reference picture. \nThe content of the decoded reference picture marking syntax structure shall be the same in all slice headers of the primary \ncoded picture. When one or more redundant coded pictures are present, the content of the decoded reference picture \nmarking syntax structure shall be the same in all slice headers of a redundant coded picture with a particular value of \nredundant_pic_cnt. \nNOTE 1 – It is not required that the content of the decoded reference picture marking syntax structure in a redundant coded picture \nwith a particular value of redundant_pic_cnt is identical to the content of the decoded reference picture marking syntax structure in \nthe corresponding primary coded picture or a redundant coded picture with a different value of redundant_pic_cnt. However, as \nspecified in clause 7.4.3, the content of the decoded reference picture marking syntax structure in a redundant coded picture is \nconstrained in the way that the marking status of reference pictures and the value of frame_num after the decoded reference picture \nmarking process in clause 8.2.5 must be identical regardless whether the primary coded picture or any redundant coded picture of \nthe access unit would be decoded. \nThe syntax category of the decoded reference picture marking syntax structure shall be inferred as follows: \n–  If the decoded reference picture marking syntax structure is in a slice header, the syntax category of the decoded \nreference picture marking syntax structure is inferred to be equal to 2. \n–  Otherwise (the decoded reference picture marking syntax structure is in a decoded reference picture marking repetition \nSEI message as specified in Annex D), the syntax category of the decoded reference picture marking syntax structure \nis inferred to be equal to 5. \nno_output_of_prior_pics_flag specifies how the previously-decoded pictures in the decoded picture buffer are treated \nafter decoding of an IDR picture. See Annex C. When the IDR picture is the first IDR picture in the bitstream, the value \nof no_output_of_prior_pics_flag has no effect on the decoding process. When the IDR picture is not the first IDR picture \nin the bitstream and the value of PicWidthInMbs, FrameHeightInMbs, or max_dec_frame_buffering derived from the \nactive  sequence  parameter  set  is  different  from  the  value  of  PicWidthInMbs,  FrameHeightInMbs,  or \nmax_dec_frame_buffering  derived  from  the  sequence  parameter  set  active  for  the  preceding  picture, \nno_output_of_prior_pics_flag equal to 1 may (but should not) be inferred by the decoder, regardless of the actual value of \nno_output_of_prior_pics_flag. \nlong_term_reference_flag equal to 0 specifies that the MaxLongTermFrameIdx variable is set equal to \"no long-term \nframe indices\" and that the IDR picture is marked as \"used for short-term reference\". long_term_reference_flag equal to 1 \nspecifies that the MaxLongTermFrameIdx variable is set equal to 0 and that the current IDR picture is marked \"used for \nlong-term  reference\"  and  is  assigned  LongTermFrameIdx  equal  to 0.  When  max_num_ref_frames  is  equal  to 0, \nlong_term_reference_flag shall be equal to 0. \nadaptive_ref_pic_marking_mode_flag selects the reference picture marking mode of the currently decoded picture as \nspecified  in  Table 7-8.  adaptive_ref_pic_marking_mode_flag  shall  be  equal  to  1  when  the  number  of  frames, \ncomplementary field pairs, and non-paired fields that are currently marked as \"used for long-term reference\" is equal to \nMax( max_num_ref_frames, 1 ). \nTable 7-8 – Interpretation of adaptive_ref_pic_marking_mode_flag \nadaptive_ref_pic_marking_mode_flag  Reference picture marking mode specified \n0  Sliding window reference picture marking mode: A marking mode \nproviding  a  first-in  first-out  mechanism  for  short-term  reference \npictures. \n1  Adaptive  reference  picture  marking  mode:  A  reference  picture \nmarking  mode  providing  syntax  elements  to  specify  marking  of \nreference pictures as \"unused for reference\" and to assign long-term \nframe indices. \n \n94  Rec. ITU-T H.264 (06/2019) \n \nmemory_management_control_operation specifies a control operation to be applied to affect the reference picture \nmarking. The memory_management_control_operation syntax element is followed by data necessary for the operation \nspecified by the value of memory_management_control_operation. The values and control operations associated with \nmemory_management_control_operation are specified in Table 7-9. The memory_management_control_operation syntax \nelements are processed by the decoding process in the order in which they appear in the slice header, and the semantics \nconstraints expressed for each memory_management_control_operation apply at the specific position in that order at which \nthat individual memory_management_control_operation is processed. \nFor interpretation of memory_management_control_operation, the term reference picture is interpreted as follows: \n–  If the current picture is a frame, the term reference picture refers either to a reference frame or a complementary \nreference field pair. \n–  Otherwise (the current picture is a field), the term reference picture refers either to a reference field or a field of a \nreference frame. \nmemory_management_control_operation shall not be equal to 1 in a slice header unless the specified reference picture is \nmarked as \"used for short-term reference\" when the memory_management_control_operation is processed by the decoding \nprocess. \nmemory_management_control_operation shall not be equal to 2 in a slice header unless the specified long-term picture \nnumber  refers  to  a  reference  picture  that  is  marked  as  \"used  for  long-term  reference\"  when  the \nmemory_management_control_operation is processed by the decoding process. \nmemory_management_control_operation shall not be equal to 3 in a slice header unless the specified reference picture is \nmarked as \"used for short-term reference\" when the memory_management_control_operation is processed by the decoding \nprocess. \nmemory_management_control_operation shall not be equal to 3 or 6 if the value of the variable MaxLongTermFrameIdx \nis equal to \"no long-term frame indices\" when the memory_management_control_operation is processed by the decoding \nprocess. \nNot more than one memory_management_control_operation equal to 4 shall be present in a slice header. \nNot more than one memory_management_control_operation equal to 5 shall be present in a slice header. \nNot more than one memory_management_control_operation equal to 6 shall be present in a slice header. \nmemory_management_control_operation  shall  not  be  equal  to  5  in  a  slice  header  unless  no \nmemory_management_control_operation in the range of 1 to 3 is present in the same decoded reference picture marking \nsyntax structure. \nA memory_management_control_operation equal to 5 shall not follow a memory_management_control_operation equal \nto 6 in the same slice header. \nWhen a  memory_management_control_operation equal to 6 is present, any  memory_management_control_operation \nequal to 2, 3, or 4 that follows the memory_management_control_operation equal to 6 within the same slice header shall \nnot specify the current picture to be marked as \"unused for reference\". \nNOTE 2 – These constraints prohibit any combination of multiple memory_management_control_operation syntax elements that \nwould  specify  the  current  picture  to  be  marked  as  \"unused  for  reference\".  However,  some  other  combinations  of \nmemory_management_control_operation syntax elements are permitted that may affect the marking status of other reference \npictures more than once in the same slice header. In particular, it is permitted for a memory_management_control_operation equal \nto 3 that specifies a long-term frame index to be assigned to a particular short-term reference picture to be followed in the same slice \nheader by a memory_management_control_operation equal to 2, 3, 4 or 6 that specifies the same reference picture to subsequently \nbe marked as \"unused for reference\". \n    Rec. ITU-T H.264 (06/2019)  95 \n \nTable 7-9 – Memory management control operation (memory_management_control_operation) values \nmemory_management_control_operation  Memory Management Control Operation \n0  End memory_management_control_operation \nsyntax element loop \n1  Mark a short-term reference picture as \n\"unused for reference\" \n2  Mark a long-term reference picture as \n\"unused for reference\" \n3  Mark a short-term reference picture as \n\"used for long-term reference\" and assign a \nlong-term frame index to it \n4  Specify the maximum long-term frame index \nand mark all long-term reference pictures \nhaving long-term frame indices greater than \nthe maximum value as \"unused for reference\" \n5  Mark all reference pictures as \n\"unused for reference\" and set the \nMaxLongTermFrameIdx variable to \n\"no long-term frame indices\" \n6  Mark the current picture as \n\"used for long-term reference\" and assign a \nlong-term frame index to it \n \nWhen decoding a field and a memory_management_control_operation command equal to 3 is present that assigns a long-\nterm frame index to a field that is part of a short-term reference frame or part of a complementary reference field pair, \nanother memory_management_control_operation command (equal to 3 or 6) to assign the same long-term frame index to \nthe other field of the same frame or complementary reference field pair shall be present in the same decoded reference \npicture marking syntax structure. \nNOTE 3 – The above requirement must be fulfilled even when the field referred to by the memory_management_control_operation \nequal to 3 is subsequently marked as \"unused for reference\" (for example when a memory_management_control_operation equal \nto 2 is present in the same slice header that causes the field to be marked as \"unused for reference\"). \nNOTE 4 – The above requirement has the following implications: \n–  When a memory_management_control_operation equal to 3 is present that assigns a long-term frame index to a field that is part \nof a reference frame or complementary reference field pair with both fields marked as \"used for short-term reference\" (when \nprocessing the memory_management_control_operation equal to 3), another memory_management_control_operation equal \nto 3 must also be present in the same decoded reference picture marking syntax structure that assigns the same long-term frame \nindex to the other field of the reference frame or complementary reference field pair. \n–  When  the  current  picture  is  the  second  field  (in  decoding  order)  of  a  complementary  reference  field  pair  and  a \nmemory_management_control_operation equal to 3 is present in the decoded reference picture marking syntax structure of the \ncurrent picture that assigns a long-term frame index to the first field (in decoding order) of the complementary reference field \npair, a memory_management_control_operation equal to 6 must be present in the same decoded reference picture marking \nsyntax structure that assigns the same long-term frame index to the second field of the complementary reference field pair. \nWhen the first field (in decoding order) of a complementary reference field pair included a long_term_reference_flag equal \nto 1 or a memory_management_control_operation command equal to 6, the decoded reference picture marking syntax \nstructure  for  the  second  field  of  the  complementary  reference  field  pair  shall  contain  a \nmemory_management_control_operation command equal to 6 that assigns the same long-term frame index to the second \nfield. \nNOTE 5 – The above requirement must be  fulfilled even when the first field of the complementary reference  field pair is \nsubsequently marked as \"unused for reference\" (for example, when a memory_management_control_operation equal to 2 is present \nin the slice header of the second field that causes the first field to be marked as \"unused for reference\"). \nWhen  the  second  field  (in  decoding  order)  of  a  complementary  reference  field  pair  includes  a \nmemory_management_control_operation command equal to 6 that assigns a long-term frame index to this field and the \nfirst  field  of  the  complementary  reference  field  pair  is  marked  as  \"used  for  short-term  reference\"  when  the \nmemory_management_control_operation command equal to 6 is processed by the decoding process, the decoded reference \npicture  marking  syntax  structure  of  that  second  field  shall  contain  either  a  memory_management_control_operation \ncommand  equal  to 1  that  marks  the  first  field  of  the  complementary  field  pair  as  \"unused  for  reference\"  or  a \nmemory_management_control_operation command equal to 3 that marks the first field of the complementary field pair as \n\"used for long-term reference\" and assigns the same long-term frame index to the first field. \n96  Rec. ITU-T H.264 (06/2019) \n \nNOTE 6 – The above constraints specify that when both fields of a frame or a complementary field pair are marked as \"used for \nreference\" after processing all memory_management_control_operation commands of the decoded reference picture marking syntax \nstructure, either both fields must be marked as \"used for short-term reference\" or both fields must be marked as \"used for long-term \nreference\". When both fields are marked as \"used for long-term reference\", the same long-term frame index must be assigned to \nboth fields. \ndifference_of_pic_nums_minus1 is used (with memory_management_control_operation equal to 3 or 1) to assign a long-\nterm frame index to a short-term reference picture or to mark a short-term reference picture as \"unused for reference\". \nWhen the associated memory_management_control_operation is processed by the decoding process, the resulting picture \nnumber derived from difference_of_pic_nums_minus1 shall be a picture number assigned to one of the reference pictures \nmarked as \"used for reference\" and not previously assigned to a long-term frame index. \nThe resulting picture number is constrained as follows: \n–  If field_pic_flag is equal to 0, the resulting picture number shall be one of the set of picture numbers assigned to \nreference frames or complementary reference field pairs. \nNOTE 7 – When field_pic_flag is equal to 0, the resulting picture number must be a picture number assigned to a \ncomplementary reference field pair in which both fields are marked as \"used for reference\" or a frame in which both \nfields are marked as \"used for reference\". In particular, when field_pic_flag is equal to 0, the marking of a non-paired \nfield  or  a  frame  in  which  a  single  field  is  marked  as  \"used  for  reference\"  cannot  be  affected  by  a \nmemory_management_control_operation equal to 1. \n–  Otherwise (field_pic_flag is equal to 1), the resulting picture number shall be one of the set of picture numbers \nassigned to reference fields. \nlong_term_pic_num is used (with memory_management_control_operation equal to 2) to mark a long-term reference \npicture as \"unused for reference\". When the associated memory_management_control_operation is processed by the \ndecoding process, long_term_pic_num shall be equal to a long-term picture number assigned to one of the reference \npictures that is currently marked as \"used for long-term reference\". \nThe resulting long-term picture number is constrained as follows: \n–  If field_pic_flag is equal to 0, the resulting long-term picture number shall be one of the set of long-term picture \nnumbers assigned to reference frames or complementary reference field pairs. \nNOTE 8 – When field_pic_flag is equal to 0, the resulting long-term picture number must be a long-term picture number \nassigned to a complementary reference field pair in which both fields are marked as \"used for reference\" or a frame in \nwhich both fields are marked as \"used for reference\". In particular, when field_pic_flag is equal to 0, the marking of a \nnon-paired  field  or  a  frame  in  which  a  single  field  is  marked  as  \"used  for  reference\"  cannot  be  affected  by  a \nmemory_management_control_operation equal to 2. \n–  Otherwise (field_pic_flag is equal to 1), the resulting long-term picture number shall be one of the set of long-term \npicture numbers assigned to reference fields. \nlong_term_frame_idx is used (with memory_management_control_operation equal to 3 or 6) to assign a long-term frame \nindex to a picture. When the associated memory_management_control_operation is processed by the decoding process, \nthe value of long_term_frame_idx shall be in the range of 0 to MaxLongTermFrameIdx, inclusive. \nmax_long_term_frame_idx_plus1 minus 1 specifies the maximum value of long-term frame index allowed for long-term \nreference  pictures  (until  receipt  of  another  value  of  max_long_term_frame_idx_plus1).  The  value  of \nmax_long_term_frame_idx_plus1 shall be in the range of 0 to max_num_ref_frames, inclusive. \n7.4.4  Slice data semantics \ncabac_alignment_one_bit is a bit equal to 1. \nmb_skip_run specifies the number of consecutive skipped macroblocks for which, when decoding a P or SP slice, \nmb_type shall be inferred to be P_Skip and the macroblock type is collectively referred to as a P macroblock type, or for \nwhich, when decoding a B slice, mb_type shall be inferred to be B_Skip and the macroblock type is collectively referred \nto as a B macroblock type. The value of mb_skip_run shall be in the range of 0 to PicSizeInMbs − CurrMbAddr, inclusive. \nmb_skip_flag equal to 1 specifies that for the current macroblock, when decoding a P or SP slice, mb_type shall be inferred \nto be P_Skip and the macroblock type is collectively referred to as P macroblock type, or for which, when decoding a B \nslice, mb_type shall be inferred to be B_Skip and the macroblock type is collectively referred to as B macroblock type. \nmb_skip_flag equal to 0 specifies that the current macroblock is not skipped. \nmb_field_decoding_flag  equal  to 0  specifies  that  the  current  macroblock  pair  is  a  frame  macroblock  pair. \nmb_field_decoding_flag equal to 1 specifies that the macroblock pair is a field macroblock pair. Both macroblocks of a \nframe macroblock pair are referred to in the text as frame macroblocks, whereas both macroblocks of a field macroblock \npair are referred to in the text as field macroblocks. \n    Rec. ITU-T H.264 (06/2019)  97 \n \nWhen MbaffFrameFlag is equal to 0 (mb_field_decoding_flag is not present), mb_field_decoding_flag is inferred to be \nequal to field_pic_flag. \nWhen MbaffFrameFlag is equal to 1 and mb_field_decoding_flag is not present for both the top and the bottom macroblock \nof a macroblock pair, the value of mb_field_decoding_flag shall be inferred as follows: \n–  If there is a neighbouring macroblock pair immediately to the left of the current macroblock pair in the same slice, \nthe  value  of  mb_field_decoding_flag  is  inferred  to  be  equal  to  the  value  of  mb_field_decoding_flag  for  the \nneighbouring macroblock pair immediately to the left of the current macroblock pair, \n–  Otherwise, if there is no neighbouring macroblock pair immediately to the left of the current macroblock pair in the \nsame slice and there is a neighbouring macroblock pair immediately above the current macroblock pair in the same \nslice, the value of mb_field_decoding_flag is inferred to be equal to the value of mb_field_decoding_flag for the \nneighbouring macroblock pair immediately above the current macroblock pair, \n–  Otherwise (there is no neighbouring macroblock pair either immediately to the left or immediately above the current \nmacroblock pair in the same slice), the value of mb_field_decoding_flag is inferred to be equal to 0. \nNOTE – When MbaffFrameFlag is equal to 1 and mb_field_decoding_flag is not present for the top macroblock of a macroblock \npair (because the top macroblock is skipped), a decoder must wait until mb_field_decoding_flag for the bottom macroblock is read \n(when the bottom macroblock is not skipped) or the value of mb_field_decoding_flag is inferred as specified above (when the bottom \nmacroblock is also skipped) before it starts the decoding process for the top macroblock. \nend_of_slice_flag equal to 0 specifies that another macroblock is following in the slice. end_of_slice_flag equal to 1 \nspecifies the end of the slice and that no further macroblock follows. \nThe function NextMbAddress( ) used in the slice data syntax table is specified in clause 8.2.2. \n7.4.5  Macroblock layer semantics \nmb_type specifies the macroblock type. The semantics of mb_type depend on the slice type. \nTables and semantics are specified for the various macroblock types for I, SI, P, SP, and B slices. Each table presents the \nvalue of mb_type, the name of mb_type, the number of macroblock partitions used (given by the NumMbPart( mb_type ) \nfunction),  the  prediction  mode  of  the  macroblock  (when  it  is  not  partitioned)  or  the  first  partition  (given  by  the \nMbPartPredMode( mb_type, 0 )  function)  and  the  prediction  mode  of  the  second  partition  (given  by  the \nMbPartPredMode( mb_type, 1 ) function). When a value is not applicable it is designated by \"na\". In the text, the value of \nmb_type may be referred to as the macroblock type, the value of MbPartPredMode( ) may be referred to in the text by \n\"macroblock (partition) prediction mode\", and a value X of MbPartPredMode( ) may be referred to in the text by \"X \nmacroblock (partition) prediction mode\" or as \"X prediction macroblocks\". \nTable 7-10 shows the allowed collective macroblock types for each slice_type. \nNOTE 1 – There are some macroblock types with Pred_L0 macroblock (partition) prediction mode(s) that are classified as B \nmacroblock types. \nTable 7-10 – Allowed collective macroblock types for slice_type \nslice_type  allowed collective macroblock types \nI (slice)  I (see Table 7-11) (macroblock types) \nP (slice)  P (see Table 7-13) and I (see Table 7-11) (macroblock types) \nB (slice)  B (see Table 7-14) and I (see Table 7-11) (macroblock types) \nSI (slice)  SI (see Table 7-12) and I (see Table 7-11) (macroblock types) \nSP (slice)  P (see Table 7-13) and I (see Table 7-11) (macroblock types) \n \ntransform_size_8x8_flag equal to 1 specifies that for the current macroblock the transform coefficient decoding process \nand picture construction process prior to deblocking filter process for residual 8x8 blocks shall be invoked for luma \nsamples, and when ChromaArrayType  = =  3 also for Cb and Cr samples. transform_size_8x8_flag equal to 0 specifies \nthat for the current macroblock the transform coefficient decoding process and picture construction process prior to \ndeblocking filter process for residual 4x4 blocks shall be invoked for luma samples, and when ChromaArrayType  = =  3 \nalso for Cb and Cr samples. When transform_size_8x8_flag is not present in the bitstream, it shall be inferred to be equal \nto 0. \nNOTE  2  –  When  the  current  macroblock  prediction  mode  MbPartPredMode( mb_type, 0 )  is  equal  to Intra_16x16, \ntransform_size_8x8_flag is not present in the bitstream and then inferred to be equal to 0. \n98  Rec. ITU-T H.264 (06/2019) \n \nWhen  sub_mb_type[ mbPartIdx ]  (see  clause 7.4.5.2)  is  present  in  the  bitstream  for  all  8x8  blocks  indexed  by \nmbPartIdx = 0..3, the variable noSubMbPartSizeLessThan8x8Flag indicates whether for each of the four 8x8 blocks the \ncorresponding  SubMbPartWidth( sub_mb_type[ mbPartIdx ] )  and  SubMbPartHeight( sub_mb_type[ mbPartIdx ] )  are \nboth equal to 8. \nNOTE 3 – When noSubMbPartSizeLessThan8x8Flag is equal to 0 and the current macroblock type is not equal to I_NxN, \ntransform_size_8x8_flag is not present in the bitstream and then inferred to be equal to 0. \nMacroblock types that may be collectively referred to as I macroblock types are specified in Table 7-11. \nThe macroblock types for I slices are all I macroblock types. \n    Rec. ITU-T H.264 (06/2019)  99 \n \nTable 7-11 – Macroblock types for I slices \n \n \na\n \n  m a\ng\na   e o m\n  m b _ t y p e     o f   m b _ t y p e m _ s i z e _ 8 x 8 _ f l   r t P r e d M o d e       ) 0 b _ t y p e , x 1 6 P r e d M o d k P a t t e r n C h r c k P a t t e r n L u\nN a m e n s f o r M b P a   ( m t r a 1 6 d B l o c e d B l o\na n e d\nr I d o\nt o C\nC\n0  I_NxN  0  Intra_4x4  na  Equation 7-36  Equation 7-36 \n0  I_NxN  1  Intra_8x8  na  Equation 7-36  Equation 7-36 \n1  I_16x16_0_0_0  na  Intra_16x16  0  0  0 \n2  I_16x16_1_0_0  na  Intra_16x16  1  0  0 \n3  I_16x16_2_0_0  na  Intra_16x16  2  0  0 \n4  I_16x16_3_0_0  na  Intra_16x16  3  0  0 \n5  I_16x16_0_1_0  na  Intra_16x16  0  1  0 \n6  I_16x16_1_1_0  na  Intra_16x16  1  1  0 \n7  I_16x16_2_1_0  na  Intra_16x16  2  1  0 \n8  I_16x16_3_1_0  na  Intra_16x16  3  1  0 \n9  I_16x16_0_2_0  na  Intra_16x16  0  2  0 \n10  I_16x16_1_2_0  na  Intra_16x16  1  2  0 \n11  I_16x16_2_2_0  na  Intra_16x16  2  2  0 \n12  I_16x16_3_2_0  na  Intra_16x16  3  2  0 \n13  I_16x16_0_0_1  na  Intra_16x16  0  0  15 \n14  I_16x16_1_0_1  na  Intra_16x16  1  0  15 \n15  I_16x16_2_0_1  na  Intra_16x16  2  0  15 \n16  I_16x16_3_0_1  na  Intra_16x16  3  0  15 \n17  I_16x16_0_1_1  na  Intra_16x16  0  1  15 \n18  I_16x16_1_1_1  na  Intra_16x16  1  1  15 \n19  I_16x16_2_1_1  na  Intra_16x16  2  1  15 \n20  I_16x16_3_1_1  na  Intra_16x16  3  1  15 \n21  I_16x16_0_2_1  na  Intra_16x16  0  2  15 \n22  I_16x16_1_2_1  na  Intra_16x16  1  2  15 \n23  I_16x16_2_2_1  na  Intra_16x16  2  2  15 \n24  I_16x16_3_2_1  na  Intra_16x16  3  2  15 \n25  I_PCM  na  na  na  na  na \n \n \n100  Rec. ITU-T H.264 (06/2019) \n \nThe following semantics are assigned to the macroblock types in Table 7-11: \n–  I_NxN:  A  mnemonic  name  for  mb_type  equal  to 0  with  MbPartPredMode( mb_type, 0 )  equal  to Intra_4x4  or \nIntra_8x8. \n–  I_16x16_0_0_0,  I_16x16_1_0_0,  I_16x16_2_0_0,  I_16x16_3_0_0,  I_16x16_0_1_0,  I_16x16_1_1_0, \nI_16x16_2_1_0,  I_16x16_3_1_0,  I_16x16_0_2_0,  I_16x16_1_2_0,  I_16x16_2_2_0,  I_16x16_3_2_0, \nI_16x16_0_0_1,  I_16x16_1_0_1,  I_16x16_2_0_1,  I_16x16_3_0_1,  I_16x16_0_1_1,  I_16x16_1_1_1, \nI_16x16_2_1_1,  I_16x16_3_1_1,  I_16x16_0_2_1,  I_16x16_1_2_1,  I_16x16_2_2_1,  I_16x16_3_2_1:  the \nmacroblock is coded as an Intra_16x16 prediction macroblock. \nTo  each  Intra_16x16  prediction  macroblock,  an  Intra16x16PredMode  is  assigned,  which  specifies  the  Intra_16x16 \nprediction mode, and values of CodedBlockPatternLuma and CodedBlockPatternChroma are assigned as specified in \nTable 7-11. \nIntra_4x4 specifies the macroblock prediction mode and specifies that the Intra_4x4 prediction process is invoked as \nspecified in clause 8.3.1. Intra_4x4 is an Intra macroblock prediction mode. \nIntra_8x8 specifies the macroblock prediction mode and specifies that the Intra_8x8 prediction process is invoked as \nspecified in clause 8.3.2. Intra_8x8 is an Intra macroblock prediction mode. \nIntra_16x16 specifies the macroblock prediction mode and specifies that the Intra_16x16 prediction process is invoked as \nspecified in clause 8.3.3. Intra_16x16 is an Intra macroblock prediction mode. \nFor a macroblock coded with mb_type equal to I_PCM, the Intra macroblock prediction mode shall be inferred. \n \nA macroblock type that may be referred to as the SI macroblock type is specified in Table 7-12. \nThe macroblock types for SI slices are specified in Tables 7-12 and 7-11. The mb_type value 0 is specified in Table 7-12 \nand the mb_type values 1 to 26 are specified in Table 7-11, indexed by subtracting 1 from the value of mb_type. \nTable 7-12 – Macroblock type with value 0 for SI slices \n \na\n \nm a\n  e o m\n  e   _ t y p e   M o d e       ) 0 d M o d r n C h r e r n L u\nt y p m b r e d y p e , P r e a t t e P a t t\nm b _   o f   r t P b _ t x 1 6 k P c k\nN a m e M b P a   ( m t r a 1 6 d B l o c e d B l o\nn e d\nI d o\no C\nC\n0  SI  Intra_4x4  na  Equation 7-36  Equation 7-36 \n \nThe following semantics are assigned to the macroblock type in Table 7-12: \n–  The SI macroblock is coded as Intra_4x4 prediction macroblock. \nMacroblock types that may be collectively referred to as P macroblock types are specified in Table 7-13. \nThe macroblock types for P and SP slices are specified in Tables 7-13 and 7-11. mb_type values 0 to 4 are specified in \nTable 7-13 and mb_type values 5 to 30 are specified in Table 7-11, indexed by subtracting 5 from the value of mb_type. \n    Rec. ITU-T H.264 (06/2019)  101 \n \nTable 7-13 – Macroblock type values 0 to 4 for P and SP slices \n  e   e   e\n  p e b _ t y p   P a r t     ) p e d M o d       ) 0 e , d M o d       ) 1 e ,   W i d t h     ) p e   e i g h t     ) p e\ny m by ep ep y Hy\n_ t f   M _ t P r t y P r t y r t _ t r t _ t\nb o mb t_ t_ ab ab\nm   m rb rb Pm Pm\na m e N u   ( b P a   ( m b P a   ( m M b   ( M b   (\nN M M\n0  P_L0_16x16  1  Pred_L0  na  16  16 \n1  P_L0_L0_16x8  2  Pred_L0  Pred_L0  16  8 \n2  P_L0_L0_8x16  2  Pred_L0  Pred_L0  8  16 \n3  P_8x8  4  na  na  8  8 \n4  P_8x8ref0  4  na  na  8  8 \ninferred  P_Skip  1  Pred_L0  na  16  16 \n \nThe following semantics are assigned to the macroblock types in Table 7-13: \n–  P_L0_16x16: the samples of the macroblock are predicted with one luma macroblock partition of size 16x16 luma \nsamples and associated chroma samples. \n–  P_L0_L0_MxN, with MxN being replaced by 16x8 or 8x16: the samples of the macroblock are predicted using two \nluma partitions of size MxN equal to 16x8, or two luma partitions of size MxN equal to 8x16, and associated chroma \nsamples, respectively. \n–  P_8x8: for each sub-macroblock an additional syntax element (sub_mb_type[ mbPartIdx ] with mbPartIdx being the \nmacroblock partition index for the corresponding sub-macroblock) is present in the bitstream that specifies the type \nof the corresponding sub-macroblock (see clause 7.4.5.2). \n–  P_8x8ref0: has the same semantics as P_8x8 but no syntax element for the reference index (ref_idx_l0[ mbPartIdx ] \nwith mbPartIdx = 0..3) is present in the bitstream and ref_idx_l0[ mbPartIdx ] shall be inferred to be equal to 0 for all \nsub-macroblocks of the macroblock (with indices mbPartIdx = 0..3). \n–  P_Skip: no further data is present for the macroblock in the bitstream. \nThe following semantics are assigned to the macroblock prediction modes (for macroblocks that are not partitioned) and \nmacroblock  partition  prediction  modes  (for  macroblocks  that  are  partitioned)  specified  by  MbPartPredMode( )  in \nTable 7-13: \n–  Pred_L0: specifies that the Inter prediction process is invoked using list 0 prediction. Pred_L0 is an Inter macroblock \nprediction mode (for macroblocks that are not partitioned) and an Inter macroblock partition prediction mode (for \nmacroblocks that are partitioned). \nWhen mb_type is equal to any of the values specified in Table 7-13, the macroblock is coded in an Inter macroblock \nprediction mode. \nMacroblock types that may be collectively referred to as B macroblock types are specified in Table 7-14. \nThe macroblock types for B slices are specified in Tables 7-14 and 7-11. The mb_type values 0 to 22 are specified in \nTable 7-14 and the mb_type values 23 to 48 are specified in Table 7-11, indexed by subtracting 23 from the value of \nmb_type. \n102  Rec. ITU-T H.264 (06/2019) \n \nTable 7-14 – Macroblock type values 0 to 22 for B slices \n  e   e   e\n  p e b _ t y p   P a r t     ) p e d M o d       ) 0 e , d M o d       ) 1 e ,   W i d t h     ) p e   e i g h t     ) p e\ny m by ep ep y Hy\n_ t f   M _ t P r t y P r t y r t _ t r t _ t\nb o mb t_ t_ ab ab\nm   m rb rb Pm Pm\na m e N u   ( b P a   ( m b P a   ( m M b   ( M b   (\nN M M\n0  B_Direct_16x16  na  Direct  na  8  8 \n1  B_L0_16x16  1  Pred_L0  na  16  16 \n2  B_L1_16x16  1  Pred_L1  na  16  16 \n3  B_Bi_16x16  1  BiPred  na  16  16 \n4  B_L0_L0_16x8  2  Pred_L0  Pred_L0  16  8 \n5  B_L0_L0_8x16  2  Pred_L0  Pred_L0  8  16 \n6  B_L1_L1_16x8  2  Pred_L1  Pred_L1  16  8 \n7  B_L1_L1_8x16  2  Pred_L1  Pred_L1  8  16 \n8  B_L0_L1_16x8  2  Pred_L0  Pred_L1  16  8 \n9  B_L0_L1_8x16  2  Pred_L0  Pred_L1  8  16 \n10  B_L1_L0_16x8  2  Pred_L1  Pred_L0  16  8 \n11  B_L1_L0_8x16  2  Pred_L1  Pred_L0  8  16 \n12  B_L0_Bi_16x8  2  Pred_L0  BiPred  16  8 \n13  B_L0_Bi_8x16  2  Pred_L0  BiPred  8  16 \n14  B_L1_Bi_16x8  2  Pred_L1  BiPred  16  8 \n15  B_L1_Bi_8x16  2  Pred_L1  BiPred  8  16 \n16  B_Bi_L0_16x8  2  BiPred  Pred_L0  16  8 \n17  B_Bi_L0_8x16  2  BiPred  Pred_L0  8  16 \n18  B_Bi_L1_16x8  2  BiPred  Pred_L1  16  8 \n19  B_Bi_L1_8x16  2  BiPred  Pred_L1  8  16 \n20  B_Bi_Bi_16x8  2  BiPred  BiPred  16  8 \n21  B_Bi_Bi_8x16  2  BiPred  BiPred  8  16 \n22  B_8x8  4  na  na  8  8 \ninferred  B_Skip  na  Direct  na  8  8 \n \nThe following semantics are assigned to the macroblock types in Table 7-14: \n–  B_Direct_16x16: no motion vector differences or reference indices are present for the macroblock in the bitstream. \nThe functions MbPartWidth( B_Direct_16x16 ), and MbPartHeight( B_Direct_16x16 ) are used in the derivation \nprocess for motion vectors and reference frame indices in clause 8.4.1 for direct mode prediction. \n–  B_X_16x16 with X being replaced by L0, L1, or Bi: the samples of the macroblock are predicted with one luma \nmacroblock partition of size 16x16 luma samples and associated chroma samples. For a macroblock with type \nB_X_16x16 with X being replaced by either L0 or L1, one motion vector difference and one reference index is present \n    Rec. ITU-T H.264 (06/2019)  103 \n \nin the bitstream for the macroblock. For a macroblock with type B_X_16x16 with X being replaced by Bi, two motion \nvector differences and two reference indices are present in the bitstream for the macroblock. \n–  B_X0_X1_MxN, with X0, X1 referring to the first and second macroblock partition and being replaced by L0, L1, or \nBi, and MxN being replaced by 16x8 or 8x16: the samples of the macroblock are predicted using two luma partitions \nof size MxN equal to 16x8, or two luma partitions of size MxN equal to 8x16, and associated chroma samples, \nrespectively. For a macroblock partition X0 or X1 with X0 or X1 being replaced by either L0 or L1, one motion vector \ndifference and one reference index is present in the bitstream. For a macroblock partition X0 or X1 with X0 or X1 \nbeing replaced by Bi, two motion vector differences and two reference indices are present in the bitstream for the \nmacroblock partition. \n–  B_8x8: for each sub-macroblock an additional syntax element (sub_mb_type[ mbPartIdx ] with mbPartIdx being the \nmacroblock partition index for the corresponding sub-macroblock) is present in the bitstream that specifies the type \nof the corresponding sub-macroblock (see clause 7.4.5.2). \n–  B_Skip: no further data is present for the macroblock in the bitstream. The functions MbPartWidth( B_Skip ), and \nMbPartHeight( B_Skip )  are  used  in  the  derivation  process  for  motion  vectors  and  reference  frame  indices  in \nclause 8.4.1 for direct mode prediction. \nThe following semantics are assigned to the macroblock prediction modes (for macroblocks that are not partitioned) and \nmacroblock  partition  prediction  modes  (for  macroblocks  that  are  partitioned)  specified  by  MbPartPredMode( )  in \nTable 7-14: \n–  Direct: no motion vector differences or reference indices are present for the macroblock (in case of B_Skip or \nB_Direct_16x16) in the bitstream. Direct is an Inter macroblock prediction mode (for macroblocks that are not \npartitioned) and an Inter macroblock partition prediction mode (for macroblocks that are partitioned, see Table 7-18). \n–  Pred_L0: the semantics specified for Table 7-13 apply. \n–  Pred_L1: specifies that the Inter prediction process is invoked using list 1 prediction. Pred_L1 is an Inter macroblock \nprediction mode (for macroblocks that are not partitioned) and an Inter macroblock partition prediction mode (for \nmacroblocks that are partitioned). \n–  BiPred: specifies that the Inter prediction process is invoked using list 0 and list 1 prediction. BiPred is an Inter \nmacroblock prediction mode (for macroblocks that are not partitioned) and an Inter macroblock partition prediction \nmode (for macroblocks that are partitioned). \nWhen mb_type is equal to any of the values specified in Table 7-14, the macroblock is coded in an Inter macroblock \nprediction mode. \npcm_alignment_zero_bit is a bit equal to 0. \npcm_sample_luma[ i ] is a sample value. The pcm_sample_luma[ i ] values represent luma sample values in the raster \nscan within the macroblock. The number of bits used to represent each of these samples is BitDepth . \nY\npcm_sample_chroma[ i ] is a sample value. The first MbWidthC * MbHeightC pcm_sample_chroma[ i ] values represent \nCb  sample  values  in  the  raster  scan  within  the  macroblock  and  the  remaining  MbWidthC * MbHeightC \npcm_sample_chroma[ i ] values represent Cr sample values in the raster scan within the macroblock. The number of bits \nused to represent each of these samples is BitDepth . \nC\ncoded_block_pattern specifies which of the four 8x8 luma blocks and associated chroma blocks of a macroblock may \ncontain  non-zero  transform  coefficient  levels.  When  coded_block_pattern  is  present  in  the  bitstream,  the  variables \nCodedBlockPatternLuma and CodedBlockPatternChroma are derived as \nCodedBlockPatternLuma = coded_block_pattern % 16 \nCodedBlockPatternChroma = coded_block_pattern / 16  (7-36) \nWhen the macroblock type is not equal to P_Skip, B_Skip, or I_PCM, the following applies: \n–  If the macroblock prediction mode is equal Intra_16x16, the following applies: \n–  If ChromaArrayType is not equal to 3, the value of CodedBlockPatternLuma specifies the following. \n–  If CodedBlockPatternLuma is equal to 0, all AC transform coefficient levels of the luma component of the \nmacroblock are equal to 0 for all 16 of the 4x4 blocks in the 16x16 luma block. \n–  Otherwise (CodedBlockPatternLuma is not equal to 0), CodedBlockPatternLuma is equal to 15, at least one \nof the AC transform coefficient levels of the luma component of the macroblock shall be non-zero, and the \nAC transform coefficient levels are scanned for all 16 of the 4x4 blocks in the 16x16 block. \n104  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (ChromaArrayType is equal to 3), the value of CodedBlockPatternLuma specifies the following. \n–  If CodedBlockPatternLuma is equal to 0, all AC transform coefficient levels of the luma, Cb, and Cr \ncomponents of the macroblock are equal to 0 for all 16 of the 4x4 blocks in the luma, Cb, and Cr components \nof the macroblock. \n–  Otherwise (CodedBlockPatternLuma is not equal to 0), CodedBlockPatternLuma is equal to 15, at least one \nof the AC transform coefficient levels of the luma, Cb, or Cr components of the macroblock shall be non-\nzero, and the AC transform coefficient levels are scanned for all 16 of the 4x4 blocks in the luma Cb, and \nCr components of the macroblock. \n–  Otherwise (the macroblock prediction mode is not equal to Intra_16x16), coded_block_pattern is present in the \nbitstream, and the following applies: \n–  If ChromaArrayType is not equal to 3, each of the four LSBs of CodedBlockPatternLuma specifies, for one of \nthe four 8x8 luma blocks of the macroblock, the following. \n–  If the corresponding bit of CodedBlockPatternLuma is equal to 0, all transform coefficient levels of the \nluma transform blocks in the 8x8 luma block are equal to zero. \n–  Otherwise  (the  corresponding  bit  of  CodedBlockPatternLuma  is  equal  to  1),  one  or  more  transform \ncoefficient levels of one or more of the luma transform blocks in the 8x8 luma block shall be non-zero \nvalued and the transform coefficient levels of the corresponding transform blocks are scanned. \n–  Otherwise (ChromaArrayType is equal to 3), each of the four LSBs of CodedBlockPatternLuma specifies, for \none of the four 8x8 luma blocks of the macroblock, the following. \n–  If the corresponding bit of CodedBlockPatternLuma is equal to 0, all transform coefficient levels of the \nluma, Cb, and Cr transform blocks in the 8x8 luma block are equal to zero. \n–  Otherwise  (the  corresponding  bit  of  CodedBlockPatternLuma  is  equal  to  1),  one  or  more  transform \ncoefficient levels of one or more of the luma, Cb, or Cr transform blocks in the 8x8 luma block shall be \nnon-zero valued and the transform coefficient levels of the corresponding transform blocks are scanned. \nWhen the macroblock type is not equal to P_Skip, B_Skip, or I_PCM, CodedBlockPatternChroma is interpreted as follows: \n–  If ChromaArrayType is not equal to 0 or 3, CodedBlockPatternChroma is specified in Table 7-15. \n–  Otherwise (ChromaArrayType is equal to 0 or 3), the bitstream shall not contain data that result in a derived value of \nCodedBlockPatternChroma that is not equal to 0. \nTable 7-15 – Specification of CodedBlockPatternChroma values \n \nCodedBlockPatternChroma  Description \n0  All chroma transform coefficient levels are equal to 0. \n1  One or more chroma DC transform coefficient levels shall be non-zero valued.  \nAll chroma AC transform coefficient levels are equal to 0. \n2  Zero  or  more  chroma  DC  transform  coefficient  levels  are  non-zero  valued.  \nOne or more chroma AC transform coefficient levels shall be non-zero valued. \n \nmb_qp_delta can change the value of QP  in the macroblock layer. The decoded value of mb_qp_delta shall be in the \nY\nrange of −( 26 + QpBdOffset  / 2) to +( 25 + QpBdOffset  / 2 ), inclusive. mb_qp_delta shall be inferred to be equal to 0 \nY Y\nwhen it is not present for any macroblock (including P_Skip and B_Skip macroblock types). \nThe value of QP  is derived as \nY\nQP  = ( ( QP  + mb_qp_delta + 52 + 2 * QpBdOffset  ) % ( 52 + QpBdOffset  ) ) − QpBdOffset   (7-37) \nY Y,PREV Y Y Y\nwhere QP  is the luma quantization parameter, QP , of the previous macroblock in decoding order in the current slice. \nY,PREV Y\nFor the first macroblock in the slice QP  is initially set equal to SliceQP  derived in Equation 7-30 at the start of each \nY,PREV Y\nslice. \nThe value of QP′  is derived as \nY\nQP′  = QP  + QpBdOffset     (7-38) \nY Y Y\nThe variable TransformBypassModeFlag is derived as follows: \n    Rec. ITU-T H.264 (06/2019)  105 \n \n–  If qpprime_y_zero_transform_bypass_flag is equal to 1 and QP′  is equal to 0, TransformBypassModeFlag is set \nY\nequal to 1. \n–  Otherwise  (qpprime_y_zero_transform_bypass_flag  is  equal  to  0  or  QP′   is  not  equal  to  0), \nY\nTransformBypassModeFlag is set equal to 0. \n7.4.5.1  Macroblock prediction semantics \nAll samples of the macroblock are predicted. The prediction modes are derived using the following syntax elements. \nprev_intra4x4_pred_mode_flag[ luma4x4BlkIdx ]  and  rem_intra4x4_pred_mode[ luma4x4BlkIdx ]  specify  the \nIntra_4x4 prediction of the 4x4 luma block with index luma4x4BlkIdx = 0..15. When ChromaArrayType is equal to 3, \nprev_intra4x4_pred_mode_flag[ luma4x4BlkIdx ]  and  rem_intra4x4_pred_mode[ luma4x4BlkIdx ]  also  specify  the \nIntra_4x4 prediction of the 4x4 Cb block with luma4x4BlkIdx equal to cb4x4BlkIdx for cb4x4BlkIdx = 0..15 and the \nIntra_4x4 prediction of the 4x4 Cr block with luma4x4BlkIdx equal to cr4x4BlkIdx for cr4x4BlkIdx = 0..15. \nprev_intra8x8_pred_mode_flag[ luma8x8BlkIdx ]  and  rem_intra8x8_pred_mode[ luma8x8BlkIdx ]  specify  the \nIntra_8x8 prediction of the 8x8 luma block with index luma8x8BlkIdx = 0..3. When ChromaArrayType is equal to 3, \nprev_intra8x8_pred_mode_flag[ luma8x8BlkIdx ]  and  rem_intra8x8_pred_mode[ luma8x8BlkIdx ]  also  specify  the \nIntra_8x8 prediction of the 8x8 Cb block with luma8x8BlkIdx equal to cb8x8BlkIdx for cb8x8BlkIdx = 0..3 and the \nIntra_8x8 prediction of the 8x8 Cr block with index luma8x8BlkIdx equal to cr8x8BlkIdx for cr8x8BlkIdx = 0..3. \nintra_chroma_pred_mode specifies, when ChromaArrayType is equal to 1 or 2, the type of spatial prediction used for \nchroma in macroblocks using Intra_4x4, Intra_8x8, or Intra_16x16 prediction, as shown in Table 7-16. The value of \nintra_chroma_pred_mode shall be in the range of 0 to 3, inclusive. \nTable 7-16 – Relationship between intra_chroma_pred_mode and spatial prediction modes \n \nintra_chroma_pred_mode  Intra Chroma Prediction Mode \n0  DC \n1  Horizontal \n2  Vertical \n3  Plane \n \nref_idx_l0[ mbPartIdx ] when present, specifies the index in reference picture list 0 of the reference picture to be used for \nprediction. \nThe range of ref_idx_l0[ mbPartIdx ], the index in list 0 of the reference picture, and, if applicable, the parity of the field \nwithin the reference picture used for prediction are specified as follows: \n–  If MbaffFrameFlag is equal to 0 or mb_field_decoding_flag is equal to 0, the value of ref_idx_l0[ mbPartIdx ] shall \nbe in the range of 0 to num_ref_idx_l0_active_minus1, inclusive. \n–  Otherwise  (MbaffFrameFlag  is  equal  to 1  and  mb_field_decoding_flag  is  equal  to 1),  the  value  of \nref_idx_l0[ mbPartIdx ] shall be in the range of 0 to 2 * num_ref_idx_l0_active_minus1 + 1, inclusive. \nWhen only one reference picture is used for inter prediction, the values of ref_idx_l0[ mbPartIdx ] shall be inferred to be \nequal to 0. \nref_idx_l1[ mbPartIdx ] has the same semantics as ref_idx_l0, with l0 and list 0 replaced by l1 and list 1, respectively. \nmvd_l0[ mbPartIdx ][ 0 ][ compIdx ] specifies the difference between a list 0 motion vector component to be used and its \nprediction. The index mbPartIdx specifies to which macroblock partition mvd_l0 is assigned. The partitioning of the \nmacroblock is specified by mb_type. The horizontal motion vector component difference is decoded first in decoding order \nand is assigned compIdx = 0. The vertical motion vector component is decoded second in decoding order and is assigned \ncompIdx = 1. The value of mvd_l0[ mbPartIdx ][ 0 ][ compIdx ] shall be in the range of −8192 to 8191.75, inclusive. The \nrange of mvd_l0[ mbPartIdx ][ 0 ][ compIdx ] is also constrained indirectly by constraints on the motion vector variable \nvalues derived from it as specified in Annex A. \nmvd_l1[ mbPartIdx ][ 0 ][ compIdx ] has the same semantics as mvd_l0, with l0 and list 0 replaced by l1 and list 1, \nrespectively. \n106  Rec. ITU-T H.264 (06/2019) \n \n7.4.5.2  Sub-macroblock prediction semantics \nsub_mb_type[ mbPartIdx ] specifies the sub-macroblock types. \nTables and semantics are specified for the various sub-macroblock types for P, and B macroblock types. Each table presents \nthe value of sub_mb_type[ mbPartIdx ], the name of sub_mb_type[ mbPartIdx ], the number of sub-macroblock partitions \nused  (given  by  the  NumSubMbPart( sub_mb_type[ mbPartIdx ] )  function),  and  the  prediction  mode  of  the  sub-\nmacroblock  (given  by  the  SubMbPredMode( sub_mb_type[ mbPartIdx ] )  function).  In  the  text,  the  value  of \nsub_mb_type[ mbPartIdx ] may be referred to by \"sub-macroblock type\". In the text, the value of SubMbPredMode( ) may \nbe referred to by \"sub-macroblock prediction mode\" or \"macroblock partition prediction mode\". \nThe interpretation of sub_mb_type[ mbPartIdx ] for P macroblock types is specified in Table 7-17, where the row for \n\"inferred\" specifies values inferred when sub_mb_type[ mbPartIdx ] is not present. \nTable 7-17 – Sub-macroblock types in P macroblocks \n \n       \n) ) ) )\n           \n] ] ] ] ] ]\n           \nx x x x x x\nd d d d d d\na r t I a r t I   a r t a r t I   o d e a r t I   d t h a r t I   g h t a r t I\nb P f  b P b P b P M b P W i b P H e i b P\n  m [ m e   o   m [ b M   m [ r e d   m [ a r t   m [ a r t   m [\nt y p e N a t y p e m S u t y p e M b P t y p e M b P t y p e M b P t y p e\n_ _ _ _ _ _\nb b ub b b bb bb\nm m Nm u m um um\nS S S\n_ _ _ _ _ _\nb b b b b b\nu u u u u u\ns s s s s s\n       \n( ( ( (\ninferred  na  na  na  na  na \n0  P_L0_8x8  1  Pred_L0  8  8 \n1  P_L0_8x4  2  Pred_L0  8  4 \n2  P_L0_4x8  2  Pred_L0  4  8 \n3  P_L0_4x4  4  Pred_L0  4  4 \n \nThe following semantics are assigned to the sub-macroblock types in Table 7-17: \n–  P_L0_MxN, with MxN being replaced by 8x8, 8x4, 4x8, or 4x4: the samples of the sub-macroblock are predicted \nusing one luma partition of size MxN equal to 8x8, two luma partitions of size MxN equal to 8x4, or two luma \npartitions of size MxN equal to 4x8, or four luma partitions of size MxN equal to 4x4, and associated chroma samples, \nrespectively. \nThe following semantics are assigned to the sub-macroblock prediction modes (or macroblock partition prediction modes) \nspecified by SubMbPredMode( ) in Table 7-17: \n–  Pred_L0: see semantics for Table 7-13. \n    Rec. ITU-T H.264 (06/2019)  107 \n \nThe interpretation of sub_mb_type[ mbPartIdx ] for B macroblock types is specified in Table 7-18, where the row for \n\"inferred\" specifies values inferred when sub_mb_type[ mbPartIdx ] is not present, and the inferred value \"mb_type\" \nspecifies that the name of sub_mb_type[ mbPartIdx ] is the same as the name of mb_type for this case. \nTable 7-18 – Sub-macroblock types in B macroblocks \n \n       \n) ) ) )\n           \n] ] ] ] ] ]\n           \nx x x x x x\nd d d d d d\na r t I a r t I   a r t a r t I   o d e a r t I   d t h a r t I   g h t a r t I\nb P   f  b P b P b P M b P W i b P H e i b P\n  m [ m e   o   m [ b M   m [ r e d   m [ a r t   m [ a r t   m [\nt y p e N a t y p e m S u t y p e M b P t y p e M b P t y p e M b P t y p e\n_ _ _ _ _ _\nb b ub b b bb bb\nm m Nm u m um um\nS S S\n_ _ _ _ _ _\nb b b b b b\nu u u u u u\ns s s s s s\n       \n( ( ( (\ninferred  mb_type  4  Direct  4  4 \n0  B_Direct_8x8  4  Direct  4  4 \n1  B_L0_8x8  1  Pred_L0  8  8 \n2  B_L1_8x8  1  Pred_L1  8  8 \n3  B_Bi_8x8  1  BiPred  8  8 \n4  B_L0_8x4  2  Pred_L0  8  4 \n5  B_L0_4x8  2  Pred_L0  4  8 \n6  B_L1_8x4  2  Pred_L1  8  4 \n7  B_L1_4x8  2  Pred_L1  4  8 \n8  B_Bi_8x4  2  BiPred  8  4 \n9  B_Bi_4x8  2  BiPred  4  8 \n10  B_L0_4x4  4  Pred_L0  4  4 \n11  B_L1_4x4  4  Pred_L1  4  4 \n12  B_Bi_4x4  4  BiPred  4  4 \n \nThe following semantics are assigned to the sub-macroblock types in Table 7-18: \n–  B_Skip and B_Direct_16x16: no motion vector differences or reference indices are present for the sub-macroblock \nin the bitstream. The functions SubMbPartWidth( ) and SubMbPartHeight( ) are used in the derivation process for \nmotion vectors and reference frame indices in clause 8.4.1 for direct mode prediction. \n–  B_Direct_8x8: no motion vector differences or reference indices are present for the sub-macroblock in the bitstream. \nThe functions SubMbPartWidth( B_Direct_8x8 ) and SubMbPartHeight( B_Direct_8x8 ) are used in the derivation \nprocess for motion vectors and reference frame indices in clause 8.4.1 for direct mode prediction. \n–  B_X_MxN, with X being replaced by L0, L1, or Bi, and MxN being replaced by 8x8, 8x4, 4x8 or 4x4: the samples \nof the sub-macroblock are predicted using one luma partition of size MxN equal to 8x8, or the samples of the sub-\nmacroblock are predicted using two luma partitions of size MxN equal to 8x4, or the samples of the sub-macroblock \nare predicted using two luma partitions of size MxN equal to 4x8, or the samples of the sub-macroblock are predicted \nusing  four  luma  partitions  of  size  MxN  equal  to 4x4,  and  associated  chroma  samples,  respectively.  All  sub-\nmacroblock partitions share the same reference index. For an MxN sub-macroblock partition in a sub-macroblock \nwith sub_mb_type[ mbPartIdx ] being B_X_MxN with X being replaced by either L0 or L1, one motion vector \ndifference  is  present  in  the  bitstream.  For  an  MxN  sub-macroblock  partition  in  a  sub-macroblock  with \nsub_mb_type[ mbPartIdx ] being B_Bi_MxN, two motion vector difference are present in the bitstream. \n108  Rec. ITU-T H.264 (06/2019) \n \nThe following semantics are assigned to the sub-macroblock prediction modes (or macroblock partition prediction modes) \nspecified by SubMbPredMode( ) in Table 7-18: \n–  Direct: see semantics for Table 7-14. \n–  Pred_L0: see semantics for Table 7-13. \n–  Pred_L1: see semantics for Table 7-14. \n–  BiPred: see semantics for Table 7-14. \nref_idx_l0[ mbPartIdx ] has the same semantics as ref_idx_l0 in clause 7.4.5.1. \nref_idx_l1[ mbPartIdx ] has the same semantics as ref_idx_l1 in clause 7.4.5.1. \nmvd_l0[ mbPartIdx ][ subMbPartIdx ][ compIdx ] has the same semantics as mvd_l0 in clause 7.4.5.1, except that it is \napplied to the sub-macroblock partition index with subMbPartIdx. The indices mbPartIdx and subMbPartIdx specify to \nwhich macroblock partition and sub-macroblock partition mvd_l0 is assigned. \nmvd_l1[ mbPartIdx ][ subMbPartIdx ][ compIdx ] has the same semantics as mvd_l1 in clause 7.4.5.1, except that it is \napplied to the sub-macroblock partition index with subMbPartIdx. The indices mbPartIdx and subMbPartIdx specify to \nwhich macroblock partition and sub-macroblock partition mvd_l1 is assigned. \n7.4.5.3  Residual data semantics \nThe syntax structure residual_block( ), which is used for parsing the transform coefficient levels, is assigned as follows: \n–  If entropy_coding_mode_flag is equal to 0, residual_block is set equal to residual_block_cavlc, which is used for \nparsing the syntax elements for transform coefficient levels. \n–  Otherwise (entropy_coding_mode_flag is equal to 1), residual_block is set equal to residual_block_cabac, which is \nused for parsing the syntax elements for transform coefficient levels. \nThe syntax structure residual_luma( i16x16DClevel, i16x16AClevel, level4x4, level8x8, startIdx, endIdx ) is used with \nthe first four variables in brackets being its output and being assigned as follows. \nIntra16x16DCLevel is set equal to i16x16DClevel, Intra16x16ACLevel is set equal to i16x16AClevel, LumaLevel4x4 is \nset equal to level4x4, and LumaLevel8x8 is set equal to level8x8. \nWhen ChromaArrayType is equal to 1 or 2, the following applies: \n–  For each chroma component, indexed by iCbCr = 0..1, the DC transform coefficient levels of the 4 * NumC8x8 4x4 \nchroma blocks are parsed into the iCbCr-th list ChromaDCLevel[ iCbCr ]. \n–  For each of the 4x4 chroma blocks, indexed by i4x4 = 0..3 and i8x8 = 0..NumC8x8  1, of each chroma component, \nindexed by iCbCr = 0..1, the 15 AC transform coefficient levels are parsed into the (i8x8*4 + i4x4)-th list of the \niCbCr-th chroma component ChromaACLevel[ iCbCr ][ i8x8*4 + i4x4 ]. \nWhen ChromaArrayType is equal to 3, the following applies: \n–  The syntax structure residual_luma( i16x16DClevel, i16x16AClevel, level4x4, level8x8, startIdx, endIdx ) is used \nfor the Cb component with the  first four variables in brackets being its output and being assigned as follows. \nCbIntra16x16DCLevel  is  set  equal  to  i16x16DClevel,  CbIntra16x16ACLevel  is  set  equal  to  i16x16AClevel, \nCbLevel4x4 is set equal to level4x4, and CbLevel8x8 is set equal to level8x8. \n–  The syntax structure residual_luma( i16x16DClevel, i16x16AClevel, level4x4, level8x8, startIdx, endIdx ) is used \nfor the Cr component  with the  first four  variables in brackets being its output and being assigned as follows. \nCrIntra16x16DCLevel  is  set  equal  to  i16x16DClevel,  CrIntra16x16ACLevel  is  set  equal  to  i16x16AClevel, \nCrLevel4x4 is set equal to level4x4, and CrLevel8x8 is set equal to level8x8. \n7.4.5.3.1 Residual luma data semantics \nOutput of this syntax structure are the variables i16x16DClevel, i16x16AClevel, level4x4, and level8x8. \nDepending on mb_type, the syntax structure residual_block( coeffLevel, startIdx, endIdx, maxNumCoeff ) is used with \nthe arguments coeffLevel, which is a list containing the maxNumCoeff transform coefficient levels that are parsed in \nresidual_block( ), startIdx, endIdx, and maxNumCoeff as follows. \nDepending on MbPartPredMode( mb_type, 0 ), the following applies: \n–  If MbPartPredMode( mb_type, 0 ) is equal to Intra_16x16, the transform coefficient levels are parsed into the list \ni16x16DClevel and into the 16 lists i16x16AClevel[ i ]. i16x16DClevel contains the 16 transform coefficient levels \n    Rec. ITU-T H.264 (06/2019)  109 \n \nof the DC transform coefficient levels for each 4x4 luma block. For each of the 16 4x4 luma blocks indexed by \ni = 0..15, the 15 AC transform coefficients levels of the i-th block are parsed into the i-th list i16x16AClevel[ i ]. \n–  Otherwise (MbPartPredMode( mb_type, 0 ) is not equal to Intra_16x16), the following applies: \n–  If transform_size_8x8_flag is equal to 0, for each of the 16 4x4 luma blocks indexed by i = 0..15, the 16 \ntransform coefficient levels of the i-th block are parsed into the i-th list level4x4[ i ]. \n–  Otherwise (transform_size_8x8_flag is equal to 1), for each of the 4 8x8 luma blocks indexed by i8x8 = 0..3, the \nfollowing applies: \n–  If entropy_coding_mode_flag is equal to 0, first for each of the 4 4x4 luma blocks indexed by i4x4 = 0..3, \nthe  16  transform  coefficient  levels  of  the  i4x4-th  block  are  parsed  into  the  (i8x8 * 4 + i4x4)-th  list \nlevel4x4[ i8x8 * 4 + i4x4 ]. Then, the 64 transform coefficient levels of the i8x8-th 8x8 luma block which \nare indexed by 4 * i + i4x4, where i = 0..15 and i4x4 = 0..3, are derived as level8x8[ i8x8 ][ 4 * i + i4x4 ] = \nlevel4x4[ i8x8 * 4 + i4x4 ][ i ]. \nNOTE – The 4x4 luma blocks with luma4x4BlkIdx = i8x8 * 4 + i4x4 containing every fourth transform coefficient \nlevel of the corresponding i8x8-th 8x8 luma block with offset i4x4 are assumed to represent spatial locations given by \nthe inverse 4x4 luma block scanning process in clause 6.4.3. \n–  Otherwise (entropy_coding_mode_flag is equal to 1), the 64 transform coefficient levels of the i8x8-th \nblock are parsed into the i8x8-th list level8x8[ i8x8 ]. \n \n7.4.5.3.2 Residual block CAVLC semantics \nThe function TotalCoeff( coeff_token ) that is used in clause 7.3.5.3.2 returns the number of non-zero transform coefficient \nlevels derived from coeff_token. \nThe function TrailingOnes( coeff_token ) that is used in clause 7.3.5.3.2 returns the trailing ones derived from coeff_token. \ncoeff_token specifies the total number of non-zero transform coefficient levels and the number of trailing one transform \ncoefficient levels in a transform coefficient level scan. A trailing one transform coefficient level is one of up to three \nconsecutive non-zero transform coefficient levels having an absolute value equal to 1 at the end of a scan of non-zero \ntransform coefficient levels. The range of coeff_token is specified in clause 9.2.1. \ntrailing_ones_sign_flag specifies the sign of a trailing one transform coefficient level as follows: \n–  If trailing_ones_sign_flag is equal to 0, the corresponding transform coefficient level is decoded as +1. \n–  Otherwise (trailing_ones_sign_flag equal to 1), the corresponding transform coefficient level is decoded as −1. \nlevel_prefix and level_suffix specify the value of a non-zero transform coefficient level. The range of level_prefix and \nlevel_suffix is specified in clause 9.2.2. \ntotal_zeros specifies the total number of zero-valued transform coefficient levels that are located before the position of \nthe last non-zero transform coefficient level in a scan of transform coefficient levels. The range of total_zeros is specified \nin clause 9.2.3. \nrun_before specifies the number of consecutive transform coefficient levels in the scan with zero value before a non-zero \nvalued transform coefficient level. The range of run_before is specified in clause 9.2.3. \ncoeffLevel contains maxNumCoeff transform coefficient levels for the current list of transform coefficient levels. \n7.4.5.3.3 Residual block CABAC semantics \ncoded_block_flag specifies whether the transform block contains non-zero transform coefficient levels as follows: \n–  If coded_block_flag is equal to 0, the transform block contains no non-zero transform coefficient levels. \n–  Otherwise (coded_block_flag is equal to 1), the transform block contains at least one non-zero transform coefficient \nlevel. \nWhen coded_block_flag is not present, it shall be inferred to be equal to 1. \nsignificant_coeff_flag[ i ] specifies whether the transform coefficient level at scanning position i is non-zero as follows: \n–  If significant_coeff_flag[ i ] is equal to 0, the transform coefficient level at scanning position i is set equal to 0; \n–  Otherwise (significant_coeff_flag[ i ] is equal to 1), the transform coefficient level at scanning position i has a \nnon-zero value. \n110  Rec. ITU-T H.264 (06/2019) \n \nlast_significant_coeff_flag[ i ] specifies for the scanning position i whether there are non-zero transform coefficient levels \nfor subsequent scanning positions i + 1 to maxNumCoeff − 1 as follows: \n–  If last_significant_coeff_flag[ i ] is equal to 1, all following transform coefficient levels (in scanning order) of the \nblock have value equal to 0. \n–  Otherwise (last_significant_coeff_flag[ i ] is equal to 0), there are further non-zero transform coefficient levels along \nthe scanning path. \ncoeff_abs_level_minus1[ i ]  is  the  absolute  value  of  a  transform  coefficient  level  minus  1.  The  value  of \ncoeff_abs_level_minus1 is constrained by the limits in clause 8.5. \ncoeff_sign_flag[ i ] specifies the sign of a transform coefficient level as follows: \n–  If coeff_sign_flag is equal to 0, the corresponding transform coefficient level has a positive value. \n–  Otherwise (coeff_sign_flag is equal to 1), the corresponding transform coefficient level has a negative value. \ncoeffLevel contains maxNumCoeff transform coefficient levels for the current list of transform coefficient levels. \n8  Decoding process \nOutputs of this process are decoded samples of the current picture (sometimes referred to by the variable CurrPic). \nDepending on the value of chroma_format_idc, the number of sample arrays of the current picture is as follows: \n–  If chroma_format_idc is equal to 0, the current picture consists of 1 sample array S . \nL\n–  Otherwise (chroma_format_idc is not equal to 0), the current picture consists of 3 sample arrays S , S , S . \nL Cb Cr\nThis clause describes the decoding process, given syntax elements and upper-case variables from clause 7. \nThe decoding process is specified such that all decoders shall produce numerically identical results. Any decoding process \nthat produces identical results to the process described here conforms to the decoding process requirements of this \nRecommendation | International Standard. \nEach picture referred to in this clause is a complete primary coded picture or part of a primary coded picture. Each slice \nreferred to in this clause is a slice of a primary coded picture. Each slice data partition referred to in this clause is a slice \ndata partition of a primary coded picture. \nDepending on the value of separate_colour_plane_flag, the decoding process is structured as follows: \n–  If separate_colour_plane_flag is equal to 0, the decoding process is invoked a single time with the current picture \nbeing the output. \n–  Otherwise (separate_colour_plane_flag is equal to 1), the decoding process is invoked three times. Inputs to the \ndecoding process are all NAL units of the primary coded picture with identical value of colour_plane_id. The decoding \nprocess of NAL units with a particular value of colour_plane_id is specified as if only a coded video sequence with \nmonochrome colour format with that particular value of colour_plane_id would be present in the bitstream. The output \nof each of the three decoding processes is assigned to the 3 sample arrays of the current picture with the NAL units \nwith colour_plane_id equal to 0 being assigned to S , the NAL units with colour_plane_id equal to 1 being assigned \nL\nto S , and the NAL units with colour_plane_id equal to 2 being assigned to S . \nCb Cr\nNOTE  –  The  variable  ChromaArrayType  is  derived  as  0  when  separate_colour_plane_flag  is  equal  to  1  and \nchroma_format_idc is equal to 3. In the decoding process, the value of this variable is evaluated resulting in operations \nidentical to that of monochrome pictures with chroma_format_idc being equal to 0. \nAn overview of the decoding process is given as follows: \n1.  The decoding of NAL units is specified in clause 8.1. \n2.  The processes in clause 8.2 specify decoding processes using syntax elements in the slice layer and above: \n–  Variables and functions relating to picture order count are derived in clause 8.2.1. (only needed to be \ninvoked for one slice of a picture) \n–  Variables and functions relating to the macroblock to slice group map are derived in clause 8.2.2. (only \nneeded to be invoked for one slice of a picture) \n–  The method of combining the various slice data partitions when slice data partitioning is used is described \nin clause 8.2.3. \n    Rec. ITU-T H.264 (06/2019)  111 \n \n–  When  the  frame_num  of  the  current  picture  is  not  equal  to  PrevRefFrameNum  and  is  not  equal  to \n( PrevRefFrameNum + 1 ) % MaxFrameNum, the decoding process for gaps in frame_num is performed \naccording to clause 8.2.5.2 prior to the decoding of any slices of the current picture. \n–  At the beginning of the decoding process for each P, SP, or B slice, the decoding process for reference \npicture lists construction specified in clause 8.2.4 is invoked for derivation of reference picture list 0 \n(RefPicList0), and when decoding a B slice, reference picture list 1 (RefPicList1). \n–  When the current picture is a reference picture and after all slices of the current picture have been decoded, \nthe decoded reference picture marking process in clause 8.2.5 specifies how the current picture is used in \nthe decoding process of inter prediction in later decoded pictures. \n3.  The processes in clauses 8.3, 8.4, 8.5, 8.6, and 8.7 specify decoding processes using syntax elements in the \nmacroblock layer and above. \n–  The intra prediction process for I and SI macroblocks, except for I_PCM macroblocks as specified in \nclause 8.3, has intra prediction samples as its output. For I_PCM macroblocks clause 8.3 directly specifies \na picture construction process. The output are constructed samples prior to the deblocking filter process. \n–  The inter prediction process for P and B macroblocks is specified in clause 8.4 with inter prediction samples \nbeing the output. \n–  The transform coefficient decoding process and picture construction process prior to deblocking filter \nprocess are specified in clause 8.5. That process derives samples for I and B macroblocks and for P \nmacroblocks in P slices. The output are constructed samples prior to the deblocking filter process. \n–  The decoding process for P macroblocks in SP slices or SI macroblocks is specified in clause 8.6. That \nprocess derives samples for P macroblocks in SP slices and for SI macroblocks. The output are constructed \nsamples prior to the deblocking filter process. \n–  The constructed samples prior to the deblocking filter process that are next to the edges of blocks and \nmacroblocks are processed by a deblocking filter as specified in  clause 8.7 with the output being the \ndecoded samples. \n8.1  NAL unit decoding process \nInputs to this process are NAL units. \nOutputs of this process are the RBSP syntax structures encapsulated within the NAL units. \nThe decoding process for each NAL unit extracts the RBSP syntax structure from the NAL unit and then operates the \ndecoding processes specified for the RBSP syntax structure in the NAL unit as follows. \nClause 8.2 describes the decoding process for NAL units with nal_unit_type equal to 1 through 5. \nClause 8.3 describes the decoding process for a macroblock or part of a macroblock coded in NAL units with nal_unit_type \nequal to 1, 2, and 5. \nClause 8.4 describes the decoding process for a macroblock or part of a macroblock coded in NAL units with nal_unit_type \nequal to 1 and 2. \nClause 8.5 describes the decoding process for a macroblock or part of a macroblock coded in NAL units with nal_unit_type \nequal to 1 and 3 to 5. \nClause 8.6 describes the decoding process for a macroblock or part of a macroblock coded in NAL units with nal_unit_type \nequal to 1 and 3 to 5. \nClause 8.7 describes the decoding process for a macroblock or part of a macroblock coded in NAL units with nal_unit_type \nequal to 1 to 5. \nNAL units with nal_unit_type equal to 7 and 8 contain sequence parameter sets and picture parameter sets, respectively. \nPicture parameter sets are used in the decoding processes of other NAL units as determined by reference to a picture \nparameter set within the slice headers of each picture. Sequence parameter sets are used in the decoding processes of other \nNAL units as determined by reference to a sequence parameter set within the picture parameter sets of each sequence. \nNo normative decoding process is specified for NAL units with nal_unit_type equal to 6, 9, 10, 11, and 12. \n112  Rec. ITU-T H.264 (06/2019) \n \n8.2  Slice decoding process \n8.2.1  Decoding process for picture order count \nOutputs of this process are TopFieldOrderCnt (if applicable) and BottomFieldOrderCnt (if applicable). \nPicture order counts are used to determine initial picture orderings for reference pictures in the decoding of B slices (see \nclauses 8.2.4.2.3 and 8.2.4.2.4), to determine co-located pictures (see clause 8.4.1.2.1) for deriving motion parameters in \ntemporal or spatial direct mode, to represent picture order differences between frames or fields for motion vector derivation \nin temporal direct mode (see clause 8.4.1.2.3), for implicit mode weighted prediction in B slices (see clause 8.4.2.3.2), and \nfor decoder conformance checking (see clause C.4). \nPicture order count information is derived for every frame, field (whether decoded from a coded field or as a part of a \ndecoded frame), or complementary field pair as follows: \n–  Each coded frame is associated with two picture order counts, called TopFieldOrderCnt and BottomFieldOrderCnt \nfor its top field and bottom field, respectively. \n–  Each  coded  field  is  associated  with  a  picture  order  count,  called TopFieldOrderCnt  for  a  coded  top  field  and \nBottomFieldOrderCnt for a bottom field. \n–  Each complementary field pair is associated with two picture order counts, which are the TopFieldOrderCnt for its \ncoded top field and the BottomFieldOrderCnt for its coded bottom field, respectively. \nTopFieldOrderCnt and BottomFieldOrderCnt indicate the picture order of the corresponding top field or bottom field \nrelative  to  the  first  output  field  of  the  previous  IDR  picture  or  the  previous  reference  picture  including  a \nmemory_management_control_operation equal to 5 in decoding order. \nTopFieldOrderCnt and BottomFieldOrderCnt are derived by invoking one of the decoding processes for picture order \ncount  type  0,  1,  and  2  in  clauses 8.2.1.1,  8.2.1.2,  and  8.2.1.3,  respectively.  When  the  current  picture  includes  a \nmemory_management_control_operation equal to 5, after the decoding of the current picture, tempPicOrderCnt is set equal \nto  PicOrderCnt( CurrPic ),  TopFieldOrderCnt  of  the  current  picture  (if  any)  is  set  equal  to \nTopFieldOrderCnt − tempPicOrderCnt,  and  BottomFieldOrderCnt  of  the  current  picture  (if  any)  is  set  equal  to \nBottomFieldOrderCnt − tempPicOrderCnt. \nNOTE 1 – When the decoding process for a picture currPic that includes a memory_management_control_operation equal to 5 refers \nto the values of  TopFieldOrderCnt (if applicable) or BottomFieldOrderCnt (if applicable) for the picture currPic (including \nreferences to the function PicOrderCnt( ) with the picture currPic as the argument and references to the function DiffPicOrderCnt( ) \nwith one of the arguments being currPic), the values of TopFieldOrderCnt (if applicable) and BottomFieldOrderCnt (if applicable) \nthat are derived as specified in clauses 8.2.1.1, 8.2.1.2, and 8.2.1.3 for the picture currPic are used. When the decoding process for \na picture refers to the values TopFieldOrderCnt (if applicable) or BottomFieldOrderCnt (if applicable) of the previous picture \nprevMmco5Pic in decoding order that includes a memory_management_control_operation equal to 5 (including references via the \nfunctions PicOrderCnt( ) or DiffPicOrderCnt( )), the values of TopFieldOrderCnt (if applicable) and BottomFieldOrderCnt (if \napplicable) that are used for the picture prevMmco5Pic are the values after the modification specified in the paragraph above \n(resulting in TopFieldOrderCnt and/or BottomFieldOrderCnt equal to 0). \nThe bitstream shall not contain data that result in Min( TopFieldOrderCnt, BottomFieldOrderCnt ) not equal to 0 for a \ncoded IDR frame, TopFieldOrderCnt not equal to 0 for a coded IDR top field, or BottomFieldOrderCnt not equal to 0 for \na coded IDR bottom field. Thus, at least one of TopFieldOrderCnt and BottomFieldOrderCnt shall be equal to 0 for the \nfields of a coded IDR frame. \nWhen the current picture is not an IDR picture, the following applies: \n1)  Consider the list variable listD containing as elements the TopFieldOrderCnt and BottomFieldOrderCnt values \nassociated with the list of pictures including all of the following: \na.  The first picture in the list is the previous picture of any of the following types: \n–  an IDR picture, \n–  a picture containing a memory_management_control_operation equal to 5. \nb.  The following additional pictures: \n–  If pic_order_cnt_type is equal to 0, all other pictures that follow in decoding order after the first picture \nin the list and are not \"non-existing\" frames inferred by the decoding process for gaps in frame_num \nspecified in clause 8.2.5.2 and either precede the current picture in decoding order or are the current \npicture. When pic_order_cnt_type is equal to 0 and the current picture is not a \"non-existing\" frame \ninferred by the decoding process for gaps in frame_num specified in clause 8.2.5.2, the current picture \nis included in listD prior to the invoking of the decoded reference picture marking process. \n–  Otherwise (pic_order_cnt_type is not equal to 0), all other pictures that follow in decoding order after \nthe first picture in the list and either precede the current picture in decoding order or are the current \n    Rec. ITU-T H.264 (06/2019)  113 \n \npicture. When pic_order_cnt_type is not equal to 0, the current picture is included in listD prior to the \ninvoking of the decoded reference picture marking process. \n2)  Consider the list variable listO which contains the elements of listD sorted in ascending order. listO shall not \ncontain any of the following: \n–  a pair of TopFieldOrderCnt and BottomFieldOrderCnt for a frame or complementary field pair that are not \nat consecutive positions in listO, \n–  a TopFieldOrderCnt that has a value equal to another TopFieldOrderCnt, \n–  a BottomFieldOrderCnt that has a value equal to another BottomFieldOrderCnt, \n–  a BottomFieldOrderCnt that has a value equal to a TopFieldOrderCnt unless the BottomFieldOrderCnt and \nTopFieldOrderCnt belong to the same coded frame or complementary field pair. \nThe bitstream shall not contain data that result in values of TopFieldOrderCnt, BottomFieldOrderCnt, PicOrderCntMsb, \nor FrameNumOffset used in the decoding process as specified in clauses 8.2.1.1 to 8.2.1.3 that exceed the range of values \nfrom −231 to 231 − 1, inclusive. \nThe function PicOrderCnt( picX ) is specified as follows: \nif( picX is a frame or a complementary field pair )  \n  PicOrderCnt( picX ) = Min( TopFieldOrderCnt, BottomFieldOrderCnt ) of the frame or complementary field \npair picX \nelse if( picX is a top field )  \n  PicOrderCnt( picX ) = TopFieldOrderCnt of field picX  (8-1) \nelse if( picX is a bottom field )  \n  PicOrderCnt( picX ) = BottomFieldOrderCnt of field picX \nThen DiffPicOrderCnt( picA, picB ) is specified as follows: \nDiffPicOrderCnt( picA, picB ) = PicOrderCnt( picA ) − PicOrderCnt( picB )  (8-2) \nThe bitstream shall not contain data that result in values of DiffPicOrderCnt( picA, picB ) used in the decoding process \nthat exceed the range of −215 to 215 − 1, inclusive. \nNOTE 2 – Let X be the current picture and Y and Z be two other pictures in the same sequence, Y and Z are considered to be in the \nsame output order direction from X when both DiffPicOrderCnt( X, Y ) and DiffPicOrderCnt( X, Z ) are positive or both are negative. \nNOTE 3  –  Many  encoders  assign  TopFieldOrderCnt  and  BottomFieldOrderCnt  proportional  to  the  sampling  time  of  the \ncorresponding field (which is either a coded field or a field of a coded frame) relative to the sampling time of the first output field \nof  the  previous  IDR  picture  or  the  previous  reference  picture  (in  decoding  order)  that  includes  a \nmemory_management_control_operation equal to 5. \nWhen the current picture includes a memory_management_control_operation equal to 5, PicOrderCnt( CurrPic ) shall be \ngreater than PicOrderCnt( any other picture in listD ). \n8.2.1.1  Decoding process for picture order count type 0 \nThis process is invoked when pic_order_cnt_type is equal to 0. \nInput to this process is PicOrderCntMsb of the previous reference picture in decoding order as specified in this clause. \nOutputs of this process are either or both TopFieldOrderCnt or BottomFieldOrderCnt. \nThe variables prevPicOrderCntMsb and prevPicOrderCntLsb are derived as follows: \n–  If the current picture is an IDR picture, prevPicOrderCntMsb is set equal to 0 and prevPicOrderCntLsb is set equal \nto 0. \n–  Otherwise (the current picture is not an IDR picture), the following applies: \n–  If the previous reference picture in decoding order included a memory_management_control_operation equal \nto 5, the following applies: \n–  If the previous reference picture in decoding order is not a bottom field, prevPicOrderCntMsb is set equal \nto 0 and prevPicOrderCntLsb is set equal to the value of TopFieldOrderCnt for the previous reference \npicture in decoding order. \n–  Otherwise (the previous reference picture in decoding order is a bottom field), prevPicOrderCntMsb is set \nequal to 0 and prevPicOrderCntLsb is set equal to 0. \n114  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise  (the  previous  reference  picture  in  decoding  order  did  not  include  a \nmemory_management_control_operation equal to 5), prevPicOrderCntMsb is set equal to PicOrderCntMsb of \nthe  previous  reference  picture  in  decoding  order  and  prevPicOrderCntLsb  is  set  equal  to  the  value  of \npic_order_cnt_lsb of the previous reference picture in decoding order. \nPicOrderCntMsb of the current picture is derived as specified by the following pseudo-code: \nif( ( pic_order_cnt_lsb  <  prevPicOrderCntLsb )  &&   \n     ( ( prevPicOrderCntLsb − pic_order_cnt_lsb )  >=  ( MaxPicOrderCntLsb / 2 ) ) ) \n  PicOrderCntMsb = prevPicOrderCntMsb + MaxPicOrderCntLsb  (8-3) \nelse if( ( pic_order_cnt_lsb  >  prevPicOrderCntLsb )  && \n            ( ( pic_order_cnt_lsb − prevPicOrderCntLsb )  >  ( MaxPicOrderCntLsb / 2 ) ) ) \n  PicOrderCntMsb = prevPicOrderCntMsb − MaxPicOrderCntLsb \nelse \n  PicOrderCntMsb = prevPicOrderCntMsb \nWhen the current picture is not a bottom field, TopFieldOrderCnt is derived as \nTopFieldOrderCnt = PicOrderCntMsb + pic_order_cnt_lsb  (8-4) \nWhen the current picture is not a top field, BottomFieldOrderCnt is derived as specified by the following pseudo-code: \nif( !field_pic_flag ) \n  BottomFieldOrderCnt = TopFieldOrderCnt + delta_pic_order_cnt_bottom \nelse          (8-5) \n  BottomFieldOrderCnt = PicOrderCntMsb + pic_order_cnt_lsb \n8.2.1.2  Decoding process for picture order count type 1 \nThis process is invoked when pic_order_cnt_type is equal to 1. \nInput to this process is FrameNumOffset of the previous picture in decoding order as specified in this clause. \nOutputs of this process are either or both TopFieldOrderCnt or BottomFieldOrderCnt. \nThe values of TopFieldOrderCnt and BottomFieldOrderCnt are derived as specified in this clause. Let prevFrameNum be \nequal to the frame_num of the previous picture in decoding order. \nWhen the current picture is not an IDR picture, the variable prevFrameNumOffset is derived as follows: \n–  If  the  previous  picture  in  decoding  order  included  a  memory_management_control_operation  equal  to  5, \nprevFrameNumOffset is set equal to 0. \n–  Otherwise (the previous picture in decoding order did not include a memory_management_control_operation equal \nto 5), prevFrameNumOffset is set equal to the value of FrameNumOffset of the previous picture in decoding order. \nNOTE  –  When  gaps_in_frame_num_value_allowed_flag  is  equal  to  1,  the  previous  picture  in  decoding  order  may  be  a \n\"non-existing\" frame inferred by the decoding process for gaps in frame_num specified in clause 8.2.5.2. \nThe variable FrameNumOffset is derived as specified by the following pseudo-code: \nif( IdrPicFlag  = =  1 ) \n  FrameNumOffset = 0 \nelse if( prevFrameNum > frame_num )     (8-6) \n  FrameNumOffset = prevFrameNumOffset + MaxFrameNum \nelse \n  FrameNumOffset = prevFrameNumOffset \nThe variable absFrameNum is derived as specified by the following pseudo-code: \nif( num_ref_frames_in_pic_order_cnt_cycle  !=  0 ) \n  absFrameNum = FrameNumOffset + frame_num \nelse      (8-7) \n  absFrameNum = 0 \nif( nal_ref_idc  = =  0  &&  absFrameNum  >  0 ) \n  absFrameNum = absFrameNum − 1 \n    Rec. ITU-T H.264 (06/2019)  115 \n \nWhen absFrameNum > 0, picOrderCntCycleCnt and frameNumInPicOrderCntCycle are derived as \npicOrderCntCycleCnt = ( absFrameNum − 1 ) / num_ref_frames_in_pic_order_cnt_cycle \nframeNumInPicOrderCntCycle = ( absFrameNum − 1 ) % num_ref_frames_in_pic_order_cnt_cycle  (8-8) \nThe variable expectedPicOrderCnt is derived as specified by the following pseudo-code: \nif( absFrameNum > 0 ) { \n  expectedPicOrderCnt = picOrderCntCycleCnt * ExpectedDeltaPerPicOrderCntCycle \n  for( i = 0; i <= frameNumInPicOrderCntCycle; i++ ) \n    expectedPicOrderCnt = expectedPicOrderCnt + offset_for_ref_frame[ i ] \n} else \n  expectedPicOrderCnt = 0 \nif( nal_ref_idc  = =  0 )     (8-9) \n  expectedPicOrderCnt = expectedPicOrderCnt + offset_for_non_ref_pic \nThe variables TopFieldOrderCnt or BottomFieldOrderCnt are derived as specified by the following pseudo-code: \nif( !field_pic_flag ) { \n  TopFieldOrderCnt = expectedPicOrderCnt + delta_pic_order_cnt[ 0 ] \n  BottomFieldOrderCnt = TopFieldOrderCnt + \n      offset_for_top_to_bottom_field + delta_pic_order_cnt[ 1 ]   (8-10) \n} else if( !bottom_field_flag ) \n  TopFieldOrderCnt = expectedPicOrderCnt + delta_pic_order_cnt[ 0 ] \nelse \n  BottomFieldOrderCnt = expectedPicOrderCnt + offset_for_top_to_bottom_field + delta_pic_order_cnt[ 0 ] \n8.2.1.3  Decoding process for picture order count type 2 \nThis process is invoked when pic_order_cnt_type is equal to 2. \nOutputs of this process are either or both TopFieldOrderCnt or BottomFieldOrderCnt. \nLet prevFrameNum be equal to the frame_num of the previous picture in decoding order. \nWhen the current picture is not an IDR picture, the variable prevFrameNumOffset is derived as follows: \n–  If  the  previous  picture  in  decoding  order  included  a  memory_management_control_operation  equal  to  5, \nprevFrameNumOffset is set equal to 0. \n–  Otherwise (the previous picture in decoding order did not include a memory_management_control_operation equal \nto 5), prevFrameNumOffset is set equal to the value of FrameNumOffset of the previous picture in decoding order. \nNOTE  1  –  When  gaps_in_frame_num_value_allowed_flag  is  equal  to  1,  the  previous  picture  in  decoding  order  may  be  a \n\"non-existing\" frame inferred by the decoding process for gaps in frame_num specified in clause 8.2.5.2. \nThe variable FrameNumOffset is derived as specified by the following pseudo-code: \nif( IdrPicFlag  = =  1 ) \n  FrameNumOffset = 0 \nelse if( prevFrameNum  >  frame_num )     (8-11) \n  FrameNumOffset = prevFrameNumOffset + MaxFrameNum \nelse \n  FrameNumOffset = prevFrameNumOffset \nThe variable tempPicOrderCnt is derived as specified by the following pseudo-code: \nif( IdrPicFlag  = =  1 ) \n  tempPicOrderCnt = 0 \nelse if( nal_ref_idc  = =  0 )     (8-12) \n  tempPicOrderCnt = 2 * ( FrameNumOffset + frame_num ) − 1 \nelse \n  tempPicOrderCnt = 2 * ( FrameNumOffset + frame_num ) \n116  Rec. ITU-T H.264 (06/2019) \n \nThe variables TopFieldOrderCnt or BottomFieldOrderCnt are derived as specified by the following pseudo-code: \nif( !field_pic_flag ) { \n  TopFieldOrderCnt = tempPicOrderCnt \n  BottomFieldOrderCnt = tempPicOrderCnt    (8-13) \n} else if( bottom_field_flag ) \n  BottomFieldOrderCnt = tempPicOrderCnt \nelse \n  TopFieldOrderCnt = tempPicOrderCnt \nNOTE 2 – Picture order count type 2 cannot be used in a coded video sequence that contains consecutive non-reference pictures that \nwould result in more than one of these pictures having the same value of TopFieldOrderCnt or more than one of these pictures \nhaving the same value of BottomFieldOrderCnt. \nNOTE 3 – Picture order count type 2 results in an output order that is the same as the decoding order. \n8.2.2  Decoding process for macroblock to slice group map \nInputs to this process are the active picture parameter set and the slice header of the slice to be decoded. \nOutput of this process is a macroblock to slice group map MbToSliceGroupMap. \nThis process is invoked at the start of every slice. \nNOTE – The output of this process is equal for all slices of a picture. \nWhen num_slice_groups_minus1 is equal to 1 and slice_group_map_type is equal to 3, 4, or 5, slice groups 0 and 1 have \na size and shape determined by slice_group_change_direction_flag as shown in Table 8-1 and specified in clauses 8.2.2.4 \nto 8.2.2.6. \nTable 8-1 – Refined slice group map type \n \nslice_group_map_type  slice_group_change_direction_flag  refined slice group map type \n3  0  Box-out clockwise \n3  1  Box-out counter-clockwise \n4  0  Raster scan \n4  1  Reverse raster scan \n5  0  Wipe right \n5  1  Wipe left \n \nIn such a case, MapUnitsInSliceGroup0 slice group map units in the specified growth order are allocated for slice group 0 \nand the remaining PicSizeInMapUnits − MapUnitsInSliceGroup0 slice group map units of the picture are allocated for \nslice group 1. \nWhen  num_slice_groups_minus1  is  equal  to 1  and  slice_group_map_type  is  equal  to 4  or  5,  the  variable \nsizeOfUpperLeftGroup is defined as follows: \nsizeOfUpperLeftGroup = ( slice_group_change_direction_flag ?  \n                         ( PicSizeInMapUnits − MapUnitsInSliceGroup0 ) : MapUnitsInSliceGroup0 )  (8-14) \nThe mapUnitToSliceGroupMap array is derived as follows: \n–  If num_slice_groups_minus1 is equal to 0, the map unit to slice group map is generated for all i ranging from 0 to \nPicSizeInMapUnits − 1, inclusive, as specified by \nmapUnitToSliceGroupMap[ i ] = 0    (8-15) \n–  Otherwise (num_slice_groups_minus1 is not equal to 0), mapUnitToSliceGroupMap is derived as follows: \n–  If  slice_group_map_type  is  equal  to 0,  the  derivation  of  mapUnitToSliceGroupMap  as  specified  in \nclause 8.2.2.1 applies. \n–  Otherwise, if slice_group_map_type is equal to 1, the derivation of mapUnitToSliceGroupMap as specified in \nclause 8.2.2.2 applies. \n–  Otherwise, if slice_group_map_type is equal to 2, the derivation of mapUnitToSliceGroupMap as specified in \nclause 8.2.2.3 applies. \n    Rec. ITU-T H.264 (06/2019)  117 \n \n–  Otherwise, if slice_group_map_type is equal to 3, the derivation of mapUnitToSliceGroupMap as specified in \nclause 8.2.2.4 applies. \n–  Otherwise, if slice_group_map_type is equal to 4, the derivation of mapUnitToSliceGroupMap as specified in \nclause 8.2.2.5 applies. \n–  Otherwise, if slice_group_map_type is equal to 5, the derivation of mapUnitToSliceGroupMap as specified in \nclause 8.2.2.6 applies. \n–  Otherwise (slice_group_map_type is equal to 6), the derivation of mapUnitToSliceGroupMap as specified in \nclause 8.2.2.7 applies. \nAfter derivation of the mapUnitToSliceGroupMap, the process specified in clause 8.2.2.8 is invoked to convert the map \nunit to slice group map mapUnitToSliceGroupMap to the macroblock to slice group map MbToSliceGroupMap. After \nderivation of the macroblock to slice group map as specified in clause 8.2.2.8, the function NextMbAddress( n ) is defined \nas the value of the variable nextMbAddress derived as specified by the following pseudo-code: \ni = n + 1 \nwhile( i < PicSizeInMbs  &&  MbToSliceGroupMap[ i ]  !=  MbToSliceGroupMap[ n ] ) \n  i++; \nnextMbAddress = i    (8-16) \n8.2.2.1  Specification for interleaved slice group map type \nThe specifications in this clause apply when slice_group_map_type is equal to 0. \nThe map unit to slice group map is generated as specified by the following pseudo-code: \ni = 0 \ndo \n  for( iGroup = 0; iGroup <= num_slice_groups_minus1 && i < PicSizeInMapUnits; \n             i += run_length_minus1[ iGroup++ ] + 1 ) \n    for( j = 0; j <= run_length_minus1[ iGroup ] && i + j < PicSizeInMapUnits; j++ ) \n      mapUnitToSliceGroupMap[ i + j ] = iGroup  (8-17) \nwhile( i < PicSizeInMapUnits ) \n8.2.2.2  Specification for dispersed slice group map type \nThe specifications in this clause apply when slice_group_map_type is equal to 1. \nThe map unit to slice group map is generated as specified by the following pseudo-code: \nfor( i = 0; i < PicSizeInMapUnits; i++ ) \n  mapUnitToSliceGroupMap[ i ] = ( ( i % PicWidthInMbs ) +  \n                                                              ( ( ( i / PicWidthInMbs ) * ( num_slice_groups_minus1 + 1 ) ) / 2 ) ) \n                                                            % ( num_slice_groups_minus1 + 1 )  (8-18) \n8.2.2.3  Specification for foreground with left-over slice group map type \nThe specifications in this clause apply when slice_group_map_type is equal to 2. \nThe map unit to slice group map is generated as specified by the following pseudo-code: \nfor( i = 0; i < PicSizeInMapUnits; i++ ) \n  mapUnitToSliceGroupMap[ i ] = num_slice_groups_minus1 \nfor( iGroup = num_slice_groups_minus1 − 1; iGroup >= 0; iGroup− − ) { \n  yTopLeft = top_left[ iGroup ] / PicWidthInMbs \n  xTopLeft = top_left[ iGroup ] % PicWidthInMbs \n  yBottomRight = bottom_right[ iGroup ] / PicWidthInMbs \n  xBottomRight = bottom_right[ iGroup ] % PicWidthInMbs \n  for( y = yTopLeft; y <= yBottomRight; y++ ) \n    for( x = xTopLeft; x <= xBottomRight; x++ ) \n      mapUnitToSliceGroupMap[ y * PicWidthInMbs + x ] = iGroup  (8-19) \n} \nNOTE – The rectangles may overlap. Slice group 0 contains the macroblocks that are within the rectangle specified by top_left[ 0 ] \nand bottom_right[ 0 ]. A slice group having slice group ID greater than 0 and less than num_slice_groups_minus1 contains the \nmacroblocks that are within the specified rectangle for that slice group that are not within the rectangle specified for any slice group \n118  Rec. ITU-T H.264 (06/2019) \n \nhaving a smaller slice group ID. The slice group with slice group ID equal to num_slice_groups_minus1 contains the macroblocks \nthat are not in the other slice groups. \n8.2.2.4  Specification for box-out slice group map types \nThe specifications in this clause apply when slice_group_map_type is equal to 3. \nThe map unit to slice group map is generated as specified by \nfor( i = 0; i < PicSizeInMapUnits; i++ ) \n  mapUnitToSliceGroupMap[ i ] = 1 \nx = ( PicWidthInMbs − slice_group_change_direction_flag ) / 2 \ny = ( PicHeightInMapUnits − slice_group_change_direction_flag ) / 2 \n( leftBound, topBound ) = ( x, y ) \n( rightBound, bottomBound ) = ( x, y ) \n( xDir, yDir ) = ( slice_group_change_direction_flag − 1, slice_group_change_direction_flag ) \nfor( k = 0; k < MapUnitsInSliceGroup0; k += mapUnitVacant ) { \n  mapUnitVacant = ( mapUnitToSliceGroupMap[ y * PicWidthInMbs + x ]  = =  1 ) \n  if( mapUnitVacant ) \n    mapUnitToSliceGroupMap[ y * PicWidthInMbs + x ] = 0   (8-20) \n  if( xDir  = =  −1  &&  x  = =  leftBound ) { \n    leftBound = Max( leftBound − 1, 0 ) \n    x = leftBound \n    ( xDir, yDir ) = ( 0, 2 * slice_group_change_direction_flag − 1 ) \n  } else if( xDir  = =  1  &&  x  = =  rightBound ) { \n    rightBound = Min( rightBound + 1, PicWidthInMbs − 1 ) \n    x = rightBound \n    ( xDir, yDir ) = ( 0, 1 − 2 * slice_group_change_direction_flag ) \n  } else if( yDir  = =  −1  &&  y  = =  topBound ) { \n    topBound = Max( topBound − 1, 0 ) \n    y = topBound \n    ( xDir, yDir ) = ( 1 − 2 * slice_group_change_direction_flag, 0 ) \n  } else if( yDir  = =  1  &&  y  = =  bottomBound ) { \n    bottomBound  =  Min( bottomBound + 1, PicHeightInMapUnits − 1 ) \n    y = bottomBound \n    ( xDir, yDir ) = ( 2 * slice_group_change_direction_flag − 1, 0 ) \n  } else \n    ( x, y ) = ( x + xDir, y + yDir ) \n} \n8.2.2.5  Specification for raster scan slice group map types \nThe specifications in this clause apply when slice_group_map_type is equal to 4. \nThe map unit to slice group map is generated as specified by \nfor( i = 0; i < PicSizeInMapUnits; i++ ) \n  if( i < sizeOfUpperLeftGroup ) \n    mapUnitToSliceGroupMap[ i ] = slice_group_change_direction_flag \n  else        (8-21) \n    mapUnitToSliceGroupMap[ i ] = 1 − slice_group_change_direction_flag \n8.2.2.6  Specification for wipe slice group map types \nThe specifications in this clause apply when slice_group_map_type is equal to 5. \nThe map unit to slice group map is generated as specified by \nk = 0; \nfor( j = 0; j < PicWidthInMbs; j++ ) \n  for( i = 0; i < PicHeightInMapUnits; i++ ) \n    if( k++ < sizeOfUpperLeftGroup ) \n      mapUnitToSliceGroupMap[ i * PicWidthInMbs + j ] = slice_group_change_direction_flag \n    else      (8-22) \n      mapUnitToSliceGroupMap[ i * PicWidthInMbs + j ] = 1 − slice_group_change_direction_flag \n    Rec. ITU-T H.264 (06/2019)  119 \n \n8.2.2.7  Specification for explicit slice group map type \nThe specifications in this clause apply when slice_group_map_type is equal to 6. \nThe map unit to slice group map is generated as specified by \nmapUnitToSliceGroupMap[ i ] = slice_group_id[ i ]  (8-23) \nfor all i ranging from 0 to PicSizeInMapUnits − 1, inclusive. \n8.2.2.8  Specification for conversion of map unit to slice group map to macroblock to slice group map \nFor each value of i ranging from 0 to PicSizeInMbs − 1, inclusive, the macroblock to slice group map is specified as \nfollows: \n–  If frame_mbs_only_flag is equal to 1 or field_pic_flag is equal to 1, the macroblock to slice group map is specified \nby \nMbToSliceGroupMap[ i ] = mapUnitToSliceGroupMap[ i ]  (8-24) \n–  Otherwise, if MbaffFrameFlag is equal to 1, the macroblock to slice group map is specified by \nMbToSliceGroupMap[ i ] = mapUnitToSliceGroupMap[ i / 2 ]  (8-25) \n–  Otherwise (frame_mbs_only_flag is equal to 0 and mb_adaptive_frame_field_flag is equal to 0 and field_pic_flag is \nequal to 0), the macroblock to slice group map is specified by \nMbToSliceGroupMap[ i ] = mapUnitToSliceGroupMap[ ( i / ( 2 * PicWidthInMbs ) ) * PicWidthInMbs \n                                                                                            + ( i % PicWidthInMbs ) ]  (8-26) \n8.2.3  Decoding process for slice data partitions \nInputs to this process are: \n–  a slice data partition A layer RBSP, \n–  when syntax elements of category 3 are present in the slice data, a slice data partition B layer RBSP having the same \nslice_id as in the slice data partition A layer RBSP, \n–  when syntax elements of category 4 are present in the slice data, a slice data partition C layer RBSP having the same \nslice_id as in the slice data partition A layer RBSP. \nNOTE 1 – The slice data partition B layer RBSP and slice data partition C layer RBSP need not be present. \nOutput of this process is a coded slice. \nWhen slice data partitioning is not used, coded slices are represented by a slice layer without partitioning RBSP that \ncontains a slice header followed by a slice data syntax structure that contains all the syntax elements of categories 2, 3, and \n4 (see category column in clause 7.3) of the macroblock data for the macroblocks of the slice. \nWhen slice data partitioning is used, the macroblock data of a slice is partitioned into one to three partitions contained in \nseparate NAL units. Partition A contains a slice data partition A header, and all syntax elements of category 2. Partition B, \nwhen present, contains a slice data partition B header and all syntax elements of category 3. Partition C, when present, \ncontains a slice data partition C header and all syntax elements of category 4. \nWhen slice data partitioning is used, the syntax elements of each category are parsed from a separate NAL unit, which \nneed not be present when no symbols of the respective category exist. The decoding process shall process the slice data \npartitions of a coded slice in a manner equivalent to processing a corresponding slice layer without partitioning RBSP by \nextracting each syntax element from the slice data partition in which the syntax element appears depending on the slice \ndata partition assignment in the syntax tables in clause 7.3. \nNOTE 2 – Syntax elements of category 3 are relevant to the decoding of residual data of I and SI macroblock types. Syntax elements \nof category 4 are relevant to the decoding of residual data of P and B macroblock types. Category 2 encompasses all other syntax \nelements related to the decoding of macroblocks, and their information is often denoted as header information. The slice data \npartition A header contains all the syntax elements of the slice header, and additionally a slice_id that are used to associate the slice \ndata partitions B and C with the slice data partition A. The slice data partition B and C headers contain the slice_id syntax element \nthat establishes their association with the slice data partition A of the slice. \n120  Rec. ITU-T H.264 (06/2019) \n \n8.2.4  Decoding process for reference picture lists construction \nThis process is invoked at the beginning of the decoding process for each P, SP, or B slice. \nDecoded reference pictures are marked as \"used for short-term reference\" or \"used for long-term reference\" as specified \nby the bitstream and specified in clause 8.2.5. Short-term reference pictures are identified by the value of frame_num. \nLong-term  reference  pictures  are  assigned  a  long-term  frame  index  as  specified  by  the  bitstream  and  specified  in \nclause 8.2.5. \nClause 8.2.4.1 is invoked to specify \n–  the assignment of variables FrameNum, FrameNumWrap, and PicNum to each of the short-term reference pictures, \nand \n–  the assignment of variable LongTermPicNum to each of the long-term reference pictures. \nReference pictures are addressed through reference indices as specified in clause 8.4.2.1. A reference index is an index \ninto a reference picture list. When decoding a P or SP slice, there is a single reference picture list RefPicList0. When \ndecoding a B slice, there is a second independent reference picture list RefPicList1 in addition to RefPicList0. \nAt the beginning of the decoding process for each slice, reference picture list RefPicList0, and for B slices RefPicList1, \nare derived as specified by the following ordered steps: \n1.  An initial reference picture list RefPicList0 and for B slices RefPicList1 are derived as specified in clause 8.2.4.2. \n2.  When  ref_pic_list_modification_flag_l0  is  equal  to 1  or,  when  decoding  a  B  slice, \nref_pic_list_modification_flag_l1 is equal to 1, the initial reference picture list RefPicList0 and, for B slices, \nRefPicList1 are modified as specified in clause 8.2.4.3. \nNOTE  –  The  modification  process  for  reference  picture  lists  specified  in  clause 8.2.4.3  allows  the  contents  of \nRefPicList0 and for B slices RefPicList1 to be modified in a flexible fashion. In particular, it is possible for a picture \nthat is currently marked \"used for reference\" to be inserted into RefPicList0 and for B slices RefPicList1 even when the \npicture is not in the initial reference picture list derived as specified in clause 8.2.4.2. \nThe number of entries in the modified reference picture list RefPicList0 is num_ref_idx_l0_active_minus1 + 1, and for B \nslices the number of entries in the modified reference picture list RefPicList1 is num_ref_idx_l1_active_minus1 + 1. A \nreference picture may appear at more than one index in the modified reference picture lists RefPicList0 or RefPicList1. \n8.2.4.1  Decoding process for picture numbers \nThis process is invoked when the decoding process for reference picture lists construction specified in clause 8.2.4, the \ndecoded reference picture marking process specified in clause 8.2.5, or the decoding process for gaps in frame_num \nspecified in clause 8.2.5.2 is invoked. \nThe  variables  FrameNum,  FrameNumWrap,  PicNum,  LongTermFrameIdx,  and  LongTermPicNum  are  used  for  the \ninitialization process for reference picture lists in clause 8.2.4.2, the modification process for reference picture lists in \nclause 8.2.4.3, the decoded reference picture  marking process in  clause 8.2.5, and the decoding process for gaps in \nframe_num in clause 8.2.5.2. \nTo  each  short-term  reference  picture  the  variables  FrameNum  and  FrameNumWrap  are  assigned  as  follows.  First, \nFrameNum is set equal to the syntax element frame_num that has been decoded in the slice header(s) of the corresponding \nshort-term reference picture. Then the variable FrameNumWrap is derived as \nif( FrameNum > frame_num ) \n  FrameNumWrap = FrameNum − MaxFrameNum   (8-27) \nelse \n  FrameNumWrap = FrameNum \nwhere the value of frame_num used in Equation 8-27 is the frame_num in the slice header(s) for the current picture. \nEach long-term reference picture has an associated value of LongTermFrameIdx (that was assigned to it as specified in \nclause 8.2.5). \nTo each short-term reference picture a variable PicNum is assigned, and to each long-term reference picture a variable \nLongTermPicNum is assigned. The values of these variables depend on the value of field_pic_flag and bottom_field_flag \nfor the current picture and they are set as follows: \n    Rec. ITU-T H.264 (06/2019)  121 \n \n–  If field_pic_flag is equal to 0, the following ordered steps are specified: \n1.  For each short-term reference frame or complementary reference field pair: \nPicNum = FrameNumWrap    (8-28) \n2.  For each long-term reference frame or long-term complementary reference field pair: \nLongTermPicNum = LongTermFrameIdx  (8-29) \nNOTE  –  When  decoding  a  frame  the  value  of  MbaffFrameFlag  has  no  influence  on  the  derivations  in \nclauses 8.2.4.2, 8.2.4.3, and 8.2.5. \n–  Otherwise (field_pic_flag is equal to 1), the following ordered steps are specified: \n1.  For each short-term reference field the following applies: \n–  If the reference field has the same parity as the current field \nPicNum = 2 * FrameNumWrap + 1   (8-30) \n–  Otherwise (the reference field has the opposite parity of the current field), \nPicNum = 2 * FrameNumWrap    (8-31) \n2.  For each long-term reference field the following applies: \n–  If the reference field has the same parity as the current field \nLongTermPicNum = 2 * LongTermFrameIdx + 1  (8-32) \n–  Otherwise (the reference field has the opposite parity of the current field), \nLongTermPicNum = 2 * LongTermFrameIdx  (8-33) \n8.2.4.2  Initialization process for reference picture lists \nThis initialization process is invoked when decoding a P, SP, or B slice header. \nRefPicList0 and RefPicList1 have initial entries as specified in clauses 8.2.4.2.1 through 8.2.4.2.5. \nWhen the number of entries in the initial RefPicList0 or RefPicList1 produced as specified in clauses 8.2.4.2.1 through \n8.2.4.2.5 is greater than num_ref_idx_l0_active_minus1 + 1 or num_ref_idx_l1_active_minus1 + 1, respectively, the extra \nentries past position num_ref_idx_l0_active_minus1 or num_ref_idx_l1_active_minus1 are discarded from the initial \nreference picture list. \nWhen the number of entries in the initial RefPicList0 or RefPicList1 produced as specified in clauses 8.2.4.2.1 through \n8.2.4.2.5  is  less  than  num_ref_idx_l0_active_minus1 + 1  or  num_ref_idx_l1_active_minus1 + 1,  respectively,  the \nremaining entries in the initial reference picture list are set equal to \"no reference picture\". \n8.2.4.2.1 Initialization process for the reference picture list for P and SP slices in frames \nThis initialization process is invoked when decoding a P or SP slice in a coded frame. \nWhen this process is invoked, there shall be at least one reference frame or complementary reference field pair that is \ncurrently marked as \"used for reference\" (i.e., as \"used for short-term reference\" or \"used for long-term reference\") and is \nnot marked as \"non-existing\". \nThe reference picture list RefPicList0 is ordered so that short-term reference frames and short-term complementary \nreference field pairs have lower indices than long-term reference frames and long-term complementary reference field \npairs. \nThe  short-term  reference  frames  and  complementary  reference  field  pairs  are  ordered  starting  with  the  frame  or \ncomplementary field pair with the highest PicNum value and proceeding through in descending order to the frame or \ncomplementary field pair with the lowest PicNum value. \nThe  long-term  reference  frames  and  complementary  reference  field  pairs  are  ordered  starting  with  the  frame  or \ncomplementary field pair with the lowest LongTermPicNum value and proceeding through in ascending order to the frame \nor complementary field pair with the highest LongTermPicNum value. \n122  Rec. ITU-T H.264 (06/2019) \n \nNOTE  –  A  non-paired  reference  field  is  not  used  for  inter  prediction  for  decoding  a  frame,  regardless  of  the  value  of \nMbaffFrameFlag. \nFor example, when three reference frames are marked as \"used for short-term reference\" with PicNum equal to 300, 302, \nand 303 and two reference frames are marked as \"used for long-term reference\" with LongTermPicNum equal to 0 and 3, \nthe initial index order is: \n–  RefPicList0[ 0 ] is set equal to the short-term reference picture with PicNum = 303, \n–  RefPicList0[ 1 ] is set equal to the short-term reference picture with PicNum = 302, \n–  RefPicList0[ 2 ] is set equal to the short-term reference picture with PicNum = 300, \n–  RefPicList0[ 3 ] is set equal to the long-term reference picture with LongTermPicNum = 0, \n–  RefPicList0[ 4 ] is set equal to the long-term reference picture with LongTermPicNum = 3. \n8.2.4.2.2 Initialization process for the reference picture list for P and SP slices in fields \nThis initialization process is invoked when decoding a P or SP slice in a coded field. \nWhen this process is invoked, there shall be at least one reference field (which can be a field of a reference frame) that is \ncurrently marked as \"used for reference\" (i.e., as \"used for short-term reference\" or \"used for long-term reference\") and is \nnot marked as \"non-existing\". \nEach field included in the reference picture list RefPicList0 has a separate index in the reference picture list RefPicList0. \nNOTE – When decoding a field, there are effectively at least twice as many pictures available for referencing as there would be \nwhen decoding a frame at the same position in decoding order. \nTwo ordered lists of reference frames, refFrameList0ShortTerm and refFrameList0LongTerm, are derived as follows. For \npurposes of the formation of this list of frames, decoded reference frames, complementary reference field pairs, non-paired \nreference fields and reference frames in which a single field is marked \"used for short-term reference\" or \"used for long-\nterm reference\" are all considered reference frames. \n1.  All frames having one or more fields marked \"used for short-term reference\" are included in the list of short-term \nreference frames refFrameList0ShortTerm. When the current field is the second field (in decoding order) of a \ncomplementary reference field pair and the first field is marked as \"used for short-term reference\", the first field is \nincluded in the list of short-term reference frames refFrameList0ShortTerm. refFrameList0ShortTerm is ordered \nstarting with the reference frame with the highest FrameNumWrap value and proceeding through in descending \norder to the reference frame with the lowest FrameNumWrap value. \n2.  All frames having one or more fields marked \"used for long-term reference\" are included in the list of long-term \nreference frames refFrameList0LongTerm. When the current field is the second field (in decoding order) of a \ncomplementary reference field pair and the first field is marked as \"used for long-term reference, the first field is \nincluded in the list of long-term reference frames refFrameList0LongTerm. refFrameList0LongTerm is ordered \nstarting with the reference frame with the lowest LongTermFrameIdx value and proceeding through in ascending \norder to the reference frame with the highest LongTermFrameIdx value. \nThe process specified in clause 8.2.4.2.5 is invoked with refFrameList0ShortTerm and refFrameList0LongTerm given as \ninput and the output is assigned to RefPicList0. \n8.2.4.2.3 Initialization process for reference picture lists for B slices in frames \nThis initialization process is invoked when decoding a B slice in a coded frame. \nFor purposes of the formation of the reference picture lists RefPicList0 and RefPicList1 the term reference entry refers in \nthe following to decoded reference frames or complementary reference field pairs. \nWhen this process is invoked, there shall be at least one reference entry that is currently marked as \"used for reference\" \n(i.e., as \"used for short-term reference\" or \"used for long-term reference\") and is not marked as \"non-existing\". \nFor B slices, the order of short-term reference entries in the reference picture lists RefPicList0 and RefPicList1 depends \non output order, as given by PicOrderCnt( ). When pic_order_cnt_type is equal to 0, reference pictures that are marked as \n\"non-existing\" as specified in clause 8.2.5.2 are not included in either RefPicList0 or RefPicList1. \nNOTE 1 – When gaps_in_frame_num_value_allowed_flag is equal to 1, encoders should use reference picture list modification to \nensure proper operation of the decoding process (particularly when pic_order_cnt_type is equal to 0, in which case PicOrderCnt( ) \nis not inferred for \"non-existing\" frames). \n    Rec. ITU-T H.264 (06/2019)  123 \n \nThe reference picture list RefPicList0 is ordered such that short-term reference entries have lower indices than long-term \nreference entries. It is ordered as follows: \n1.  Let entryShortTerm be a variable ranging over all reference entries that are currently marked as \"used for \nshort-term reference\". When some values of entryShortTerm are present having PicOrderCnt( entryShortTerm ) \nless than PicOrderCnt( CurrPic ), these values of entryShortTerm are placed at the beginning of refPicList0 in \ndescending  order  of  PicOrderCnt( entryShortTerm ).  All  of  the  remaining  values  of  entryShortTerm  (when \npresent) are then appended to refPicList0 in ascending order of PicOrderCnt( entryShortTerm ). \n2.  The long-term reference entries are ordered starting  with the long-term reference entry that has the lowest \nLongTermPicNum value and proceeding through in ascending order to the long-term reference entry that has the \nhighest LongTermPicNum value. \nThe reference picture list RefPicList1 is ordered so that short-term reference entries have lower indices than long-term \nreference entries. It is ordered as follows: \n1.  Let entryShortTerm be a variable ranging over all reference entries that are currently marked as \"used for \nshort-term reference\". When some values of entryShortTerm are present having PicOrderCnt( entryShortTerm ) \ngreater than PicOrderCnt( CurrPic ), these values of entryShortTerm are placed at the beginning of refPicList1 in \nascending order of PicOrderCnt( entryShortTerm ). All of the remaining values of entryShortTerm (when present) \nare then appended to refPicList1 in descending order of PicOrderCnt( entryShortTerm ). \n2.  Long-term reference entries are ordered starting with the long-term reference frame or complementary reference \nfield pair that has the lowest LongTermPicNum value and proceeding through in ascending order to the long-term \nreference entry that has the highest LongTermPicNum value. \n3.  When the reference picture list RefPicList1 has more than one entry and RefPicList1 is identical to the reference \npicture list RefPicList0, the first two entries RefPicList1[ 0 ] and RefPicList1[ 1 ] are switched. \nNOTE 2 – A non-paired reference field is not used for inter prediction of frames (independent of the value of MbaffFrameFlag). \n8.2.4.2.4 Initialization process for reference picture lists for B slices in fields \nThis initialization process is invoked when decoding a B slice in a coded field. \nWhen this process is invoked, there shall be at least one reference field (which can be a field of a reference frame) that is \ncurrently marked as \"used for reference\" (i.e., as \"used for short-term reference\" or \"used for long-term reference\") and is \nnot marked as \"non-existing\". \nWhen decoding a field, each field of a stored reference frame is identified as a separate reference picture with a unique \nindex. The order of short-term reference pictures in the reference picture lists RefPicList0 and RefPicList1 depend on \noutput order, as given by PicOrderCnt( ). When pic_order_cnt_type is equal to 0, reference pictures that are marked as \n\"non-existing\" as specified in clause 8.2.5.2 are not included in either RefPicList0 or RefPicList1. \nNOTE 1 – When gaps_in_frame_num_value_allowed_flag is equal to 1, encoders should use reference picture list modification to \nensure proper operation of the decoding process (particularly when pic_order_cnt_type is equal to 0, in which case PicOrderCnt( ) \nis not inferred for \"non-existing\" frames). \nNOTE 2 – When decoding a field, there are effectively at least twice as many pictures available for referencing as there would be \nwhen decoding a frame at the same position in decoding order. \nThree ordered lists of reference frames, refFrameList0ShortTerm, refFrameList1ShortTerm and refFrameListLongTerm, \nare derived as follows. For purposes of the formation of these lists of frames the term reference entry refers in the following \nto  decoded  reference  frames,  complementary  reference  field  pairs,  or  non-paired  reference  fields.  When \npic_order_cnt_type is equal to 0, the term reference entry does not refer to frames that are marked as \"non-existing\" as \nspecified in clause 8.2.5.2. \n1.  Let entryShortTerm be a variable ranging over all reference entries that are currently marked as \"used for \nshort-term reference\". When some values of entryShortTerm are present having PicOrderCnt( entryShortTerm ) \nless than or equal to PicOrderCnt( CurrPic ), these values of entryShortTerm are placed at the beginning of \nrefFrameList0ShortTerm in descending order of PicOrderCnt( entryShortTerm ). All of the remaining values of \nentryShortTerm  (when  present)  are  then  appended  to  refFrameList0ShortTerm  in  ascending  order  of \nPicOrderCnt( entryShortTerm ). \nNOTE 3 – When the current field follows in decoding order a coded field fldPrev with which together it forms a \ncomplementary  reference  field  pair,  fldPrev  is  included  into  the  list  refFrameList0ShortTerm  using \nPicOrderCnt( fldPrev ) and the ordering method described in the previous sentence is applied. \n2.  Let entryShortTerm be a variable ranging over all reference entries that are currently marked as \"used for \nshort-term reference\". When some values of entryShortTerm are present having PicOrderCnt( entryShortTerm ) \ngreater  than  PicOrderCnt( CurrPic ),  these  values  of  entryShortTerm  are  placed  at  the  beginning  of \nrefFrameList1ShortTerm in ascending order of PicOrderCnt( entryShortTerm ). All of the remaining values of \n124  Rec. ITU-T H.264 (06/2019) \n \nentryShortTerm  (when  present)  are  then  appended  to  refFrameList1ShortTerm  in  descending  order  of \nPicOrderCnt( entryShortTerm ). \nNOTE 4 – When the current field follows in decoding order a coded field fldPrev with which together it forms a \ncomplementary  reference  field  pair,  fldPrev  is  included  into  the  list  refFrameList1ShortTerm  using \nPicOrderCnt( fldPrev ) and the ordering method described in the previous sentence is applied. \n3.  refFrameListLongTerm is ordered starting with the reference entry having the lowest LongTermFrameIdx value \nand proceeding through in ascending order to the reference entry having highest LongTermFrameIdx value. \nNOTE 5 – When the current picture is the second field of a complementary field pair and the first field of the \ncomplementary  field  pair  is  marked  as  \"used  for  long-term  reference\",  the  first  field  is  included  into  the  list \nrefFrameListLongTerm. A reference entry in which only one field is marked as \"used for long-term reference\" is \nincluded into the list refFrameListLongTerm. \nThe process specified in clause 8.2.4.2.5 is invoked with refFrameList0ShortTerm and refFrameListLongTerm given as \ninput and the output is assigned to RefPicList0. \nThe process specified in clause 8.2.4.2.5 is invoked with refFrameList1ShortTerm and refFrameListLongTerm given as \ninput and the output is assigned to RefPicList1. \nWhen the reference picture list RefPicList1 has more than one entry and RefPicList1 is identical to the reference picture \nlist RefPicList0, the first two entries RefPicList1[ 0 ] and RefPicList1[ 1 ] are switched. \n8.2.4.2.5 Initialization process for reference picture lists in fields \nInputs  of  this  process  are  the  reference  frame  lists  refFrameListXShortTerm  (with  X  may  be  0  or  1)  and \nrefFrameListLongTerm. \nThe reference picture list RefPicListX is a list ordered such that short-term reference fields have lower indices than \nlong-term reference fields. Given the reference frame lists refFrameListXShortTerm and refFrameListLongTerm, it is \nderived as specified by the following ordered steps: \n1.  Short-term  reference  fields  are  ordered  by  selecting  reference  fields  from  the  ordered  list  of  frames \nrefFrameListXShortTerm by alternating between fields of differing parity, starting with a field that has the same \nparity as the current field (when present). When one field of a reference frame was not decoded or is not marked \nas \"used for short-term reference\", the missing field is ignored and instead the next available stored reference field \nof the chosen parity from the ordered list of frames refFrameListXShortTerm is inserted into RefPicListX. When \nthere  are  no  more  short-term  reference  fields  of  the  alternate  parity  in  the  ordered  list  of  frames \nrefFrameListXShortTerm, the next not yet indexed fields of the available parity are inserted into RefPicListX in \nthe order in which they occur in the ordered list of frames refFrameListXShortTerm. \n2.  Long-term  reference  fields  are  ordered  by  selecting  reference  fields  from  the  ordered  list  of  frames \nrefFrameListLongTerm by alternating between fields of differing parity, starting with a field that has the same \nparity as the current field (when present). When one field of a reference frame was not decoded or is not marked \nas \"used for long-term reference\", the missing field is ignored and instead the next available stored reference field \nof the chosen parity from the ordered list of frames refFrameListLongTerm is inserted into RefPicListX. When \nthere  are  no  more  long-term  reference  fields  of  the  alternate  parity  in  the  ordered  list  of  frames \nrefFrameListLongTerm, the next not yet indexed fields of the available parity are inserted into RefPicListX in the \norder in which they occur in the ordered list of frames refFrameListLongTerm. \n8.2.4.3  Modification process for reference picture lists \nWhen ref_pic_list_modification_flag_l0 is equal to 1, the following applies: \n1.  Let refIdxL0 be an index into the reference picture list RefPicList0. It is initially set equal to 0. \n2.  The corresponding syntax elements modification_of_pic_nums_idc are processed in the order they occur in the \nbitstream. For each of these syntax elements, the following applies: \n–  If modification_of_pic_nums_idc is equal to 0 or equal to 1, the process specified in clause 8.2.4.3.1 is \ninvoked with refIdxL0 as input, and the output is assigned to refIdxL0. \n–  Otherwise,  if  modification_of_pic_nums_idc  is  equal  to 2,  the  process  specified  in  clause 8.2.4.3.2  is \ninvoked with refIdxL0 as input, and the output is assigned to refIdxL0. \n–  Otherwise (modification_of_pic_nums_idc is equal to 3), the modification process for reference picture list \nRefPicList0 is finished. \nWhen the current slice is a B slice and ref_pic_list_modification_flag_l1 is equal to 1, the following applies: \n1.  Let refIdxL1 be an index into the reference picture list RefPicList1. It is initially set equal to 0. \n    Rec. ITU-T H.264 (06/2019)  125 \n \n2.  The corresponding syntax elements modification_of_pic_nums_idc are processed in the order they occur in the \nbitstream. For each of these syntax elements, the following applies: \n–  If modification_of_pic_nums_idc is equal to 0 or equal to 1, the process specified in clause 8.2.4.3.1 is \ninvoked with refIdxL1 as input, and the output is assigned to refIdxL1. \n–  Otherwise,  if  modification_of_pic_nums_idc  is  equal  to 2,  the  process  specified  in  clause 8.2.4.3.2  is \ninvoked with refIdxL1 as input, and the output is assigned to refIdxL1. \n–  Otherwise (modification_of_pic_nums_idc is equal to 3), the modification process for reference picture list \nRefPicList1 is finished. \n8.2.4.3.1 Modification process of reference picture lists for short-term reference pictures \nInput to this process is an index refIdxLX (with X being 0 or 1). \nOutput of this process is an incremented index refIdxLX. \nThe variable picNumLXNoWrap is derived as follows: \n–  If modification_of_pic_nums_idc is equal to 0, \nif( picNumLXPred − ( abs_diff_pic_num_minus1 + 1 ) < 0 ) \n  picNumLXNoWrap = picNumLXPred − ( abs_diff_pic_num_minus1 + 1 ) + MaxPicNum  (8-34) \nelse \n  picNumLXNoWrap = picNumLXPred − ( abs_diff_pic_num_minus1 + 1 ) \n–  Otherwise (modification_of_pic_nums_idc is equal to 1), \nif( picNumLXPred + ( abs_diff_pic_num_minus1 + 1 )  >=  MaxPicNum ) \n  picNumLXNoWrap = picNumLXPred + ( abs_diff_pic_num_minus1 + 1 ) − MaxPicNum  (8-35) \nelse \n  picNumLXNoWrap = picNumLXPred + ( abs_diff_pic_num_minus1 + 1 ) \npicNumLXPred is the prediction value for the variable picNumLXNoWrap. When the process specified in this clause is \ninvoked the first time for a slice (that is, for the first occurrence of modification_of_pic_nums_idc equal to 0 or 1 in the \nref_pic_list_modification( ) syntax), picNumL0Pred and picNumL1Pred are initially set equal to CurrPicNum. After each \nassignment of picNumLXNoWrap, the value of picNumLXNoWrap is assigned to picNumLXPred. \nThe variable picNumLX is derived as specified by the following pseudo-code: \nif( picNumLXNoWrap > CurrPicNum ) \n  picNumLX = picNumLXNoWrap − MaxPicNum  (8-36) \nelse \n  picNumLX = picNumLXNoWrap \npicNumLX shall be equal to the PicNum of a reference picture that is marked as \"used for short-term reference\" and shall \nnot be equal to the PicNum of a short-term reference picture that is marked as \"non-existing\". \nThe following procedure is conducted to place the picture with short-term picture number picNumLX into the index \nposition refIdxLX, shift the position of any other remaining pictures to later in the list, and increment the value of refIdxLX. \nfor( cIdx = num_ref_idx_lX_active_minus1 + 1; cIdx > refIdxLX; cIdx− − ) \n  RefPicListX[ cIdx ] = RefPicListX[ cIdx − 1] \nRefPicListX[ refIdxLX++ ] = short-term reference picture with PicNum equal to picNumLX \nnIdx = refIdxLX \nfor( cIdx = refIdxLX; cIdx <= num_ref_idx_lX_active_minus1 + 1; cIdx++ )   (8-37) \n  if( PicNumF( RefPicListX[ cIdx ] ) != picNumLX ) \n    RefPicListX[ nIdx++ ] = RefPicListX[ cIdx ] \nwhere the function PicNumF( RefPicListX[ cIdx ] ) is derived as follows: \n–  If the picture RefPicListX[ cIdx ] is marked as \"used for short-term reference\", PicNumF( RefPicListX[ cIdx ] ) is the \nPicNum of the picture RefPicListX[ cIdx ]. \n–  Otherwise  (the  picture  RefPicListX[ cIdx ]  is  not  marked  as  \"used  for  short-term  reference\"), \nPicNumF( RefPicListX[ cIdx ] ) is equal to MaxPicNum. \nNOTE 1 – A value of MaxPicNum can never be equal to picNumLX. \n126  Rec. ITU-T H.264 (06/2019) \n \nNOTE 2 – Within this pseudo-code procedure, the length of the list RefPicListX is temporarily made one element longer than the \nlength needed for the final list. After the execution of this procedure, only elements 0 through num_ref_idx_lX_active_minus1 of \nthe list need to be retained. \n8.2.4.3.2 Modification process of reference picture lists for long-term reference pictures \nInput to this process is an index refIdxLX (with X being 0 or 1). \nOutput of this process is an incremented index refIdxLX. \nThe following procedure is conducted to place the picture with long-term picture number long_term_pic_num into the \nindex position refIdxLX, shift the position of any other remaining pictures to later in the list, and increment the value of \nrefIdxLX. \nfor( cIdx = num_ref_idx_lX_active_minus1 + 1; cIdx > refIdxLX; cIdx− − ) \n  RefPicListX[ cIdx ] = RefPicListX[ cIdx − 1] \nRefPicListX[ refIdxLX++ ] = long-term reference picture with LongTermPicNum equal to long_term_pic_num \nnIdx = refIdxLX \nfor( cIdx = refIdxLX; cIdx <= num_ref_idx_lX_active_minus1 + 1; cIdx++ )  (8-38) \n  if( LongTermPicNumF( RefPicListX[ cIdx ] ) != long_term_pic_num ) \n    RefPicListX[ nIdx++ ] = RefPicListX[ cIdx ] \nwhere the function LongTermPicNumF( RefPicListX[ cIdx ] ) is derived as follows: \n–  If  the  picture  RefPicListX[ cIdx ]  is  marked  as  \"used  for  long-term  reference\", \nLongTermPicNumF( RefPicListX[ cIdx ] ) is the LongTermPicNum of the picture RefPicListX[ cIdx ]. \n–  Otherwise  (the  picture  RefPicListX[ cIdx ]  is  not  marked  as  \"used  for  long-term  reference\"), \nLongTermPicNumF( RefPicListX[ cIdx ] ) is equal to 2 * ( MaxLongTermFrameIdx + 1 ). \nNOTE 1 – A value of 2 * ( MaxLongTermFrameIdx + 1 ) can never be equal to long_term_pic_num. \nNOTE 2 – Within this pseudo-code procedure, the length of the list RefPicListX is temporarily made one element longer than the \nlength needed for the final list. After the execution of this procedure, only elements 0 through num_ref_idx_lX_active_minus1 of \nthe list need to be retained. \n8.2.5  Decoded reference picture marking process \nThis process is invoked for decoded pictures when nal_ref_idc is not equal to 0. \nNOTE 1 – The decoding process for gaps in frame_num that is specified in clause 8.2.5.2 may also be invoked when nal_ref_idc is \nequal to 0, as specified in clause 8. \nA decoded picture with nal_ref_idc not equal to 0, referred to as a reference picture, is marked as \"used for short-term \nreference\" or \"used for long-term reference\". For a decoded reference frame, both of its fields are marked the same as the \nframe. For a complementary reference field pair, the pair is marked the same as both of its fields. A picture that is marked \nas \"used for short-term reference\" is identified by its FrameNum and, when it is a field, by its parity. A picture that is \nmarked as \"used for long-term reference\" is identified by its LongTermFrameIdx and, when it is a field, by its parity. \nFrames or complementary field pairs marked as \"used for short-term reference\" or as \"used for long-term reference\" can \nbe used as a reference for inter prediction when decoding a frame until the frame, the complementary field pair, or one of \nits constituent fields is marked as \"unused for reference\". A field marked as \"used for short-term reference\" or as \"used for \nlong-term reference\" can be used as a reference for inter prediction when decoding a field until marked as \"unused for \nreference\". \nNOTE 2 – The marking status of a frame or complementary field pair can always be deduced from the marking status of its two \nfields. If both fields of a frame or complementary field pair are marked as \"used for reference\", the frame or complementary field \npair is also marked as \"used for reference\"; otherwise (one field or both fields of a frame or complementary field pair are marked as \n\"unused for reference\"), the frame or complementary field pair is marked as \"unused for reference\". \nA picture can be marked as \"unused for reference\" by the sliding window reference picture marking process, a first-in, \nfirst-out mechanism specified in clause 8.2.5.3 or by the adaptive memory control reference picture marking process, a \ncustomised adaptive marking operation specified in clause 8.2.5.4. \nA short-term reference picture is identified for use in the decoding process by its variables FrameNum and FrameNumWrap \nand its picture number PicNum, and a long-term reference picture is identified for use in the decoding process by its long-\nterm picture number LongTermPicNum. When the current picture is not an IDR picture, clause 8.2.4.1 is invoked to specify \nthe assignment of the variables FrameNum, FrameNumWrap, PicNum and LongTermPicNum. \n    Rec. ITU-T H.264 (06/2019)  127 \n \n8.2.5.1  Sequence of operations for decoded reference picture marking process \nDecoded reference picture marking proceeds in the following ordered steps: \n1.  All slices of the current picture are decoded. \n2.  Depending on whether the current picture is an IDR picture, the following applies: \n–  If the current picture is an IDR picture, the following ordered steps are specified: \na.  All reference pictures are marked as \"unused for reference\" \nb.  Depending on long_term_reference_flag, the following applies: \n–  If  long_term_reference_flag  is  equal  to 0,  the  IDR  picture  is  marked  as  \"used  for  short-term \nreference\" and MaxLongTermFrameIdx is set equal to \"no long-term frame indices\". \n–  Otherwise  (long_term_reference_flag  is  equal  to 1),  the  IDR  picture  is  marked  as  \"used  for \nlong-term  reference\",  the  LongTermFrameIdx  for  the  IDR  picture  is  set  equal  to 0,  and \nMaxLongTermFrameIdx is set equal to 0. \n–  Otherwise (the current picture is not an IDR picture), the following applies: \n–  If adaptive_ref_pic_marking_mode_flag is equal to 0, the process specified in clause 8.2.5.3 is invoked. \n–  Otherwise (adaptive_ref_pic_marking_mode_flag is equal to 1), the process specified in clause 8.2.5.4 \nis invoked. \n3.  When the current picture is  not an IDR picture and it  was not  marked as \"used for long-term reference\" by \nmemory_management_control_operation equal to 6, it is marked as \"used for short-term reference\". \nIt is a requirement of bitstream conformance that, after marking the current decoded reference picture, the total number of \nframes with at least one field marked as \"used for reference\", plus the number of complementary field pairs with at least \none field marked as \"used for reference\", plus the number of non-paired fields marked as \"used for reference\" shall not be \ngreater than Max( max_num_ref_frames, 1 ). \n8.2.5.2  Decoding process for gaps in frame_num \nThis process is invoked when frame_num is not equal to PrevRefFrameNum and is not equal to ( PrevRefFrameNum + 1 ) \n% MaxFrameNum. \nNOTE 1 – Although this process is specified as a subclause within clause 8.2.5 (which defines a process that is invoked only when \nnal_ref_idc is not equal to 0), this process may also be invoked when nal_ref_idc is equal to 0 (as specified in clause 8). The reasons \nfor the location of this clause within the structure of this Recommendation | International Standard are historical. \nNOTE 2 – This process can only be invoked for a conforming bitstream when gaps_in_frame_num_value_allowed_flag is equal \nto 1. When gaps_in_frame_num_value_allowed_flag is equal to 0 and frame_num is not equal to PrevRefFrameNum and is not \nequal to ( PrevRefFrameNum + 1 ) % MaxFrameNum, the decoding process should infer an unintentional loss of pictures. \nWhen this process is invoked, a set of values of frame_num pertaining to \"non-existing\" pictures is derived as all values \ntaken on by UnusedShortTermFrameNum in Equation 7-24 except the value of frame_num for the current picture. \nFor  each  of  the  values  of  frame_num  pertaining  to  \"non-existing\"  pictures,  in  the  order  in  which  the  values  of \nUnusedShortTermFrameNum are generated by Equation 7-24, the following ordered steps are specified: \n1.  The decoding process for picture numbers as specified in clause 8.2.4.1 is invoked. \n2.  The sliding window decoded reference picture marking process as specified in clause 8.2.5.3 is invoked. \n3.  The decoding process generates a frame and the generated frame is marked as \"non-existing\" and \"used for short-\nterm reference\". The sample values of the generated frame may be set to any value. \nThe following constraints shall be obeyed: \na)  The bitstream shall not contain data that result in the derivation of a co-located picture colPic that is marked as \n\"non-existing\" in any invocation of the derivation process for the co-located 4x4 sub-macroblock partitions \nspecified in clause 8.4.1.2.1. \nb)  The  bitstream  shall  not  contain  data  that  result  in  the  derivation  of  a  reference  picture  that  is  marked  as \n\"non-existing\" in any invocation of the reference picture selection process specified in clause 8.4.2.1. \nc)  The bitstream shall not contain data that result in a variable picNumLX that is equal to the PicNum of a picture \nmarked as \"non-existing\" in any invocation of the modification process for reference picture lists for short-term \nreference pictures specified in clause 8.2.4.3.1. \n128  Rec. ITU-T H.264 (06/2019) \n \nd)  The bitstream shall not contain data that result in a variable picNumLX that is equal to the PicNum of a picture \nmarked as \"non-existing\" in any invocation of the assignment process of a LongTermFrameIdx to a short-term \nreference picture specified in clause 8.2.5.4.3. \nNOTE 3 – The above constraints specify that frames that are marked as \"non-existing\" by the process specified in this clause must \nnot be referenced in the inter prediction process (clause 8.4, including the derivation process for co-located 4x4 sub-macroblock \npartitions  in  clause 8.4.1.2.1),  the  modification  commands  for  reference  picture  lists  for  short-term  reference  pictures \n(clause 8.2.4.3.1), or the assignment process of a LongTermFrameIdx to a short-term reference picture (clause 8.2.5.4.3). \nWhen pic_order_cnt_type is not equal to 0, TopFieldOrderCnt and BottomFieldOrderCnt are derived for each of the \"non-\nexisting\" frames by invoking the decoding process for picture order count in clause 8.2.1. When invoking the process in \nclause 8.2.1 for a particular \"non-existing\" frame, the current picture is considered to be a picture considered having \nframe_num inferred to be equal to UnusedShortTermFrameNum, nal_ref_idc inferred to be not equal to 0, nal_unit_type \ninferred  to  be  not  equal  to  5,  IdrPicFlag  inferred  to  be  equal  to 0,  field_pic_flag  inferred  to  be  equal  to  0, \nadaptive_ref_pic_marking_mode_flag inferred to be equal to 0, delta_pic_order_cnt[ 0 ] (if needed) inferred to be equal \nto 0, and delta_pic_order_cnt[ 1 ] (if needed) inferred to be equal to 0. \nNOTE 4 – The decoding process should infer an unintentional picture loss when any of these values of frame_num pertaining to \n\"non-existing\" pictures is referred to in the inter prediction process (clause 8.4, including the derivation process for the co-located \n4x4 sub-macroblock partitions in clause 8.4.1.2.1), is referred to in the modification commands for reference picture lists for short-\nterm reference pictures (clause 8.2.4.3.1), or is referred to in the assignment process of a LongTermFrameIdx to a short-term \nreference picture (clause 8.2.5.4.3). The decoding process should not infer an unintentional picture loss when a memory management \ncontrol operation not equal to 3 is applied to a frame marked as \"non-existing\". \n8.2.5.3  Sliding window decoded reference picture marking process \nThis process is invoked when adaptive_ref_pic_marking_mode_flag is equal to 0. \nDepending on the properties of the current picture as specified below, the following applies: \n–  If the current picture is a coded field that is the second field in decoding order of a complementary reference field \npair, and the first field has been marked as \"used for short-term reference\", the current picture and the complementary \nreference field pair are also marked as \"used for short-term reference\". \n–  Otherwise, the following applies: \n1.  Let numShortTerm be the total number of reference frames, complementary reference field pairs and non-paired \nreference fields for which at least one field is marked as \"used for short-term reference\". Let numLongTerm be \nthe total number of reference frames, complementary reference field pairs and non-paired reference fields for \nwhich at least one field is marked as \"used for long-term reference\". \n2.  When  numShortTerm + numLongTerm  is  equal  to  Max( max_num_ref_frames, 1 ),  the  condition  that \nnumShortTerm is greater than 0 shall be fulfilled, and the short-term reference frame, complementary reference \nfield pair or non-paired reference field that has the smallest value of FrameNumWrap is marked as \"unused for \nreference\". When it is a frame or a complementary field pair, both of its fields are also marked as \"unused for \nreference\". \n8.2.5.4  Adaptive memory control decoded reference picture marking process \nThis process is invoked when adaptive_ref_pic_marking_mode_flag is equal to 1. \nThe memory_management_control_operation commands with values of 1 to 6 are processed in the order they occur in the \nbitstream  after  the  current  picture  has  been  decoded.  For  each  of  these  memory_management_control_operation \ncommands,  one  of  the  processes  specified  in  clauses 8.2.5.4.1  to 8.2.5.4.6  is  invoked  depending  on  the  value  of \nmemory_management_control_operation.  The  memory_management_control_operation  command  with  value  of  0 \nspecifies the end of memory_management_control_operation commands. \nMemory management control operations are applied to pictures as follows: \n–  If field_pic_flag is equal to 0, memory_management_control_operation commands are applied to the frames or \ncomplementary reference field pairs specified. \n–  Otherwise  (field_pic_flag  is  equal  to 1),  memory_management_control_operation  commands  are  applied  to  the \nindividual reference fields specified. \n8.2.5.4.1 Marking process of a short-term reference picture as \"unused for reference\" \nThis process is invoked when memory_management_control_operation is equal to 1. \nLet picNumX be specified by \npicNumX = CurrPicNum − ( difference_of_pic_nums_minus1 + 1 ).   (8-39) \n    Rec. ITU-T H.264 (06/2019)  129 \n \nDepending on field_pic_flag the value of picNumX is used to mark a short-term reference picture as \"unused for reference\" \nas follows: \n–  If field_pic_flag is equal to 0, the short-term reference frame or short-term complementary reference field pair \nspecified by picNumX and both of its fields are marked as \"unused for reference\". \n–  Otherwise (field_pic_flag is equal to 1), the short-term reference field specified by picNumX is marked as \"unused \nfor reference\". When that reference field is part of a reference frame or a complementary reference field pair, the \nframe or complementary field pair is also marked as \"unused for reference\", but the marking of the other field in the \nsame reference frame or complementary reference field pair is not changed. \n8.2.5.4.2 Marking process of a long-term reference picture as \"unused for reference\" \nThis process is invoked when memory_management_control_operation is equal to 2. \nDepending on field_pic_flag the value of LongTermPicNum is used to mark a long-term reference picture as \"unused for \nreference\" as follows: \n–  If field_pic_flag is equal to 0, the long-term reference frame or long-term complementary reference field pair having \nLongTermPicNum equal to long_term_pic_num and both of its fields are marked as \"unused for reference\". \n–  Otherwise  (field_pic_flag  is  equal  to 1),  the  long-term  reference  field  specified  by  LongTermPicNum  equal  to \nlong_term_pic_num is marked as \"unused for reference\". When that reference field is part of a reference frame or a \ncomplementary reference field pair, the frame or complementary field pair is also marked as \"unused for reference\", \nbut the marking of the other field in the same reference frame or complementary reference field pair is not changed. \n8.2.5.4.3 Assignment process of a LongTermFrameIdx to a short-term reference picture \nThis process is invoked when memory_management_control_operation is equal to 3. \nGiven  the  syntax  element  difference_of_pic_nums_minus1,  the  variable  picNumX  is  obtained  as  specified  in \nclause 8.2.5.4.1. picNumX shall refer to a frame or complementary reference field pair or non-paired reference field marked \nas \"used for short-term reference\" and not marked as \"non-existing\". \nWhen LongTermFrameIdx equal to long_term_frame_idx is already assigned to a long-term reference frame or a long-term \ncomplementary reference field pair, that frame or complementary field pair and both of its fields are marked as \"unused \nfor reference\". When LongTermFrameIdx is already assigned to a reference field, and that reference field is not part of a \ncomplementary field pair that includes the picture specified by picNumX, that field is marked as \"unused for reference\". \nDepending  on  field_pic_flag  the  value  of  LongTermFrameIdx  is  used  to  mark  a  picture  from  \"used  for  short-term \nreference\" to \"used for long-term reference\" as follows: \n–  If field_pic_flag is equal to 0, the marking of the short-term reference frame or short-term complementary reference \nfield pair specified by picNumX and both of its fields are changed from \"used for short-term reference\" to \"used for \nlong-term reference\" and assigned LongTermFrameIdx equal to long_term_frame_idx. \n–  Otherwise (field_pic_flag is equal to 1), the marking of the short-term reference field specified by picNumX is \nchanged from \"used for short-term reference\" to \"used for long-term reference\" and assigned LongTermFrameIdx \nequal to long_term_frame_idx. When the field is part of a reference frame or a complementary reference field pair, \nand the other field of the same reference frame or complementary reference field pair is also marked as \"used for \nlong-term reference\", the reference frame or complementary reference field pair is also marked as \"used for long-term \nreference\" and assigned LongTermFrameIdx equal to long_term_frame_idx. \n8.2.5.4.4 Decoding process for MaxLongTermFrameIdx \nThis process is invoked when memory_management_control_operation is equal to 4. \nAll pictures for which LongTermFrameIdx is greater than max_long_term_frame_idx_plus1 − 1 and that are marked as \n\"used for long-term reference\" are marked as \"unused for reference\". \nThe variable MaxLongTermFrameIdx is derived as follows: \n–  If  max_long_term_frame_idx_plus1 is equal to 0, MaxLongTermFrameIdx  is set equal to  \"no long-term  frame \nindices\". \n–  Otherwise  (max_long_term_frame_idx_plus1  is  greater  than  0),  MaxLongTermFrameIdx  is  set  equal  to \nmax_long_term_frame_idx_plus1 − 1. \nNOTE – The memory_management_control_operation command equal to 4 can be used to mark long-term reference pictures as \n\"unused  for  reference\".  The  frequency  of  transmitting  max_long_term_frame_idx_plus1  is  not  specified  by  this \nRecommendation | International Standard. However, the encoder should send a memory_management_control_operation command \nequal to 4 upon receiving an error message, such as an intra refresh request message. \n130  Rec. ITU-T H.264 (06/2019) \n \n8.2.5.4.5 Marking process of all reference pictures as \"unused for reference\" and setting MaxLongTermFrameIdx \nto \"no long-term frame indices\" \nThis process is invoked when memory_management_control_operation is equal to 5. \nAll reference pictures are marked as \"unused for reference\" and the variable MaxLongTermFrameIdx is set equal to \"no \nlong-term frame indices\". \n8.2.5.4.6 Process for assigning a long-term frame index to the current picture \nThis process is invoked when memory_management_control_operation is equal to 6. \nWhen a variable LongTermFrameIdx equal to long_term_frame_idx is already assigned to a long-term reference frame or \na long-term complementary reference field pair, that frame or complementary field pair and both of its fields are marked \nas \"unused for reference\". When LongTermFrameIdx is already assigned to a reference field, and that reference field is \nnot part of a complementary field pair that includes the current picture, that field is marked as \"unused for reference\". \nThe  current  picture  is  marked  as  \"used  for  long-term  reference\"  and  assigned  LongTermFrameIdx  equal  to \nlong_term_frame_idx. \nWhen  field_pic_flag  is  equal  to 0,  both  its  fields  are  also  marked  as  \"used  for  long-term  reference\"  and  assigned \nLongTermFrameIdx equal to long_term_frame_idx. \nWhen field_pic_flag is equal to 1 and the current picture is the second field (in decoding order) of a complementary \nreference field pair, and the first field of the complementary reference field pair is also currently marked as \"used for long-\nterm reference\", the complementary reference field pair is also marked as \"used for long-term reference\" and assigned \nLongTermFrameIdx equal to long_term_frame_idx. \nAfter marking the current decoded reference picture, the total number of frames with at least one field marked as \"used for \nreference\", plus the number of complementary field pairs with at least one field marked as \"used for reference\", plus the \nnumber of non-paired fields marked as \"used for reference\" shall not be greater than Max( max_num_ref_frames, 1 ). \nNOTE  –  Under  some  circumstances,  the  above  statement  may  impose  a  constraint  on  the  order  in  which  a \nmemory_management_control_operation syntax element equal to 6 can appear in the decoded reference picture marking syntax \nrelative to a memory_management_control_operation syntax element equal to 1, 2, 3, or 4. \n8.3  Intra prediction process \nThis process is invoked for I and SI macroblock types. \nInputs to this process are constructed samples prior to the deblocking filter process and, for Intra_NxN prediction modes \n(where NxN is equal to 4x4 or 8x8), the values of IntraNxNPredMode from neighbouring macroblocks. \nOutputs of this process are specified as follows: \n–  If the macroblock prediction mode is Intra_4x4 or Intra_8x8, the outputs are constructed luma samples prior to the \ndeblocking filter process and (when ChromaArrayType is not equal to 0) chroma prediction samples of the \nmacroblock pred , where C is equal to Cb and Cr. \nC\n–  Otherwise, if mb_type is not equal to I_PCM, the outputs are luma prediction samples of the macroblock pred  and \nL\n(when ChromaArrayType is not equal to 0) chroma prediction samples of the macroblock pred , where C is equal to \nC\nCb and Cr. \n–  Otherwise (mb_type is equal to I_PCM), the outputs are constructed luma and (when ChromaArrayType is not \nequal to 0) chroma samples prior to the deblocking filter process. \nThe variable MvCnt is set equal to 0. \nDepending on the value of mb_type the following applies: \n–  If mb_type is equal to I_PCM, the sample construction process for I_PCM macroblocks as specified in clause 8.3.5 \nis invoked. \n–  Otherwise (mb_type is not equal to I_PCM), the following applies: \n1.  The decoding processes for Intra prediction modes are described for the luma component as follows: \n–  If the macroblock prediction mode is equal to Intra_4x4, the Intra_4x4 prediction process for luma \nsamples as specified in clause 8.3.1 is invoked. \n–  Otherwise, if the macroblock prediction mode is equal to Intra_8x8, the Intra_8x8 prediction process as \nspecified in clause 8.3.2 is invoked. \n    Rec. ITU-T H.264 (06/2019)  131 \n \n–  Otherwise (the macroblock prediction mode is equal to Intra_16x16), the Intra_16x16 prediction process \nas specified in clause 8.3.3 is invoked with S′  as the input and the outputs are luma prediction samples \nL\nof the macroblock pred . \nL\n2.  When ChromaArrayType is not equal to 0, the Intra prediction process for chroma samples as specified in \nclause 8.3.4 is invoked with S′ , and S′  as the inputs and the outputs are chroma prediction samples of the \nCb Cr\nmacroblock pred  and pred . \nCb Cr\nSamples used in the Intra prediction process are the sample values prior to alteration by any deblocking filter operation. \n8.3.1  Intra_4x4 prediction process for luma samples \nThis process is invoked when the macroblock prediction mode is equal to Intra_4x4. \nInputs  to  this  process  are  the  values  of  Intra4x4PredMode  (if  available)  or  Intra8x8PredMode  (if  available)  from \nneighbouring macroblocks or macroblock pairs. \nThe luma component of a macroblock consists of 16 blocks of 4x4 luma samples. These blocks are inverse scanned using \nthe 4x4 luma block inverse scanning process as specified in clause 6.4.3. \nFor all 4x4 luma blocks of the luma component of a macroblock with luma4x4BlkIdx = 0..15, the derivation process for \nthe Intra4x4PredMode as specified in clause 8.3.1.1 is invoked with luma4x4BlkIdx as well as Intra4x4PredMode and \nIntra8x8PredMode that are previously (in decoding order) derived for adjacent macroblocks as the input and the variable \nIntra4x4PredMode[ luma4x4BlkIdx ] as the output. \nFor each luma block of 4x4 samples indexed using luma4x4BlkIdx = 0..15, the following ordered steps are specified: \n1.  The  Intra_4x4  sample  prediction  process  in  clause 8.3.1.2  is  invoked  with  luma4x4BlkIdx  and  the  array  S′  \nL\ncontaining constructed luma samples prior to the deblocking filter process from adjacent luma blocks as the inputs \nand the outputs are the Intra_4x4 luma prediction samples pred4x4 [ x, y ] with x, y = 0..3. \nL\n2.  The position of the upper-left sample of a 4x4 luma block with index luma4x4BlkIdx inside the current macroblock \nis derived by invoking the inverse 4x4 luma block scanning process in clause 6.4.3 with luma4x4BlkIdx as the input \nand the output being assigned to ( xO, yO ). \n3.  The values of the prediction samples pred [ xO + x, yO + y ] with x, y = 0..3 are derived by \nL\npred [ xO + x, yO + y ] = pred4x4 [ x, y ]    (8-40) \nL L\n4.  The transform coefficient decoding process and picture construction process prior to deblocking filter process in \nclause 8.5 is invoked with pred  and luma4x4BlkIdx as the input and the constructed samples for the current 4x4 \nL\nluma block S′  as the output. \nL\n8.3.1.1  Derivation process for Intra4x4PredMode \nInputs to this process are the index of the 4x4 luma block luma4x4BlkIdx and variable arrays Intra4x4PredMode (if \navailable) and Intra8x8PredMode (if available) that are previously (in decoding order) derived for adjacent macroblocks. \nOutput of this process is the variable Intra4x4PredMode[ luma4x4BlkIdx ]. \nTable 8-2 specifies the values for Intra4x4PredMode[ luma4x4BlkIdx ] and the associated names. \nTable 8-2 – Specification of Intra4x4PredMode[ luma4x4BlkIdx ] and associated names \nIntra4x4PredMode[ luma4x4BlkIdx ]  Name of Intra4x4PredMode[ luma4x4BlkIdx ] \n0  Intra_4x4_Vertical (prediction mode) \n1  Intra_4x4_Horizontal (prediction mode) \n2  Intra_4x4_DC (prediction mode) \n3  Intra_4x4_Diagonal_Down_Left (prediction mode) \n4  Intra_4x4_Diagonal_Down_Right (prediction mode) \n5  Intra_4x4_Vertical_Right (prediction mode) \n6  Intra_4x4_Horizontal_Down (prediction mode) \n7  Intra_4x4_Vertical_Left (prediction mode) \n8  Intra_4x4_Horizontal_Up (prediction mode) \n132  Rec. ITU-T H.264 (06/2019) \n \nIntra4x4PredMode[ luma4x4BlkIdx ] labelled 0, 1, 3, 4, 5, 6, 7, and 8 represent directions of predictions as illustrated in \nFigure 8-1. \n \nFigure 8-1 – Intra_4x4 prediction mode directions (informative) \nIntra4x4PredMode[ luma4x4BlkIdx ] is derived as specified by the following ordered steps: \n1.  The process specified in clause 6.4.11.4 is invoked with luma4x4BlkIdx given as input and the output is assigned \nto mbAddrA, luma4x4BlkIdxA, mbAddrB, and luma4x4BlkIdxB. \n2.  The variable dcPredModePredictedFlag is derived as follows: \n–  If any of the following conditions are true, dcPredModePredictedFlag is set equal to 1 \n–  the macroblock with address mbAddrA is not available \n–  the macroblock with address mbAddrB is not available \n–  the macroblock with address mbAddrA is available and coded in an Inter macroblock prediction mode \nand constrained_intra_pred_flag is equal to 1 \n–  the macroblock with address mbAddrB is available and coded in an Inter macroblock prediction mode \nand constrained_intra_pred_flag is equal to 1 \n–  Otherwise, dcPredModePredictedFlag is set equal to 0. \n3.  For N being either replaced by A or B, the variables intraMxMPredModeN are derived as follows: \n–  If dcPredModePredictedFlag  is equal to 1 or the  macroblock  with address  mbAddrN  is not coded in \nIntra_4x4 or Intra_8x8 macroblock prediction mode, intraMxMPredModeN is set equal to 2 (Intra_4x4_DC \nprediction mode). \n–  Otherwise (dcPredModePredictedFlag is equal to 0 and the macroblock with address mbAddrN is coded in \nIntra_4x4 or Intra_8x8 macroblock prediction mode), the following applies: \n–  If  the  macroblock  with  address  mbAddrN  is  coded  in  Intra_4x4  macroblock  prediction  mode, \nintraMxMPredModeN  is  set  equal  to Intra4x4PredMode[ luma4x4BlkIdxN ],  where \nIntra4x4PredMode is the variable array assigned to the macroblock mbAddrN. \n–  Otherwise (the macroblock with address mbAddrN is coded in Intra_8x8 macroblock  prediction \nmode),  intraMxMPredModeN  is  set  equal  to Intra8x8PredMode[ luma4x4BlkIdxN >> 2 ],  where \nIntra8x8PredMode is the variable array assigned to the macroblock mbAddrN. \n4.  Intra4x4PredMode[ luma4x4BlkIdx ] is derived by applying the following procedure: \npredIntra4x4PredMode = Min( intraMxMPredModeA, intraMxMPredModeB ) \nif( prev_intra4x4_pred_mode_flag[ luma4x4BlkIdx ] ) \n  Intra4x4PredMode[ luma4x4BlkIdx ] = predIntra4x4PredMode \nelse          (8-41) \n  if( rem_intra4x4_pred_mode[ luma4x4BlkIdx ] < predIntra4x4PredMode ) \n    Intra4x4PredMode[ luma4x4BlkIdx ] = rem_intra4x4_pred_mode[ luma4x4BlkIdx ] \n  else \n    Intra4x4PredMode[ luma4x4BlkIdx ] = rem_intra4x4_pred_mode[ luma4x4BlkIdx ] + 1 \n    Rec. ITU-T H.264 (06/2019)  133 \n \n8.3.1.2  Intra_4x4 sample prediction \nThis process is invoked for each 4x4 luma block of a macroblock with macroblock prediction mode equal to Intra_4x4 \nfollowed by the transform decoding process and picture construction process prior to deblocking for each 4x4 luma block. \nInputs to this process are: \n–  the index of a 4x4 luma block luma4x4BlkIdx, \n–  an (PicWidthInSamples )x(PicHeightInSamples ) array cS  containing constructed luma samples prior to the \nL L L\ndeblocking filter process of neighbouring macroblocks. \nOutput of this process are the prediction samples pred4x4 [ x, y ], with x, y = 0..3, for the 4x4 luma block with index \nL\nluma4x4BlkIdx. \nThe position of the upper-left sample of a 4x4 luma block with index luma4x4BlkIdx inside the current macroblock is \nderived by invoking the inverse 4x4 luma block scanning process in clause 6.4.3 with luma4x4BlkIdx as the input and the \noutput being assigned to ( xO, yO ). \nThe 13 neighbouring samples p[ x, y ] that are constructed luma samples prior to the deblocking filter process, with x = −1, \ny = −1..3 and x = 0..7, y = −1, are derived as specified by the following ordered steps: \n1.  The luma location ( xN, yN ) is specified by \nxN = xO + x    (8-42) \nyN = yO + y    (8-43) \n2.  The derivation process for neighbouring locations in clause 6.4.12 is invoked for luma locations with ( xN, yN ) as \ninput and mbAddrN and ( xW, yW ) as output. \n3.  Each sample p[ x, y ] with x = −1, y = −1..3 and x = 0..7, y = −1 is derived as follows: \n–  If any of the following conditions are true, the sample p[ x, y ] is marked as \"not available for Intra_4x4 \nprediction\" \n–  mbAddrN is not available, \n–  the  macroblock  mbAddrN  is  coded  in  an  Inter  macroblock  prediction  mode  and \nconstrained_intra_pred_flag is equal to 1, \n–  the macroblock mbAddrN has mb_type equal to SI and constrained_intra_pred_flag is equal to 1 and \nthe current macroblock does not have mb_type equal to SI, \n–  x is greater than 3 and luma4x4BlkIdx is equal to 3 or 11. \n–  Otherwise, the sample p[ x, y ] is marked as \"available for Intra_4x4 prediction\" and the value of the sample \np[ x, y ] is derived as specified by the following ordered steps: \na.  The location of the upper-left luma sample of the macroblock mbAddrN is derived by invoking the \ninverse macroblock scanning process in clause 6.4.1 with mbAddrN as the input and the output is \nassigned to ( xM, yM ). \nb.  Depending on the variable MbaffFrameFlag and the macroblock mbAddrN, the sample value p[ x, y ] \nis derived as follows: \n–  If MbaffFrameFlag is equal to 1 and the macroblock mbAddrN is a field macroblock, \np[ x, y ] = cS [ xM + xW, yM + 2 * yW ]  (8-44) \nL\n–  Otherwise (MbaffFrameFlag is equal to 0 or the macroblock mbAddrN is a frame macroblock), \np[ x, y ] = cS [ xM + xW, yM + yW ]  (8-45) \nL\nWhen samples p[ x, −1 ], with x = 4..7, are marked as \"not available for Intra_4x4 prediction,\" and the sample p[ 3, −1 ] is \nmarked as \"available for Intra_4x4 prediction,\" the sample value of p[ 3, −1 ] is substituted for sample values p[ x, −1 ], \nwith x = 4..7, and samples p[ x, −1 ], with x = 4..7, are marked as \"available for Intra_4x4 prediction\". \nNOTE – Each block is assumed to be constructed into a picture array prior to decoding of the next block. \nDepending on Intra4x4PredMode[ luma4x4BlkIdx ], one of the Intra_4x4 prediction modes specified in clauses 8.3.1.2.1 \nto 8.3.1.2.9 is invoked. \n134  Rec. ITU-T H.264 (06/2019) \n \n8.3.1.2.1 Specification of Intra_4x4_Vertical prediction mode \nThis Intra_4x4 prediction mode is invoked when Intra4x4PredMode[ luma4x4BlkIdx ] is equal to 0. \nThis mode shall be used only when the samples p[ x, −1 ] with x = 0..3 are marked as \"available for Intra_4x4 prediction\". \nThe values of the prediction samples pred4x4 [ x, y ], with x, y = 0..3, are derived by \nL\n  pred4x4 [ x, y ] = p[ x, −1 ], with x, y = 0..3    (8-46) \nL\n8.3.1.2.2 Specification of Intra_4x4_Horizontal prediction mode \nThis Intra_4x4 prediction mode is invoked when Intra4x4PredMode[ luma4x4BlkIdx ] is equal to 1. \nThis mode shall be used only when the samples p[ −1, y ], with y = 0..3, are marked as \"available for Intra_4x4 prediction\". \nThe values of the prediction samples pred4x4 [ x, y ], with x, y = 0..3, are derived by \nL\n  pred4x4 [ x, y ] = p[ −1, y ], with x,y = 0..3    (8-47) \nL\n8.3.1.2.3 Specification of Intra_4x4_DC prediction mode \nThis Intra_4x4 prediction mode is invoked when Intra4x4PredMode[ luma4x4BlkIdx ] is equal to 2. \nThe values of the prediction samples pred4x4 [ x, y ], with x, y = 0..3, are derived as follows: \nL\n–  If all samples p[ x, −1 ], with x = 0..3, and p[ −1, y ], with y = 0..3, are marked as \"available for Intra_4x4 prediction\", \nthe values of the prediction samples pred4x4 [ x, y ], with x, y = 0..3, are derived by \nL\npred4x4 [ x, y ] = ( p[ 0, −1 ] + p[ 1, −1 ] + p[ 2, −1 ] + p[ 3, −1 ] +  \nL\n                p[ −1, 0 ] + p[ −1, 1 ] + p[ −1, 2 ] + p[ −1, 3 ] + 4 ) >> 3  (8-48) \n–  Otherwise, if any samples p[ x, −1 ], with x = 0..3, are marked as \"not available for Intra_4x4 prediction\" and all \nsamples p[ −1, y ], with y = 0..3, are marked as \"available for Intra_4x4 prediction\", the values of the prediction \nsamples pred4x4 [ x, y ], with x, y = 0..3, are derived by \nL\npred4x4 [ x, y ] = ( p[ −1, 0 ] + p[ −1, 1 ] + p[ −1, 2 ] + p[ −1, 3 ] + 2 ) >> 2  (8-49) \nL\n–  Otherwise, if any samples p[ −1, y ], with y = 0..3, are marked as \"not available for Intra_4x4 prediction\" and all \nsamples p[ x, −1 ], with x = 0 .. 3, are marked as \"available for Intra_4x4 prediction\", the values of the prediction \nsamples pred4x4 [ x, y ], with x, y = 0 .. 3, are derived by \nL\npred4x4 [ x, y ] = ( p[ 0, −1 ] + p[ 1, −1 ] + p[ 2, −1 ] + p[ 3, −1 ] + 2 ) >> 2  (8-50) \nL\n–  Otherwise (some samples p[ x, −1 ], with x = 0..3, and some samples p[ −1, y ], with y = 0..3, are marked as \"not \navailable for Intra_4x4 prediction\"), the values of the prediction samples pred4x4 [ x, y ], with x, y = 0..3, are derived \nL\nby \npred4x4 [ x, y ] = ( 1 << ( BitDepth  − 1 ) )    (8-51) \nL Y\nNOTE – A 4x4 luma block can always be predicted using this mode. \n8.3.1.2.4 Specification of Intra_4x4_Diagonal_Down_Left prediction mode \nThis Intra_4x4 prediction mode is invoked when Intra4x4PredMode[ luma4x4BlkIdx ] is equal to 3. \nThis mode shall be used only when the samples p[ x, −1 ] with x = 0..7 are marked as \"available for Intra_4x4 prediction\". \nThe values of the prediction samples pred4x4 [ x, y ], with x, y = 0..3, are derived as follows: \nL\n–  If x is equal to 3 and y is equal to 3, \npred4x4 [ x, y ] = ( p[ 6, −1 ] + 3 * p[ 7, −1 ] + 2 ) >> 2  (8-52) \nL\n–  Otherwise (x is not equal to 3 or y is not equal to 3), \npred4x4 [ x, y ] = ( p[ x + y, −1 ] + 2 * p[ x + y + 1, −1 ] + p[ x + y + 2, −1 ] + 2 ) >> 2  (8-53) \nL\n    Rec. ITU-T H.264 (06/2019)  135 \n \n8.3.1.2.5 Specification of Intra_4x4_Diagonal_Down_Right prediction mode \nThis Intra_4x4 prediction mode is invoked when Intra4x4PredMode[ luma4x4BlkIdx ] is equal to 4. \nThis mode shall be used only when the samples p[ x, −1 ] with x = 0..3 and p[ −1, y ] with y = −1..3 are marked as \"available \nfor Intra_4x4 prediction\". \nThe values of the prediction samples pred4x4 [ x, y ], with x, y = 0..3, are derived as follows: \nL\n–  If x is greater than y, \npred4x4 [ x, y ] = ( p[ x − y − 2, −1] + 2 * p[ x − y − 1, −1 ] + p[ x − y, −1 ] + 2 ) >> 2  (8-54) \nL\n–  Otherwise if x is less than y, \npred4x4 [ x, y ] = ( p[ −1, y − x − 2 ] + 2 * p[ −1, y − x − 1 ] + p[ −1, y − x ] + 2 ) >> 2  (8-55) \nL\n–  Otherwise (x is equal to y), \npred4x4 [ x, y ] = ( p[ 0, −1 ] + 2 * p[ −1, −1 ] + p[ −1, 0 ] + 2 ) >> 2  (8-56) \nL\n8.3.1.2.6 Specification of Intra_4x4_Vertical_Right prediction mode \nThis Intra_4x4 prediction mode is invoked when Intra4x4PredMode[ luma4x4BlkIdx ] is equal to 5. \nThis mode shall be used only when the samples p[ x, −1 ] with x = 0..3 and p[ −1, y ] with y = −1..3 are marked as \"available \nfor Intra_4x4 prediction\". \nLet the variable zVR be set equal to 2 * x − y. \nThe values of the prediction samples pred4x4 [ x, y ], with x, y = 0..3, are derived as follows: \nL\n–  If zVR is equal to 0, 2, 4, or 6, \npred4x4 [ x, y ] = ( p[ x − ( y >> 1 ) − 1, −1 ] + p[ x − ( y >> 1 ), −1 ] + 1 ) >> 1  (8-57) \nL\n–  Otherwise, if zVR is equal to 1, 3, or 5, \npred4x4 [ x, y ] = ( p[ x − ( y >> 1 ) − 2, −1] + 2 * p[ x − ( y >> 1 ) − 1, −1 ] + p[ x − ( y >> 1 ), −1 ] + 2 ) >> 2 \nL\n        (8-58) \n–  Otherwise, if zVR is equal to −1, \npred4x4 [ x, y ] = ( p[ −1, 0 ] + 2 * p[ −1, −1 ] + p[ 0, −1 ] + 2 ) >> 2  (8-59) \nL\n–  Otherwise (zVR is equal to −2 or −3), \npred4x4 [ x, y ] = ( p[ −1, y − 1 ] + 2 * p[ −1, y − 2 ] + p[ −1, y − 3 ] + 2 ) >> 2  (8-60) \nL\n8.3.1.2.7 Specification of Intra_4x4_Horizontal_Down prediction mode \nThis Intra_4x4 prediction mode is invoked when Intra4x4PredMode[ luma4x4BlkIdx ] is equal to 6. \nThis mode shall be used only when the samples p[ x, −1 ] with x = 0..3 and p[ −1, y ] with y = −1..3 are marked as \"available \nfor Intra_4x4 prediction\". \nLet the variable zHD be set equal to 2 * y − x. \nThe values of the prediction samples pred4x4 [ x, y ], with x, y = 0..3, are derived as follows: \nL\n–  If zHD is equal to 0, 2, 4, or 6, \npred4x4 [ x, y ] = ( p[ −1, y − ( x >> 1 ) − 1 ] + p[ −1, y − ( x >> 1 ) ] + 1 ) >> 1  (8-61) \nL\n–  Otherwise, if zHD is equal to 1, 3, or 5, \npred4x4 [ x, y ] = ( p[ −1, y − ( x >> 1 ) − 2 ] + 2 * p[ −1, y − ( x >> 1 ) − 1 ] + p[ −1, y − ( x >> 1 ) ] + 2 ) >> 2 \nL\n        (8-62) \n–  Otherwise, if zHD is equal to −1, \n136  Rec. ITU-T H.264 (06/2019) \n \npred4x4 [ x, y ] = ( p[ −1, 0 ] + 2 * p[ −1, −1 ] + p[ 0, −1 ] + 2 ) >> 2  (8-63) \nL\n–  Otherwise (zHD is equal to −2 or −3), \npred4x4 [ x, y ] = ( p[ x − 1, −1 ] + 2 * p[ x − 2, −1 ] + p[ x − 3, −1 ] + 2 ) >> 2  (8-64) \nL\n8.3.1.2.8 Specification of Intra_4x4_Vertical_Left prediction mode \nThis Intra_4x4 prediction mode is invoked when Intra4x4PredMode[ luma4x4BlkIdx ] is equal to 7. \nThis mode shall be used only when the samples p[ x, −1 ] with x = 0..7 are marked as \"available for Intra_4x4 prediction\". \nThe values of the prediction samples pred4x4 [ x, y ], with x, y = 0..3, are derived as follows: \nL\n–  If y is equal to 0 or 2, \npred4x4 [ x, y ] = ( p[ x + ( y >> 1 ), −1 ] + p[ x + ( y >> 1 ) + 1, −1 ] + 1) >> 1  (8-65) \nL\n–  Otherwise (y is equal to 1 or 3), \npred4x4 [ x, y ] = ( p[ x + ( y >> 1 ), −1 ] + 2 * p[ x + ( y >> 1 ) + 1, −1 ] + p[ x + ( y >> 1 ) + 2, −1 ] + 2 ) >> 2 \nL\n        (8-66) \n8.3.1.2.9 Specification of Intra_4x4_Horizontal_Up prediction mode \nThis Intra_4x4 prediction mode is invoked when Intra4x4PredMode[ luma4x4BlkIdx ] is equal to 8. \nThis mode shall be used only when the samples p[ −1, y ] with y = 0..3 are marked as \"available for Intra_4x4 prediction\". \nLet the variable zHU be set equal to x + 2 * y. \nThe values of the prediction samples pred4x4 [ x, y ], with x, y = 0..3, are derived as follows: \nL\n–  If zHU is equal to 0, 2, or 4 \npred4x4 [ x, y ] = ( p[ −1, y + ( x >> 1 ) ] + p[ −1, y + ( x >> 1 ) + 1 ] + 1 ) >> 1  (8-67) \nL\n–  Otherwise, if zHU is equal to 1 or 3 \npred4x4 [ x, y ] = ( p[ −1, y + ( x >> 1 ) ] + 2 * p[ −1, y + ( x >> 1 ) + 1 ] + p[ −1, y + ( x >> 1 ) + 2 ] + 2 ) >> 2 \nL\n        (8-68) \n–  Otherwise, if zHU is equal to 5, \npred4x4 [ x, y ] = ( p[ −1, 2 ] + 3 * p[ −1, 3 ] + 2 ) >> 2  (8-69) \nL\n–  Otherwise (zHU is greater than 5), \npred4x4 [ x, y ] = p[ −1, 3 ]    (8-70) \nL\n8.3.2  Intra_8x8 prediction process for luma samples \nThis process is invoked when the macroblock prediction mode is equal to Intra_8x8. \nInputs to this process are the values of Intra4x4PredMode (if available) or Intra8x8PredMode (if available) from the \nneighbouring macroblocks or macroblock pairs. \nOutputs of this process are 8x8 luma sample arrays as part of the 16x16 luma array of prediction samples of the macroblock \npred . \nL\nThe luma component of a macroblock consists of 4 blocks of 8x8 luma samples. These blocks are inverse scanned using \nthe inverse 8x8 luma block scanning process as specified in clause 6.4.5. \nFor all 8x8 luma blocks of the luma component of a macroblock with luma8x8BlkIdx = 0..3, the derivation process for \nIntra8x8PredMode  as  specified  in  clause 8.3.2.1  is  invoked  with  luma8x8BlkIdx  as  well  as  Intra4x4PredMode  and \nIntra8x8PredMode that are previously (in decoding order) derived for adjacent macroblocks as the input and the variable \nIntra8x8PredMode[ luma8x8BlkIdx ] as the output. \nFor each luma block of 8x8 samples indexed using luma8x8BlkIdx = 0..3, the following ordered steps are specified: \n    Rec. ITU-T H.264 (06/2019)  137 \n \n1.  The Intra_8x8 sample prediction process in  clause 8.3.2.2 is invoked  with luma8x8BlkIdx and the array S′  \nL\ncontaining constructed samples prior to the deblocking filter process from adjacent luma blocks as the input and \nthe output are the Intra_8x8 luma prediction samples pred8x8 [ x, y ] with x, y = 0..7. \nL\n2.  The  position  of  the  upper-left  sample  of  an  8x8  luma  block  with  index  luma8x8BlkIdx  inside  the  current \nmacroblock  is  derived  by  invoking  the  inverse  8x8  luma  block  scanning  process  in  clause 6.4.5  with \nluma8x8BlkIdx as the input and the output being assigned to ( xO, yO ). \n3.  The values of the prediction samples pred [ xO + x, yO + y ] with x, y = 0..7 are derived by \nL\npred [ xO + x, yO + y ] = pred8x8 [ x, y ]    (8-71) \nL L\n4.  The transform coefficient decoding process and picture construction process prior to deblocking filter process in \nclause 8.5 is invoked with pred  and luma8x8BlkIdx as the input and the constructed samples for the current 8x8 \nL\nluma block S′  as the output. \nL\n8.3.2.1  Derivation process for Intra8x8PredMode \nInputs to this process are the index of the 8x8 luma block luma8x8BlkIdx and variable arrays Intra4x4PredMode (if \navailable) and Intra8x8PredMode (if available) that are previously (in decoding order) derived for adjacent macroblocks. \nOutput of this process is the variable Intra8x8PredMode[ luma8x8BlkIdx ]. \nTable 8-3 specifies the values for Intra8x8PredMode[ luma8x8BlkIdx ] and the associated mnemonic names. \nTable 8-3 – Specification of Intra8x8PredMode[ luma8x8BlkIdx ] and associated names \n \nIntra8x8PredMode[ luma8x8BlkIdx ]  Name of Intra8x8PredMode[ luma8x8BlkIdx ] \n0  Intra_8x8_Vertical (prediction mode) \n1  Intra_8x8_Horizontal (prediction mode) \n2  Intra_8x8_DC (prediction mode) \n3  Intra_8x8_Diagonal_Down_Left (prediction mode) \n4  Intra_8x8_Diagonal_Down_Right (prediction mode) \n5  Intra_8x8_Vertical_Right (prediction mode) \n6  Intra_8x8_Horizontal_Down (prediction mode) \n7  Intra_8x8_Vertical_Left (prediction mode) \n8  Intra_8x8_Horizontal_Up (prediction mode) \n \nIntra8x8PredMode[ luma8x8BlkIdx ] is derived as specified by the following ordered steps: \n1.  The process specified in clause 6.4.11.2 is invoked with luma8x8BlkIdx given as input and the output is assigned \nto mbAddrA, luma8x8BlkIdxA, mbAddrB, and luma8x8BlkIdxB. \n2.  The variable dcPredModePredictedFlag is derived as follows: \n–  If any of the following conditions are true, dcPredModePredictedFlag is set equal to 1: \n–  the macroblock with address mbAddrA is not available, \n–  the macroblock with address mbAddrB is not available, \n–  the macroblock with address mbAddrA is available and coded in an Inter macroblock prediction mode \nand constrained_intra_pred_flag is equal to 1, \n–  the macroblock with address mbAddrB is available and coded in an Inter macroblock prediction mode \nand constrained_intra_pred_flag is equal to 1. \n–  Otherwise, dcPredModePredictedFlag is set equal to 0. \n3.  For N being either replaced by A or B, the variables intraMxMPredModeN are derived as follows: \n138  Rec. ITU-T H.264 (06/2019) \n \n–  If dcPredModePredictedFlag is equal to 1 or the macroblock with address mbAddrN is not coded in Intra_4x4 \nor Intra_8x8 macroblock prediction mode, intraMxMPredModeN is set equal to 2 (Intra_8x8_DC prediction \nmode). \n–  Otherwise (dcPredModePredictedFlag is equal to 0 and (the macroblock with address mbAddrN is coded in \nIntra_4x4 macroblock prediction mode or the macroblock with address mbAddrN is coded in Intra_8x8 \nmacroblock prediction mode)), the following applies: \n–  If  the  macroblock  with  address  mbAddrN  is  coded  in  Intra_8x8  macroblock  prediction  mode, \nintraMxMPredModeN is set equal to Intra8x8PredMode[ luma8x8BlkIdxN ], where Intra8x8PredMode \nis the variable array assigned to the macroblock mbAddrN. \n–  Otherwise (the macroblock with address mbAddrN is coded in Intra_4x4 macroblock prediction mode), \nintraMxMPredModeN is derived by the following procedure, where Intra4x4PredMode is the variable \narray assigned to the macroblock mbAddrN. \nintraMxMPredModeN = Intra4x4PredMode[ luma8x8BlkIdxN * 4 + n ]  (8-72) \nwhere the variable n is derived as follows: \n–  If N is equal to A, depending on the variable MbaffFrameFlag, the variable luma8x8BlkIdx, the \ncurrent macroblock, and the macroblock mbAddrN, the following applies: \n–  If MbaffFrameFlag is equal to 1, the current macroblock is a frame coded macroblock, the \nmacroblock mbAddrN is a field coded macroblock, and luma8x8BlkIdx is equal to 2, n is set \nequal to 3. \n–  Otherwise  (MbaffFrameFlag  is  equal  to 0  or  the  current  macroblock  is  a  field  coded \nmacroblock or the macroblock mbAddrN is a frame coded macroblock or luma8x8BlkIdx is \nnot equal to 2), n is set equal to 1. \n–  Otherwise (N is equal to B), n is set equal to 2. \n4.  Finally,  given  intraMxMPredModeA  and  intraMxMPredModeB,  the  variable \nIntra8x8PredMode[ luma8x8BlkIdx ] is derived by applying the following procedure. \npredIntra8x8PredMode = Min( intraMxMPredModeA, intraMxMPredModeB ) \nif( prev_intra8x8_pred_mode_flag[ luma8x8BlkIdx ] ) \n  Intra8x8PredMode[ luma8x8BlkIdx ] = predIntra8x8PredMode \nelse        (8-73) \n  if( rem_intra8x8_pred_mode[ luma8x8BlkIdx ] < predIntra8x8PredMode ) \n    Intra8x8PredMode[ luma8x8BlkIdx ] = rem_intra8x8_pred_mode[ luma8x8BlkIdx ] \n  else \n    Intra8x8PredMode[ luma8x8BlkIdx ] = rem_intra8x8_pred_mode[ luma8x8BlkIdx ] + 1 \n8.3.2.2  Intra_8x8 sample prediction \nThis process is invoked for each 8x8 luma block of a macroblock with macroblock prediction mode equal to Intra_8x8 \nfollowed by the transform decoding process and picture construction process prior to deblocking for each 8x8 luma block. \nInputs to this process are: \n–  the index of an 8x8 luma block luma8x8BlkIdx, \n–  an (PicWidthInSamples )x(PicHeightInSamples ) array cS  containing constructed luma samples prior to the \nL L L\ndeblocking filter process of neighbouring macroblocks. \nOutput of this process are the prediction samples pred8x8 [ x, y ], with x, y = 0..7, for the 8x8 luma block with index \nL\nluma8x8BlkIdx. \nThe position of the upper-left sample of an 8x8 luma block with index luma8x8BlkIdx inside the current macroblock is \nderived by invoking the inverse 8x8 luma block scanning process in clause 6.4.5 with luma8x8BlkIdx as the input and the \noutput being assigned to ( xO, yO ). \nThe 25 neighbouring samples p[ x, y ] that are constructed luma samples prior to the deblocking filter process, with x = −1, \ny = −1..7 and x = 0..15, y = −1, are derived as specified by the following ordered steps: \n1.  The luma location ( xN, yN ) is specified by \nxN = xO + x    (8-74) \n    Rec. ITU-T H.264 (06/2019)  139 \n \nyN = yO + y    (8-75) \n2.  The derivation process for neighbouring locations in clause 6.4.12 is invoked for luma locations with ( xN, yN ) as \ninput and mbAddrN and ( xW, yW ) as output. \n3.  Each sample p[ x, y ] with x = −1, y = −1..7 and x = 0..15, y = −1 is derived as follows: \n–  If any of the following conditions are true, the sample p[ x, y ] is marked as \"not available for Intra_8x8 \nprediction\": \n–  mbAddrN is not available, \n–  the  macroblock  mbAddrN  is  coded  in  an  Inter  macroblock  prediction  mode  and \nconstrained_intra_pred_flag is equal to 1. \n–  Otherwise, the sample p[ x, y ] is marked as \"available for Intra_8x8 prediction\" and the sample value p[ x, y ] \nis derived as specified by the following ordered steps: \na.  The location of the upper-left luma sample of the macroblock mbAddrN is derived by invoking the \ninverse macroblock scanning process in clause 6.4.1 with mbAddrN as the input and the output is \nassigned to ( xM, yM ). \nb.  Depending on the variable MbaffFrameFlag and the macroblock mbAddrN, the sample value p[ x, y ] \nis derived as follows: \n–  If MbaffFrameFlag is equal to 1 and the macroblock mbAddrN is a field macroblock, \np[ x, y ] = cS [ xM + xW, yM + 2 * yW ]  (8-76) \nL\n–  Otherwise (MbaffFrameFlag is equal to 0 or the macroblock mbAddrN is a frame macroblock), \np[ x, y ] = cS [ xM + xW, yM + yW ]  (8-77) \nL\nWhen samples p[ x, −1 ], with x = 8..15, are marked as \"not available for Intra_8x8 prediction,\" and the sample p[ 7, −1 ] \nis marked as \"available for Intra_8x8 prediction,\" the sample value of p[ 7, −1 ] is substituted for sample values p[ x, −1 ], \nwith x = 8..15, and samples p[ x, −1 ], with x = 8..15, are marked as \"available for Intra_8x8 prediction\". \nNOTE – Each block is assumed to be constructed into a picture array prior to decoding of the next block. \nThe reference sample filtering process for Intra_8x8 sample prediction in clause 8.3.2.2.1 is invoked with the samples \np[ x, y ]  with x = −1,  y = −1..7 and x = 0..15, y = −1 (if available) as input and p′[ x, y ]  with x = −1, y = −1..7 and \nx = 0..15, y = −1 as output. \nDepending on Intra8x8PredMode[ luma8x8BlkIdx ], one of the Intra_8x8 prediction modes specified in clauses 8.3.2.2.2 \nto 8.3.2.2.10 is invoked. \n8.3.2.2.1 Reference sample filtering process for Intra_8x8 sample prediction \nInputs to this process are the reference samples p[ x, y ] with x = −1, y = −1..7 and x = 0..15, y = −1 (if available) for \nIntra_8x8 sample prediction. \nOutputs of this process are the filtered reference samples p′[ x, y ] with x = −1, y = −1..7 and x = 0..15, y = −1 for Intra_8x8 \nsample prediction. \nWhen all samples p[ x, −1 ] with x = 0..15 are marked as \"available for Intra_8x8 prediction\", the following applies: \n1.  The value of p′[ 0, −1 ] is derived as follows: \n–  If p[ −1, −1 ] is marked as \"available for Intra_8x8 prediction\", p′[ 0, −1 ] is derived by \np′[ 0, −1 ] = ( p[ −1, −1 ] + 2 * p[ 0, −1 ] + p[ 1, −1 ] + 2 ) >> 2  (8-78) \n–  Otherwise (p[ −1, −1 ] is marked as \"not available for Intra_8x8 prediction\"), p′[ 0, −1 ] is derived by \np′[ 0, −1 ] = ( 3 * p[ 0, −1 ] + p[ 1, −1 ] + 2 ) >> 2  (8-79) \n2.  The values of p′[ x, −1 ], with x = 1..14, are derived by \np′[ x, −1 ] = ( p[ x − 1, −1 ] + 2 * p[ x, −1 ] + p[ x+1, −1 ] + 2 ) >> 2  (8-80) \n3.  The value of p′[ 15, −1 ] is derived by \n140  Rec. ITU-T H.264 (06/2019) \n \np′[ 15, −1 ] = ( p[ 14, −1 ] + 3 * p[ 15, −1 ] + 2 ) >> 2  (8-81) \nWhen the sample p[ −1, −1 ] is marked as \"available for Intra_8x8 prediction\", the value of p′[ −1, −1 ] is derived as \nfollows: \n–  If the sample p[ 0, −1 ] is marked as \"not available for Intra_8x8 prediction\" or the sample p[ −1, 0 ] is marked as \"not \navailable for Intra_8x8 prediction\", the following applies: \n–  If the sample p[ 0, −1 ] is marked as \"available for Intra_8x8 prediction\", p′[ −1, −1 ] is derived by \np′[ −1, −1 ] = ( 3 * p[ −1, −1 ] + p[ 0, −1 ] + 2 ) >> 2  (8-82) \n–  Otherwise, if the sample p[ 0, −1 ] is marked as \"not available for Intra_8x8 prediction\" and the sample p[ −1, 0 ] \nis marked as \"available for Intra_8x8 prediction\", p′[ −1, −1 ] is derived by \np′[ −1, −1 ] = ( 3 * p[ −1, −1 ] + p[ −1, 0 ] + 2) >> 2  (8-83) \n–  Otherwise (the sample p[ 0, −1 ] is marked as \"not available for Intra_8x8 prediction\" and the sample p[ −1, 0 ] \nis marked as \"not available for Intra_8x8 prediction\"), p′[ −1, −1 ] is set equal to p[ −1, −1 ]. \nNOTE – When both samples p[ 0, −1 ] and p[ −1, 0 ] are marked as \"not available for Intra_8x8 prediction\", the derived \nsample p′[ −1, −1 ] is not used in the intra prediction process. \n–  Otherwise (the sample p[ 0, −1 ] is marked as \"available for Intra_8x8 prediction\" and the sample p[ −1, 0 ] is marked \nas \"available for Intra_8x8 prediction\"), p′[ −1, −1 ] is derived by \np′[ −1, −1 ] = ( p[ 0, −1 ] + 2 * p[ −1, −1 ] + p[ −1, 0 ] + 2) >> 2  (8-84) \nWhen all samples p[ −1, y ] with y = 0..7 are marked as \"available for Intra_8x8 prediction\", the following applies: \n1.  The value of p′[ −1, 0 ] is derived as follows: \n–  If p[ −1, −1 ] is marked as \"available for Intra_8x8 prediction\", p′[ −1, 0 ] is derived by \np′[ −1, 0 ] = ( p[ −1, −1 ] + 2 * p[ −1, 0 ] + p[ −1, 1 ] + 2 ) >> 2  (8-85) \n–  Otherwise (p[ −1, −1 ] is marked as \"not available for Intra_8x8 prediction\"), p′[ −1, 0 ] is derived by \np′[ −1, 0 ] = ( 3 * p[ −1, 0 ] + p[ −1, 1 ] + 2 ) >> 2  (8-86) \n2.  The values of p′[ −1, y ], with y = 1..6, are derived by \np′[ −1, y ] = ( p[ −1, y − 1 ] + 2 * p[ −1, y ] + p[ −1, y+1 ] + 2 ) >> 2  (8-87) \n3.  The value of p′[ −1, 7 ] is derived by \np′[ −1, 7 ] = ( p[ −1, 6 ] + 3 * p[ −1, 7 ] + 2 ) >> 2  (8-88) \n8.3.2.2.2 Specification of Intra_8x8_Vertical prediction mode \nThis Intra_8x8 prediction mode is invoked when Intra8x8PredMode[ luma8x8BlkIdx ] is equal to 0. \nThis mode shall be used only when the samples p[ x, −1 ] with x = 0..7 are marked as \"available for Intra_8x8 prediction\". \nThe values of the prediction samples pred8x8 [ x, y ], with x, y = 0..7, are derived by \nL\npred8x8 [ x, y ] = p′[ x, −1 ], with x, y = 0..7    (8-89) \nL\n8.3.2.2.3 Specification of Intra_8x8_Horizontal prediction mode \nThis Intra_8x8 prediction mode is invoked when Intra8x8PredMode[ luma8x8BlkIdx ] is equal to 1. \nThis mode shall be used only when the samples p[ −1, y ], with y = 0..7, are marked as \"available for Intra_8x8 prediction\". \nThe values of the prediction samples pred8x8 [ x, y ], with x, y = 0..7, are derived by \nL\npred8x8 [ x, y ] = p′[ −1, y ], with x, y = 0..7    (8-90) \nL\n    Rec. ITU-T H.264 (06/2019)  141 \n \n8.3.2.2.4 Specification of Intra_8x8_DC prediction mode \nThis Intra_8x8 prediction mode is invoked when Intra8x8PredMode[ luma8x8BlkIdx ] is equal to 2. \nThe values of the prediction samples pred8x8 [ x, y ], with x, y = 0..7, are derived as follows: \nL\n–  If all samples p[ x, −1 ], with x = 0..7, and p[ −1, y ], with y = 0..7, are marked as \"available for Intra_8x8 prediction,\" \nthe values of the prediction samples pred8x8 [ x, y ], with x, y = 0..7, are derived by \nL\n7 7\npred8x8 [ x, y ]  (p'[x',1]p'[1, y']8)  4   (8-91) \nL\nx'0 y'0\n–  Otherwise, if any samples p[ x, −1 ], with x = 0..7, are marked as \"not available for Intra_8x8 prediction\" and all \nsamples p[ −1, y ], with y = 0..7, are marked as \"available for Intra_8x8 prediction\", the values of the prediction \nsamples pred8x8 [ x, y ], with x, y = 0..7, are derived by \nL\n7\npred8x8 [ x, y ]  (p'[1, y']4)  3     (8-92) \nL\ny'0\n–  Otherwise, if any samples p[ −1, y ], with y = 0..7, are marked as \"not available for Intra_8x8 prediction\" and all \nsamples p[ x, −1 ], with x = 0..7, are marked as \"available for Intra_8x8 prediction\", the values of the prediction \nsamples pred8x8 [ x, y ], with x, y = 0..7, are derived by \nL\n7\npred8x8 [ x, y ]  (p'[x',1]4)  3     (8-93) \nL\nx'0\n–  Otherwise (some samples p[ x, −1 ], with x = 0..7, and some samples p[ −1, y ], with y = 0..7, are marked as \"not \navailable for Intra_8x8 prediction\"), the values of the prediction samples pred8x8 [ x, y ], with x, y = 0..7, are derived \nL\nby \npred8x8 [ x, y ] = ( 1 << ( BitDepth  − 1 ) )    (8-94) \nL Y\nNOTE – An 8x8 luma block can always be predicted using this mode. \n8.3.2.2.5 Specification of Intra_8x8_Diagonal_Down_Left prediction mode \nThis Intra_8x8 prediction mode is invoked when Intra8x8PredMode[ luma8x8BlkIdx ] is equal to 3. \nThis mode shall be used only when the samples p[ x, −1 ] with x = 0..15 are marked as \"available for Intra_8x8 prediction\". \nThe values of the prediction samples pred8x8 [ x, y ], with x, y = 0..7, are derived as follows: \nL\n–  If x is equal to 7 and y is equal to 7, \npred8x8 [ x, y ] = ( p′[ 14, −1 ] + 3 * p′[ 15, −1 ] + 2 ) >> 2  (8-95) \nL\n–  Otherwise (x is not equal to 7 or y is not equal to 7), \npred8x8 [ x, y ] = ( p′[ x + y, −1 ] + 2 * p′[ x + y + 1, −1 ] + p′[ x + y + 2, −1 ] + 2 ) >> 2  (8-96) \nL\n8.3.2.2.6 Specification of Intra_8x8_Diagonal_Down_Right prediction mode \nThis Intra_8x8 prediction mode is invoked when Intra8x8PredMode[ luma8x8BlkIdx ] is equal to 4. \nThis mode shall be used only when the samples p[ x, −1 ] with x = 0..7 and p[ −1, y ] with y = −1..7 are marked as \n\"available for Intra_8x8 prediction\". \nThe values of the prediction samples pred8x8 [ x, y ], with x, y = 0..7, are derived as follows: \nL\n–  If x is greater than y, \npred8x8 [ x, y ] = ( p′[ x − y − 2, −1] + 2 * p′[ x − y − 1, −1 ] + p′[ x − y, −1 ] + 2 ) >> 2  (8-97) \nL\n–  Otherwise if x is less than y, \npred8x8 [ x, y ] = ( p′[ −1, y − x − 2 ] + 2 * p′[ −1, y − x − 1 ] + p′[ −1, y − x ] + 2 ) >> 2  (8-98) \nL\n–  Otherwise (x is equal to y), \n142  Rec. ITU-T H.264 (06/2019) \n \npred8x8 [ x, y ] = ( p′[ 0, −1 ] + 2 * p′[ −1, −1 ] + p′[ −1, 0 ] + 2 ) >> 2  (8-99) \nL\n8.3.2.2.7 Specification of Intra_8x8_Vertical_Right prediction mode \nThis Intra_8x8 prediction mode is invoked when Intra8x8PredMode[ luma8x8BlkIdx ] is equal to 5. \nThis mode shall be used only when the samples p[ x, −1 ] with x = 0..7 and p[ −1, y ] with y = −1..7 are marked as \n\"available for Intra_8x8 prediction\". \nLet the variable zVR be set equal to 2 * x − y. \nThe values of the prediction samples pred8x8 [ x, y ], with x, y = 0..7, are derived as follows: \nL\n–  If zVR is equal to 0, 2, 4, 6, 8, 10, 12, or 14 \npred8x8 [ x, y ] = ( p′[ x − ( y >> 1 ) − 1, −1 ] + p′[ x − ( y >> 1 ), −1 ] + 1 ) >> 1  (8-100) \nL\n–  Otherwise, if zVR is equal to 1, 3, 5, 7, 9, 11, or 13 \npred8x8 [ x, y ] = ( p′[ x − ( y >> 1 ) − 2, −1] + 2 * p′[ x − ( y >> 1 ) − 1, −1 ] + \nL\n                                 p′[ x − ( y >> 1 ), −1 ] + 2 ) >> 2    (8-101) \n–  Otherwise, if zVR is equal to −1, \npred8x8 [ x, y ] = ( p′[ −1, 0 ] + 2 * p′[ −1, −1 ] + p′[ 0, −1 ] + 2 ) >> 2  (8-102) \nL\n–  Otherwise (zVR is equal to −2, −3, −4, −5, −6, or −7), \npred8x8 [ x, y ] = ( p′[ −1, y − 2*x − 1 ] + 2 * p′[ −1, y − 2*x − 2 ] + p′[ −1, y − 2*x − 3 ] + 2 ) >> 2  (8-103) \nL\n8.3.2.2.8 Specification of Intra_8x8_Horizontal_Down prediction mode \nThis Intra_8x8 prediction mode is invoked when Intra8x8PredMode[ luma8x8BlkIdx ] is equal to 6. \nThis mode shall be used only when the samples p[ x, −1 ] with x = 0..7 and p[ −1, y ] with y = −1..7 are marked as \n\"available for Intra_8x8 prediction\". \nLet the variable zHD be set equal to 2 * y − x. \nThe values of the prediction samples pred8x8 [ x, y ], with x, y = 0..7, are derived as follows: \nL\n–  If zHD is equal to 0, 2, 4, 6, 8, 10, 12, or 14 \npred8x8 [ x, y ] = ( p′[ −1, y − ( x >> 1 ) − 1 ] + p′[ −1, y − ( x >> 1 ) ] + 1 ) >> 1  (8-104) \nL\n–  Otherwise, if zHD is equal to 1, 3, 5, 7, 9, 11, or 13 \npred8x8 [ x, y ] = ( p′[ −1, y − ( x >> 1 ) − 2 ] + 2 * p′[ −1, y − ( x >> 1 ) − 1 ] + \nL\n                                 p′[ −1, y − ( x >> 1 ) ] + 2 ) >> 2    (8-105) \n–  Otherwise, if zHD is equal to −1, \npred8x8 [ x, y ] = ( p′[ −1, 0 ] + 2 * p′[ −1, −1 ] + p′[ 0, −1 ] + 2 ) >> 2  (8-106) \nL\n–  Otherwise (zHD is equal to −2, −3, −4, −5, −6, −7), \npred8x8 [ x, y ] = ( p′[ x − 2*y − 1, −1 ] + 2 * p′[ x − 2*y − 2, −1 ] + p′[ x − 2*y − 3, −1 ] + 2 ) >> 2  (8-107) \nL\n8.3.2.2.9 Specification of Intra_8x8_Vertical_Left prediction mode \nThis Intra_8x8 prediction mode is invoked when Intra8x8PredMode[ luma8x8BlkIdx ] is equal to 7. \nThis mode shall be used only when the samples p[ x, −1 ] with x = 0..15 are marked as \"available for Intra_8x8 prediction\". \nThe values of the prediction samples pred8x8 [ x, y ], with x, y = 0..7, are derived as follows: \nL\n–  If y is equal to 0, 2, 4 or 6 \npred8x8 [ x, y ] = ( p′[ x + ( y >> 1 ), −1 ] + p′[ x + ( y >> 1 ) + 1, −1 ] + 1) >> 1  (8-108) \nL\n    Rec. ITU-T H.264 (06/2019)  143 \n \n–  Otherwise (y is equal to 1, 3, 5, 7), \npred8x8 [ x, y ] = ( p′[ x + ( y >> 1 ), −1 ] + 2 * p′[ x + ( y >> 1 ) + 1, −1 ] + \nL\n                                 p′[ x + ( y >> 1 ) + 2, −1 ] + 2 ) >>2    (8-109) \n8.3.2.2.10  Specification of Intra_8x8_Horizontal_Up prediction mode \nThis Intra_8x8 prediction mode is invoked when Intra8x8PredMode[ luma8x8BlkIdx ] is equal to 8. \nThis mode shall be used only when the samples p[ −1, y ] with y = 0..7 are marked as \"available for Intra_8x8 prediction\". \nLet the variable zHU be set equal to x + 2 * y. \nThe values of the prediction samples pred8x8 [ x, y ], with x, y = 0..7, are derived as follows: \nL\n–  If zHU is equal to 0, 2, 4, 6, 8, 10, or 12 \npred8x8 [ x, y ] = ( p′[ −1, y + ( x >> 1 ) ] + p′[ −1, y + ( x >> 1 ) + 1 ] + 1 ) >> 1  (8-110) \nL\n–  Otherwise, if zHU is equal to 1, 3, 5, 7, 9, or 11 \npred8x8 [ x, y ] = ( p′[ −1, y + ( x >> 1 ) ] + 2 * p′[ −1, y + ( x >> 1 ) + 1 ] + \nL\n                                 p′[ −1, y + ( x >> 1 ) + 2 ] + 2 ) >>2    (8-111) \n–  Otherwise, if zHU is equal to 13, \npred8x8 [ x, y ] = ( p′[ −1, 6 ] + 3 * p′[ −1, 7 ] + 2 ) >> 2  (8-112) \nL\n–  Otherwise (zHU is greater than 13), \npred8x8 [ x, y ] = p′[ −1, 7 ]    (8-113) \nL\n8.3.3  Intra_16x16 prediction process for luma samples \nThis process is invoked when the macroblock prediction mode is equal to Intra_16x16. It specifies how the Intra prediction \nluma samples for the current macroblock are derived. \nInput to this process is a (PicWidthInSamples )x(PicHeightInSamples ) array cS  containing constructed luma samples \nL L L\nprior to the deblocking filter process of neighbouring macroblocks. \nOutputs of this process are Intra prediction luma samples for the current macroblock pred [ x, y ]. \nL\nThe 33 neighbouring samples p[ x, y ] that are constructed luma samples prior to the deblocking filter process, with x = −1, \ny = −1..15 and with x = 0..15, y = −1, are derived as specified by the following ordered steps: \n1.  The derivation process for neighbouring locations in clause 6.4.12 is invoked for luma locations with ( x, y ) \nassigned to ( xN, yN ) as input and mbAddrN and ( xW, yW ) as output. \n2.  Each sample p[ x, y ] with x = −1, y = −1..15 and with x = 0..15, y = −1 is derived as follows: \n–  If any of the following conditions are true, the sample p[ x, y ] is marked as \"not available for Intra_16x16 \nprediction\": \n–  mbAddrN is not available, \n–  the  macroblock  mbAddrN  is  coded  in  an  Inter  macroblock  prediction  mode  and \nconstrained_intra_pred_flag is equal to 1, \n–  the macroblock mbAddrN has mb_type equal to SI and constrained_intra_pred_flag is equal to 1. \n–  Otherwise, the sample p[ x, y ] is marked as \"available for Intra_16x16 prediction\" and the value of the sample \np[ x, y ] is derived as specified by the following ordered steps: \na.  The location of the upper-left luma sample of the macroblock mbAddrN is derived by invoking the \ninverse macroblock scanning process in clause 6.4.1 with mbAddrN as the input and the output is \nassigned to ( xM, yM ). \nb.  Depending on the variable MbaffFrameFlag and the macroblock mbAddrN, the sample value p[ x, y ] \nis derived as follows: \n–  If MbaffFrameFlag is equal to 1 and the macroblock mbAddrN is a field macroblock, \n144  Rec. ITU-T H.264 (06/2019) \n \np[ x, y ] = cS [ xM + xW, yM + 2 * yW ]  (8-114) \nL\n–  Otherwise (MbaffFrameFlag is equal to 0 or the macroblock mbAddrN is a frame macroblock), \np[ x, y ] = cS [ xM + xW, yM + yW ]  (8-115) \nL\nLet pred [ x, y ] with x, y = 0..15 denote the prediction samples for the 16x16 luma block samples. \nL\nIntra_16x16 prediction modes are specified in Table 8-4. \nTable 8-4 – Specification of Intra16x16PredMode and associated names \nIntra16x16PredMode  Name of Intra16x16PredMode \n0  Intra_16x16_Vertical (prediction mode) \n1  Intra_16x16_Horizontal (prediction mode) \n2  Intra_16x16_DC (prediction mode) \n3  Intra_16x16_Plane (prediction mode) \nDepending on Intra16x16PredMode, one of the Intra_16x16 prediction modes specified in clauses 8.3.3.1 to 8.3.3.4 is \ninvoked. \n8.3.3.1  Specification of Intra_16x16_Vertical prediction mode \nThis Intra_16x16 prediction mode shall be used only when the samples p[ x, −1 ] with x = 0..15 are marked as \"available \nfor Intra_16x16 prediction\". \nThe values of the prediction samples pred [ x, y ], with x, y = 0..15, are derived by \nL\npred [ x, y ] = p[ x, −1 ], with x, y = 0..15    (8-116) \nL\n8.3.3.2  Specification of Intra_16x16_Horizontal prediction mode \nThis Intra_16x16 prediction mode shall be used only when the samples p[−1, y] with y = 0..15 are marked as \"available \nfor Intra_16x16 prediction\". \nThe values of the prediction samples pred [ x, y ], with x, y = 0..15, are derived by \nL\npred [ x, y ] = p[ −1, y ], with x, y = 0..15    (8-117) \nL\n8.3.3.3  Specification of Intra_16x16_DC prediction mode \nThis Intra_16x16 prediction mode operates, depending on whether the neighbouring samples are marked as \"available for \nIntra_16x16 prediction\", as follows: \n–  If all neighbouring samples p[ x, −1 ], with x = 0..15, and p[ −1, y ], with y = 0..15, are marked as \"available for \nIntra_16x16 prediction\", the prediction for all luma samples in the macroblock is given by: \n15 15\npred L [ x, y ] =  (p  x',1   p  1,y'  16)  5, with x, y = 0..15  (8-118) \nx'0 y'0\n–  Otherwise, if any of the neighbouring samples p[ x, −1 ], with x = 0..15, are marked as \"not available for Intra_16x16 \nprediction\" and all of the neighbouring samples p[ −1, y ], with y = 0..15, are marked as \"available for Intra_16x16 \nprediction\", the prediction for all luma samples in the macroblock is given by: \n15\npred L [ x, y ] =  (p  1,y'  8)  4 , with x, y = 0..15  (8-119) \ny'0\n–  Otherwise, if any of the neighbouring samples p[ −1, y ], with y = 0..15, are marked as \"not available for Intra_16x16 \nprediction\" and all of the neighbouring samples p[ x, −1 ], with x = 0..15, are marked as \"available for Intra_16x16 \nprediction\", the prediction for all luma samples in the macroblock is given by: \n15\npred L [ x, y ] =  (p  x',1  8)  4 , with x, y = 0..15  (8-120) \nx'0\n    Rec. ITU-T H.264 (06/2019)  145 \n \n–  Otherwise (some of the neighbouring samples p[ x, −1 ], with x = 0..15, and some of the neighbouring samples \np[ −1, y ], with y = 0..15, are marked as \"not available for Intra_16x16 prediction\"), the prediction for all luma samples \nin the macroblock is given by: \npred [ x, y ] = ( 1 << ( BitDepth  − 1 ) ), with x, y = 0..15  (8-121) \nL Y\n8.3.3.4  Specification of Intra_16x16_Plane prediction mode \nThis Intra_16x16 prediction mode shall be used only when the samples p[ x, −1 ] with x = −1..15 and p[ −1, y ] with \ny = 0..15 are marked as \"available for Intra_16x16 prediction\". \nThe values of the prediction samples pred [ x, y ], with x, y = 0..15, are derived by \nL\npred [ x, y ] = Clip1 ( ( a + b * ( x − 7 ) + c * ( y − 7 ) + 16 ) >> 5 ), with x, y = 0..15,  (8-122) \nL Y\nwhere \na = 16 * ( p[ −1, 15 ] + p[ 15, −1 ] )    (8-123) \nb = ( 5 * H + 32 ) >> 6    (8-124) \nc = ( 5 * V + 32 ) >> 6    (8-125) \nand H and V are specified as \n7\nH  ( x'1 )*( p   8 x', 1   - p   6-x', -1    )     (8-126) \nx'0\n7\nV  ( y'1 )*( p   -1, 8 y'   -p   -1, 6-y'    )     (8-127) \ny'0\n8.3.4  Intra prediction process for chroma samples \nThis process is invoked for I and SI macroblock types. It specifies how the Intra prediction chroma samples for the current \nmacroblock are derived. \nInputs to this process are two (PicWidthInSamples )x(PicHeightInSamples ) arrays cS  and cS  containing constructed \nC C Cb Cr\nchroma samples prior to the deblocking filter process of neighbouring macroblocks. \nOutputs of this process are Intra prediction chroma samples for the current macroblock pred [ x, y ] and pred [ x, y ]. \nCb Cr\nDepending on the value of ChromaArrayType, the following applies: \n–  If ChromaArrayType is equal to 3, the Intra prediction chroma samples for the current macroblock pred [ x, y ] and \nCb\npred [ x, y ] are derived using the Intra prediction process for chroma samples with ChromaArrayType equal to 3 as \nCr\nspecified in clause 8.3.4.5. \n–  Otherwise (ChromaArrayType is equal to 1 or 2), the following text specifies the Intra prediction chroma samples for \nthe current macroblock pred [ x, y ] and pred [ x, y ]. \nCb Cr\nBoth chroma blocks (Cb and Cr) of the macroblock use the same prediction mode. The prediction mode is applied to each \nof the chroma blocks separately. The process specified in this clause is invoked for each chroma block. In the remainder \nof this clause, chroma block refers to one of the two chroma blocks and the subscript C is used as a replacement of the \nsubscript Cb or Cr. \nThe neighbouring samples p[ x, y ] that are constructed chroma samples prior to the deblocking filter process, with x = −1, \ny = −1..MbHeightC − 1 and with x = 0..MbWidthC − 1, y = −1, are derived as specified by the following ordered steps: \n1.  The derivation process for neighbouring locations in clause 6.4.12 is invoked for chroma locations with ( x, y ) \nassigned to ( xN, yN ) as input and mbAddrN and ( xW, yW ) as output. \n2.  Each sample p[ x, y ] is derived as follows: \n–  If any of the following conditions are true, the sample p[ x, y ] is marked as \"not available for Intra chroma \nprediction\": \n–  mbAddrN is not available, \n146  Rec. ITU-T H.264 (06/2019) \n \n–  the  macroblock  mbAddrN  is  coded  in  an  Inter  macroblock  prediction  mode  and \nconstrained_intra_pred_flag is equal to 1, \n–  the macroblock mbAddrN has mb_type equal to SI and constrained_intra_pred_flag is equal to 1 and the \ncurrent macroblock does not have mb_type equal to SI. \n–  Otherwise, the sample p[ x, y ] is marked as \"available for Intra chroma prediction\" and the value of the sample \np[ x, y ] is derived as specified by the following ordered steps: \na.  The location of the upper-left luma sample of the macroblock mbAddrN is derived by invoking the \ninverse macroblock scanning process in clause 6.4.1 with mbAddrN as the input and the output is \nassigned to ( xL, yL ). \nb.  The location ( xM, yM ) of the upper-left chroma sample of the macroblock mbAddr is derived by: \nxM =   ( xL >> 4 ) * MbWidthC    (8-128) \nyM = ( ( yL >> 4 )* MbHeightC ) + ( yL % 2 )  (8-129) \nc.  Depending on the variable MbaffFrameFlag and the macroblock mbAddrN, the sample value p[ x, y ] \nis derived as follows: \n–  If MbaffFrameFlag is equal to 1 and the macroblock mbAddrN is a field macroblock, \np[ x, y ] = cS [ xM + xW, yM + 2 * yW ]  (8-130) \nC\n–  Otherwise (MbaffFrameFlag is equal to 0 or the macroblock mbAddrN is a frame macroblock), \np[ x, y ] = cS [ xM + xW, yM + yW ]  (8-131) \nC\nLet pred [ x, y ] with x = 0..MbWidthC − 1, y = 0..MbHeightC − 1 denote the prediction samples for the chroma block \nC\nsamples. \nIntra chroma prediction modes are specified in Table 8-5. \nTable 8-5 – Specification of Intra chroma prediction modes and associated names \nintra_chroma_pred_mode  Name of intra_chroma_pred_mode \n0  Intra_Chroma_DC (prediction mode) \n1  Intra_Chroma_Horizontal (prediction mode) \n2  Intra_Chroma_Vertical (prediction mode) \n3  Intra_Chroma_Plane (prediction mode) \n \nDepending on intra_chroma_pred_mode, one of the Intra chroma prediction modes specified in clauses 8.3.4.1 to 8.3.4.4 \nis invoked. \n8.3.4.1  Specification of Intra_Chroma_DC prediction mode \nThis Intra chroma prediction mode is invoked when intra_chroma_pred_mode is equal to 0. \nFor each chroma block of 4x4  samples  indexed by chroma4x4BlkIdx = 0..( 1 << ( ChromaArrayType + 1 ) ) − 1, the \nfollowing applies: \n–  The  position  of  the  upper-left  sample  of  a  4x4  chroma  block  with  index  chroma4x4BlkIdx  inside  the  current \nmacroblock  is  derived  by  invoking  the  inverse  4x4  chroma  block  scanning  process  in  clause 6.4.7  with \nchroma4x4BlkIdx as the input and the output being assigned to ( xO, yO ). \n–  Depending on the values of xO and yO, the following applies: \n–  If  (  xO,  yO  )  is  equal  to ( 0,  0  )  or  xO  and  yO  are  greater  than 0,  the  values  of  the  prediction  samples \npred [ x + xO, y + yO ] with x, y = 0..3 are derived as follows: \nC\n–  If all samples p[ x + xO, −1 ], with x = 0..3, and p[ −1, y +yO ], with y = 0..3, are marked as \"available for \nIntra chroma prediction\", the values of the prediction samples pred [ x + xO, y + yO ], with x, y = 0..3, are \nC\nderived as: \n    Rec. ITU-T H.264 (06/2019)  147 \n \n 3 3 \npred [ x  xO, y  yO ]   p[x'xO,1] p[1,y'yO] 4  3 , with x, y = 0..3.  (8-132) \nC  \nx'0 y'0 \n–  Otherwise, if any samples p[ x + xO, −1 ], with x = 0..3, are marked as \"not available for Intra chroma \nprediction\"  and  all  samples  p[ −1, y +yO ],  with  y = 0..3,  are  marked  as  \"available  for  Intra  chroma \nprediction\", the values of the prediction samples pred [ x + xO, y + yO ], with x, y = 0..3, are derived as: \nC\n 3 \npred [ x xO, yyO ]  p[1,y'yO]2  2, with x, y = 0..3.  (8-133) \nC  \ny'0 \n–  Otherwise, if any samples p[ −1, y +yO ], with y = 0..3, are marked as \"not available for Intra chroma \nprediction\"  and  all  samples  p[ x + xO, −1 ],  with  x = 0..3,  are  marked  as  \"available  for  Intra  chroma \nprediction\", the values of the prediction samples pred [ x + xO, y + yO ], with x, y = 0..3, are derived as: \nC\n 3 \npred [ x  xO, y yO ]  p[x'xO,1]2  2, with x, y = 0..3.  (8-134) \nC  \n \nx'0\n–  Otherwise (some samples p[ x + xO, −1 ], with x = 0..3, and some samples p[ −1, y +yO ], with y = 0..3, \nare  marked  as  \"not  available  for  Intra  chroma  prediction\"),  the  values  of  the  prediction  samples \npred [ x + xO, y + yO ], with x, y = 0..3, are derived as: \nC\npred [ x + xO, y + yO ] = ( 1 << ( BitDepth  − 1 ) ), with x, y = 0..3.  (8-135) \nC C\n–  Otherwise,  if  xO  is  greater  than 0  and  yO  is  equal  to 0,  the  values  of  the  prediction  samples \npred [ x + xO, y + yO ] with x, y = 0..3 are derived as follows: \nC\n–  If all samples p[ x + xO, −1 ], with x = 0..3, are marked as \"available for Intra chroma prediction\", the \nvalues of the prediction samples pred [ x + xO, y + yO ], with x, y = 0..3, are derived as: \nC\n 3 \npred [ x  xO, y yO ]  p[x'xO,1]2  2, with x, y = 0..3.  (8-136) \nC  \n \nx'0\n–  Otherwise,  if  all  samples  p[ −1, y +yO ],  with  y = 0..3,  are  marked  as  \"available  for  Intra  chroma \nprediction\", the values of the prediction samples pred [ x + xO, y + yO ], with x, y = 0..3, are derived as: \nC\n 3 \npred [ x xO, yyO ]  p[1,y'yO]2  2, with x, y = 0..3.  (8-137) \nC  \ny'0 \n–  Otherwise (some samples p[ x + xO, −1 ], with x = 0..3, and some samples p[ −1, y +yO ], with y = 0..3, \nare  marked  as  \"not  available  for  Intra  chroma  prediction\"),  the  values  of  the  prediction  samples \npred [ x + xO, y + yO ], with x, y = 0..3, are derived as: \nC\npred [ x + xO, y + yO ] = ( 1 << ( BitDepth  − 1 ) ), with x, y = 0..3.  (8-138) \nC C\n–  Otherwise  (xO  is  equal  to 0  and  yO  is  greater  than 0),  the  values  of  the  prediction  samples \npred [ x + xO, y + yO ] with x, y = 0..3 are derived as follows: \nC\n–  If all samples p[ −1, y +yO ], with y = 0..3, are marked as \"available for Intra chroma prediction\", the values \nof the prediction samples pred [ x + xO, y + yO ], with x, y = 0..3, are derived as: \nC\n 3 \npred [ x xO, yyO ]  p[1,y'yO]2  2, with x, y = 0..3.  (8-139) \nC  \ny'0 \n–  Otherwise,  if  all  samples  p[ x + xO, −1 ],  with  x = 0..3,  are  marked  as  \"available  for  Intra  chroma \nprediction\", the values of the prediction samples pred [ x + xO, y + yO ], with x, y = 0..3, are derived as: \nC\n 3 \npred [ x  xO, y yO ]  p[x'xO,1]2  2, with x, y = 0..3.  (8-140) \nC  \n \nx'0\n148  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (some samples p[ x + xO, −1 ], with x = 0..3, and some samples p[ −1, y +yO ], with y = 0..3, \nare  marked  as  \"not  available  for  Intra  chroma  prediction\"),  the  values  of  the  prediction  samples \npred [ x + xO, y + yO ], with x, y = 0..3, are derived as: \nC\npred [ x + xO, y + yO ] = ( 1 << ( BitDepth  − 1 ) ), with x, y = 0..3.  (8-141) \nC C\n8.3.4.2  Specification of Intra_Chroma_Horizontal prediction mode \nThis Intra chroma prediction mode is invoked when intra_chroma_pred_mode is equal to 1. \nThis mode shall be used only when the samples p[ −1, y ] with y = 0..MbHeightC − 1 are marked as \"available for Intra \nchroma prediction\". \nThe values of the prediction samples pred [ x, y ] are derived as: \nC\npred [ x, y ] = p[ −1, y ], with x = 0..MbWidthC − 1 and y = 0..MbHeightC − 1  (8-142) \nC\n8.3.4.3  Specification of Intra_Chroma_Vertical prediction mode \nThis Intra chroma prediction mode is invoked when intra_chroma_pred_mode is equal to 2. \nThis mode shall be used only when the samples p[ x, −1 ] with x = 0..MbWidthC − 1 are marked as \"available for Intra \nchroma prediction\". \nThe values of the prediction samples pred [ x, y ] are derived as: \nC\npred [ x, y ] = p[ x, −1 ], with x = 0..MbWidthC − 1 and y = 0..MbHeightC − 1  (8-143) \nC\n8.3.4.4  Specification of Intra_Chroma_Plane prediction mode \nThis Intra chroma prediction mode is invoked when intra_chroma_pred_mode is equal to 3. \nThis  mode  shall  be  used  only  when  the  samples  p[ x, −1 ],  with  x  =  0..MbWidthC − 1  and  p[ −1, y ],  with \ny = −1..MbHeightC − 1 are marked as \"available for Intra chroma prediction\". \nLet the variable xCF be set equal to ( ( ChromaArrayType  = =  3 )  ?  4  :  0 ) and let the variable yCF be set equal to \n( ( ChromaArrayType  !=  1 )  ?  4  :  0 ). \nThe values of the prediction samples pred [ x, y ] are derived by: \nC\npred [ x, y ] = Clip1 ( ( a + b * ( x − 3 − xCF ) + c * ( y − 3 − yCF ) + 16 ) >> 5 ),  \nC C\n      with x = 0..MbWidthC − 1 and y = 0..MbHeightC − 1  (8-144) \nwhere \na = 16 * ( p[ −1, MbHeightC − 1 ] + p[ MbWidthC − 1, −1 ] )   (8-145) \nb = ( ( 34 − 29 * ( ChromaArrayType  = = 3 ) ) * H + 32 ) >> 6  (8-146) \nc = ( ( 34 − 29 * ( ChromaArrayType  !=  1 ) ) * V + 32 ) >> 6  (8-147) \nand H and V are specified as: \n3  xCF\nH   (x'1)*(p  4xCF x', 1  p  2xCF x', 1  ) (8-148) \nx'0  \n3yCF\nV  (y'1)*(p[1, 4 yCF y']p[1, 2 yCFy'])   (8-149) \ny'0\n8.3.4.5  Intra prediction for chroma samples with ChromaArrayType equal to 3 \nThis process is invoked when ChromaArrayType is equal to 3. This process is invoked for I and SI macroblock types. It \nspecifies how the Intra prediction chroma samples for the current macroblock are derived when ChromaArrayType is equal \nto 3. \nInputs to this process are constructed samples prior to the deblocking filter process from neighbouring Cb and Cr blocks \nand for Intra_NxN (where NxN is equal to 4x4 or 8x8) prediction mode, the associated values of IntraNxNPredMode from \nneighbouring macroblocks. \n    Rec. ITU-T H.264 (06/2019)  149 \n \nOutputs of this process are the Intra prediction samples of the Cb and Cr components of the macroblock or in case of the \nIntra_NxN prediction process, the outputs are NxN Cb sample arrays as part of the 16x16 Cb array of prediction samples \nof the macroblock, and NxN Cb sample arrays as part of the 16x16 Cb array of prediction samples of the macroblock. \nEach Cb, Cr, and luma block with the same block index of the macroblock use the same prediction mode. The prediction \nmode is applied to each of the Cb and Cr blocks separately. The process specified in this clause is invoked for each Cb and \nCr block. \nDepending on the macroblock prediction mode, the following applies: \n–  If the macroblock prediction mode is equal to Intra_4x4, the following applies: \n–  The same process described in clause 8.3.1 is also applied to Cb or Cr samples, substituting luma with Cb or Cr, \nsubstituting  luma4x4BlkIdx  with  cb4x4BlkIdx  or  cr4x4BlkIdx,  substituting  pred4x4   with  pred4x4 or \nL Cb \npred4x4 , and substituting BitDepth  with BitDepth . \nCr Y C\n–  The output variable Intra4x4PredMode[luma4x4BlkIdx] from the process described in clause 8.3.1.1 is also used \nfor the 4x4 Cb or 4x4 Cr blocks with index luma4x4BlkIdx equal to index cb4x4BlkIdx or cr4x4BlkIdx. \n–  The process to derive prediction Cb or Cr samples is identical to the process described in clause 8.3.1.2 and its \nsubsequent subclauses when substituting luma with Cb or Cr, substituting pred4x4 withpred4x4 or pred4x4 , \nL    Cb  Cr\nand substituting BitDepth  with BitDepth . \nY C\n–  Otherwise, if the macroblock prediction mode is equal to Intra_8x8, the following applies: \n–  The same process described in clause 8.3.2 is also applied to Cb or Cr samples, substituting luma with Cb or Cr, \nsubstituting  luma8x8BlkIdx  with  cb8x8BlkIdx  or  cr8x8BlkIdx,  substituting  pred8x8   with  pred8x8 or \nL Cb \npred8x8 , and substituting BitDepth  with BitDepth . \nCr Y C\n–  The output variable Intra8x8PredMode[luma8x8BlkIdx] from the process described in clause 8.3.2.1 is used for \nthe 8x8 Cb or 8x8 Cr blocks with index luma8x8BlkIdx equal to index cb8x8BlkIdx or cr8x8BlkIdx. \n–  The process to derive prediction Cb or Cr samples is identical to the process described in clause 8.3.2.2 and its \nsubsequent subclauses when substituting luma with Cb or Cr, substituting pred8x8 with pred8x8 or pred8x8 , \nL  Cb  Cr\nand substituting BitDepth  with BitDepth . \nY C\n–  Otherwise (the macroblock prediction mode is equal to Intra_16x16), the same process described in clause 8.3.3 and \nits subsequent subclauses is also applied to Cb or Cr samples, substituting luma with Cb or Cr, substituting pred  with \nL\npred  or pred , and substituting BitDepth  with BitDepth . \nCb Cr Y C\n8.3.5  Sample construction process for I_PCM macroblocks \nThis process is invoked when mb_type is equal to I_PCM. \nThe variable dy is derived as follows: \n–  If MbaffFrameFlag is equal to 1 and the current macroblock is a field macroblock, dy is set equal to 2. \n–  Otherwise (MbaffFrameFlag is equal to 0 or the current macroblock is a frame macroblock), dy is set equal to 1. \nThe position of the upper-left luma sample of the current macroblock is derived by invoking the inverse macroblock \nscanning process in clause 6.4.1 with CurrMbAddr as input and the output being assigned to ( xP, yP ). \nThe constructed luma samples prior to the deblocking process are generated as specified by: \nfor( i = 0; i < 256; i++ ) \n  S′ [ xP + ( i % 16 ), yP + dy * ( i / 16 ) ) ] = pcm_sample_luma[ i ]  (8-150) \nL\n150  Rec. ITU-T H.264 (06/2019) \n \nWhen ChromaArrayType is not equal to 0, the constructed chroma samples prior to the deblocking process are generated \nas specified by: \nfor( i = 0; i < MbWidthC * MbHeightC; i++ ) { \n  S′ [ ( xP / SubWidthC ) + ( i % MbWidthC ), \nCb\n    ( ( yP + SubHeightC − 1 ) / SubHeightC ) + dy * ( i / MbWidthC ) ] = \n      pcm_sample_chroma[ i ]    (8-151) \n  S′ [ ( xP / SubWidthC ) + ( i % MbWidthC ), \nCr\n    ( ( yP + SubHeightC − 1 ) / SubHeightC ) + dy * ( i / MbWidthC ) ] = \n      pcm_sample_chroma[ i + MbWidthC * MbHeightC ] \n} \n8.4  Inter prediction process \nThis process is invoked when decoding P and B macroblock types. \nOutputs of this process are Inter prediction samples for the current macroblock that are a 16x16 array pred  of luma samples \nL\nand when ChromaArrayType is not equal to 0 two (MbWidthC)x(MbHeightC) arrays pred  and pred  of chroma samples, \nCb Cr\none for each of the chroma components Cb and Cr. \nThe partitioning of a macroblock is specified by mb_type. Each macroblock partition is referred to by mbPartIdx. When \nthe macroblock partitioning consists of partitions that are equal to sub-macroblocks, each sub-macroblock can be further \npartitioned into sub-macroblock partitions as specified by sub_mb_type[ mbPartIdx ]. Each sub-macroblock partition is \nreferred to by subMbPartIdx. When the macroblock partitioning does not consist of sub-macroblocks, subMbPartIdx is set \nequal to 0. \nThe following steps are specified for each macroblock partition or for each sub-macroblock partition. \nThe functions MbPartWidth( ), MbPartHeight( ), SubMbPartWidth( ), and SubMbPartHeight( ) describing the width and \nheight of macroblock partitions and sub-macroblock partitions are specified in Tables 7-13, 7-14, 7-17, and 7-18. \nThe range of the macroblock partition index mbPartIdx is derived as follows: \n–  If mb_type is equal to B_Skip or B_Direct_16x16, mbPartIdx proceeds over values 0..3. \n–  Otherwise  (mb_type  is  not  equal  to  B_Skip  or  B_Direct_16x16),  mbPartIdx  proceeds  over  values \n0..NumMbPart( mb_type ) − 1. \nFor each value of mbPartIdx, the variables partWidth and partHeight for each macroblock partition or sub-macroblock \npartition in the macroblock are derived as follows: \n–  If mb_type is not equal to P_8x8, P_8x8ref0, B_Skip, B_Direct_16x16, or B_8x8, subMbPartIdx is set equal to 0, \nand partWidth and partHeight are derived as: \npartWidth = MbPartWidth( mb_type )     (8-152) \npartHeight = MbPartHeight( mb_type )     (8-153) \n–  Otherwise, if mb_type is equal to P_8x8 or P_8x8ref0, or mb_type is equal to B_8x8 and sub_mb_type[ mbPartIdx ] \nis  not  equal  to  B_Direct_8x8,  subMbPartIdx  proceeds  over  values \n0..NumSubMbPart( sub_mb_type[ mbPartIdx ] ) − 1, and partWidth and partHeight are derived as: \npartWidth = SubMbPartWidth( sub_mb_type[ mbPartIdx ] )   (8-154) \npartHeight = SubMbPartHeight( sub_mb_type[ mbPartIdx ] ).   (8-155) \n–  Otherwise  (mb_type  is  equal  to  B_Skip  or  B_Direct_16x16,  or  mb_type  is  equal  to  B_8x8  and \nsub_mb_type[ mbPartIdx ] is equal to B_Direct_8x8), subMbPartIdx proceeds over values 0..3, and partWidth and \npartHeight are derived as: \npartWidth = 4     (8-156) \npartHeight = 4     (8-157) \n    Rec. ITU-T H.264 (06/2019)  151 \n \nWhen ChromaArrayType is not equal to 0, the variables partWidthC and partHeightC are derived as: \npartWidthC = partWidth / SubWidthC    (8-158) \npartHeightC = partHeight / SubHeightC    (8-159) \nLet the variable MvCnt be initially set equal to 0 before any invocation of clause 8.4.1 for the macroblock. \nThe Inter prediction process for a macroblock partition mbPartIdx and a sub-macroblock partition subMbPartIdx consists \nof the following ordered steps: \n1.  The derivation process for motion vector components and reference indices as specified in clause 8.4.1 is invoked. \nInputs to this process are: \n–  a macroblock partition mbPartIdx, \n–  a sub-macroblock partition subMbPartIdx. \nOutputs of this process are: \n–  luma motion vectors mvL0 and mvL1 and when ChromaArrayType is not equal to 0, the chroma motion \nvectors mvCL0 and mvCL1 \n–  reference indices refIdxL0 and refIdxL1 \n–  prediction list utilization flags predFlagL0 and predFlagL1 \n–  the sub-macroblock partition motion vector count subMvCnt. \n2.  The variable MvCnt is incremented by subMvCnt. \n3.  When (weighted_pred_flag is equal to 1 and (slice_type % 5) is equal to 0 or 3) or (weighted_bipred_idc is greater \nthan 0 and (slice_type % 5) is equal to 1), the derivation process for prediction weights as specified in clause 8.4.3 is \ninvoked. \nInputs to this process are: \n–  reference indices refIdxL0 and refIdxL1 \n–  prediction list utilization flags predFlagL0 and predFlagL1 \nOutputs of this process are variables for weighted prediction logWD , w , w , o , o  with C being replaced by L \nC 0C 1C 0C 1C\nand, when ChromaArrayType is not equal to 0, Cb and Cr. \n4.  The decoding process for Inter prediction samples as specified in clause 8.4.2 is invoked. \nInputs to this process are: \n–  a macroblock partition mbPartIdx, \n–  a sub-macroblock partition subMbPartIdx, \n–  variables specifying partition  width and height  for luma and chroma (if available), partWidth, partHeight, \npartWidthC (if available), and partHeightC (if available), \n–  luma motion vectors mvL0 and mvL1 and when ChromaArrayType is not equal to 0, the chroma motion vectors \nmvCL0 and mvCL1, \n–  reference indices refIdxL0 and refIdxL1, \n–  prediction list utilization flags predFlagL0 and predFlagL1, \n–  variables  for  weighted  prediction  logWD ,  w ,  w ,  o ,  o   with  C  being  replaced  by  L  and,  when \nC 0C 1C 0C 1C\nChromaArrayType is not equal to 0, Cb and Cr. \nOutputs of this process are inter prediction samples (pred); which are a (partWidth)x(partHeight) array predPart  of \nL\nprediction luma samples and  when  ChromaArrayType is  not equal to 0 two (partWidthC)x(partHeightC) arrays \npredPart , and predPart  of prediction chroma samples, one for each of the chroma components Cb and Cr. \nCr Cb\nFor use in derivation processes of variables invoked later in the decoding process, the following assignments are made: \nMvL0[ mbPartIdx ][ subMbPartIdx ] = mvL0    (8-160) \nMvL1[ mbPartIdx ][ subMbPartIdx ] = mvL1    (8-161) \n152  Rec. ITU-T H.264 (06/2019) \n \nRefIdxL0[ mbPartIdx ] = refIdxL0    (8-162) \nRefIdxL1[ mbPartIdx ] = refIdxL1    (8-163) \nPredFlagL0[ mbPartIdx ] = predFlagL0    (8-164) \nPredFlagL1[ mbPartIdx ] = predFlagL1    (8-165) \nThe location of the upper-left sample of the macroblock partition relative to the upper-left sample of the macroblock is \nderived by invoking the inverse macroblock partition scanning process as described in clause 6.4.2.1 with mbPartIdx as \nthe input and ( xP, yP ) as the output. \nThe location of the upper-left sample of the sub-macroblock partition relative to the upper-left sample of the macroblock \npartition is derived by invoking the inverse sub-macroblock partition scanning process as described in clause 6.4.2.2 with \nsubMbPartIdx as the input and ( xS, yS ) as the output. \nThe macroblock prediction is formed by placing the macroblock or sub-macroblock partition prediction samples in their \ncorrect relative positions in the macroblock, as follows. \nThe variable pred [ xP + xS + x, yP + yS + y ] with x = 0..partWidth − 1, y = 0..partHeight − 1 is derived by: \nL\npred [ xP + xS + x, yP + yS + y ] = predPart [ x, y ]    (8-166) \nL L\nWhen ChromaArrayType is not equal to 0, the variable pred  with x = 0..partWidthC − 1, y = 0..partHeightC − 1, and C \nC\nin pred  and predPart  being replaced by Cb or Cr is derived by: \nC C\npred [ xP / SubWidthC + xS / SubWidthC + x, yP / SubHeightC + yS / SubHeightC + y ] = predPart [ x, y ] \nC C\n        (8-167) \n8.4.1  Derivation process for motion vector components and reference indices \nInputs to this process are: \n–  a macroblock partition mbPartIdx, \n–  a sub-macroblock partition subMbPartIdx. \nOutputs of this process are: \n–  luma motion vectors mvL0 and mvL1 and when ChromaArrayType is not equal to 0, the chroma motion vectors \nmvCL0 and mvCL1, \n–  reference indices refIdxL0 and refIdxL1, \n–  prediction list utilization flags predFlagL0 and predFlagL1, \n–  a motion vector count variable subMvCnt. \nFor the derivation of the variables mvL0 and mvL1 as well as refIdxL0 and refIdxL1, the following applies: \n–  If mb_type is equal to P_Skip, the derivation process for luma motion vectors for skipped macroblocks in P and SP \nslices in clause 8.4.1.1 is invoked with the output being the luma motion vectors mvL0 and reference indices refIdxL0, \nand predFlagL0 is set equal to 1. mvL1 and refIdxL1 are marked as not available and predFlagL1 is set equal to 0. \nThe motion vector count variable subMvCnt is set equal to 1. \n–  Otherwise, if mb_type is equal to B_Skip or B_Direct_16x16 or sub_mb_type[ mbPartIdx ] is equal to B_Direct_8x8, \nthe derivation process for luma  motion  vectors for B_Skip, B_Direct_16x16, and B_Direct_8x8 in B slices in \nclause 8.4.1.2 is invoked with mbPartIdx and subMbPartIdx as the input and the output being the luma motion vectors \nmvL0,  mvL1,  the  reference  indices  refIdxL0,  refIdxL1,  the  motion  vector  count  variable  subMvCnt,  and  the \nprediction utilization flags predFlagL0 and predFlagL1. \n–  Otherwise, for X being replaced by either 0 or 1 in the variables predFlagLX, mvLX, refIdxLX, and in Pred_LX and \nin the syntax elements ref_idx_lX and mvd_lX, the following applies: \n1.  The variables refIdxLX and predFlagLX are derived as follows: \n–  If MbPartPredMode( mb_type, mbPartIdx ) or SubMbPredMode( sub_mb_type[ mbPartIdx ] ) is equal \nto Pred_LX or to BiPred, \nrefIdxLX = ref_idx_lX[ mbPartIdx ]    (8-168) \n    Rec. ITU-T H.264 (06/2019)  153 \n \npredFlagLX = 1    (8-169) \n–  Otherwise, the variables refIdxLX and predFlagLX are specified by \nrefIdxLX = −1    (8-170) \npredFlagLX = 0    (8-171) \n2.  The motion vector count variable subMvCnt is set equal to predFlagL0 + predFlagL1. \n3.  The variable currSubMbType is derived as follows: \n–  If the macroblock type is equal to B_8x8, currSubMbType is set equal to sub_mb_type[ mbPartIdx ]. \n–  Otherwise (the macroblock type is not equal to B_8x8), currSubMbType is set equal to \"na\". \n4.  When predFlagLX is equal to 1, the derivation process for luma motion vector prediction in clause 8.4.1.3 is \ninvoked with mbPartIdx subMbPartIdx, refIdxLX, and currSubMbType as the inputs and the output being \nmvpLX. The luma motion vectors are derived by \nmvLX[ 0 ] = mvpLX[ 0 ] + mvd_lX[ mbPartIdx ][ subMbPartIdx ][ 0 ]  (8-172) \nmvLX[ 1 ] = mvpLX[ 1 ] + mvd_lX[ mbPartIdx ][ subMbPartIdx ][ 1 ]  (8-173) \nWhen ChromaArrayType is not equal to 0 and predFlagLX (with X being either 0 or 1) is equal to 1, the derivation process \nfor chroma motion vectors in clause 8.4.1.4 is invoked with mvLX and refIdxLX as input and the output being mvCLX. \n8.4.1.1  Derivation process for luma motion vectors for skipped macroblocks in P and SP slices \nThis process is invoked when mb_type is equal to P_Skip. \nOutputs of this process are the motion vector mvL0 and the reference index refIdxL0. \nThe reference index refIdxL0 for a skipped macroblock is derived as: \nrefIdxL0 = 0.    (8-174) \nFor the derivation of the motion vector mvL0 of a P_Skip macroblock type, the following ordered steps are specified: \n1.  The process specified in clause 8.4.1.3.2 is invoked with mbPartIdx set equal to 0, subMbPartIdx set equal to 0, \ncurrSubMbType set equal to \"na\", and listSuffixFlag set equal to 0 as input and the output is assigned to mbAddrA, \nmbAddrB, mvL0A, mvL0B, refIdxL0A, and refIdxL0B. \n2.  The variable mvL0 is specified as follows: \n–  If any of the following conditions are true, both components of the motion vector mvL0 are set equal to 0: \n–  mbAddrA is not available, \n–  mbAddrB is not available, \n–  refIdxL0A is equal to 0 and both components of mvL0A are equal to 0, \n–  refIdxL0B is equal to 0 and both components of mvL0B are equal to 0. \n–  Otherwise, the derivation process for luma motion vector prediction as specified in clause 8.4.1.3 is invoked \nwith mbPartIdx = 0, subMbPartIdx = 0, refIdxL0, and currSubMbType = \"na\" as inputs and the output is \nassigned to mvL0. \nNOTE – The output is directly assigned to mvL0, since the predictor is equal to the actual motion vector. \n8.4.1.2  Derivation process for luma motion vectors for B_Skip, B_Direct_16x16, and B_Direct_8x8 \nThis process is invoked when mb_type is equal to B_Skip or B_Direct_16x16, or sub_mb_type[ mbPartIdx ] is equal to \nB_Direct_8x8. \nInputs to this process are mbPartIdx and subMbPartIdx. \nOutputs of this process are the reference indices refIdxL0, refIdxL1, the motion vectors mvL0 and mvL1, the motion vector \ncount variable subMvCnt, and the prediction list utilization flags, predFlagL0 and predFlagL1. \nThe derivation process depends on the value of direct_spatial_mv_pred_flag, which is present in the bitstream in the slice \nheader syntax as specified in clause 7.3.3, and is specified as follows: \n154  Rec. ITU-T H.264 (06/2019) \n \n–  If direct_spatial_mv_pred_flag is equal to 1, the mode in which the outputs of this process are derived is referred to \nas spatial direct prediction mode. \n–  Otherwise (direct_spatial_mv_pred_flag is equal to 0), mode in which the outputs of this process are derived is \nreferred to as temporal direct prediction mode. \nBoth spatial and temporal direct prediction mode use the co-located motion vectors and reference indices as specified in \nclause 8.4.1.2.1. \nThe motion vectors and reference indices are derived as follows: \n–  If spatial direct prediction mode is used, the direct motion vector and reference index prediction mode specified in \nclause 8.4.1.2.2 is used, with subMvCnt being an output. \n–  Otherwise (temporal direct prediction mode is used), the direct motion vector and reference index prediction mode \nspecified in clause 8.4.1.2.3 is used and the variable subMvCnt is derived as follows: \n–  If subMbPartIdx is equal to 0, subMvCnt is set equal to 2. \n–  Otherwise (subMbPartIdx is not equal to 0), subMvCnt is set equal to 0. \n8.4.1.2.1 Derivation process for the co-located 4x4 sub-macroblock partitions \nInputs to this process are mbPartIdx and subMbPartIdx. \nOutputs of this process are the picture colPic, the co-located macroblock mbAddrCol, the motion vector mvCol, the \nreference index refIdxCol, and the variable vertMvScale (which can be One_To_One, Frm_To_Fld or Fld_To_Frm). \nWhen RefPicList1[ 0 ] is a frame or a complementary field pair, let firstRefPicL1Top and firstRefPicL1Bottom be the top \nand bottom fields of RefPicList1[ 0 ], respectively, and let the following variables be specified as \ntopAbsDiffPOC = Abs( DiffPicOrderCnt( firstRefPicL1Top, CurrPic ) )  (8-175) \nbottomAbsDiffPOC = Abs( DiffPicOrderCnt( firstRefPicL1Bottom, CurrPic ) )  (8-176) \nThe variable colPic specifies the picture that contains the co-located macroblock as specified in Table 8-6. \nTable 8-6 – Specification of the variable colPic \nfield_pic_flag  RefPicList1[ 0 ]  mb_field_decoding_flag  additional condition  colPic \nis … \na field of a  the frame containing \n   \ndecoded frame  RefPicList1[ 0 ] \n1 \na decoded field      RefPicList1[ 0 ] \na decoded \n    RefPicList1[ 0 ] \nframe \ntopAbsDiffPOC < \nfirstRefPicL1Top \nbottomAbsDiffPOC \n0 \n0 \na \ntopAbsDiffPOC >= \nfirstRefPicL1Bottom \ncomplementary \nbottomAbsDiffPOC \nfield pair \n( CurrMbAddr & 1 )  = =  0  firstRefPicL1Top \n1 \n( CurrMbAddr & 1 ) != 0  firstRefPicL1Bottom \nNOTE – The picture order count values of a complementary field pair marked as \"used for long-term reference\" have an impact on \nthe  decoding  process  when  the  current  picture  is  a  coded  frame,  the  current  macroblock  is  a  frame  macroblock,  and  the \ncomplementary field pair marked as \"used for long-term reference\" is the first picture in reference list 1. \n \nLet PicCodingStruct( X ) be a function with the argument X being either CurrPic or colPic. It is specified in Table 8-7. \nTable 8-7 – Specification of PicCodingStruct( X ) \nX is coded with field_pic_flag equal to …  mb_adaptive_frame_field_flag  PicCodingStruct( X ) \n1    FLD \n0  0  FRM \n0  1  AFRM \n    Rec. ITU-T H.264 (06/2019)  155 \n \n \nThe variable luma4x4BlkIdx is derived as follows: \n–  If direct_8x8_inference_flag is equal to 0, luma4x4BlkIdx is set equal to (4 * mbPartIdx + subMbPartIdx). \n–  Otherwise (direct_8x8_inference_flag is equal to 1), luma4x4BlkIdx is set equal to (5 * mbPartIdx). \nThe inverse 4x4 luma block scanning process as specified in clause 6.4.3 is invoked with luma4x4BlkIdx as the input and \n( x, y ) assigned to ( xCol, yCol ) as the output. \nTable 8-8 specifies the co-located macroblock address mbAddrCol, yM, and the variable vertMvScale in two steps: \n1.  Specification  of  a  macroblock  address  mbAddrX  depending  on  PicCodingStruct( CurrPic ),  and \nPicCodingStruct( colPic ). \nNOTE – It is not possible for CurrPic and colPic picture coding types to be either (FRM, AFRM) or (AFRM, FRM) \nbecause these picture coding types must be separated by an IDR picture. \n2.  Specification  of  mbAddrCol,  yM,  and  vertMvScale  depending  on  mb_field_decoding_flag  and  the  variable \nfieldDecodingFlagX, which is derived as follows: \n–  If the macroblock mbAddrX in the picture colPic is a field macroblock, fieldDecodingFlagX is set equal to 1. \n–  Otherwise (the macroblock mbAddrX in the picture colPic is a frame macroblock), fieldDecodingFlagX is set \nequal to 0. \nUnspecified values in Table 8-8 indicate that the value of the corresponding variable is not relevant for the current table \nrow. \nmbAddrCol is set equal to CurrMbAddr or to one of the following values. \nmbAddrCol1 = 2 * PicWidthInMbs * ( CurrMbAddr / PicWidthInMbs ) +  \n    ( CurrMbAddr % PicWidthInMbs ) + PicWidthInMbs * ( yCol / 8 )  (8-177) \nmbAddrCol2 = 2 * CurrMbAddr + ( yCol / 8 )    (8-178) \nmbAddrCol3 = 2 * CurrMbAddr + bottom_field_flag    (8-179) \nmbAddrCol4 = PicWidthInMbs * ( CurrMbAddr / ( 2 * PicWidthInMbs ) ) +  \n    ( CurrMbAddr % PicWidthInMbs )     (8-180) \nmbAddrCol5 = CurrMbAddr / 2    (8-181) \nmbAddrCol6 = 2 * ( CurrMbAddr / 2 ) + ( ( topAbsDiffPOC < bottomAbsDiffPOC ) ? 0 : 1 )  (8-182) \nmbAddrCol7 = 2 * ( CurrMbAddr / 2 ) + ( yCol / 8 )    (8-183) \n \n156  Rec. ITU-T H.264 (06/2019) \n \nTable 8-8 – Specification of mbAddrCol, yM, and vertMvScale \n \n)\nc       )   g\ni c\nr P P i f l a   X\nr l _ g\nt r u c t (   C u S t r u c t (   c o   A d d r X d e c o d i n g o d i n g F l a   A d d r C o l   y M   M v S c a l e\nS g b _ c t\nd i n g o d i n m f i e l d l d D e m b v e r\no C _ e\nC c m b f i\nc i\ni P\nP\nFLD        CurrMbAddr  yCol  One_To_One \nFRM        mbAddrCol1  ( 2 * yCol ) % 16  Frm_To_Fld \nFLD \n  0  mbAddrCol2  ( 2 * yCol ) % 16  Frm_To_Fld \nAFRM  2*CurrMbAddr \n  1  mbAddrCol3  yCol  One_To_One \n8 * ( (CurrMbAddr / PicWidthInMbs ) % 2) \nFLD        mbAddrCol4  Fld_To_Frm \n+ 4 * ( yCol / 8 ) \nFRM \nFRM        CurrMbAddr  yCol  One_To_One \n  0    mbAddrCol5  8 * ( CurrMbAddr % 2 ) +4 * ( yCol / 8 )  Fld_To_Frm \nFLD \n  1    mbAddrCol5  yCol  One_To_One \n0  CurrMbAddr  yCol  One_To_One \nAFRM  CurrMbAddr  0 \n1  mbAddrCol6  8 * ( CurrMbAddr % 2 ) + 4 * ( yCol / 8 )  Fld_To_Frm \nAFRM \n0  mbAddrCol7  ( 2 * yCol ) % 16  Frm_To_Fld \nCurrMbAddr  1 \n1  CurrMbAddr  yCol  One_To_One \n \nLet mbTypeCol be the syntax element mb_type of the macroblock with address mbAddrCol inside the picture colPic and, \nwhen mbTypeCol is equal to P_8x8, P_8x8ref0, or B_8x8, let subMbTypeCol be the syntax element list sub_mb_type of \nthe macroblock with address mbAddrCol inside the picture colPic. \nLet mbPartIdxCol be the macroblock partition index of the co-located partition and subMbPartIdxCol the sub-macroblock \npartition index of the co-located sub-macroblock partition. The derivation process for macroblock and sub-macroblock \npartition indices as specified in clause 6.4.13.4 is invoked with the luma location ( xCol, yM ), the macroblock type \nmbTypeCol,  and,  when  mbTypeCol  is  equal  to  P_8x8,  P_8x8ref0,  or  B_8x8,  the  list  of  sub-macroblock  types \nsubMbTypeCol as the inputs and the outputs are the macroblock partition index mbPartIdxCol and the sub-macroblock \npartition index subMbPartIdxCol. \nThe motion vector mvCol and the reference index refIdxCol are derived as follows: \n–  If the macroblock mbAddrCol is coded in an Intra macroblock prediction mode, both components of mvCol are set \nequal to 0 and refIdxCol is set equal to −1. \n–  Otherwise  (the  macroblock  mbAddrCol  is  not  coded  in  an  Intra  macroblock  prediction  mode),  the  prediction \nutilization  flags  predFlagL0Col  and  predFlagL1Col  are  set  equal  to  PredFlagL0[ mbPartIdxCol ]  and \nPredFlagL1[ mbPartIdxCol ], respectively, which are the prediction utilization flags that have been assigned to the \nmacroblock partition mbAddrCol\\mbPartIdxCol inside the picture colPic, and the following applies: \n–  If predFlagL0Col is equal to 1, the motion vector mvCol and the reference index refIdxCol are set equal to \nMvL0[ mbPartIdxCol ][ subMbPartIdxCol ] and RefIdxL0[ mbPartIdxCol ], respectively, which are the motion \nvector  mvL0  and  the  reference  index  refIdxL0  that  have  been  assigned  to  the  (sub-)macroblock  partition \nmbAddrCol\\mbPartIdxCol\\subMbPartIdxCol inside the picture colPic. \n    Rec. ITU-T H.264 (06/2019)  157 \n \n–  Otherwise (predFlagL0Col is equal to 0 and predFlagL1Col is equal to 1), the motion vector mvCol and the \nreference  index  refIdxCol  are  set  equal  to  MvL1[ mbPartIdxCol ][ subMbPartIdxCol ]  and \nRefIdxL1[ mbPartIdxCol ], respectively, which are the motion vector mvL1 and the reference index refIdxL1 \nthat have been assigned to the (sub-)macroblock partition mbAddrCol\\mbPartIdxCol\\subMbPartIdxCol inside \nthe picture colPic. \n8.4.1.2.2 Derivation process for spatial direct luma motion vector and reference index prediction mode \nThis process is invoked when direct_spatial_mv_pred_flag is equal to 1 and any of the following conditions are true: \n–  mb_type is equal to B_Skip, \n–  mb_type is equal to B_Direct_16x16, \n–  sub_mb_type[ mbPartIdx ] is equal to B_Direct_8x8. \nInputs to this process are mbPartIdx, subMbPartIdx. \nOutputs of this process are the reference indices refIdxL0, refIdxL1, the motion vectors mvL0 and mvL1, the motion vector \ncount variable subMvCnt, and the prediction list utilization flags, predFlagL0 and predFlagL1. \nThe reference indices refIdxL0 and refIdxL1 and the variable directZeroPredictionFlag are derived by applying the \nfollowing ordered steps. \n1.  Let the variable currSubMbType be set equal to sub_mb_type[ mbPartIdx ]. \n2.  The process specified in clause 8.4.1.3.2 is invoked with mbPartIdx = 0, subMbPartIdx = 0, currSubMbType, and \nlistSuffixFlag = 0 as inputs and the output is assigned to the motion vectors mvL0N and the reference indices \nrefIdxL0N with N being replaced by A, B, or C. \n3.  The process specified in clause 8.4.1.3.2 is invoked with mbPartIdx = 0, subMbPartIdx = 0, currSubMbType, and \nlistSuffixFlag = 1 as inputs and the output is assigned to the motion vectors mvL1N and the reference indices \nrefIdxL1N with N being replaced by A, B, or C. \nNOTE 1 – The motion vectors mvL0N, mvL1N and the reference indices refIdxL0N, refIdxL1N are identical for all 4x4 sub-\nmacroblock partitions of a macroblock. \n4.  The reference indices refIdxL0, refIdxL1, and directZeroPredictionFlag are derived by: \nrefIdxL0 = MinPositive( refIdxL0A, MinPositive( refIdxL0B, refIdxL0C ) )   (8-184) \nrefIdxL1 = MinPositive( refIdxL1A, MinPositive( refIdxL1B, refIdxL1C ) )   (8-185) \ndirectZeroPredictionFlag = 0    (8-186) \nwhere \nMin( x,y) if x  0and y  0\n  (8-187) \nMinPositiv e( x, y )  \nMax(x,y) otherwise\n\n5.  When both reference indices refIdxL0 and refIdxL1 are less than 0, \nrefIdxL0 = 0    (8-188) \nrefIdxL1 = 0    (8-189) \ndirectZeroPredictionFlag = 1    (8-190) \nThe process specified in clause 8.4.1.2.1 is invoked with mbPartIdx, subMbPartIdx given as input and the output is \nassigned to refIdxCol and mvCol. \nThe variable colZeroFlag is derived as follows: \n–  If all of the following conditions are true, colZeroFlag is set equal to 1: \n–  RefPicList1[ 0 ] is currently marked as \"used for short-term reference\", \n–  refIdxCol is equal to 0, \n–  both motion vector components mvCol[ 0 ] and mvCol[ 1 ] lie in the range of −1 to 1 in units specified as follows: \n–  If the co-located macroblock is a frame macroblock, the units of mvCol[ 0 ] and mvCol[ 1 ] are units of \nquarter luma frame samples. \n–  Otherwise (the co-located macroblock is a field macroblock), the units of mvCol[ 0 ] and mvCol[ 1 ] are \nunits of quarter luma field samples. \n158  Rec. ITU-T H.264 (06/2019) \n \nNOTE 2 – For purposes of determining the condition above, the value mvCol[ 1 ] is not scaled to use the units of a motion vector \nfor the current macroblock in cases when the current macroblock is a frame macroblock and the co-located macroblock is a field \nmacroblock or when the current macroblock is a field macroblock and the co-located macroblock is a frame macroblock. This aspect \ndiffers from the use of mvCol[ 1 ] in the temporal direct mode as specified in clause 8.4.1.2.3, which applies scaling to the motion \nvector of the co-located macroblock to use the same units as the units of a motion vector for the current macroblock, using \nEquation 8-193 or Equation 8-194 in these cases. \n–  Otherwise, colZeroFlag is set equal to 0. \nThe motion vectors mvLX (with X being 0 or 1) are derived as follows: \n–  If any of the following conditions are true, both components of the motion vector mvLX are set equal to 0: \n–  directZeroPredictionFlag is equal to 1, \n–  refIdxLX is less than 0, \n–  refIdxLX is equal to 0 and colZeroFlag is equal to 1. \n–  Otherwise, the process specified in clause 8.4.1.3 is invoked with mbPartIdx = 0, subMbPartIdx = 0, refIdxLX, and \ncurrSubMbType as inputs and the output is assigned to mvLX. \nNOTE 3 – The motion vector mvLX returned from clause 8.4.1.3 is identical for all 4x4 sub-macroblock partitions of a \nmacroblock for which the process is invoked. \nThe prediction utilization flags predFlagL0 and predFlagL1 are derived as specified using Table 8-9. \nTable 8-9 – Assignment of prediction utilization flags \nrefIdxL0  refIdxL1  predFlagL0  predFlagL1 \n>= 0  >= 0  1  1 \n>= 0  < 0  1  0 \n< 0  >= 0  0  1 \n \nThe variable subMvCnt is derived as follows: \n–  If subMbPartIdx is not equal to 0, subMvCnt is set equal to 0. \n–  Otherwise (subMbPartIdx is equal to 0), subMvCnt is set equal to predFlagL0 + predFLagL1. \n8.4.1.2.3 Derivation process for temporal direct luma motion vector and reference index prediction mode \nThis process is invoked when direct_spatial_mv_pred_flag is equal to 0 and any of the following conditions are true: \n–  mb_type is equal to B_Skip, \n–  mb_type is equal to B_Direct_16x16, \n–  sub_mb_type[ mbPartIdx ] is equal to B_Direct_8x8. \nInputs to this process are mbPartIdx and subMbPartIdx. \nOutputs of this process are the motion vectors mvL0 and mvL1, the reference indices refIdxL0 and refIdxL1, and the \nprediction list utilization flags, predFlagL0 and predFlagL1. \nThe process specified in clause 8.4.1.2.1 is invoked with mbPartIdx, subMbPartIdx given as input and the output is \nassigned to colPic, mbAddrCol, mvCol, refIdxCol, and vertMvScale. \nThe reference indices refIdxL0 and refIdxL1 are derived as \nrefIdxL0 = ( ( refIdxCol < 0 ) ? 0 : MapColToList0( refIdxCol ) )   (8-191) \nrefIdxL1 = 0    (8-192) \nNOTE 1 – If the current macroblock is a field macroblock, refIdxL0 and refIdxL1 index a list of fields; otherwise (the current \nmacroblock is a frame macroblock), refIdxL0 and refIdxL1 index a list of frames or complementary reference field pairs. \nLet refPicCol be a frame, a field, or a complementary field pair that was referred by the reference index refIdxCol when \ndecoding the co-located macroblock mbAddrCol inside the picture colPic. The function MapColToList0( refIdxCol ) is \nspecified as follows: \n    Rec. ITU-T H.264 (06/2019)  159 \n \n–  If vertMvScale is equal to One_To_One, the following applies: \n–  If field_pic_flag is equal to 0 and the current macroblock is a field macroblock, the following applies: \n–  Let refIdxL0Frm be the lowest valued reference index in the current reference picture list RefPicList0 that \nreferences the frame or complementary field pair that contains the field refPicCol. RefPicList0 shall contain \na frame or complementary field pair that contains the field refPicCol. The return value of MapColToList0( ) \nis specified as follows: \n–  If  the  field  referred  to  by  refIdxCol  has  the  same  parity  as  the  current  macroblock, \nMapColToList0( refIdxCol ) returns the reference index ( refIdxL0Frm << 1 ). \n–  Otherwise  (the  field  referred  by  refIdxCol  has  the  opposite  parity  of  the  current  macroblock), \nMapColToList0( refIdxCol ) returns the reference index ( ( refIdxL0Frm << 1 ) + 1 ). \n–  Otherwise  (field_pic_flag  is  equal  to  1  or  the  current  macroblock  is  a  frame  macroblock), \nMapColToList0( refIdxCol ) returns the lowest valued reference index refIdxL0 in the current reference picture \nlist RefPicList0 that references refPicCol. RefPicList0 shall contain refPicCol. \n–  Otherwise, if vertMvScale is equal to Frm_To_Fld, the following applies: \n–  If field_pic_flag is equal to 0, let refIdxL0Frm be the lowest valued reference index in the current reference \npicture  list  RefPicList0  that  references  refPicCol.  MapColToList0( refIdxCol )  returns  the  reference  index \n( refIdxL0Frm << 1 ). RefPicList0 shall contain refPicCol. \n–  Otherwise (field_pic_flag is equal to 1), MapColToList0( refIdxCol ) returns the lowest valued reference index \nrefIdxL0 in the current reference picture list RefPicList0 that references the field of refPicCol with the same \nparity as the current picture CurrPic. RefPicList0 shall contain the field of refPicCol with the same parity as the \ncurrent picture CurrPic. \n–  Otherwise (vertMvScale is equal to Fld_To_Frm), MapColToList0( refIdxCol ) returns the lowest valued reference \nindex refIdxL0 in the current reference picture list RefPicList0 that references the frame or complementary field pair \nthat  contains  refPicCol.  RefPicList0  shall  contain  a  frame  or  complementary  field  pair  that  contains  the  field \nrefPicCol. \nNOTE 2 – A decoded reference picture that was marked as \"used for short-term reference\" when it was referenced in the \ndecoding process of the picture containing the co-located macroblock may have been modified to be marked as \"used for \nlong-term reference\" before being used for reference for inter prediction using the direct prediction mode for the current \nmacroblock. \nDepending on the value of vertMvScale the vertical component of mvCol is modified as follows: \n–  If vertMvScale is equal to Frm_To_Fld \nmvCol[ 1 ] = mvCol[ 1 ] / 2    (8-193) \n–  Otherwise, if vertMvScale is equal to Fld_To_Frm \nmvCol[ 1 ] = mvCol[ 1 ] * 2    (8-194) \n–  Otherwise (vertMvScale is equal to One_To_One), mvCol[ 1 ] remains unchanged. \nThe variables currPicOrField, pic0, and pic1, are derived as follows: \n–  If field_pic_flag is equal to 0 and the current macroblock is a field macroblock, the following applies: \n1.  currPicOrField is the field of the current picture CurrPic that has the same parity as the current macroblock. \n2.  pic1 is the field of RefPicList1[ 0 ] that has the same parity as the current macroblock. \n3.  The variable pic0 is derived as follows: \n–  If refIdxL0 % 2 is equal to 0, pic0 is the field of RefPicList0[ refIdxL0 / 2 ] that has the same parity as \nthe current macroblock. \n–  Otherwise (refIdxL0 % 2 is not equal to 0), pic0 is the field of RefPicList0[ refIdxL0 / 2 ] that has the \nopposite parity of the current macroblock. \n–  Otherwise (field_pic_flag is equal to 1 or the current macroblock is a frame macroblock), currPicOrField is the current \npicture CurrPic, pic1 is the decoded reference picture RefPicList1[ 0 ], and pic0 is the decoded reference picture \nRefPicList0[ refIdxL0 ]. \nThe two motion vectors mvL0 and mvL1 for each 4x4 sub-macroblock partition of the current macroblock are derived as \nfollows: \n160  Rec. ITU-T H.264 (06/2019) \n \nNOTE 3 – It is often the case that many of the 4x4 sub-macroblock partitions share the same motion vectors and reference \npictures. In these cases, temporal direct mode motion compensation can calculate the inter prediction sample values in \nlarger units than 4x4 luma sample blocks. For example, when direct_8x8_inference_flag is equal to 1, at least each 8x8 \nluma sample quadrant of the macroblock shares the same motion vectors and reference pictures. \n–  If the reference index refIdxL0 refers to a long-term reference picture, or DiffPicOrderCnt( pic1, pic0 ) is equal to 0, \nthe motion vectors mvL0, mvL1 for the direct mode partition are derived by: \nmvL0 = mvCol    (8-195) \nmvL1 = 0     (8-196) \n–  Otherwise, the motion vectors mvL0, mvL1 are derived as scaled versions of the motion vector mvCol of the \nco-located sub-macroblock partition as specified below (see Figure 8-2). \ntx = ( 16 384 + Abs( td / 2 ) ) / td    (8-197) \nDistScaleFactor = Clip3( -1024, 1023, ( tb * tx + 32 ) >> 6 )   (8-198) \nmvL0 = ( DistScaleFactor * mvCol + 128 ) >> 8    (8-199) \nmvL1 = mvL0 − mvCol     (8-200) \nwhere tb and td are derived as: \ntb = Clip3( -128, 127, DiffPicOrderCnt( currPicOrField, pic0 ) )  (8-201) \ntd = Clip3( -128, 127, DiffPicOrderCnt( pic1, pic0 ) )  (8-202) \nNOTE 4 – mvL0 and mvL1 cannot exceed the ranges specified in Annex A. \nThe prediction utilization flags predFlagL0 and predFlagL1 are both set equal to 1. \nFigure 8-2 illustrates the temporal direct-mode motion vector inference when the current picture is temporally between the \nreference picture from reference picture list 0 and the reference picture from reference picture list 1. \n \nList 0 reference Current B List 1 reference\n. . . .\nCo-located partition\nDirect-mode B partition\ntd\ntb\n \nFigure 8-2 – Example for temporal direct-mode motion vector inference (informative) \n8.4.1.3  Derivation process for luma motion vector prediction \nInputs to this process are: \n–  the macroblock partition index mbPartIdx, \n–  the sub-macroblock partition index subMbPartIdx, \n–  the reference index of the current partition refIdxLX (with X being 0 or 1), \n–  the variable currSubMbType. \n    Rec. ITU-T H.264 (06/2019)  161 \n \nOutput of this process is the prediction mvpLX of the motion vector mvLX (with X being 0 or 1). \nThe  derivation  process  for  the  neighbouring  blocks  for  motion  data  in  clause 8.4.1.3.2  is  invoked  with  mbPartIdx, \nsubMbPartIdx, currSubMbType, and listSuffixFlag = X (with X being 0 or 1 for refIdxLX being refIdxL0 or refIdxL1, \nrespectively) as the input and with mbAddrN\\mbPartIdxN\\subMbPartIdxN, reference indices refIdxLXN and the motion \nvectors mvLXN with N being replaced by A, B, or C as the output. \nThe motion vector predictor mvpLX is derived as follows: \n–  If MbPartWidth( mb_type ) is equal to 16, MbPartHeight( mb_type ) is equal to 8, mbPartIdx is equal to 0, and \nrefIdxLXB is equal to refIdxLX, the motion vector predictor mvpLX is derived by: \nmvpLX = mvLXB    (8-203) \n–  Otherwise, if MbPartWidth( mb_type ) is equal to 16, MbPartHeight( mb_type ) is equal to 8, mbPartIdx is equal to 1, \nand refIdxLXA is equal to refIdxLX, the motion vector predictor mvpLX is derived by: \nmvpLX = mvLXA    (8-204) \n–  Otherwise, if MbPartWidth( mb_type ) is equal to 8, MbPartHeight( mb_type ) is equal to 16, mbPartIdx is equal to 0, \nand refIdxLXA is equal to refIdxLX, the motion vector predictor mvpLX is derived by: \nmvpLX = mvLXA    (8-205) \n–  Otherwise, if MbPartWidth( mb_type ) is equal to 8, MbPartHeight( mb_type ) is equal to 16, mbPartIdx is equal to 1, \nand refIdxLXC is equal to refIdxLX, the motion vector predictor mvpLX is derived by: \nmvpLX = mvLXC    (8-206) \n–  Otherwise, the derivation process for median luma motion vector prediction in  clause 8.4.1.3.1 is invoked with \nmbAddrN\\mbPartIdxN\\subMbPartIdxN, mvLXN, refIdxLXN with N being replaced by A, B, or C, and refIdxLX as \nthe inputs and the output is assigned to the motion vector predictor mvpLX. \nFigure 8-3 illustrates the non-median prediction as specified in Equations 8-203 to 8-206. \n8*16 16*8\n \nFigure 8-3 – Directional segmentation prediction (informative) \n8.4.1.3.1 Derivation process for median luma motion vector prediction \nInputs to this process are: \n–  the neighbouring partitions mbAddrN\\mbPartIdxN\\subMbPartIdxN (with N being replaced by A, B, or C), \n–  the motion vectors mvLXN (with N being replaced by A, B, or C) of the neighbouring partitions, \n–  the reference indices refIdxLXN (with N being replaced by A, B, or C) of the neighbouring partitions, \n–  the reference index refIdxLX of the current partition. \nOutput of this process is the motion vector prediction mvpLX. \n162  Rec. ITU-T H.264 (06/2019) \n \nThe variable mvpLX is derived as specified by the following ordered steps: \n1.  When both partitions mbAddrB\\mbPartIdxB\\subMbPartIdxB and mbAddrC\\mbPartIdxC\\subMbPartIdxC are not \navailable and mbAddrA\\mbPartIdxA\\subMbPartIdxA is available, \nmvLXB = mvLXA    (8-207) \nmvLXC = mvLXA    (8-208) \nrefIdxLXB = refIdxLXA    (8-209) \nrefIdxLXC = refIdxLXA    (8-210) \n2.  Depending on reference indices refIdxLXA, refIdxLXB, or refIdxLXC, the following applies: \n–  If one and only one of the reference indices refIdxLXA, refIdxLXB, or refIdxLXC is equal to the reference \nindex refIdxLX of the current partition, the following applies. Let refIdxLXN be the reference index that is \nequal to refIdxLX, the motion vector mvLXN is assigned to the motion vector prediction mvpLX: \nmvpLX = mvLXN    (8-211) \n–  Otherwise,  each  component  of  the  motion  vector  prediction  mvpLX  is  given  by  the  median  of  the \ncorresponding vector components of the motion vector mvLXA, mvLXB, and mvLXC: \nmvpLX[ 0 ] = Median( mvLXA[ 0 ], mvLXB[ 0 ], mvLXC[ 0 ] )   (8-212) \nmvpLX[ 1 ] = Median( mvLXA[ 1 ], mvLXB[ 1 ], mvLXC[ 1 ] )   (8-213) \n8.4.1.3.2 Derivation process for motion data of neighbouring partitions \nInputs to this process are: \n–  the macroblock partition index mbPartIdx, \n–  the sub-macroblock partition index subMbPartIdx, \n–  the current sub-macroblock type currSubMbType, \n–  the list suffix flag listSuffixFlag. \nOutputs of this process are (with N being replaced by A, B, or C) \n–  mbAddrN\\mbPartIdxN\\subMbPartIdxN specifying neighbouring partitions, \n–  the motion vectors mvLXN of the neighbouring partitions, \n–  the reference indices refIdxLXN of the neighbouring partitions. \nVariable names that include the string \"LX\" are interpreted with the X being equal to listSuffixFlag. \nThe partitions mbAddrN\\mbPartIdxN\\subMbPartIdxN with N being either A, B, or C are derived in the following \nordered steps: \n1.  Let mbAddrD\\mbPartIdxD\\subMbPartIdxD be variables specifying an additional neighbouring partition. \n2.  The process in clause 6.4.11.7 is invoked with mbPartIdx, currSubMbType, and subMbPartIdx as input and the \noutput is assigned to mbAddrN\\mbPartIdxN\\subMbPartIdxN with N being replaced by A, B, C, or D. \n3.  When the partition mbAddrC\\mbPartIdxC\\subMbPartIdxC is not available, the following applies: \nmbAddrC = mbAddrD    (8-214) \nmbPartIdxC = mbPartIdxD    (8-215) \nsubMbPartIdxC = subMbPartIdxD    (8-216) \n    Rec. ITU-T H.264 (06/2019)  163 \n \nThe motion vectors mvLXN and reference indices refIdxLXN (with N being A, B, or C) are derived as follows: \n–  If the macroblock partition or sub-macroblock partition mbAddrN\\mbPartIdxN\\subMbPartIdxN is not available or \nmbAddrN is coded in an Intra macroblock prediction mode or predFlagLX of mbAddrN\\mbPartIdxN\\subMbPartIdxN \nis equal to 0, both components of mvLXN are set equal to 0 and refIdxLXN is set equal to −1. \n–  Otherwise, the following ordered steps are specified: \n1.  The  motion  vector  mvLXN  and  reference  index  refIdxLXN  are  set  equal  to \nMvLX[ mbPartIdxN ][ subMbPartIdxN ] and RefIdxLX[ mbPartIdxN ], respectively, which are the motion \nvector  mvLX  and  reference  index  refIdxLX  that  have  been  assigned  to  the  (sub-)macroblock  partition \nmbAddrN\\mbPartIdxN\\subMbPartIdxN. \n2.  The variables mvLXN[ 1 ] and refIdxLXN are further processed as follows: \n–  If the current macroblock is a field macroblock and the macroblock mbAddrN is a frame macroblock \nmvLXN[ 1 ] = mvLXN[ 1 ] / 2    (8-217) \nrefIdxLXN = refIdxLXN * 2    (8-218) \n–  Otherwise, if the current macroblock is a frame macroblock and the macroblock mbAddrN is a field \nmacroblock \nmvLXN[ 1 ] = mvLXN[ 1 ] * 2    (8-219) \nrefIdxLXN = refIdxLXN / 2    (8-220) \n–  Otherwise, the vertical motion vector component mvLXN[ 1 ] and the reference index refIdxLXN \nremain unchanged. \n8.4.1.4  Derivation process for chroma motion vectors \nThis process is only invoked when ChromaArrayType is not equal to 0. \nInputs to this process are a luma motion vector mvLX and a reference index refIdxLX. \nOutput of this process is a chroma motion vector mvCLX. \nA chroma motion vector is derived from the corresponding luma motion vector. \nThe precision of the chroma motion vector components is 1 ÷ ( 4 * SubWidthC ) horizontally and 1 ÷ ( 4 * SubHeightC ) \nvertically. \nNOTE – For example, when using the 4:2:0 chroma format, since the units of luma motion vectors are one-quarter luma sample \nunits and chroma has half horizontal and vertical resolution compared to luma, the units of chroma motion vectors are one-eighth \nchroma sample units, i.e., a value of 1 for the chroma motion vector refers to a one-eighth chroma sample displacement. For example, \nwhen the luma vector applies to 8x16 luma samples, the corresponding chroma vector in 4:2:0 chroma format applies to 4x8 chroma \nsamples and when the luma vector applies to 4x4 luma samples, the corresponding chroma vector in 4:2:0 chroma format applies \nto 2x2 chroma samples. \nFor the derivation of the motion vector mvCLX, the following applies: \n–  If ChromaArrayType is not equal to 1 or the current macroblock is a frame macroblock, the horizontal and vertical \ncomponents of the chroma motion vector mvCLX are derived as: \nmvCLX[ 0 ] = mvLX[ 0 ]    (8-221)\nmvCLX[ 1 ] = mvLX[ 1 ]    (8-222) \n–  Otherwise (ChromaArrayType is equal to 1 and the current macroblock is a field macroblock), only the horizontal \ncomponent of the chroma motion vector mvCLX[ 0 ] is derived using Equation 8-221. The vertical component of the \nchroma motion vector mvCLX[ 1 ] is dependent on the parity of the current field or the current macroblock and the \nreference  picture,  which  is  referred  by  the  reference  index  refIdxLX.  mvCLX[ 1 ]  is  derived  from  mvLX[ 1 ] \naccording to Table 8-10. \n164  Rec. ITU-T H.264 (06/2019) \n \nTable 8-10 – Derivation of the vertical component of the chroma vector in field coding mode \n \nParity conditions \nmvCLX[ 1 ] \nReference picture (refIdxLX)  Current field (picture/macroblock) \nTop field  Bottom field  mvLX[ 1 ] + 2 \nBottom field  Top field  mvLX[ 1 ] − 2 \nOtherwise  mvLX[ 1 ] \n \n8.4.2  Decoding process for Inter prediction samples \nInputs to this process are: \n–  a macroblock partition mbPartIdx, \n–  a sub-macroblock partition subMbPartIdx, \n–  variables specifying partition width and height for luma and chroma (if available), partWidth, partHeight, partWidthC \n(if available) and partHeightC (if available), \n–  luma motion vectors mvL0 and mvL1 and when ChromaArrayType is not equal to 0 chroma motion vectors mvCL0 \nand mvCL1, \n–  reference indices refIdxL0 and refIdxL1, \n–  prediction list utilization flags, predFlagL0 and predFlagL1, \n–  variables  for  weighted  prediction  logWD ,  w ,  w ,  o ,  o   with  C  being  replaced  by  L  and,  when \nC 0C 1C 0C 1C\nChromaArrayType is not equal to 0, Cb and Cr. \nOutputs of this process are the Inter prediction samples predPart, which are a (partWidth)x(partHeight) array predPart  of \nL\nprediction  luma  samples,  and  when  ChromaArrayType  is  not  equal  to 0  two  (partWidthC)x(partHeightC)  arrays \npredPart , predPart  of prediction chroma samples, one for each of the chroma components Cb and Cr. \nCb Cr\nLet  predPartL0   and  predPartL1   be  (partWidth)x(partHeight)  arrays  of  predicted  luma  sample  values  and  when \nL L\nChromaArrayType  is  not  equal  to 0  predPartL0 ,  predPartL1 ,  predPartL0 ,  and  predPartL1   be \nCb Cb Cr Cr\n(partWidthC)x(partHeightC) arrays of predicted chroma sample values. \nFor LX being replaced by either L0 or L1 in the variables predFlagLX, RefPicListX, refIdxLX, refPicLX, predPartLX, the \nfollowing is specified. \nWhen predFlagLX is equal to 1, the following applies: \n–  The  reference  picture  consisting  of  an  ordered  two-dimensional  array  refPicLX   of  luma  samples  and  when \nL\nChromaArrayType is not equal to 0 two ordered two-dimensional arrays refPicLX  and refPicLX  of chroma \nCb Cr\nsamples is derived by invoking the process specified in clause 8.4.2.1 with refIdxLX and RefPicListX given as input. \n–  The array predPartLX  and when ChromaArrayType is not equal to 0 the arrays predPartLX  and predPartLX  are \nL Cb Cr\nderived  by  invoking  the  process  specified  in  clause 8.4.2.2  with  the  current  partition  specified  by \nmbPartIdx\\subMbPartIdx, the motion vectors mvLX, mvCLX (if available), and the reference arrays with refPicLX , \nL\nrefPicLX  (if available), and refPicLX  (if available) given as input. \nCb Cr\nFor C being replaced by L, Cb (if available), or Cr (if available), the array predPart  of the prediction samples of component \nC\nC is derived by invoking the process specified in clause 8.4.2.3 with the current partition specified by mbPartIdx and \nsubMbPartIdx, the prediction utilization flags predFlagL0 and predFlagL1, the arrays predPartL0  and predPartL1 , and \nC C\nthe variables for weighted prediction logWD , w , w , o , o  given as input. \nC 0C 1C 0C 1C\n8.4.2.1  Reference picture selection process \nInput to this process is a reference index refIdxLX. \nOutput of this process is a reference picture consisting of a two-dimensional array of luma samples refPicLX  and, when \nL\nChromaArrayType is not equal to 0, two two-dimensional arrays of chroma samples refPicLX  and refPicLX . \nCb Cr\n    Rec. ITU-T H.264 (06/2019)  165 \n \nDepending on field_pic_flag, the reference picture list RefPicListX (which has been derived as specified in clause 8.2.4) \nconsists of the following. \n–  If field_pic_flag is equal to 1, each entry of RefPicListX is a reference field or a field of a reference frame. \n–  Otherwise (field_pic_flag is equal to 0), each entry of RefPicListX is a reference frame or a complementary reference \nfield pair. \nFor the derivation of the reference picture, the following applies: \n–  If field_pic_flag is equal to 1, the reference field or field of a reference frame RefPicListX[ refIdxLX ] is the output. \nThe output reference field or field of a reference frame consists of a (PicWidthInSamples )x(PicHeightInSamples ) \nL L\narray  of  luma  samples  refPicLX   and,  when  ChromaArrayType  is  not  equal  to 0,  two \nL\n(PicWidthInSamples )x(PicHeightInSamples ) arrays of chroma samples refPicLX  and refPicLX . \nC C Cb Cr\n–  Otherwise (field_pic_flag is equal to 0), the following applies: \n–  If the current macroblock is a frame macroblock, the reference frame or complementary reference field pair \nRefPicListX[ refIdxLX ] is the output. The output reference frame or complementary reference field pair consists \nof  a  (PicWidthInSamples )x(PicHeightInSamples )  array  of  luma  samples  refPicLX   and,  when \nL L L\nChromaArrayType  is  not  equal  to 0,  two  (PicWidthInSamples )x(PicHeightInSamples )  arrays  of  chroma \nC C\nsamples refPicLX  and refPicLX . \nCb Cr\n–  Otherwise (the current macroblock is a field macroblock), the following ordered steps are specified: \n1.  Let refFrame be the reference frame or complementary reference field pair RefPicListX[ refIdxLX / 2 ]. \n2.  The field of refFrame is selected as follows: \n–  If refIdxLX % 2 is equal to 0, the field of refFrame that has the same parity as the current macroblock \nis the output. \n–  Otherwise (refIdxLX % 2 is equal to 1), the field of refFrame that has the opposite parity as the \ncurrent macroblock is the output. \n3.  The  output  reference  field  or  field  of  a  reference  frame  consists  of  a \n(PicWidthInSamples )x(PicHeightInSamples  / 2)  array  of  luma  samples  refPicLX   and,  when \nL L L\nChromaArrayType  is  not  equal  to 0,  two  (PicWidthInSamples )x(PicHeightInSamples  / 2)  arrays  of \nC C\nchroma samples refPicLX  and refPicLX . \nCb Cr\nDepending on separate_colour_plane_flag, the following applies: \n–  If separate_colour_plane_flag is equal to 0, the reference picture sample arrays refPicLX , refPicLX  (if available), \nL Cb\nand refPicLX  (if available) correspond to decoded sample arrays S , S  (if available), S  (if available) derived in \nCr L Cb Cr\nclause 8.7 for a previously-decoded reference field or reference frame or complementary reference field pair or field \nof a reference frame. \n–  Otherwise (separate_colour_plane_flag is equal to 1), the following applies: \n–  If colour_plane_id is equal to 0, the reference picture sample array refPicLX  corresponds to the decoded sample \nL\narray S  derived in clause 8.7 for a previously-decoded reference field or reference frame or complementary \nL\nreference field pair or field of a reference frame. \n–  Otherwise, if colour_plane_id is equal to 1, the reference picture sample array refPicLX  corresponds to the \nL\ndecoded sample array S  derived in clause 8.7 for a previously-decoded reference field or reference frame or \nCb\ncomplementary reference field pair or field of a reference frame. \n–  Otherwise (colour_plane_id is equal to 2), the reference picture sample array refPicLX  corresponds to the \nL\ndecoded sample array S  derived in clause 8.7 for a previously-decoded reference field or reference frame or \nCr\ncomplementary reference field pair or field of a reference frame. \n8.4.2.2  Fractional sample interpolation process \nInputs to this process are: \n–  the current partition given by its partition index mbPartIdx and its sub-macroblock partition index subMbPartIdx, \n–  the width and height partWidth, partHeight of this partition in luma-sample units, \n–  a luma motion vector mvLX given in quarter-luma-sample units, \n–  when ChromaArrayType is not equal to 0, a chroma motion vector mvCLX with a precision of one-(4*SubWidthC)-\nth chroma-sample units horizontally and one-(4*SubHeightC)-th chroma-sample units vertically, \n166  Rec. ITU-T H.264 (06/2019) \n \n–  the selected reference picture sample arrays refPicLX , and when ChromaArrayType is not equal to 0, refPicLX , \nL Cb\nand refPicLX . \nCr\nOutputs of this process are: \n–  a (partWidth)x(partHeight) array predPartLX  of prediction luma sample values, \nL\n–  when ChromaArrayType is not equal to 0, two (partWidthC)x(partHeightC) arrays predPartLX , and predPartLX  \nCb Cr\nof prediction chroma sample values. \nLet ( xA , yA  ) be the location given in full-sample units of the upper-left luma sample of the current partition given by \nL L\nmbPartIdx\\subMbPartIdx relative to the upper-left luma sample location of the given two-dimensional array of luma \nsamples. \nLet ( xInt , yInt  ) be a luma location given in full-sample units and ( xFrac , yFrac  ) be an offset given in quarter-sample \nL L L L\nunits. These variables are used only inside this clause for specifying general fractional-sample locations inside the reference \nsample arrays refPicLX , refPicLX  (if available), and refPicLX  (if available). \nL Cb Cr\nFor  each  luma  sample  location  (0 <= x  < partWidth,  0 <= y  < partHeight)  inside  the  prediction  luma  sample  array \nL L\npredPartLX ,  the  corresponding  prediction  luma  sample  value  predPartLX [ x , y  ]  is  derived  as  specified  by  the \nL L L L\nfollowing ordered steps: \n1.  The variables xInt , yInt , xFrac , and yFrac  are derived by: \nL L L L\nxInt  = xA  + ( mvLX[ 0 ] >> 2 ) + x     (8-223) \nL L L\nyInt  = yA  + ( mvLX[ 1 ] >> 2 ) + y     (8-224) \nL L L\nxFrac  = mvLX[ 0 ] & 3    (8-225) \nL\nyFrac  = mvLX[ 1 ] & 3    (8-226) \nL\n2.  The  prediction  luma  sample  value  predPartLX [ x , y  ]  is  derived  by  invoking  the  process  specified  in \nL L L\nclause 8.4.2.2.1 with ( xInt , yInt  ), ( xFrac , yFrac  ) and refPicLX  given as input. \nL L L L L\nWhen ChromaArrayType is not equal to 0, the following applies. \nLet  ( xInt , yInt  )  be  a  chroma  location  given  in  full-sample  units  and  ( xFrac , yFrac  )  be  an  offset  given  in \nC C C C\none-(4*SubWidthC)-th chroma-sample units horizontally and one-(4*SubHeightC)-th chroma-sample units vertically. \nThese variables are used only inside this clause for specifying general fractional-sample locations inside the reference \nsample arrays refPicLX , and refPicLX . \nCb Cr\nFor each chroma sample location (0 <= x  < partWidthC, 0 <= y  < partHeightC) inside the prediction chroma sample \nC C\narrays predPartLX  and predPartLX , the corresponding prediction chroma sample values predPartLX [ x  y  ] and \nCb Cr Cb C, C\npredPartLX [ x  y  ] are derived as specified by the following ordered steps: \nCr C, C\n1.  Depending on ChromaArrayType, the variables xInt , yInt , xFrac , and yFrac  are derived as follows: \nC C C C\n–  If ChromaArrayType is equal to 1, \nxInt  = ( xA  / SubWidthC ) + ( mvCLX[ 0 ] >> 3 ) + x   (8-227) \nC L C\nyInt  = ( yA  / SubHeightC ) + ( mvCLX[ 1 ] >> 3 ) + y   (8-228) \nC L C\nxFrac  = mvCLX[ 0 ] & 7    (8-229) \nC\nyFrac  = mvCLX[ 1 ] & 7    (8-230) \nC\n–  Otherwise, if ChromaArrayType is equal to 2, \nxInt  = ( xA  / SubWidthC ) + ( mvCLX[ 0 ] >> 3 ) + x   (8-231) \nC L C\nyInt  = ( yA  / SubHeightC ) + ( mvCLX[ 1 ] >> 2 ) + y   (8-232) \nC L C\nxFrac  = mvCLX[ 0 ] & 7    (8-233) \nC\nyFrac  = ( mvCLX[ 1 ] & 3 ) << 1    (8-234) \nC\n    Rec. ITU-T H.264 (06/2019)  167 \n \n–  Otherwise (ChromaArrayType is equal to 3), \nxInt  = xA  + ( mvLX[ 0 ] >> 2 ) + x     (8-235) \nC L C\nyInt  = yA  + ( mvLX[ 1 ] >> 2 ) + y     (8-236) \nC L C\nxFrac  = ( mvCX[ 0 ] & 3 )    (8-237) \nC\nyFrac  = ( mvCX[ 1 ] & 3 )    (8-238) \nC\n2.  Depending on ChromaArrayType, the following applies: \n–  If ChromaArrayType is not equal to 3, the following applies: \n–  The prediction sample value predPartLX [ x  y  ] is derived by invoking the process specified in \nCb C, C\nclause 8.4.2.2.2 with ( xInt , yInt  ), ( xFrac , yFrac  ) and refPicLX  given as input. \nC C C C Cb\n–  The  prediction  sample  value  predPartLX [ x  y  ]  is  derived  by  invoking  the  process  specified  in \nCr C, C\nclause 8.4.2.2.2 with ( xInt , yInt  ), ( xFrac , yFrac  ) and refPicLX  given as input. \nC C C C Cr\n–  Otherwise (ChromaArrayType is equal to 3), the following applies: \n–  The prediction  sample value predPartLX [ x  y  ] is derived by invoking the process specified in \nCb C, C\nclause 8.4.2.2.1 with ( xInt , yInt  ), ( xFrac , yFrac  ) and refPicLX  given as input. \nC C C C Cb\n–  The  prediction  sample  value  predPartLX [ x  y  ]  is  derived  by  invoking  the  process  specified  in \nCr C, C\nclause 8.4.2.2.1 with ( xInt , yInt  ), ( xFrac , yFrac  ) and refPicLX  given as input. \nC C C C Cr\n8.4.2.2.1 Luma sample interpolation process \nInputs to this process are: \n–  a luma location in full-sample units ( xInt , yInt  ), \nL L\n–  a luma location offset in fractional-sample units ( xFrac , yFrac  ), \nL L\n–  the luma sample array of the selected reference picture refPicLX . \nL\nOutput of this process is a predicted luma sample value predPartLX [ x , y  ]. \nL L L\n168  Rec. ITU-T H.264 (06/2019) \n \nA aa B\nC bb D\nE F G a b c H I J\nd e f g\ncc dd h i j k m ee ff\nn p q r\nK L M s N P Q\nR gg S\nT hh U\n \nFigure 8-4 – Integer samples (shaded blocks with upper-case letters) and fractional sample positions (un-shaded \nblocks with lower-case letters) for quarter sample luma interpolation \nThe variable refPicHeightEffective , which is the height of the effective reference picture luma array, is derived as follows: \nL\n–  If MbaffFrameFlag is equal to 0 or mb_field_decoding_flag is equal to 0, refPicHeightEffective  is set equal to \nL\nPicHeightInSamples . \nL\n–  Otherwise (MbaffFrameFlag is equal to 1 and mb_field_decoding_flag is equal to 1), refPicHeightEffective  is set \nL\nequal to PicHeightInSamples  / 2. \nL\nIn Figure 8-4, the positions labelled with upper-case letters within shaded blocks represent luma samples at full-sample \nlocations inside the given two-dimensional array refPicLX  of luma samples. These samples may be used for generating \nL\nthe predicted luma sample value predPartLX [ x , y  ]. The locations ( xZ , yZ  ) for each of the corresponding luma \nL L L L L\nsamples Z, where Z may be A, B, C, D, E, F, G, H, I, J, K, L, M, N, P, Q, R, S, T, or U, inside the given array refPicLX  \nL\nof luma samples are derived as: \nxZ  = Clip3( 0, PicWidthInSamples  − 1, xInt  + xDZ  )   (8-239) \nL L L L\nyZ  = Clip3( 0, refPicHeightEffective  − 1, yInt  + yDZ  )  (8-240) \nL L L L\nTable 8-11 specifies ( xDZ , yDZ  ) for different replacements of Z. \nL L\nTable 8-11 – Differential full-sample luma locations \n \nZ  A  B  C  D  E  F  G  H  I  J  K  L  M  N  P  Q  R  S  T  U \nxDZ   0  1  0  1  −2  −1  0  1  2  3  −2  −1  0  1  2  3  0  1  0  1 \nL\nyDZ   −2  −2  −1  −1  0  0  0  0  0  0  1  1  1  1  1  1  2  2  3  3 \nL\n \nGiven the luma samples 'A' to 'U' at full-sample locations ( xA , yA  ) to ( xU , yU  ), the luma samples 'a' to 's' at \nL L L L\nfractional sample positions are derived by the following rules. The luma prediction values at half sample positions are \nderived by applying a 6-tap filter with tap values ( 1, −5, 20, 20, −5, 1 ). The luma prediction values at quarter sample \n    Rec. ITU-T H.264 (06/2019)  169 \n \npositions are derived by averaging samples at full and half sample positions. The process for each fractional position is \ndescribed below. \n–  The samples at half sample positions labelled b are derived by first calculating intermediate values denoted as b  by \n1\napplying the 6-tap filter to the nearest integer position samples in the horizontal direction. The samples at half sample \npositions labelled h are derived by first calculating intermediate values denoted as h  by applying the 6-tap filter to \n1\nthe nearest integer position samples in the vertical direction: \nb  = ( E − 5 * F + 20 * G + 20 * H − 5 * I + J )     (8-241) \n1\nh  = ( A − 5 * C + 20 * G + 20 * M − 5 * R + T )    (8-242) \n1\n  The final prediction values b and h are derived using \nb = Clip1 ( ( b  + 16 ) >> 5 )     (8-243) \nY 1\nh = Clip1 ( ( h  + 16 ) >> 5 )    (8-244) \nY 1\n–  The samples at half sample position labelled as j are derived by first calculating intermediate value denoted as j  by \n1\napplying the 6-tap filter to the intermediate values of the closest half sample positions in either the horizontal or \nvertical direction because these yield an equal result: \nj  = cc − 5 * dd + 20 * h  + 20 * m  − 5 * ee + ff, or    (8-245) \n1 1 1\nj  = aa − 5 * bb + 20 * b  + 20 * s   − 5 * gg + hh    (8-246) \n1 1 1\n  where intermediate values denoted as aa, bb, gg, s  and hh are derived by applying the 6-tap filter horizontally in the \n1\nsame manner as the derivation of b  and intermediate values denoted as cc, dd, ee, m  and ff are derived by applying \n1 1\nthe 6-tap filter vertically in the same manner as the derivation of h . The final prediction value j are derived using \n1\nj = Clip1 ( ( j  + 512 ) >> 10 )    (8-247) \nY 1\n–  The final prediction values s and m are derived from s  and m  in the same manner as the derivation of b and h, as \n1 1\ngiven by \ns  = Clip1 ( ( s   + 16 ) >> 5 )     (8-248) \nY 1\nm = Clip1 ( ( m  + 16 ) >> 5 )    (8-249) \nY 1\n–  The samples at quarter sample positions labelled as a, c, d, n, f, i, k, and q are derived by averaging with upward \nrounding of the two nearest samples at integer and half sample positions using \na = ( G + b + 1 ) >> 1    (8-250) \nc = ( H + b + 1 ) >> 1    (8-251) \nd = ( G + h + 1 ) >> 1    (8-252) \nn = ( M + h + 1 ) >> 1    (8-253) \nf = ( b + j + 1 ) >> 1    (8-254) \ni = ( h + j + 1 ) >> 1    (8-255) \nk = ( j + m + 1 ) >> 1    (8-256) \nq = ( j + s + 1 ) >> 1    (8-257) \n–  The samples at quarter sample positions labelled as e, g, p, and r are derived by averaging with upward rounding of \nthe two nearest samples at half sample positions in the diagonal direction using \ne = ( b + h + 1 ) >> 1    (8-258) \ng = ( b + m + 1 ) >> 1    (8-259) \np = ( h + s + 1 ) >> 1    (8-260) \nr = ( m + s + 1 ) >> 1.     (8-261) \nThe luma location offset in fractional-sample units ( xFrac , yFrac  ) specifies which of the generated luma samples at \nL L\nfull-sample and fractional-sample locations is assigned to the predicted luma sample value predPartLX [ x , y  ]. This \nL L L\nassignment is done according to Table 8-12. The value of predPartLX [ x , y  ] is the output. \nL L L\n170  Rec. ITU-T H.264 (06/2019) \n \nTable 8-12 – Assignment of the luma prediction sample predPartLX [ x , y  ] \nL L L\n \nxFrac   0  0  0  0  1  1  1  1  2  2  2  2  3  3  3  3 \nL\nyFrac   0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3 \nL\npredPartLX [ x , y  ]  G  d  h  n  a  e  i  p  b  f  j  q  c  g  k  r \nL L L\n \n8.4.2.2.2 Chroma sample interpolation process \nThis process is only invoked when ChromaArrayType is equal to 1 or 2. \nInputs to this process are: \n–  a chroma location in full-sample units ( xInt , yInt  ), \nC C\n–  a chroma location offset in fractional-sample units ( xFrac , yFrac  ), \nC C\n–  chroma component samples from the selected reference picture refPicLX . \nC\nOutput of this process is a predicted chroma sample value predPartLX [ x , y  ]. \nC C C\nIn Figure 8-5, the positions labelled with A, B, C, and D represent chroma samples at full-sample locations inside the given \ntwo-dimensional array refPicLX  of chroma samples. \nC\n \nFigure 8-5 – Fractional sample position dependent variables in chroma interpolation and surrounding integer \nposition samples A, B, C, and D \nThe variable refPicHeightEffective , which is the height of the effective reference picture chroma array, is derived as \nC\nfollows: \n–  If MbaffFrameFlag is equal to 0 or mb_field_decoding_flag is equal to 0, refPicHeightEffective  is set equal to \nC\nPicHeightInSamples . \nC\n–  Otherwise (MbaffFrameFlag is equal to 1 and mb_field_decoding_flag is equal to 1), refPicHeightEffective  is set \nC\nequal to PicHeightInSamples  / 2. \nC\nThe sample coordinates specified in Equations 8-262 through 8-269 are used for generating the predicted chroma sample \nvalue predPartLX [ x , y  ]. \nC C C\nxA  = Clip3( 0, PicWidthInSamples  − 1, xInt  )     (8-262) \nC C C\nxB  = Clip3( 0, PicWidthInSamples  − 1, xInt  + 1 )   (8-263)\nC C C  \nxC  = Clip3( 0, PicWidthInSamples  − 1, xInt  )     (8-264)\nC C C  \nxD  = Clip3( 0, PicWidthInSamples  − 1, xInt  + 1 )   (8-265) \nC C C\nyA  = Clip3( 0, refPicHeightEffective  − 1, yInt  )     (8-266) \nC C C\nyB  = Clip3( 0, refPicHeightEffective  − 1, yInt  )     (8-267)\nC C C  \nyC  = Clip3( 0, refPicHeightEffective  − 1, yInt  + 1 )   (8-268)\nC C C  \nyD  = Clip3( 0, refPicHeightEffective  − 1, yInt  + 1 )   (8-269) \nC C C\n    Rec. ITU-T H.264 (06/2019)  171 \n \nGiven the chroma samples A, B, C, and D at full-sample locations specified in Equations 8-262 through 8-269, the \npredicted chroma sample value predPartLX [ x , y  ] is derived as: \nC C C\npredPartLX [ x , y  ] = ( ( 8 − xFrac  ) * ( 8 − yFrac  ) * A + xFrac  * ( 8 − yFrac  ) * B + \nC C C C C C C\n                                         ( 8 − xFrac  ) * yFrac  * C            + xFrac  * yFrac  * D            + 32 ) >> 6  (8-270) \nC C C C\n8.4.2.3  Weighted sample prediction process \nInputs to this process are: \n–  mbPartIdx: the current partition given by the partition index, \n–  subMbPartIdx: the sub-macroblock partition index, \n–  predFlagL0 and predFlagL1: prediction list utilization flags, \n–  predPartLX : a (partWidth)x(partHeight) array of prediction luma samples (with LX being replaced by L0 or L1 \nL\ndepending on predFlagL0 and predFlagL1), \n–  when ChromaArrayType is not equal to 0, predPartLX  and predPartLX : (partWidthC)x(partHeightC) arrays of \nCb Cr\nprediction chroma samples, one for each of the chroma components Cb and Cr (with LX being replaced by L0 or L1 \ndepending on predFlagL0 and predFlagL1), \n–  variables  for  weighted  prediction  logWD ,  w ,  w ,  o ,  o   with  C  being  replaced  by  L  and,  when \nC 0C 1C 0C 1C\nChromaArrayType is not equal to 0, Cb and Cr. \nOutputs of this process are: \n–  predPart : a (partWidth)x(partHeight) array of prediction luma samples, \nL\n–  when  ChromaArrayType  is  not  equal  to  0,  predPart ,  and  predPart :  (partWidthC)x(partHeightC)  arrays  of \nCb Cr\nprediction chroma samples, one for each of the chroma components Cb and Cr. \nFor macroblocks or partitions with predFlagL0 equal to 1 in P and SP slices, the following applies: \n–  If weighted_pred_flag is equal to 0, the default weighted sample prediction process as described in clause 8.4.2.3.1 is \ninvoked with the same inputs and outputs as the process described in this clause. \n–  Otherwise  (weighted_pred_flag  is  equal  to 1),  the  explicit  weighted  sample  prediction  process  as  described  in \nclause 8.4.2.3.2 is invoked with the same inputs and outputs as the process described in this clause. \nFor macroblocks or partitions with predFlagL0 or predFlagL1 equal to 1 in B slices, the following applies: \n–  If weighted_bipred_idc is equal to 0, the default weighted sample prediction process as described in clause 8.4.2.3.1 \nis invoked with the same inputs and outputs as the process described in this clause. \n–  Otherwise, if weighted_bipred_idc is equal to 1, the explicit weighted sample prediction process as described in \nclause 8.4.2.3.2 is invoked with the same inputs and outputs as the process described in this clause. \n–  Otherwise (weighted_bipred_idc is equal to 2), the following applies: \n–  If predFlagL0 is equal to 1 and predFlagL1 is equal to 1, the implicit weighted sample prediction process as \ndescribed in clause 8.4.2.3.2 is invoked with the same inputs and outputs as the process described in this clause. \n–  Otherwise (predFlagL0 or predFlagL1 are equal to 1 but not both), the default weighted sample prediction \nprocess as described in clause 8.4.2.3.1 is invoked with the same inputs and outputs as the process described in \nthis clause. \n8.4.2.3.1 Default weighted sample prediction process \nInput to this process are the same as specified in clause 8.4.2.3. \nOutput of this process are the same as specified in clause 8.4.2.3. \nDepending on the available component for which the prediction block is derived, the following applies: \n–  If the luma sample prediction values predPart [ x, y ] are derived, the following applies with C set equal to L, x set \nL\nequal to 0..partWidth − 1, and y set equal to 0..partHeight − 1. \n–  Otherwise, if the chroma Cb component sample prediction values predPart [ x, y ] are derived, the following applies \nCb\nwith C set equal to Cb, x set equal to 0..partWidthC − 1, and y set equal to 0..partHeightC − 1. \n–  Otherwise (the chroma Cr component sample prediction values predPart [ x, y ] are derived), the following applies \nCr\nwith C set equal to Cr, x set equal to 0..partWidthC − 1, and y set equal to 0..partHeightC − 1. \n172  Rec. ITU-T H.264 (06/2019) \n \nThe prediction sample values are derived as follows: \n–  If predFlagL0 is equal to 1 and predFlagL1 is equal to 0, \npredPart [ x, y ] = predPartL0 [ x, y ]     (8-271) \nC C\n–  Otherwise, if predFlagL0 is equal to 0 and predFlagL1 is equal to 1, \npredPart [ x, y ]= predPartL1 [ x, y ]     (8-272) \nC C\n–  Otherwise (predFlagL0 and predFlagL1 are equal to 1), \npredPart [ x, y ] = ( predPartL0 [ x, y ] + predPartL1 [ x, y ] + 1 ) >> 1.   (8-273) \nC C C\n8.4.2.3.2 Weighted sample prediction process \nInputs to this process are the same as specified in clause 8.4.2.3. \nOutputs of this process are the same as specified in clause 8.4.2.3. \nDepending on the available component for which the prediction block is derived, the following applies: \n–  If the luma sample prediction values predPart [ x, y ] are derived, the following applies with C set equal to L, x set \nL\nequal to 0..partWidth − 1, y set equal to 0..partHeight − 1, and Clip1( ) being substituted with Clip1 ( ). \nY\n–  Otherwise, if the chroma Cb component sample prediction values predPart [ x, y ] are derived, the following applies \nCb\nwith C set equal to Cb, x set equal to 0..partWidthC − 1, y set equal to 0..partHeightC − 1, and Clip1( ) being \nsubstituted with Clip1 ( ). \nC\n–  Otherwise (the chroma Cr component sample prediction values predPart [ x, y ] are derived), the following applies \nCr\nwith C set equal to Cr, x set equal to 0..partWidthC − 1, y set equal to 0..partHeightC − 1, and Clip1( ) being \nsubstituted with Clip1 ( ). \nC\nThe prediction sample values are derived as follows: \n–  If the predFlagL0 is equal to 1 and predFlagL1 is equal to 0, the final predicted sample values predPart [ x, y ] are \nC\nderived by \nif( logWD  >= 1 )  \nC\n  predPart C [ x, y ] = Clip1( ( ( predPartL0 C [ x, y ] * w 0C  + 2logWD C  − 1 ) >> logWD C  ) + o 0C  )  \nelse      (8-274) \n  predPart [ x, y ] = Clip1( predPartL0 [ x, y ] * w  + o  ) \nC C 0C 0C\n–  Otherwise,  if  the  predFlagL0  is  equal  to 0  and  predFlagL1  is  equal  to 1,  the  final  predicted  sample  values \npredPart [ x, y ] are derived by \nC\nif( logWD  >= 1 ) \nC\n  predPart C [ x, y ] = Clip1( ( ( predPartL1 C [ x, y ] * w 1C  + 2logWD C  − 1 ) >> logWD C  ) + o 1C  )  \nelse      (8-275) \n  predPart [ x, y ] = Clip1( predPartL1 [ x, y ] * w  + o  ) \nC C 1C 1C\n–  Otherwise (both predFlagL0 and predFlagL1 are equal to 1), the final predicted sample values predPart [ x, y ] are \nC\nderived by \npredPart\nC\n[ x, y ] = Clip1( ( ( predPartL0\nC\n[ x, y ] * w\n0C\n + predPartL1\nC\n[ x, y ] * w\n1C\n + 2logWD C ) >>  \n      ( logWD  + 1 ) ) + ( ( o  + o  + 1 ) >> 1 ) )  (8-276) \nC 0C 1C\n8.4.3  Derivation process for prediction weights \nInputs to this process are: \n–  the reference indices refIdxL0 and refIdxL1, \n–  the prediction utilization flags predFlagL0 and predFlagL1. \nOutputs of this process are variables for weighted prediction logWD , w , w , o ,o  with C being replaced by L and, \nC 0C 1C 0C   1C\nwhen ChromaArrayType is not equal to 0, Cb and Cr. \nThe variables implicitModeFlag and explicitModeFlag are derived as follows: \n    Rec. ITU-T H.264 (06/2019)  173 \n \n–  If weighted_bipred_idc is equal to 2, (slice_type % 5) is equal to 1, predFlagL0 is equal to 1, and predFlagL1 is equal \nto 1, implicitModeFlag is set equal to 1 and explicitModeFlag is set equal to 0. \n–  Otherwise, if weighted_bipred_idc is equal to 1, (slice_type % 5) is equal to 1, and predFlagL0 + predFlagL1 is equal \nto 1 or 2, implicitModeFlag is set equal to 0 and explicitModeFlag is set equal to 1. \n–  Otherwise, if weighted_pred_flag is equal to 1, (slice_type % 5) is equal to 0 or 3, and predFlagL0 is equal to 1, \nimplicitModeFlag is set equal to 0 and explicitModeFlag is set equal to 1. \n–  Otherwise, implicitModeFlag is set equal to 0 and explicitModeFlag is set equal to 0. \nFor C being replaced by L and, when ChromaArrayType is not equal to 0, Cb and Cr, the variables logWD , w , w , \nC 0C 1C\no ,o  are derived as follows: \n0C   1C\n–  If implicitModeFlag is equal to 1, implicit mode weighted prediction is used as follows: \nlogWD  = 5     (8-277) \nC\no  = 0      (8-278) \n0C\no  = 0      (8-279) \n1C\nand w  and w  are derived as specified in the following ordered steps: \n0C 1C\n1.  The variables currPicOrField, pic0, and pic1 are derived as follows: \n–  If field_pic_flag is equal to 0 and the current macroblock is a field macroblock, the following applies: \na.  currPicOrField is the field of the current picture CurrPic that has the same parity as the current \nmacroblock. \nb.  The variable pic0 is derived as follows: \n–  If refIdxL0 % 2 is equal to 0, pic0 is the field of RefPicList0[ refIdxL0 / 2 ] that has the same \nparity as the current macroblock. \n–  Otherwise (refIdxL0 % 2 is not equal to 0), pic0 is the field of RefPicList0[ refIdxL0 / 2 ] that \nhas the opposite parity of the current macroblock. \nc.  The variable pic1 is derived as follows: \n–  If refIdxL1 % 2 is equal to 0, pic1 is the field of RefPicList1[ refIdxL1 / 2 ] that has the same \nparity as the current macroblock. \n–  Otherwise (refIdxL1 % 2 is not equal to 0), pic1 is the field of RefPicList1[ refIdxL1 / 2 ] that \nhas the opposite parity of the current macroblock. \n–  Otherwise (field_pic_flag is equal to 1 or the current macroblock is a frame macroblock), currPicOrField \nis the current picture CurrPic, pic1 is RefPicList1[ refIdxL1 ], and pic0 is RefPicList0[ refIdxL0 ]. \n2.  The variables w  and w  are derived as follows: \n0C 1C\n–  If DiffPicOrderCnt( pic1, pic0 ) is equal to 0 or one or both of pic1 and pic0 is marked as \"used for \nlong-term reference\" or ( DistScaleFactor >> 2 ) < −64 or ( DistScaleFactor >> 2 ) > 128, w  and w  are \n0C 1C\nderived as: \nw  = 32    (8-280) \n0C\nw  = 32    (8-281) \n1C\n–  Otherwise, the variables tb, td, tx, and DistScaleFactor are derived from the values of currPicOrField, pic0, \nand pic1 using Equations 8-201, 8-202, 8-197, and 8-198, respectively, and the weights w  and w  are \n0C 1C\nderived as \nw  = 64 − (DistScaleFactor >> 2)    (8-282) \n0C\nw  = DistScaleFactor >> 2    (8-283) \n1C\n–  Otherwise, if explicitModeFlag is equal to 1, explicit mode weighted prediction is used as specified by the following \nordered steps: \n174  Rec. ITU-T H.264 (06/2019) \n \n1.  The variables refIdxL0WP and refIdxL1WP are derived as follows: \n–  If MbaffFrameFlag is equal to 1 and the current macroblock is a field macroblock \nrefIdxL0WP = refIdxL0 >> 1    (8-284) \nrefIdxL1WP = refIdxL1 >> 1    (8-285) \n–  Otherwise (MbaffFrameFlag is equal to 0 or the current macroblock is a frame macroblock), \nrefIdxL0WP = refIdxL0    (8-286) \nrefIdxL1WP = refIdxL1    (8-287) \n2.  The variables logWD , w , w , o , and o  are derived as follows: \nC 0C 1C 0C 1C\n–  If C is equal to L for luma samples \nlogWD  = luma_log2_weight_denom    (8-288) \nC\nw  = luma_weight_l0[ refIdxL0WP ]    (8-289) \n0C\nw  = luma_weight_l1[ refIdxL1WP ]    (8-290) \n1C\no  = luma_offset_l0[ refIdxL0WP ] * ( 1 << ( BitDepth  − 8 ) )  (8-291) \n0C Y\no  = luma_offset_l1[ refIdxL1WP ] * ( 1 << ( BitDepth  − 8 ) )  (8-292) \n1C Y\n–  Otherwise (C is equal to Cb or Cr for chroma samples, with iCbCr = 0 for Cb, iCbCr = 1 for Cr), \nlogWD  = chroma_log2_weight_denom   (8-293) \nC\nw  = chroma_weight_l0[ refIdxL0WP ][ iCbCr ]  (8-294) \n0C\nw  = chroma_weight_l1[ refIdxL1WP ][ iCbCr ]  (8-295) \n1C\no  = chroma_offset_l0[ refIdxL0WP ][ iCbCr ] * ( 1 << ( BitDepth  − 8 ) )  (8-296) \n0C C\no  = chroma_offset_l1[ refIdxL1WP ][ iCbCr ] * ( 1 << ( BitDepth  − 8 ) )  (8-297) \n1C C\n–  Otherwise (implicitModeFlag is equal to 0 and explicitModeFlag is equal to 0), the variables logWD , w , w , o ,\nC 0C 1C 0C  \no  are not used in the reconstruction process for the current macroblock. \n1C\nWhen explicitModeFlag is equal to 1 and predFlagL0 and predFlagL1 are equal to 1, the following constraint shall be \nobeyed for C equal to L and, when ChromaArrayType is not equal to 0, Cb and Cr: \n−128 <= w  + w  <= ( ( logWD   = =  7 ) ? 127 : 128 )  (8-298) \n0C 1C C\nNOTE – For implicitModeFlag equal to 1, weights w  and w  are each guaranteed to be in the range of −64..128 and the constraint \n0C 1C\nexpressed in Equation 8-298, although not explicitly imposed, will always be met. For explicitModeFlag equal to 1 with logWD  \nC\nequal to 7, when one of the two weights w  or w  is inferred to be equal to 128 (as a consequence of luma_weight_l0_flag, \n0C 1C\nluma_weight_l1_flag, chroma_weight_l0_flag, or chroma_weight_l1_flag equal to 0), the other weight (w  or w ) must have a \n1C 0C\nnegative value in order for the constraint expressed in Equation 8-298 to hold (and therefore the other flag luma_weight_l0_flag, \nluma_weight_l1_flag, chroma_weight_l0_flag, or chroma_weight_l1_flag must be equal to 1). \n8.5  Transform coefficient decoding process and picture construction process prior to deblocking \nfilter process \nInputs to this process are Intra16x16DCLevel (if available), Intra16x16ACLevel (if available), CbIntra16x16DCLevel (if \navailable), CbIntra16x16ACLevel (if available), CrIntra16x16DCLevel (if available), CrIntra16x16ACLevel (if available), \nLumaLevel4x4 (if available), LumaLevel8x8 (if available), ChromaDCLevel (if available), ChromaACLevel (if available), \nCbLevel4x4 (if available), CrLevel4x4 (if available), CbLevel8x8 (if available), CrLevel8x8 (if available), and available \nInter or Intra prediction sample arrays for the current macroblock for the applicable components pred , pred , or pred . \nL Cb Cr\nNOTE 1 – When decoding a macroblock in Intra_4x4 (or Intra_8x8) macroblock prediction mode, the luma component of the \nmacroblock prediction array may not be complete, since for each 4x4 (or 8x8) luma block, the Intra_4x4 (or Intra_8x8) prediction \n    Rec. ITU-T H.264 (06/2019)  175 \n \nprocess for luma samples as specified in  clause 8.3.1 (or 8.3.2) and the process specified in this  clause are iterated. When \nChromaArrayType is equal to 3, the Cb and Cr component of the macroblock prediction array may not be complete for the same \nreason. \nOutputs  of  this  process  are  the  constructed  sample  arrays  prior  to  the  deblocking  filter  process  for  the  applicable \ncomponents S′ , S′ , or S′ . \nL Cb Cr\nNOTE 2 – When decoding a macroblock in Intra_4x4 (or Intra_8x8) macroblock prediction mode, the luma component of the \nmacroblock constructed sample arrays prior to the deblocking filter process may not be complete, since for each 4x4 (or 8x8) luma \nblock, the Intra_4x4 (or Intra_8x8) prediction process for luma samples as specified in clause 8.3.1 (or 8.3.2) and the process \nspecified in this clause are iterated. When ChromaArrayType is equal to 3, the Cb and Cr component of the macroblock constructed \nsample arrays prior to the deblocking filter process may not be complete for the same reason. \nThis clause specifies transform coefficient decoding and picture construction prior to the deblocking filter process. \nWhen the current macroblock is coded as P_Skip or B_Skip, all values of LumaLevel4x4, LumaLevel8x8, CbLevel4x4, \nCbLevel8x8, CrLevel4x4, CrLevel8x8, ChromaDCLevel, ChromaACLevel are set equal to 0 for the current macroblock. \n8.5.1  Specification of transform decoding process for 4x4 luma residual blocks \nThis specification applies when transform_size_8x8_flag is equal to 0. \nWhen the current macroblock prediction mode is not equal to Intra_16x16, the variable LumaLevel4x4 contains the levels \nfor the luma transform coefficients. For a 4x4 luma block indexed by luma4x4BlkIdx = 0..15, the following ordered steps \nare specified: \n1.  The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is invoked \nwith LumaLevel4x4[ luma4x4BlkIdx ] as the input and the two-dimensional array c as the output. \n2.  The scaling and transformation process for residual 4x4 blocks as specified in clause 8.5.12 is invoked with c as \nthe input and r as the output. \n3.  When TransformBypassModeFlag  is equal to 1, the  macroblock prediction  mode is equal to Intra_4x4, and \nIntra4x4PredMode[ luma4x4BlkIdx ] is equal to 0 or 1, the intra residual transform-bypass decoding process as \nspecified  in  clause 8.5.15  is  invoked  with  nW  set  equal  to 4,  nH  set  equal  to 4,  horPredFlag  set  equal  to \nIntra4x4PredMode[ luma4x4BlkIdx ], and the 4x4 array r as the inputs, and the output is a modified version of the \n4x4 array r. \n4.  The position of the upper-left sample of a 4x4 luma block with index luma4x4BlkIdx inside the macroblock is \nderived by invoking the inverse 4x4 luma block scanning process in clause 6.4.3 with luma4x4BlkIdx as the input \nand the output being assigned to ( xO, yO ). \n5.  The 4x4 array u with elements u  for i, j = 0..3 is derived as: \nij\nu  = Clip1 ( pred [ xO + j, yO + i ] + r  )     (8-299) \nij Y L ij\nWhen TransformBypassModeFlag is equal to 1, the bitstream shall not contain data that result in a value of u  as \nij\ncomputed by Equation 8-299 that is not equal to pred [ xO + j, yO + i ] + r . \nL ij\n6.  The  picture  construction  process  prior  to  deblocking  filter  process  in  clause 8.5.14  is  invoked  with  u  and \nluma4x4BlkIdx as the inputs. \n8.5.2  Specification of transform decoding process for luma samples of Intra_16x16 macroblock prediction mode \nWhen  the  current  macroblock  prediction  mode  is  equal  to  Intra_16x16,  the  variables  Intra16x16DCLevel  and \nIntra16x16ACLevel contain the levels for the luma transform coefficients. The transform coefficient decoding proceeds in \nthe following ordered steps: \n1.  The 4x4 luma DC transform coefficients of all 4x4 luma blocks of the macroblock are decoded. \na.  The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is \ninvoked with Intra16x16DCLevel as the input and the two-dimensional array c as the output. \nb.  The scaling and transformation process for luma DC transform coefficients for Intra_16x16 macroblock type \nas specified in clause 8.5.10 is invoked with BitDepth , QP′ , and c as the input and dcY as the output. \nY Y\n2.  The 16x16 array rMb is derived by processing the 4x4 luma blocks indexed by luma4x4BlkIdx = 0..15, and for \neach 4x4 luma block, the following ordered steps are specified: \na.  The variable lumaList, which is a list of 16 entries, is derived. The first entry of lumaList is the corresponding \nvalue  from  the  array  dcY.  Figure 8-6  shows  the  assignment  of  the  indices  of  the  array  dcY  to  the \n176  Rec. ITU-T H.264 (06/2019) \n \nluma4x4BlkIdx. The two numbers in the small squares refer to indices i and j in dcY , and the numbers in \nij\nlarge squares refer to luma4x4BlkIdx. \n \n00 01 02 03\n10 11 12 13\n20 21 22 23\n30 31 32 33\n \nFigure 8-6 – Assignment of the indices of dcY to luma4x4BlkIdx \nThe elements in lumaList with index k = 1..15 are specified as: \nlumaList[ k ] = Intra16x16ACLevel[ luma4x4BlkIdx ][ k − 1 ]   (8-300) \nb.  The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is \ninvoked with lumaList as the input and the two-dimensional array c as the output. \nc.  The scaling and transformation process for residual 4x4 blocks as specified in clause 8.5.12 is invoked with c \nas the input and r as the output. \nd.  The position of the upper-left sample of a 4x4 luma block with index luma4x4BlkIdx inside the macroblock \nis derived by invoking the inverse 4x4 luma block scanning process in clause 6.4.3 with luma4x4BlkIdx as \nthe input and the output being assigned to ( xO, yO ). \ne.  The elements rMb[ x, y ] of the 16x16 array rMb with x = xO..xO + 3 and y = yO..yO + 3 are derived by \nrMb[ xO + j, yO + i ] = r     (8-301) \nij\n3.  When TransformBypassModeFlag is equal to 1 and Intra16x16PredMode is equal to 0 or 1, the intra residual \ntransform-bypass decoding process as specified in clause 8.5.15 is invoked with nW set equal to 16, nH set equal \nto 16, horPredFlag set equal to Intra16x16PredMode, and the 16x16 array rMb as the inputs, and the output is a \nmodified version of the 16x16 array rMb. \n4.  The 16x16 array u with elements u  for i, j = 0..15 is derived as \nij\nu  = Clip1 ( pred [ j, i ] + rMb[ j, i ] )     (8-302) \nij Y L\nWhen TransformBypassModeFlag is equal to 1, the bitstream shall not contain data that result in a value of u  as \nij\ncomputed by Equation 8-302 that is not equal to pred [ j, i ] + rMb[ j, i ]. \nL\n5.  The picture construction process prior to deblocking filter process in clause 8.5.14 is invoked with u as the input. \n8.5.3  Specification of transform decoding process for 8x8 luma residual blocks \nThis specification applies when transform_size_8x8_flag is equal to 1. \nThe variable LumaLevel8x8[ luma8x8BlkIdx ] with luma8x8BlkIdx = 0..3 contains the levels for the luma transform \ncoefficients for the luma 8x8 block with index luma8x8BlkIdx. \nFor an 8x8 luma block indexed by luma8x8BlkIdx = 0..3, the following ordered steps are specified: \n1.  The inverse scanning process for 8x8 transform coefficients and scaling lists as specified in clause 8.5.7 is invoked \nwith LumaLevel8x8[ luma8x8BlkIdx ] as the input and the two-dimensional array c as the output. \n2.  The scaling and transformation process for residual 8x8 blocks as specified in clause 8.5.13 is invoked with c as \nthe input and r as the output. \n    Rec. ITU-T H.264 (06/2019)  177 \n \n3.  When TransformBypassModeFlag  is equal to 1, the  macroblock prediction  mode is equal to Intra_8x8, and \nIntra8x8PredMode[ luma8x8BlkIdx ] is equal to 0 or 1, the intra residual transform-bypass decoding process as \nspecified  in  clause 8.5.15  is  invoked  with  nW  set  equal  to 8,  nH  set  equal  to 8,  horPredFlag  set  equal  to \nIntra8x8PredMode[ luma8x8BlkIdx ], and the 8x8 array r as the inputs, and the output is a modified version of the \n8x8 array r. \n4.  The position of the upper-left sample of an 8x8 luma block with index luma8x8BlkIdx inside the macroblock is \nderived by invoking the inverse 8x8 luma block scanning process in clause 6.4.5 with luma8x8BlkIdx as the input \nand the output being assigned to ( xO, yO ). \n5.  The 8x8 array u with elements u  for i, j = 0..7 is derived as: \nij\nu  = Clip1 ( pred [ xO + j, yO + i ] + r  )     (8-303) \nij Y L ij\nWhen TransformBypassModeFlag is equal to 1, the bitstream shall not contain data that result in a value of u  as \nij\ncomputed by Equation 8-303 that is not equal to pred [ xO + j, yO + i ] + r . \nL ij\n6.  The  picture  construction  process  prior  to  deblocking  filter  process  in  clause 8.5.14  is  invoked  with  u  and \nluma8x8BlkIdx as the inputs. \n8.5.4  Specification of transform decoding process for chroma samples \nThis process is invoked for each chroma component Cb and Cr separately when ChromaArrayType is not equal to 0. \nDepending on ChromaArrayType, the following applies: \n–  If ChromaArrayType is equal to 3, the transform decoding process for chroma samples with ChromaArrayType equal \nto 3 as specified in clause 8.5.5 is invoked. \n–  Otherwise (ChromaArrayType is not equal to 3), the following text specifies the transform decoding process for \nchroma samples. \nFor each chroma component, the variables ChromaDCLevel[ iCbCr ] and ChromaACLevel[ iCbCr ], with iCbCr set equal \nto 0 for Cb and iCbCr set equal to 1 for Cr, contain the levels for both components of the chroma transform coefficients. \nLet the variable numChroma4x4Blks be set equal to (MbWidthC / 4) * (MbHeightC / 4). \nFor each chroma component, the transform decoding proceeds separately in the following ordered steps: \n1.  The numChroma4x4Blks chroma DC transform coefficients of the 4x4 chroma blocks of the component indexed \nby iCbCr of the macroblock are decoded as specified in the following ordered steps: \na.  Depending on the variable ChromaArrayType, the following applies: \n–  If ChromaArrayType is equal to 1, the 2x2 array c is derived using the inverse raster scanning process \napplied to ChromaDCLevel as follows: \nChromaDCLevel[iCbCr ][0] ChromaDCLevel[iCbCr ][1]\nc    (8-304) \n \nChromaDCLevel[iCbCr ][2] ChromaDCLevel[iCbCr ][3]\n \n–  Otherwise  (ChromaArrayType  is  equal  to 2),  the  2x4  array  c  is  derived  using  the  inverse  raster \nscanning process applied to ChromaDCLevel as follows: \nChromaDCLevel[iCbCr ][0] ChromaDCLevel[iCbCr ][2]\n \nChromaDCLevel[iCbCr ][1] ChromaDCLevel[iCbCr ][5]\n \nc    (8-305) \nChromaDCLevel[iCbCr ][3] ChromaDCLevel[iCbCr ][6]\n \nChromaDCLevel[iCbCr ][4] ChromaDCLevel[iCbCr ][7]\n \nb.  The scaling and transformation process for chroma DC transform coefficients as specified in clause 8.5.11 is \ninvoked with c as the input and dcC as the output. \n2.  The  (MbWidthC)x(MbHeightC)  array  rMb  is  derived  by  processing  the  4x4  chroma  blocks  indexed  by \nchroma4x4BlkIdx = 0..numChroma4x4Blks − 1 of the component indexed by iCbCr, and for each 4x4 chroma \nblock, the following ordered steps are specified: \na.  The variable chromaList, which is a list of 16 entries, is derived. The first entry of chromaList is the \ncorresponding value from the array dcC. Figure 8-7 shows the assignment of the indices of the array dcC to \n178  Rec. ITU-T H.264 (06/2019) \n \nthe chroma4x4BlkIdx. The two numbers in the small squares refer to indices i and j in dcC , and the numbers \nij\nin large squares refer to chroma4x4BlkIdx. \n \n00 01\n0 1\n10 11\n2 3\n00 01 20 21\n0 1 4 5\n10 11 30 31\n2 3 6 7\nH.264(09)_F8-7\na b  \nFigure 8-7 – Assignment of the indices of dcC to chroma4x4BlkIdx:  \n(a) ChromaArrayType equal to 1, (b) ChromaArrayType equal to 2 \nThe elements in chromaList with index k = 1..15 are specified as: \nchromaList[ k ] = ChromaACLevel[ chroma4x4BlkIdx ][ k − 1 ]   (8-306) \nb.  The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is \ninvoked with chromaList as the input and the two-dimensional array c as the output. \nc.  The scaling and transformation process for residual 4x4 blocks as specified in clause 8.5.12 is invoked with \nc as the input and r as the output. \nd.  The position of the upper-left sample of a 4x4 chroma block with index chroma4x4BlkIdx inside the current \nmacroblock is derived by invoking the inverse 4x4 chroma block scanning process as specified in clause 6.4.7 \nwith chroma4x4BlkIdx as the input and the output being assigned to ( xO, yO ). \ne.  The  elements  rMb[ x, y ]  of  the  (MbWidthC)x(MbHeightC)  array  rMb  with  x = xO..xO + 3  and \ny = yO..yO + 3 are derived by: \nrMb[ xO + j, yO + i ] = r     (8-307) \nij\n3.  When TransformBypassModeFlag is equal to 1, the macroblock prediction mode is equal to Intra_4x4, Intra_8x8, \nor Intra_16x16, and intra_chroma_pred_mode is equal to 1 or 2, the intra residual transform-bypass decoding \nprocess as specified in clause 8.5.15 is invoked with nW set equal to MbWidthC, nH set equal to MbHeightC, \nhorPredFlag set equal to (2 − intra_chroma_pred_mode), and the (MbWidthC)x(MbHeightC) array rMb as the \ninputs, and the output is a modified version of the (MbWidthC)x(MbHeightC) array rMb. \n4.  The (MbWidthC)x(MbHeightC) array u with elements u  for i = 0..MbHeightC − 1 and j = 0..MbWidthC − 1 is \nij\nderived as: \nu  = Clip1 ( pred [ j, i ] + rMb[ j, i ] )     (8-308) \nij C C\nWhen TransformBypassModeFlag is equal to 1, the bitstream shall not contain data that result in a value of u  as \nij\ncomputed by Equation 8-308 that is not equal to pred [ j, i ] + rMb[ j, i ]. \nC\n5.  The picture construction process prior to deblocking filter process in clause 8.5.14 is invoked with u as the input. \n    Rec. ITU-T H.264 (06/2019)  179 \n \n8.5.5  Specification of transform decoding process for chroma samples with ChromaArrayType equal to 3 \nThis process is invoked for each chroma component Cb and Cr separately when ChromaArrayType is equal to 3. \nDepending on the macroblock prediction mode and transform_size_8x8_flag, the following applies: \n–  If the macroblock prediction mode is equal to Intra_16x16, the transform decoding process for Cb or Cr residual \nblocks shall be identical to the process described in clause 8.5.2 when substituting luma with Cb or Cr, substituting \nIntra16x16DCLevel  with  CbIntra16x16DCLevel  or  CrIntra16x16DCLevel,  substituting  Intra16x16ACLevel  with \nCbIntra16x16ACLevel  or  CrIntra16x16ACLevel,  and  substituting  pred   with  pred   or  pred ,  substituting \nL Cb Cr\nluma4x4BlkIdx with cb4x4BlkIdx or cr4x4BlkIdx, substituting lumaList with CbList or CrList, substituting BitDepth  \nY\nwith BitDepth , substituting QP′  with QP′ , and substituting Clip1  with Clip1 . During the scaling of 4x4 block \nC Y C Y C\ntransform coefficient levels that is specified in clause 8.5.12.1, which is invoked as part of the process specified in \nclause 8.5.2, the input 4x4 array c is treated as relating to a luma residual block coded using an Intra_16x16 macroblock \nprediction mode. \n–  Otherwise, if transform_size_8x8_flag is equal to 1, the transform decoding process for 8x8 Cb or 8x8 Cr residual \nblocks shall be identical to the process described in clause 8.5.3 when substituting luma with Cb or Cr, substituting \nLumaLevel8x8 with CbLevel8x8 or CrLevel8x8, substituting pred  with pred  or pred , substituting luma8x8BlkIdx \nL Cb Cr\nwith cb8x8BlkIdx or cr8x8BlkIdx, and substituting Clip1  with Clip1 . \nY C\n–  Otherwise (the macroblock prediction mode is not equal to Intra_16x16 and transform_size_8x8_flag is equal to 0), \nthe transform decoding process for 4x4 Cb or 4x4 Cr residual blocks shall be identical to the process described in \nclause 8.5.1 when substituting luma with Cb or Cr, substituting LumaLevel4x4 with CbLevel4x4 or CrLevel4x4, \nsubstituting  pred   with  pred   or  pred ,  substituting  luma4x4BlkIdx  with  cb4x4BlkIdx  or  cr4x4BlkIdx,  and \nL Cb Cr\nsubstituting Clip1  with Clip1 . During the scaling of 4x4 block transform coefficient levels that is specified in \nY C\nclause 8.5.12.1, which is invoked as part of the process specified in clause 8.5.1, the input 4x4 array c is treated as \nrelating to a luma residual block not coded using an Intra_16x16 macroblock prediction mode. \n8.5.6  Inverse scanning process for 4x4 transform coefficients and scaling lists \nInput to this process is a list of 16 values. \nOutput of this process is a variable c containing a two-dimensional array of 4x4 values. In the case of transform coefficients, \nthese 4x4 values represent levels assigned to locations in the transform block. In the case of applying the inverse scanning \nprocess to a scaling list, the output variable c contains a two-dimensional array representing a 4x4 scaling matrix. \nWhen this clause is invoked with a list of transform coefficient levels as the input, the sequence of transform coefficient \nlevels is mapped to the transform coefficient level positions. Table 8-13 specifies the two mappings: inverse zig-zag scan \nand inverse field scan. The inverse zig-zag scan is used for transform coefficients in frame macroblocks and the inverse \nfield scan is used for transform coefficients in field macroblocks. \nWhen this clause is invoked with a scaling list as the input, the sequence of scaling list entries is mapped to the positions \nin the corresponding scaling matrix. For this mapping, the inverse zig-zag scan is used. \nFigure 8-8 illustrates the scans. \n0 1 5 6 0 2 8 12\n2 4 7 12 1 5 9 13\n3 8 11 13 3 6 10 14\n9 10 14 15 4 7 11 15\na b\n \nFigure 8-8 – 4x4 block scans. (a) Zig-zag scan. (b) Field scan (informative) \nTable 8-13 provides the mapping from the index idx of input list of 16 elements to indices i and j of the two-dimensional \narray c. \n180  Rec. ITU-T H.264 (06/2019) \n \nTable 8-13 – Specification of mapping of idx to c  for zig-zag and field scan \nij\nidx  0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15 \nzig-zag  c   c   c   c   c   c   c   c   c   c   c   c   c   c   c   c  \n00 01 10 20 11 02 03 12 21 30 31 22 13 23 32 33\nfield  c   c   c   c   c   c   c   c   c   c   c   c   c   c   c   c  \n00 10 01 20 30 11 21 31 02 12 22 32 03 13 23 33\n \n8.5.7  Inverse scanning process for 8x8 transform coefficients and scaling lists \nInput to this process is a list of 64 values. \nOutput of this process is a variable c containing a two-dimensional array of 8x8 values. In the case of transform coefficients, \nthese 8x8 values represent levels assigned to locations in the transform block. In the case of applying the inverse scanning \nprocess to a scaling list, the output variable c contains a two-dimensional array representing an 8x8 scaling matrix. \nWhen this clause is invoked with a list of transform coefficient levels as the input, the sequence of transform coefficient \nlevels is mapped to the transform coefficient level positions. Table 8-14 specifies the two mappings: inverse 8x8 zig-zag \nscan and inverse 8x8 field scan. The inverse 8x8 zig-zag scan is used for transform coefficient levels in frame macroblocks \nand the inverse 8x8 field scan is used for transform coefficient levels in field macroblocks. \nWhen this clause is invoked with a scaling list as the input, the sequence of scaling list entries is mapped to the positions \nin the corresponding scaling matrix. For this mapping, the inverse zig-zag scan is used. \nFigure 8-9 illustrates the scans. \n0 1 5 6 14 15 27 28 0 3 8 15 22 30 38 52\n2 4 7 13 16 26 29 42 1 4 14 21 29 37 45 53\n3 8 12 17 25 30 41 43 2 7 16 23 31 39 46 58\n9 11 18 24 31 40 44 53 5 9 20 28 36 44 51 59\n10 19 23 32 39 45 52 54 6 13 24 32 40 47 54 60\n20 22 33 38 51 55 60 10 17 25 33 41 48 55 61\n21 34 37 47 50 56 59 61 11 18 26 34 42 49 56 62\n35 36 48 49 57 58 62 63 12 19 27 35 43 50 57 63\nH.264(09)_F8-9\na b  \nFigure 8-9 – 8x8 block scans. (a) 8x8 zig-zag scan. (b) 8x8 field scan (informative) \nTable 8-14 provides the mapping from the index idx of the input list of 64 elements to indices i and j of the two-dimensional \narray c. \n    Rec. ITU-T H.264 (06/2019)  181 \n \nTable 8-14 – Specification of mapping of idx to c  for 8x8 zig-zag and 8x8 field scan \nij\nidx  0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15 \nzig-zag  c   c   c   c   c   c   c   c   c   c   c   c   c   c   c   c  \n00 01 10 20 11 02 03 12 21 30 40 31 22 13 04 05\nfield  c   c   c   c   c   c   c   c   c   c   c   c   c   c   c   c  \n00 10 20 01 11 30 40 21 02 31 50 60 70 41 12 03\nTable 8-14 (continued) – Specification of mapping of idx to cij for 8x8 zig-zag and 8x8 field scan \nidx  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31 \nzig-zag  c   c   c   c   c   c   c   c   c   c   c   c   c   c   c   c  \n14 23 32 41 50 60 51 42 33 24 15 06 07 16 25 34\nfield  c   c   c   c   c   c   c   c   c   c   c   c   c   c   c   c  \n22 51 61 71 32 13 04 23 42 52 62 72 33 14 05 24\nTable 8-14 (continued) – Specification of mapping of idx to cij for 8x8 zig-zag and 8x8 field scan \nidx  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47 \nzig-zag  c   c   c   c   c   c   c   c   c   c   c   c   c   c   c   c  \n43 52 61 70 71 62 53 44 35 26 17 27 36 45 54 63\nfield  c   c   c   c   c   c   c   c   c   c   c   c   c   c   c   c  \n43 53 63 73 34 15 06 25 44 54 64 74 35 16 26 45\nTable 8-14 (concluded) – Specification of mapping of idx to cij for 8x8 zig-zag and 8x8 field scan \nidx  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63 \nzig-zag  c   c   c   c   c   c   c   c   c   c   c   c   c   c   c   c  \n72 73 64 55 46 37 47 56 65 74 75 66 57 67 76 77\nfield  c   c   c   c   c   c   c   c   c   c   c   c   c   c   c   c  \n55 65 75 36 07 17 46 56 66 76 27 37 47 57 67 77\n \n8.5.8  Derivation process for chroma quantization parameters \nOutputs of this process are: \n–  QP : the chroma quantization parameter for each chroma component Cb and Cr, \nC\n–  QS : the additional chroma quantization parameter for each chroma component Cb and Cr required for decoding SP \nC\nand SI slices (if applicable). \nNOTE 1 – QP quantization parameter values QP  and QS  are always in the range of −QpBdOffset  to 51, inclusive. QP \nY Y Y\nquantization parameter values QP  and QS  are always in the range of −QpBdOffset  to 39, inclusive. \nC C C\nThe  value  of  QP   for  a  chroma  component  is  determined  from  the  current  value  of  QP   and  the  value  of \nC Y\nchroma_qp_index_offset (for Cb) or second_chroma_qp_index_offset (for Cr). \nNOTE 2 – The scaling equations are specified such that the equivalent transform coefficient level scaling factor doubles for every \nincrement of 6 in QP . Thus, there is an increase in the factor used for scaling of approximately 12 % for each increase of 1 in the \nY\nvalue of QP . \nY\nThe value of QP  for each chroma component is determined as specified in Table 8-15 based on the index denoted as qP . \nC I\nThe variable qP  for each chroma component is derived as follows: \nOffset\n–  If the chroma component is the Cb component, qP  is specified as: \nOffset\nqP  = chroma_qp_index_offset    (8-309) \nOffset\n–  Otherwise (the chroma component is the Cr component), qP  is specified as: \nOffset\nqP  = second_chroma_qp_index_offset    (8-310) \nOffset\nThe value of qP  for each chroma component is derived as: \nI\nqP  = Clip3( −QpBdOffset , 51, QP  + qP  )    (8-311) \nI C Y Offset\n182  Rec. ITU-T H.264 (06/2019) \n \nThe value of QP′  for the chroma components is derived as: \nC\nQP′  = QP  + QpBdOffset     (8-312) \nC C C\nTable 8-15 – Specification of QP  as a function of qP  \nC I\nqP   <30  3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 5 5\nI\n0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1 \nQP = qP 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n    9  0  1  2  2  3  4  4  5  5  6  6  7  7  7  8  8  8  9  9  9  9 \nC I\n \nWhen the current slice is an SP or SI slice, QS  is derived using the above process, substituting QP  with QS  and QP  \nC Y Y C\nwith QS . \nC\n8.5.9  Derivation process for scaling functions \nOutputs of this process are: \n–  LevelScale4x4: the scaling factor for 4x4 block transform luma or chroma coefficient levels, \n–  LevelScale8x8: the scaling factor for 8x8 block transform luma or chroma coefficient levels. \nThe variable mbIsInterFlag is derived as follows: \n–  If the current macroblock is coded using Inter macroblock prediction modes, mbIsInterFlag is set equal to 1. \n–  Otherwise (the current macroblock is coded using Intra macroblock prediction modes), mbIsInterFlag is set equal \nto 0. \nThe variable iYCbCr derived as follows: \n–  If separate_colour_plane_flag is equal to 1, iYCbCr is set equal to colour_plane_id. \n–  Otherwise (separate_colour_plane_flag is equal to 0), the following applies: \n–  If the scaling function LevelScale4x4 or LevelScale8x8 is derived for a luma residual block, iYCbCr is set equal \nto 0. \n–  Otherwise, if the scaling function LevelScale4x4 or LevelScale8x8 is derived for a chroma residual block and \nthe chroma component is equal to Cb, iYCbCr is set equal to 1. \n–  Otherwise (the scaling function LevelScale4x4 or LevelScale8x8 is derived for a chroma residual block and the \nchroma component is equal to Cr), iYCbCr is set equal to 2. \nThe inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is invoked with \nScalingList4x4[ iYCbCr + ( (mbIsInterFlag  = =  1 ) ? 3 : 0 )] as the input and the output is assigned to the 4x4 matrix \nweightScale4x4. \nLevelScale4x4( m, i, j ) is specified by: \nLevelScale4x4( m, i, j ) = weightScale4x4( i, j ) * normAdjust4x4( m, i, j )  (8-313) \nwhere \nv for ( i % 2, j % 2 ) equal to (0,0),\nm0\n\n \nnormAdjust4x4 m,i, j  v for ( i % 2, j % 2 ) equal to (1,1),   (8-314) \nm1\n\nv otherwise;\n\nm2\nwhere the first and second subscripts of v are row and column indices, respectively, of the matrix specified as: \n10 16 13\n \n11 18 14\n \n13 20 16\nv    .    (8-315) \n14 23 18\n \n \n16 25 20\n \n 18 29 23\n    Rec. ITU-T H.264 (06/2019)  183 \n \nThe inverse scanning process for 8x8 transform coefficients and scaling lists as specified in clause 8.5.7 is invoked with \nScalingList8x8[ 2 * iYCbCr + mbIsInterFlag ] as the input and the output is assigned to the 8x8 matrix weightScale8x8. \nLevelScale8x8( m, i, j ) is specified by: \nLevelScale8x8( m, i, j ) = weightScale8x8( i, j ) * normAdjust8x8( m, i, j )  (8-316) \nwhere \nv for (i % 4, j % 4) equal to (0,0),\nm0\n\nv for (i % 2, j % 2) equal to (1,1),\n m1\n v for (i % 4, j % 4) equal to (2,2),\nnormAdjust8x8  m,i, j    m2   (8-317) \nv for (i % 4, j % 2) equal to (0,1) or (i % 2, j % 4) equal to (1,0),\n m3\nv for (i % 4, j % 4) equal to (0,2) or (i % 4, j % 4) equal to (2,0),\nm4\n\nv otherwise;\n\nm5\nwhere the first and second subscripts of v are row and column indices, respectively, of the matrix specified as: \n20 18 32 19 25 24\n \n22 19 35 21 28 26\n \n26 23 42 24 33 31\nv    .    (8-318) \n28 25 45 26 35 33\n \n \n32 28 51 30 40 38\n \n 36 32 58 34 46 43\n8.5.10  Scaling and transformation process for DC transform coefficients for Intra_16x16 macroblock type \nInputs to this process are: \n–  the variables bitDepth and qP, \n–  transform coefficient level values for DC transform coefficients of Intra_16x16 macroblocks as a 4x4 array c with \nelements c , where i and j form a two-dimensional frequency index. \nij\nOutputs of this process are 16 scaled DC values for 4x4 blocks of Intra_16x16 macroblocks as a 4x4 array dcY with \nelements dcY . \nij\nDepending on the value of TransformBypassModeFlag, the following applies: \n–  If TransformBypassModeFlag is equal to 1, the output dcY is derived as: \ndcY  = c   with  i, j = 0..3    (8-319) \nij ij\n–  Otherwise (TransformBypassModeFlag is equal to 0), the following text of this process specifies the output. \nThe inverse transform for the 4x4 luma DC transform coefficients is specified by: \n1 1 1 1 c c c c  1 1 1 1\n00 01 02 03\n     \n1 1 1 1 c c c c 1 1 1 1\nf      10 11 12 13    .  (8-320) \n1 1 1 1 c c c c  1 1 1 1\n20 21 22 23\n     \n1 1 1 1 c c c c 1 1 1 1\n     \n30 31 32 33\nThe bitstream shall not contain data that result in any element f  of f with i, j = 0..3 that exceeds the range of integer values \nij\nfrom −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nAfter the inverse transform, the scaling is performed as follows: \n–  If qP is greater than or equal to 36, the scaled result is derived as: \ndcY  = ( f  * LevelScale4x4( qP % 6, 0, 0 ) ) << ( qP / 6 − 6 ),    with  i, j = 0...3  (8-321) \nij ij\n184  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (qP is less than 36), the scaled result is derived as: \ndcY  = ( f  * LevelScale4x4( qP % 6, 0, 0 ) + ( 1 << ( 5 − qP / 6) ) ) >> ( 6 − qP / 6 ),    with  i, j = 0...3  (8-322) \nij ij\nThe bitstream shall not contain data that result in any element dcY  of dcY with i, j = 0..3 that exceeds the range of integer \nij\nvalues from −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nNOTE 1 – When entropy_coding_mode_flag is equal to 0 and qP is less than 10 and profile_idc is equal to 66, 77, or 88, the range \nof values that can be represented for the elements c  of c is not sufficient to represent the full range of values of the elements dcY  \nij ij\nof dcY that could be necessary to form a close approximation of the content of any possible source picture by use of the Intra_16x16 \nmacroblock type. \nNOTE 2 – Since the range limit imposed on the elements dcY  of dcY is imposed after the right shift in Equation 8-322, a larger \nij\nrange of values must be supported in the decoder prior to the right shift. \n8.5.11  Scaling and transformation process for chroma DC transform coefficients \nThis process is only invoked when ChromaArrayType is equal to 1 or 2. \nInputs to this process are transform coefficient level values for chroma DC transform coefficients of one chroma component \nof the macroblock as an (MbWidthC / 4)x(MbHeightC / 4) array c with elements c , where i and j form a two-dimensional \nij\nfrequency index. \nOutputs of this process are the scaled DC values as an (MbWidthC / 4)x(MbHeightC / 4) array dcC with elements dcC . \nij\nThe variables bitDepth and qP are set equal to BitDepth  and QP′ , respectively. \nC C\nDepending on the value of TransformBypassModeFlag, the following applies: \n–  If TransformBypassModeFlag is equal to 1, the output dcC is derived as: \ndcC  = c   with  i = 0..( MbWidthC / 4 )  1 and j = 0..( MbHeightC / 4 )  1.  (8-323) \nij ij\n–  Otherwise (TransformBypassModeFlag is equal to 0), the following ordered steps are specified: \n1.  The transformation process for chroma DC transform coefficients as specified in clause 8.5.11.1 is invoked \nwith bitDepth and c as the inputs and the output is assigned to the (MbWidthC / 4)x(MbHeightC / 4) array f of \nchroma DC values with elements f . \nij\n2.  The scaling process for chroma DC transform coefficients as specified in clause 8.5.11.2 is invoked with \nbitDepth, qP, and f as the inputs and the output is assigned to the (MbWidthC / 4)x(MbHeightC / 4) array dcC \nof scaled chroma DC values with elements dcC . \nij\n8.5.11.1  Transformation process for chroma DC transform coefficients \nInputs  of  this  process  are  transform  coefficient  level  values  for  chroma  DC  transform  coefficients  of  one  chroma \ncomponent of the macroblock as an (MbWidthC / 4)x(MbHeightC / 4) array c with elements c , where i and j form a two-\nij\ndimensional frequency index. \nOutputs of this process are the DC values as an (MbWidthC / 4)x(MbHeightC / 4) array f with elements f . \nij\nDepending on the variable ChromaArrayType, the inverse transform is specified as follows: \n–  If ChromaArrayType is equal to 1, the inverse transform for the 2x2 chroma DC transform coefficients is specified \nas: \n1 1 c c  1 1\nf   00 01      (8-324) \n     \n1 1 c c 1 1\n     \n10 11\n–  Otherwise, (ChromaArrayType is equal to 2), the inverse transform for the 2x4 chroma DC transform coefficients is \nspecified as: \n1 1 1 1 c c \n00 01\n   \n1 1 1 1 c c 1 1\nf      10 11      (8-325) \n \n1 1 1 1 c c  1 1\n \n20 21\n   \n1 1 1 1 c c\n   \n30 31\n8.5.11.2  Scaling process for chroma DC transform coefficients \nInputs of this process are: \n    Rec. ITU-T H.264 (06/2019)  185 \n \n–  the variables bitDepth and qP, \n–  DC values as an (MbWidthC / 4)x(MbHeightC / 4) array f with elements f  \nij.\nOutputs of this process are scaled DC values as an (MbWidthC / 4)x(MbHeightC / 4) array dcC with elements dcC . \nij\nThe bitstream shall not contain data that result in any element f  of f with i, j = 0..3 that exceeds the range of integer values \nij\nfrom −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nScaling is performed depending on the variable ChromaArrayType as follows: \n–  If ChromaArrayType is equal to 1, the scaled result is derived as: \ndcC  ( ( f * LevelScale4x4( qP % 6, 0, 0 ) )  ( qP/ 6) )  5, with i, j 0, 1  (8-326) \nij ij\n–  Otherwise (ChromaArrayType is equal to 2), the following ordered steps are specified: \n1.  The variable qP  is derived as: \nDC\nqP  = qP + 3    (8-327) \nDC\n2.  Depending on the value of qP , the following applies: \nDC\n–  If qP  is greater than or equal to 36, the scaled result is derived as: \nDC\ndcC ( f *LevelScale4x4 ( qP %6, 0, 0 ) ) ( qP  / 6 6 ),  \nwith i = 0..3, j = 0, 1  (8-328) \nij ij DC DC\n–  Otherwise (qP  is less than 36), the scaled result is derived as: \nDC\ndcC  ( f *LevelScale4x4( qP  % 6, 0, 0 )25qP DC /6 )  ( 6 qP  / 6 ),  with  i  0..3, j 0,1  \nij ij DC DC\n    (8-329) \nThe bitstream shall not contain data that result in any element dcC  of dcC with i, j = 0..3 that exceeds the range of integer \nij\nvalues from −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nNOTE 1 – When entropy_coding_mode_flag is equal to 0 and qP is less than 4 and profile_idc is equal to 66, 77, or 88, the range \nof values that can be represented for the elements c  of c in clause 8.5.11.1 may not be sufficient to represent the full range of values \nij\nof the elements dcC  of dcC that could be necessary to form a close approximation of the content of any possible source picture. \nij\nNOTE 2 – Since the range limit imposed on the elements dcC  of dcC is imposed after the right shift in Equation 8-326 or 8-329, \nij\na larger range of values must be supported in the decoder prior to the right shift. \n8.5.12  Scaling and transformation process for residual 4x4 blocks \nInput to this process is a 4x4 array c with elements c  which is either an array relating to a residual block of the luma \nij\ncomponent or an array relating to a residual block of a chroma component. \nOutputs of this process are residual sample values as 4x4 array r with elements r . \nij\nThe variable bitDepth is derived as follows: \n–  If the input array c relates to a luma residual block, bitDepth is set equal to BitDepth . \nY\n–  Otherwise (the input array c relates to a chroma residual block), bitDepth is set equal to BitDepth . \nC\nThe variable sMbFlag is derived as follows: \n–  If mb_type is equal to SI or the macroblock prediction mode is equal to Inter in an SP slice, sMbFlag is set equal to 1, \n–  Otherwise (mb_type not equal to SI and the macroblock prediction mode is not equal to Inter in an SP slice), sMbFlag \nis set equal to 0. \nThe variable qP is derived as follows: \n–  If the input array c relates to a luma residual block and sMbFlag is equal to 0, \nqP = QP′        (8-330) \nY\n–  Otherwise, if the input array c relates to a luma residual block and sMbFlag is equal to 1, \nqP = QS        (8-331) \nY\n–  Otherwise, if the input array c relates to a chroma residual block and sMbFlag is equal to 0, \n186  Rec. ITU-T H.264 (06/2019) \n \nqP = QP′        (8-332) \nC\n–  Otherwise (the input array c relates to a chroma residual block and sMbFlag is equal to 1), \nqP = QS       (8-333) \nC\nDepending on the value of TransformBypassModeFlag, the following applies: \n–  If TransformBypassModeFlag is equal to 1, the output r is derived as: \nr  = c   with  i, j = 0..3    (8-334) \nij ij\n–  Otherwise (TransformBypassModeFlag is equal to 0), the following ordered steps are specified: \n1.  The scaling process for residual 4x4 blocks as specified in clause 8.5.12.1 is invoked with bitDepth, qP, and c \nas the inputs and the output is assigned to the 4x4 array d of scaled transform coefficients with elements d . \nij\n2.  The transformation process for residual 4x4 blocks as specified in clause 8.5.12.2 is invoked with bitDepth and \nd as the inputs and the output is assigned to the 4x4 array r of residual sample values with elements r . \nij\n8.5.12.1  Scaling process for residual 4x4 blocks \nInputs of this process are: \n–  the variables bitDepth and qP, \n–  a 4x4 array c with elements c  which is either an array relating to a residual block of luma component or an array \nij\nrelating to a residual block of a chroma component. \nOutput of this process is a 4x4 array of scaled transform coefficients d with elements d . \nij\nThe bitstream shall not contain data that result in any element c  of c with i, j = 0..3 that exceeds the range of integer values \nij\nfrom −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nScaling of 4x4 block transform coefficient levels c  proceeds as follows: \nij\n–  If all of the following conditions are true: \n–  i is equal to 0, \n–  j is equal to 0, \n–  c relates to a luma residual block coded using Intra_16x16 macroblock prediction mode or c relates to a chroma \nresidual block. \nthe variable d  is derived by \n00\nd  = c      (8-335) \n00 00\n–  Otherwise, the following applies: \n–  If qP is greater than or equal to 24, the scaled result is derived as \nd  = ( c  * LevelScale4x4( qP % 6, i, j) ) << ( qP / 6 − 4), with i, j = 0..3 except as noted above  (8-336) \nij ij\n–  Otherwise (qP is less than 24), the scaled result is derived as \nd  ( c * LevelScale4x4( qP % 6, i, j )23qP/6)  ( 4qP / 6 ),  with i, j 0..3 except as noted above\n (8-337) \nij ij\nThe bitstream shall not contain data that result in any element d  of d with i, j = 0..3 that exceeds the range of integer values \nij\nfrom −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \n8.5.12.2  Transformation process for residual 4x4 blocks \nInputs of this process are: \n–  the variable bitDepth, \n–  a 4x4 array of scaled transform coefficients d with elements d  \nij.\nOutputs of this process are residual sample values as 4x4 array r with elements r . \nij\n    Rec. ITU-T H.264 (06/2019)  187 \n \nThe bitstream shall not contain data that result in any element d  of d with i, j = 0..3 that exceeds the range of integer values \nij\nfrom −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nThe transform process shall convert the block of scaled transform coefficients to a block of output samples in a manner \nmathematically equivalent to the following. \nFirst, each (horizontal) row of scaled transform coefficients is transformed using a one-dimensional inverse transform as \nfollows. \nA set of intermediate values is computed as follows: \ne  = d  + d ,   with   i = 0..3    (8-338) \ni0 i0 i2\ne  = d  − d ,   with   i = 0..3    (8-339) \ni1 i0 i2\ne  = ( d  >> 1 ) − d ,   with   i = 0..3    (8-340) \ni2 i1 i3\ne  = d  + ( d  >> 1 ),   with   i = 0..3    (8-341) \ni3 i1 i3\nThe bitstream shall not contain data that result in any element e  of e with i, j = 0..3 that exceeds the range of integer values \nij\nfrom −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nThen, the transformed result is computed from these intermediate values as follows: \nf  = e  + e ,   with   i = 0..3    (8-342) \ni0 i0 i3\nf  = e  + e ,   with   i = 0..3    (8-343) \ni1 i1 i2\nf  = e  − e ,   with   i = 0..3    (8-344) \ni2 i1 i2\nf  = e  − e ,   with   i = 0..3    (8-345) \ni3 i0 i3\nThe bitstream shall not contain data that result in any element f  of f with i, j = 0..3 that exceeds the range of integer values \nij\nfrom −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nThen, each (vertical) column of the resulting matrix is transformed using the same one-dimensional inverse transform as \nfollows. \nA set of intermediate values is computed as follows: \ng  = f  + f ,   with   j = 0..3    (8-346) \n0j 0j 2j\ng  = f  − f ,   with   j = 0..3    (8-347) \n1j 0j 2j\ng  = ( f  >> 1 ) − f ,   with   j = 0..3    (8-348) \n2j 1j 3j\ng  = f  + ( f  >> 1 ),   with   j = 0..3    (8-349) \n3j 1j 3j\nThe bitstream shall not contain data that result in any element g  of g with i, j = 0..3 that exceeds the range of integer values \nij\nfrom −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nThen, the transformed result is computed from these intermediate values as follows: \nh  = g  + g ,   with   j = 0..3    (8-350) \n0j 0j 3j\nh  = g  + g ,   with   j = 0..3    (8-351) \n1j 1j 2j\nh  = g  − g ,   with   j = 0..3    (8-352) \n2j 1j 2j\nh  = g  − g ,   with   j = 0..3    (8-353) \n3j 0j 3j\nThe bitstream shall not contain data that result in any element h  of h with i, j = 0..3 that exceeds the range of integer values \nij\nfrom −2(7 + bitDepth) to 2(7 + bitDepth) − 33, inclusive. \nAfter performing both the one-dimensional horizontal and the one-dimensional vertical inverse transforms to produce an \narray of transformed samples, the final constructed residual sample values is derived as: \n188  Rec. ITU-T H.264 (06/2019) \n \nr  ( h  25 )  6\n   with   i, j = 0..3    (8-354) \nij ij\n8.5.13  Scaling and transformation process for residual 8x8 blocks \nInput to this process is an 8x8 array c with elements c  which is either an array relating to an 8x8 residual block of the \nij\nluma component or, when ChromaArrayType is equal to 3, an array relating to an 8x8 residual block of a chroma \ncomponent. \nNOTE 1 – When separate_colour_plane_flag is equal to 1, all residual blocks are considered to be associated with the luma \ncomponent for purposes of the decoding process of each coded picture (prior to the final assignment of the decoded picture to a \nparticular luma or chroma picture array according to the value of colour_plane_id). \nOutputs of this process are residual sample values as 8x8 array r with elements r . \nij\nThe variables bitDepth and qP are derived as follows: \n–  If the input array c relates to a luma residual block, bitDepth is set equal to BitDepth  and qP is set equal to QP′ . \nY Y\n–  Otherwise (the input array c relates to a chroma residual block), bitDepth is set equal to BitDepth  and qP is set equal \nC\nto QP′ . \nC\nNOTE 2 – When separate_colour_plane_flag is equal to 1, all residual blocks are considered to be associated with the luma \ncomponent for purposes of the decoding process of each colour component of a picture. \nDepending on the value of TransformBypassModeFlag, the following applies: \n–  If TransformBypassModeFlag is equal to 1, the output r is derived as \nr  = c   with  i, j = 0..7    (8-355) \nij ij\n–  Otherwise (TransformBypassModeFlag is equal to 0), the following ordered steps are specified: \n1.  The scaling process for residual 8x8 blocks as specified in clause 8.5.13.1 is invoked with bitDepth, qP, and \nc as the inputs and the output is assigned to the 8x8 array d of scaled transform coefficients with elements d . \nij\n2.  The transformation process for residual 8x8 blocks as specified in clause 8.5.13.2 is invoked with bitDepth \nand d as the inputs and the output is assigned to the 8x8 array r of residual sample values with elements r . \nij\n8.5.13.1  Scaling process for residual 8x8 blocks \nInputs of this process are: \n–  the variables bitDepth and qP, \n–  an 8x8 array c with elements c  which is either an array relating to a residual block of luma component or an array \nij\nrelating to a residual block of a chroma component. \nOutput of this process is an 8x8 array of scaled transform coefficients d with elements d . \nij\nThe bitstream shall not contain data that result in any element c  of c with i, j = 0..7 that exceeds the range of integer values \nij\nfrom −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nThe scaling process for 8x8 block transform coefficient levels c  proceeds as follows: \nij\n–  If qP is greater than or equal to 36, the scaled result is derived as: \nd  = (c  * LevelScale8x8( qP % 6, i, j) ) << ( qP / 6 − 6), with i, j = 0..7  (8-356) \nij ij\n–  Otherwise (qP is less than 36), the scaled result is derived as: \nd  = (c  * LevelScale8x8( qP % 6, i, j) ) + 25−qP/6) >> ( 6 − qP /6), with i, j = 0..7  (8-357) \nij ij\nThe bitstream shall not contain data that result in any element d  of d with i, j = 0..7 that exceeds the range of integer values \nij\nfrom −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \n8.5.13.2  Transformation process for residual 8x8 blocks \nInputs of this process are: \n–  the variable bitDepth, \n–  an 8x8 array of scaled transform coefficients d with elements d . \nij\nOutputs of this process are residual sample values as 8x8 array r with elements r . \nij\n    Rec. ITU-T H.264 (06/2019)  189 \n \nThe bitstream shall not contain data that result in any element d  of d with i, j = 0..7 that exceeds the range of integer values \nij\nfrom −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nThe transform process shall convert the block of scaled transform coefficients to a block of output samples in a manner \nmathematically equivalent to the following. \nFirst, each (horizontal) row of scaled transform coefficients is transformed using a one-dimensional inverse transform as \nfollows: \n–  A set of intermediate values e  is derived by: \nij\ne  = d  + d ,  with  i = 0..7    (8-358) \ni0 i0 i4\ne  = − d  + d  − d  − (d  >> 1),  with  i = 0..7    (8-359) \ni1 i3 i5 i7 i7\ne  = d  − d ,  with  i = 0..7    (8-360) \ni2 i0 i4\ne  = d  + d  − d  − (d  >> 1),  with  i = 0..7    (8-361) \ni3 i1 i7 i3 i3\ne  = ( d  >> 1 ) − d ,  with  i = 0..7    (8-362) \ni4 i2 i6\ne  = − d  + d  + d  + (d  >> 1),  with  i = 0..7    (8-363) \ni5 i1 i7 i5 i5\ne  = d  + ( d  >> 1 ),  with  i = 0..7    (8-364) \ni6 i2 i6\ne  = d  + d  + d  + (d  >> 1),  with  i = 0..7    (8-365) \ni7 i3 i5 i1 i1\n–  A second set of intermediate results f  is computed from the intermediate values e  as: \nij ij\nf  = e  + e ,  with  i = 0..7    (8-366) \ni0 i0 i6\nf  = e  + (e  >> 2),  with  i = 0..7    (8-367) \ni1 i1 i7\nf  = e  + e ,  with  i = 0..7    (8-368) \ni2 i2 i4\nf  = e  + (e  >> 2),  with   i = 0..7    (8-369) \ni3 i3 i5\nf  = e  − e ,  with  i = 0..7    (8-370) \ni4 i2 i4\nf  = (e  >> 2) − e ,  with   i = 0..7    (8-371) \ni5 i3 i5\nf  = e  − e ,  with  i = 0..7    (8-372) \ni6 i0 i6\nf  = e  − (e  >> 2),  with  i = 0..7    (8-373) \ni7 i7 i1\n–  Then, the transformed result g  is computed from these intermediate values f  as: \nij ij\ng  = f  + f ,  with  i = 0..7    (8-374) \ni0 i0 i7\ng  = f  + f ,  with  i = 0..7    (8-375) \ni1 i2 i5\ng  = f  + f ,  with  i = 0..7    (8-376) \ni2 i4 i3\ng  = f  + f ,  with  i = 0..7    (8-377) \ni3 i6 i1\ng  = f  − f ,  with  i = 0..7    (8-378) \ni4 i6 i1\ng  = f  − f ,  with  i = 0..7    (8-379) \ni5 i4 i3\ng  = f  − f ,  with  i = 0..7    (8-380) \ni6 i2 i5\ng  = f  − f ,  with  i = 0..7    (8-381) \ni7 i0 i7\n190  Rec. ITU-T H.264 (06/2019) \n \nThen, each (vertical) column of the resulting matrix is transformed using the same one-dimensional inverse transform as \nfollows: \n–  A set of intermediate values h  is computed from the horizontally transformed value g  as: \nij ij\nh  = g  + g ,  with  j = 0..7    (8-382) \n0j 0j 4j\nh  = − g  + g  − g  − (g  >> 1),  with  j = 0..7    (8-383) \n1j 3j 5j 7j 7j\nh  = g  − g ,  with  j = 0..7    (8-384) \n2j 0j 4j\nh  = g  + g  − g  − (g  >> 1),  with  j = 0..7    (8-385) \n3j 1j 7j 3j 3j\nh  = ( g  >> 1 ) − g ,  with  j = 0..7    (8-386) \n4j 2j 6j\nh  = − g  + g  + g  + (g  >> 1),  with  j = 0..7    (8-387) \n5j 1j 7j 5j 5j\nh  = g  + ( g  >> 1 ),  with  j = 0..7    (8-388) \n6j 2j 6j\nh  = g  + g  + g  + (g  >> 1),  with  j = 0..7    (8-389) \n7j 3j 5j 1j 1j\n–  A second set of intermediate results k  is computed from the intermediate values h  as: \nij ij\nk  = h  + h ,  with  j = 0..7    (8-390) \n0j 0j 6j\nk  = h  + (h  >> 2),  with  j = 0..7    (8-391) \n1j 1j 7j\nk  = h  + h ,  with  j = 0..7    (8-392) \n2j 2j 4j\nk  = h  + (h  >> 2),  with  j = 0..7    (8-393) \n3j 3j 5j\nk  = h  − h ,  with  j = 0..7    (8-394) \n4j 2j 4j\nk  = (h  >> 2) − h ,  with  j = 0..7    (8-395) \n5j 3j 5j\nk  = h  − h ,  with  j = 0..7    (8-396) \n6j 0j 6j\nk  = h  − (h  >> 2),  with  j = 0..7    (8-397) \n7j 7j 1j\n–  Then, the transformed result m  is computed from these intermediate values k  as: \nij ij\nm  = k  + k ,  with  j = 0..7    (8-398) \n0j 0j 7j\nm  = k  + k ,  with  j = 0..7    (8-399) \n1j 2j 5j\nm  = k  + k ,  with  j = 0..7    (8-400) \n2j 4j 3j\nm  = k  + k ,  with  j = 0..7    (8-401) \n3j 6j 1j\nm  = k  − k ,  with  j = 0..7    (8-402) \n4j 6j 1j\nm  = k  − k ,  with  j = 0..7    (8-403) \n5j 4j 3j\nm  = k  − k ,  with  j = 0..7    (8-404) \n6j 2j 5j\nm  = k  − k ,  with  j = 0..7    (8-405) \n7j 0j 7j\nThe bitstream shall not contain data that result in any element e , f , g , h , or k  for i and j in the range of 0..7, inclusive, \nij ij ij ij ij\nthat exceeds the range of integer values from −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nThe bitstream shall not contain data that result in any element m  for i and j in the range of 0..7, inclusive, that exceeds the \nij\nrange of integer values from −2(7 + bitDepth) to 2(7 + bitDepth) − 33, inclusive. \n    Rec. ITU-T H.264 (06/2019)  191 \n \nAfter performing both the one-dimensional horizontal and the one-dimensional vertical inverse transforms to produce an \narray of transformed samples, the final constructed residual sample values are derived as \nr  = ( m  + 25 ) >> 6  with  i, j = 0..7    (8-406) \nij ij\n8.5.14  Picture construction process prior to deblocking filter process \nInputs to this process are: \n–  a sample array u with elements u  which is a 16x16 luma block or an (MbWidthC)x(MbHeightC) chroma block or a \nij\n4x4 luma block or a 4x4 chroma block or an 8x8 luma block or, when ChromaArrayType is equal to 3, an 8x8 chroma \nblock, \n–  when u is not a 16x16 luma block or an (MbWidthC)x(MbHeightC) chroma block, a block index luma4x4BlkIdx or \nchroma4x4BlkIdx or luma8x8BlkIdx or cb4x4BlkIdx or cr4x4BlkIdx or cb8x8BlkIdx or cr8x8BlkIdx. \nThe position of the upper-left luma sample of the current macroblock is derived by invoking the inverse macroblock \nscanning process in clause 6.4.1 with CurrMbAddr as input and the output being assigned to ( xP, yP ). \nWhen u is a luma block, for each sample u  of the luma block, the following ordered steps are specified: \nij\n1.  Depending on the size of the block u, the following applies: \n–  If u is a 16x16 luma block, the position ( xO, yO ) of the upper-left sample of the 16x16 luma block inside \nthe macroblock is set equal to ( 0, 0 ) and the variable nE is set equal to 16. \n–  Otherwise, if u is an 4x4 luma block, the position of the upper-left sample of the 4x4 luma block with index \nluma4x4BlkIdx inside the macroblock is derived by invoking the inverse 4x4 luma block scanning process \nin clause 6.4.3 with luma4x4BlkIdx as the input and the output being assigned to ( xO, yO ), and the variable \nnE is set equal to 4. \n–  Otherwise (u is an 8x8 luma block), the position of the upper-left sample of the 8x8 luma block with index \nluma8x8BlkIdx inside the macroblock is derived by invoking the inverse 8x8 luma block scanning process \nin clause 6.4.5 with luma8x8BlkIdx as the input and the output being assigned to ( xO, yO ), and the variable \nnE is set equal to 8. \n2.  Depending on the variable MbaffFrameFlag and the current macroblock, the following applies: \n–  If MbaffFrameFlag is equal to 1 and the current macroblock is a field macroblock, \nS′ [ xP + xO + j, yP + 2 * ( yO + i ) ] = u    with i, j = 0..nE  1  (8-407) \nL ij\n–  Otherwise (MbaffFrameFlag is equal to 0 or the current macroblock is a frame macroblock), \nS′ [ xP + xO + j, yP + yO + i ] = u    with i, j = 0..nE  1  (8-408) \nL ij\nWhen u is a chroma block, for each sample u  of the chroma block, the following ordered steps are specified: \nij\n1.  The subscript C in the variable S′  is replaced with Cb for the Cb chroma component and with Cr for the Cr chroma \nC\ncomponent. \n2.  Depending on the size of the block u, the following applies: \n–  If u is an (MbWidthC)x(MbHeightC) Cb or Cr block, the variable nW is set equal to MbWidthC, the variable \nnH is set equal to MbHeightC, and the position ( xO, yO ) of the upper-left sample of the (nW)x(nH) Cb or \nCr block inside the macroblock is set equal to ( 0, 0 ). \n–  Otherwise, if u is a 4x4 Cb or Cr block, the variables nW and nH are set equal to 4 and, depending on the \nvariable ChromaArrayType, the position of the upper-left sample of a 4x4 Cb or Cr block with index \nchroma4x4BlkIdx inside the macroblock is derived as follows: \n–  If ChromaArrayType is equal to 1 or 2, the position of the upper-left sample of the 4x4 chroma block \nwith index chroma4x4BlkIdx inside the macroblock is derived by invoking the inverse 4x4 chroma \nblock scanning process in clause 6.4.7 with chroma4x4BlkIdx as the input and the output being assigned \nto ( xO, yO ). \n–  Otherwise (ChromaArrayType is equal to 3), the position of the upper-left sample of the 4x4 Cb block \nwith index cb4x4BlkIdx or the 4x4 Cr block with index cr4x4BlkIdx inside the macroblock is derived \nby invoking the inverse 4x4 Cb or Cr block scanning process in clause 6.4.4 with cb4x4BlkIdx or \ncr4x4BlkIdx as the input and the output being assigned to ( xO, yO ). \n192  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (u is an 8x8 Cb or Cr block when ChromaArrayType is equal to 3), the variables nW and nH are \nset equal to 8 and the position of the upper-left sample of the 8x8 Cb block with index cb8x8BlkIdx or the \nCr block with index cr8x8BlkIdx inside the macroblock is derived by invoking the inverse 8x8 Cb or Cr \nblock scanning process in clause 6.4.6 with cb8x8BlkIdx or cr8x8BlkIdx as the input and the output being \nassigned to ( xO, yO ). \n3.  Depending on the variable MbaffFrameFlag and the current macroblock, the following applies: \n–  If MbaffFrameFlag is equal to 1 and the current macroblock is a field macroblock, \nS′ [ ( xP / subWidthC ) + xO + j, ( ( yP + SubHeightC − 1 ) / SubHeightC ) + 2 * ( yO + i ) ] = u  \nC ij\n                                                                                          with i = 0..nH − 1  and   j = 0..nW − 1  (8-409) \n–  Otherwise (MbaffFrameFlag is equal to 0 or the current macroblock is a frame macroblock), \nS′ [ ( xP/ subWidthC ) + xO + j, ( yP / SubHeightC ) + yO + i ] = u  \nC ij\n                                                                                          with i = 0..nH − 1  and  j = 0..nW − 1  (8-410) \n8.5.15  Intra residual transform-bypass decoding process \nThis process is invoked when TransformBypassModeFlag is equal to 1, the macroblock prediction mode is equal to \nIntra_4x4, Intra_8x8, or Intra_16x16, and the applicable intra prediction mode is equal to the vertical or horizontal mode. \nThe process for the Cb and Cr components is applied in the same way as for the luma (L or Y) component. \nInputs to this process are: \n–  two variables nW and nH, \n–  a variable horPredFlag, \n–  an (nW)x(nH) array r with elements r  which is either an array relating to a residual transform-bypass block of the \nij\nluma component or an array relating to a residual transform-bypass block of the Cb and Cr component. \nOutput of this process is a modified version of the (nW)x(nH) array r with elements r  containing the result of the intra \nij\nresidual transform-bypass decoding process. \nLet f be a temporary (nW)x(nH) array with elements f , which are derived by: \nij\nf  = r      with i = 0..nH − 1  and  j = 0..nW − 1    (8-411) \nij ij\nDepending on horPredFlag, the following applies: \n–  If horPredFlag is equal to 0, the modified array r is derived by: \ni\nr  f      with i = 0..nH − 1  and  j = 0..nW − 1  (8-412) \nij kj\nk0\n–  Otherwise (horPredFlag is equal to 1), the modified array r is derived by: \nj\nr  f\n     with i = 0..nH − 1  and  j = 0..nW − 1  (8-413) \nij ik\nk0\n \n8.6  Decoding process for P macroblocks in SP slices or SI macroblocks \nThis process is invoked when decoding P macroblock types in an SP slice type or the SI macroblock type in SI slices. \nInputs to this process are the prediction residual transform coefficient levels and the predicted samples for the current \nmacroblock. \nOutputs of this process are the decoded samples of the current macroblock prior to the deblocking filter process. \nThis clause specifies the transform coefficient decoding process and picture construction process for P macroblock types \nin SP slices and the SI macroblock type in SI slices. \nNOTE – SP slices make use of Inter predictive coding to exploit temporal redundancy in the sequence, in a similar manner to P slice \ncoding. Unlike P slice coding, however, SP slice coding allows identical reconstruction of a slice even when different reference \npictures are being used. SI slices make use of spatial prediction, in a similar manner to I slices. SI slice coding allows identical \n    Rec. ITU-T H.264 (06/2019)  193 \n \nreconstruction to a corresponding SP slice. The properties of SP and SI slices aid in providing functionalities for bitstream switching, \nsplicing, random access, fast-forward, fast reverse, and error resilience/recovery. \nAn SP slice consists of macroblocks coded either as I macroblock types or P macroblock types. \nAn SI slice consists of macroblocks coded either as I macroblock types or SI macroblock type. \nThe transform coefficient decoding process and picture construction process prior to deblocking filter process for I \nmacroblock types in SI slices is invoked as specified in clause 8.5. The SI macroblock type is decoded as described below. \nWhen the current macroblock is coded as P_Skip, all values of LumaLevel4x4, ChromaDCLevel, ChromaACLevel are set \nequal to 0 for the current macroblock. \n8.6.1  SP decoding process for non-switching pictures \nThis process is invoked, when decoding P macroblock types in SP slices in which sp_for_switch_flag is equal to 0. \nInputs to this process are Inter prediction samples for the current macroblock from clause 8.4 and the prediction residual \ntransform coefficient levels. \nOutputs of this process are the decoded samples of the current macroblock prior to the deblocking filter process. \nThis clause applies to all macroblocks in SP slices in which sp_for_switch_flag is equal to 0, except those with macroblock \nprediction mode equal to Intra_4x4 or Intra_16x16. It does not apply to SI slices. \n8.6.1.1  Luma transform coefficient decoding process \nInputs to this process are Inter prediction luma samples for the current macroblock pred  from clause 8.4 and the prediction \nL\nresidual transform coefficient levels, LumaLevel4x4, and the index of the 4x4 luma block luma4x4BlkIdx. \nThe position of the upper-left sample of the 4x4 luma block with index luma4x4BlkIdx inside the current macroblock is \nderived by invoking the inverse 4x4 luma block scanning process in clause 6.4.3 with luma4x4BlkIdx as the input and the \noutput being assigned to ( x, y ). \nLet the variable p be a 4x4 array of prediction samples with element p  being derived as: \nij\np  = pred [ x + j, y + i ]   with i, j = 0..3    (8-414) \nij L\nThe variable p is transformed producing transform coefficients cp according to: \n1 1 1 1 p p p p  1 2 1 1\n00 01 02 03\n     \n2 1 1 2 p p p p 1 1 1 2\ncp      10 11 12 13      (8-415) \n1 1 1 1 p p p p  1 1 1 2\n20 21 22 23\n     \n1 2 2 1 p p p p 1 2 1 1\n     \n30 31 32 33\nThe inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is invoked with \nLumaLevel4x4[ luma4x4BlkIdx ] as the input and the two-dimensional array cr with elements c r as the output. \nij\nThe prediction residual transform coefficients cr are scaled using quantization parameter QP , and added to the transform \nY\ncoefficients of the prediction block cp with i, j = 0..3 as follows: \nc s = c p + ( ( ( c r * LevelScale4x4( QP  % 6, i, j ) * A  ) << ( QP  / 6 ) ) >> 10 )    (8-416) \nij ij ij Y ij Y\nwhere LevelScale4x4( m, i, j ) is specified in Equation 8-313, and where A  is specified as: \nij\n16 for (i, j) {(0,0), (0,2), (2,0), (2,2)},\n\nA  25 for (i, j) {(1,1), (1,3), (3,1), (3,3)},    (8-417) \nij\n20 otherwise;\n\nThe function LevelScale2( m, i, j ), used in the formulas below, is specified as \nw for (i, j) {(0,0), (0,2), (2,0), (2,2)},\n m0\nLevelScale 2(m, i, j)  w for (i, j) {(1,1), (1,3), (3,1), (3,3)},    (8-418) \nm1\nw otherwise;\n\nm2\nwhere the first and second subscripts of w are row and column indices, respectively, of the matrix specified as \n194  Rec. ITU-T H.264 (06/2019) \n \n13107 5243 8066\n11916 4660 7490\n10082 4194 6554\nw      (8-419) \n 9362 3647 5825\n 8192 3355 5243\n 7282 2893 4559\n \nThe resulting sum, cs, is quantized with a quantization parameter QS  and with i, j = 0..3 as follows: \nY\nc  = Sign( c s ) * ( ( Abs( c s ) * LevelScale2( QS  % 6, i, j ) + ( 1 << ( 14 + QS  / 6 ) ) ) >> ( 15 + QS  / 6 ) ) \nij ij ij Y Y Y\n          (8-420) \nThe scaling and transformation process for residual 4x4 blocks as specified in clause 8.5.12 is invoked with c as the input \nand r as the output. \nThe 4x4 array u with elements u  is derived by: \nij\nu  = Clip1 ( r  ) with i, j = 0..3      (8-421) \nij Y ij\nThe picture construction process prior to deblocking filter process in clause 8.5.14 is invoked with luma4x4BlkIdx and u \nas the inputs. \n8.6.1.2  Chroma transform coefficient decoding process \nInputs to this process are Inter prediction chroma samples for the current macroblock from clause 8.4 and the prediction \nresidual transform coefficient levels, ChromaDCLevel and ChromaACLevel. \nThis process is invoked twice: once for the Cb component and once for the Cr component. The component is referred to \nby replacing C with Cb for the Cb component and C with Cr for the Cr component. Let iCbCr select the current chroma \ncomponent. \nFor each 4x4 block of the current chroma component indexed using chroma4x4BlkIdx with chroma4x4BlkIdx equal \nto 0..3, the following ordered steps are specified: \n1.  The position of the upper-left sample of a 4x4 chroma block with index chroma4x4BlkIdx inside the macroblock \nis derived by invoking the inverse 4x4 chroma block scanning process in clause 6.4.7 with chroma4x4BlkIdx as \nthe input and the output being assigned to ( xO, yO ). \n2.  Let p be a 4x4 array of prediction samples with elements p  being derived as \nij\np  = pred [ x + j, y + i ]   with i, j = 0..3    (8-422) \nij C\n3.  The 4x4 array p is transformed producing transform coefficients cp( chroma4x4BlkIdx ) using Equation 8-415. \n4.  The variable chromaList, which is a list of 16 entries, is derived. chromaList[ 0 ] is set equal to 0. chromaList[ k ] \nwith index k = 1..15 are specified as follows: \nchromaList[ k ] = ChromaACLevel[ iCbCr ][ chroma4x4BlkIdx ][ k − 1 ]   (8-423) \n5.  The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is invoked \nwith chromaList as the input and the 4x4 array cr as the output. \n6.  The prediction residual transform coefficients cr are scaled using quantization parameter QP , and added to the \nC\ntransform coefficients of the prediction block cp with i, j = 0..3 except for the combination i = 0, j = 0 as follows: \nc s = c p( chroma4x4BlkIdx ) + ( ( ( c r * LevelScale4x4( QP  % 6, i, j ) * A  ) << ( QP  / 6 ) ) >> 10 )   (8-424) \nij ij ij C ij C\n7.  The resulting sum, cs, is quantized with a quantization parameter QS  and with i, j = 0..3 except for the combination \nC\ni = 0, j = 0 as follows. The derivation of c ( chroma4x4BlkIdx ) is described below in this clause. \n00\nc ( chroma4x4BlkIdx ) = ( Sign( c s ) * ( Abs( c s ) * LevelScale2( QS  % 6, i, j ) +  \nij ij ij C\n      ( 1 << ( 14 + QS  / 6 ) ) ) ) >> ( 15 + QS  / 6 )      (8-425) \nC C\n8.  The scaling and transformation process for residual 4x4 blocks as specified in clause 8.5.12 is invoked with \nc( chroma4x4BlkIdx ) as the input and r as the output. \n9.  The 4x4 array u with elements u  is derived by: \nij\n    Rec. ITU-T H.264 (06/2019)  195 \n \nu  = Clip1 ( r  ) with i, j = 0..3      (8-426) \nij C ij\n10.  The  picture  construction  process  prior  to  deblocking  filter  process  in  clause 8.5.14  is  invoked  with \nchroma4x4BlkIdx and u as the inputs. \nThe derivation of the DC transform coefficient level c ( chroma4x4BlkIdx ) is specified as follows. The DC transform \n00\ncoefficients of the 4 prediction chroma 4x4 blocks of the current component of the macroblock are assembled into a 2x2 \nmatrix with elements c p(chroma4x4BlkIdx) and a 2x2 transform is applied to the DC transform coefficients as follows: \n00\n1 1  cp  (0) cp  (1) 1 1 \ndcp \n \n 00 00 \n \n    (8-427) \n 1 1   cp  (2) cp  (3)   1 1 \n00 00\nThe chroma DC prediction residual transform coefficient levels, ChromaDCLevel[ iCbCr ][ k ] with k = 0..3 are scaled \nusing quantization parameter QP , and added to the prediction DC transform coefficients as follows: \nC\ndc s = dc p + ( ( ( ChromaDCLevel[ iCbCr ][ j * 2 + i ] * LevelScale4x4( QP  % 6, 0, 0) * A  ) << ( QP  / 6 ) ) \nij ij C 00 C\n               >> 9 )           with i, j = 0, 1  (8-428) \nThe 2x2 array dcs, is quantized using the quantization parameter QS  as follows: \nC\ndc r = ( Sign( dc s ) * ( Abs( dc s ) * LevelScale2( QS  % 6, 0, 0) + ( 1 << ( 15 + QS  / 6 ) ) ) ) >> ( 16 + QS  / 6 ) \nij ij ij C C C\n               with i, j = 0, 1   (8-429) \nThe 2x2 array f with elements f  and i, j = 0..1 is derived as: \nij\n1 1 dcr dcr  1 1\nf \n \n 00 01 \n \n    (8-430) \n\n1 1\n \ndcr dcr\n \n1 1\n\n10 11\nScaling of the elements f  of f is performed as follows: \nij\nc ( j * 2 + i ) = ( ( f  * LevelScale4x4( QS  % 6, 0, 0 ) ) << ( QS  / 6 ) ) >> 5  with i,  j = 0, 1  (8-431) \n00 ij C C\n8.6.2  SP and SI slice decoding process for switching pictures \nThis process is invoked, when decoding P macroblock types in SP slices in which sp_for_switch_flag is equal to 1 and \nwhen decoding the SI macroblock type in SI slices. \nInputs to this process are the prediction residual transform coefficient levels and the prediction sample arrays pred , pred  \nL Cb\nand pred  for the current macroblock. \nCr\n8.6.2.1  Luma transform coefficient decoding process \nInputs to this process are prediction luma samples pred  and the luma prediction residual transform coefficient levels, \nL\nLumaLevel4x4. \nThe 4x4 array p with elements p  with i, j = 0..3 is derived as in clause 8.6.1.1, is transformed according to Equation 8-415 \nij\nto produce transform coefficients cp. These transform coefficients are then quantized with the quantization parameter QS , \nY\nas follows: \nc s = Sign( c p ) * ( ( Abs( c p ) * LevelScale2( QS  % 6, i, j ) + ( 1 << ( 14 + QS  / 6 ) ) ) >> ( 15 + QS  / 6 ) ) \nij ij ij Y Y Y\n        with i, j = 0..3   (8-432) \nThe inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is invoked with \nLumaLevel4x4[ luma4x4BlkIdx ] as the input and the two-dimensional array cr with elements c r as the output. \nij\nThe 4x4 array c with elements c  with i, j = 0..3 is derived by: \nij\nc  = c r + c s  with i, j = 0..3    (8-433) \nij ij ij\nThe scaling and transformation process for residual 4x4 blocks as specified in clause 8.5.12 is invoked with c as the input \nand r as the output. \nThe 4x4 array u with elements u  is derived by: \nij\nu  = Clip1 ( r  ) with i, j = 0..3      (8-434) \nij Y ij\n196  Rec. ITU-T H.264 (06/2019) \n \nThe picture construction process prior to deblocking filter process in clause 8.5.14 is invoked with luma4x4BlkIdx and u \nas the inputs. \n8.6.2.2  Chroma transform coefficient decoding process \nInputs to this process are predicted chroma samples for the current macroblock from clause 8.4 and the prediction residual \ntransform coefficient levels, ChromaDCLevel and ChromaACLevel. \nThis process is invoked twice: once for the Cb component and once for the Cr component. The component is referred to \nby replacing C with Cb for the Cb component and C with Cr for the Cr component. Let iCbCr select the current chroma \ncomponent. \nFor each 4x4 block of the current chroma component indexed using chroma4x4BlkIdx with chroma4x4BlkIdx equal \nto 0..3, the following ordered steps are specified: \n1.  The 4x4 array p with elements p  with i, j = 0..3 is derived as in clause 8.6.1.2, is transformed according to \nij\nEquation 8-415 to produce transform coefficients cp( chroma4x4BlkIdx ). These transform coefficients are then \nquantized with the quantization parameter QS , with i, j = 0..3 except for the combination i = 0, j = 0 as follows. \nC\nThe processing of c p( chroma4x4BlkIdx ) is described below in this clause. \n00\nc s = ( Sign( c p( chroma4x4BlkIdx ) ) * ( Abs( c p( chroma4x4BlkIdx ) ) *  \nij ij ij\n    LevelScale2( QS  % 6, i, j ) + ( 1 << ( 14 + QS  / 6 ) ) ) ) >> ( 15 + QS  / 6)  (8-435) \nC C C\n2.  The variable chromaList, which is a list of 16 entries, is derived. chromaList[ 0 ] is set equal to 0. chromaList[ k ] \nwith index k = 1..15 are specified as follows: \nchromaList[ k ] = ChromaACLevel[ iCbCr ][ chroma4x4BlkIdx ][ k − 1 ]   (8-436) \n3.  The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is invoked \nwith  chromaList  as  the  input  and  the  two-dimensional  array  cr(  chroma4x4BlkIdx  )  with  elements \nc r( chroma4x4BlkIdx ) as the output. \nij\n4.  The  4x4  array  c(  chroma4x4BlkIdx  )  with  elements  c (  chroma4x4BlkIdx  )  with  i,  j  =  0..3  except  for  the \nij\ncombination i = 0, j = 0 is derived as follows. The derivation of c ( chroma4x4BlkIdx ) is described below. \n00\nc ( chroma4x4BlkIdx ) = c r( chroma4x4BlkIdx ) + c s  (8-437) \nij ij ij\n5.  The scaling and transformation process for residual 4x4 blocks as specified in  clause 8.5.12 is invoked with \nc( chroma4x4BlkIdx ) as the input and r as the output. \n6.  The 4x4 array u with elements u  is derived by: \nij\nu  = Clip1 ( r  ) with i, j = 0..3      (8-438) \nij C ij\n7.  The  picture  construction  process  prior  to  deblocking  filter  process  in  clause 8.5.14  is  invoked  with \nchroma4x4BlkIdx and u as the inputs. \nThe derivation of the DC transform coefficient level c ( chroma4x4BlkIdx ) is specified as follows. The DC transform \n00\ncoefficients of the 4 prediction 4x4 chroma blocks of the current component of the macroblock, c p( chroma4x4BlkIdx ), \n00\nare assembled into a 2x2 matrix, and a 2x2 transform is applied to the DC transform coefficients of these blocks according \nto Equation 8-427 resulting in DC transform coefficients dc p. \nij\nThese DC transform coefficients are then quantized with the quantization parameter QS , as given by: \nC\ndc s = ( Sign( dc p ) * ( Abs( dc p ) * LevelScale2( QS  % 6, 0, 0 ) + ( 1 << ( 15 + QS  / 6 ) ) ) ) >>  \nij ij ij C C\n    ( 16 + QS  / 6 )      with i, j = 0, 1   (8-439) \nC\nThe parsed chroma DC prediction residual transform coefficients, ChromaDCLevel[ iCbCr ][ k ] with k = 0..3 are added \nto these quantized DC transform coefficients of the prediction block, as given by: \ndc r = dc s + ChromaDCLevel[ iCbCr ][ j * 2 + i ]  with i, j = 0, 1  (8-440) \nij ij\nThe 2x2 array f with elements f  and i, j = 0..1 is derived using Equation 8-430. \nij\nThe 2x2 array f with elements f  and i, j = 0..1 is copied as follows: \nij\nc ( j * 2 + i ) = f   with i, j = 0, 1    (8-441) \n00 ij\n    Rec. ITU-T H.264 (06/2019)  197 \n \n8.7  Deblocking filter process \nA conditional filtering process is specified in this clause that is an integral part of the decoding process which shall be \napplied  by  decoders  conforming  to  the  Baseline,  Constrained Baseline,  Main,  Extended,  High,  Progressive High, \nConstrained High, High 10, Progressive High 10, High 4:2:2, and High 4:4:4 Predictive profiles. For decoders conforming \nto the High 10 Intra, High 4:2:2 Intra, High 4:4:4 Intra, and CAVLC 4:4:4 Intra profiles, the filtering process specified in \nthis clause, or one similar to it, should be applied but is not required. \nThe  conditional  filtering  process  is  applied  to  all  NxN  (where  N = 4  or  N = 8  for  luma,  N = 4  for  chroma  when \nChromaArrayType is equal to 1 or 2, and N = 4 or N = 8 for chroma when ChromaArrayType is equal to 3) block edges \nof a picture, except edges at the boundary of the picture and any edges for which the deblocking filter process is disabled \nby disable_deblocking_filter_idc, as specified below. This filtering process is performed on a macroblock basis after the \ncompletion of the picture construction process prior to deblocking filter process (as specified in clauses 8.5 and 8.6) for \nthe entire decoded picture, with all macroblocks in a picture processed in order of increasing macroblock addresses. \nNOTE 1 – Prior to the operation of the deblocking filter process for each macroblock, the deblocked samples of the macroblock or \nmacroblock pair above (if any) and the macroblock or macroblock pair to the left (if any) of the current macroblock are always \navailable because the deblocking filter process is performed after the completion of the picture construction process prior to \ndeblocking filter process for the entire decoded picture. However, for purposes of determining which edges are to be filtered when \ndisable_deblocking_filter_idc is equal to 2, macroblocks in different slices are considered not available during specified steps of the \noperation of the deblocking filter process. \nThe deblocking filter process is invoked for the luma and chroma components separately. For each macroblock and each \ncomponent, vertical edges are filtered first, starting with the edge on the left-hand side of the macroblock proceeding \nthrough the edges towards the right-hand side of the macroblock in their geometrical order, and then horizontal edges are \nfiltered, starting with the edge on the top of the macroblock proceeding through the edges towards the bottom of the \nmacroblock in their geometrical order. Figure 8-10 shows edges of a macroblock which can be interpreted as luma or \nchroma edges. \nWhen interpreting the edges in Figure 8-10 as luma edges, depending on the transform_size_8x8_flag, the following \napplies: \n–  If transform_size_8x8_flag is equal to 0, both types, the solid bold and dashed bold luma edges are filtered. \n–  Otherwise (transform_size_8x8_flag is equal to 1), only the solid bold luma edges are filtered. \nWhen interpreting the edges in Figure 8-10 as chroma edges, depending on ChromaArrayType, the following applies: \n–  If ChromaArrayType is equal to 1 (4:2:0 format), only the solid bold chroma edges are filtered. \n–  Otherwise, if ChromaArrayType is equal to 2 (4:2:2 format), the solid bold vertical chroma edges are filtered and \nboth types, the solid bold and dashed bold horizontal chroma edges are filtered. \n–  Otherwise, if ChromaArrayType is equal to 3 (4:4:4 format), the following applies: \n–  If transform_size_8x8_flag is equal to 0, both types, the solid bold and dashed bold chroma edges are filtered. \n–  Otherwise (transform_size_8x8_flag is equal to 1), only the solid bold chroma edges are filtered. \n–  Otherwise (ChromaArrayType is equal to 0), no chroma edges are filtered. \n198  Rec. ITU-T H.264 (06/2019) \n \ns\ne\ng\nd\ne\n \nl\na\nt\nn\no\nz\ni\nr\no\nH\nH.264(09)_F8-10\nVertical edges\n \nFigure 8-10 – Boundaries in a macroblock to be filtered \nFor the current macroblock address CurrMbAddr proceeding over values 0..PicSizeInMbs − 1, the following ordered steps \nare specified: \n1.  The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is \nassigned to mbAddrA and mbAddrB. \n2.  The variables fieldMbInFrameFlag, filterInternalEdgesFlag, filterLeftMbEdgeFlag and filterTopMbEdgeFlag are \nderived as specified by the following ordered steps: \na.  The variable fieldMbInFrameFlag is derived as follows: \n–  If MbaffFrameFlag is equal to 1 and mb_field_decoding_flag is equal to 1, fieldMbInFrameFlag is set \nequal to 1. \n–  Otherwise  (MbaffFrameFlag  is  equal  to  0  or  mb_field_decoding_flag  is  equal  to  0), \nfieldMbInFrameFlag is set equal to 0. \nb.  The variable filterInternalEdgesFlag is derived as follows: \n–  If disable_deblocking_filter_idc for the slice that contains the macroblock CurrMbAddr is equal to 1, \nthe variable filterInternalEdgesFlag is set equal to 0. \n–  Otherwise (disable_deblocking_filter_idc for the slice that contains the macroblock CurrMbAddr is \nnot equal to 1), the variable filterInternalEdgesFlag is set equal to 1. \nc.  The variable filterLeftMbEdgeFlag is derived as follows: \n–  If any of the following conditions are true, the variable filterLeftMbEdgeFlag is set equal to 0: \n–  MbaffFrameFlag is equal to 0 and CurrMbAddr % PicWidthInMbs is equal to 0, \n–  MbaffFrameFlag is equal to 1 and ( CurrMbAddr >> 1 ) % PicWidthInMbs is equal to 0, \n–  disable_deblocking_filter_idc for the slice that contains the macroblock CurrMbAddr is equal \nto 1, \n–  disable_deblocking_filter_idc for the slice that contains the macroblock CurrMbAddr is equal \nto 2 and the macroblock mbAddrA is not available. \n–  Otherwise, the variable filterLeftMbEdgeFlag is set equal to 1. \nd.  The variable filterTopMbEdgeFlag is derived as follows: \n–  If any of the following conditions are true, the variable filterTopMbEdgeFlag is set equal to 0: \n–  MbaffFrameFlag is equal to 0 and CurrMbAddr is less than PicWidthInMbs, \n–  MbaffFrameFlag  is  equal  to  1,  ( CurrMbAddr >> 1 )  is  less  than  PicWidthInMbs,  and  the \nmacroblock CurrMbAddr is a field macroblock, \n–  MbaffFrameFlag  is  equal  to  1,  ( CurrMbAddr >> 1 )  is  less  than  PicWidthInMbs,  the \nmacroblock CurrMbAddr is a frame macroblock, and CurrMbAddr % 2 is equal to 0, \n    Rec. ITU-T H.264 (06/2019)  199 \n \n–  disable_deblocking_filter_idc for the slice that contains the macroblock CurrMbAddr is equal \nto 1, \n–  disable_deblocking_filter_idc for the slice that contains the macroblock CurrMbAddr is equal \nto 2 and the macroblock mbAddrB is not available. \n–  Otherwise, the variable filterTopMbEdgeFlag is set equal to 1. \n3.  Given  the  variables  fieldMbInFrameFlag,  filterInternalEdgesFlag,  filterLeftMbEdgeFlag  and \nfilterTopMbEdgeFlag the deblocking filtering is controlled as follows: \na.  When filterLeftMbEdgeFlag is equal to 1, the left vertical luma edge is filtered by invoking the process \nspecified  in  clause 8.7.1  with  chromaEdgeFlag = 0,  verticalEdgeFlag = 1, \nfieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and (xE , yE ) = (0, k) with k = 0..15 as the inputs \nk k\nand S′  as the output. \nL\nb.  When filterInternalEdgesFlag is equal to 1, the filtering of the internal vertical luma edges is specified by the \nfollowing ordered steps: \ni.  When transform_size_8x8_flag is equal to 0, the process specified in clause 8.7.1 is invoked with \nchromaEdgeFlag = 0,  verticalEdgeFlag = 1,  fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, \nand (xE , yE ) = (4, k) with k = 0..15 as the inputs and S′  as the output. \nk k L\nii.  The  process  specified  in  clause 8.7.1  is  invoked  with  chromaEdgeFlag = 0,  verticalEdgeFlag = 1, \nfieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and (xE , yE ) = (8, k) with k = 0..15 as the \nk k\ninputs and S′  as the output. \nL\niii.  When transform_size_8x8_flag is equal to 0, the process specified in clause 8.7.1 is invoked with \nchromaEdgeFlag = 0,  verticalEdgeFlag = 1,  fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, \nand (xE , yE ) = (12, k) with k = 0..15 as the inputs and S′  as the output. \nk k L\nc.  When filterTopMbEdgeFlag is equal to 1, the filtering of the top horizontal luma edge is specified as follows: \n–  If MbaffFrameFlag is equal to 1, (CurrMbAddr % 2) is equal to 0, CurrMbAddr is greater than or equal \nto 2 * PicWidthInMbs,  the  macroblock  CurrMbAddr  is  a  frame  macroblock,  and  the  macroblock \n(CurrMbAddr − 2 * PicWidthInMbs + 1)  is  a  field  macroblock,  the  following  ordered  steps  are \nspecified: \ni.  The process specified in clause 8.7.1 is invoked with chromaEdgeFlag = 0, verticalEdgeFlag = 0, \nfieldModeInFrameFilteringFlag = 1, and (xE , yE ) = (k, 0) with k = 0..15 as the inputs and S′  \nk k L\nas the output. \nii.  The process specified in clause 8.7.1 is invoked with chromaEdgeFlag = 0, verticalEdgeFlag = 0, \nfieldModeInFrameFilteringFlag = 1, and (xE , yE ) = (k, 1) with k = 0..15 as the inputs and S′  \nk k L\nas the output. \n–  Otherwise,  the  process  specified  in  clause 8.7.1  is  invoked  with  chromaEdgeFlag = 0, \nverticalEdgeFlag = 0, fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and (xE , yE ) = (k, 0) \nk k\nwith k = 0..15 as the inputs and S′  as the output. \nL\nd.  When filterInternalEdgesFlag is equal to 1, the filtering of the internal horizontal luma edges is specified by \nthe following ordered steps: \ni.  When transform_size_8x8_flag is equal to 0, the process specified in clause 8.7.1 is invoked with \nchromaEdgeFlag = 0,  verticalEdgeFlag = 0,  fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, \nand (xE , yE ) = (k, 4) with k = 0..15 as the inputs and S′  as the output. \nk k L\nii.  The  process  specified  in  clause 8.7.1  is  invoked  with  chromaEdgeFlag = 0,  verticalEdgeFlag = 0, \nfieldModeInFrameFilteringFlag = fieldMbInFrameFlag, and (xE , yE ) = (k, 8) with k = 0..15 as the \nk k\ninputs and S′  as the output. \nL\niii.  When transform_size_8x8_flag is equal to 0, the process specified in clause 8.7.1 is invoked with \nchromaEdgeFlag = 0,  verticalEdgeFlag = 0,  fieldModeInFrameFilteringFlag = fieldMbInFrameFlag, \nand (xE , yE ) = (k, 12) with k = 0..15 as the inputs and S′  as the output. \nk k L\ne.  When ChromaArrayType is not equal to 0, for the filtering of both chroma components, with iCbCr = 0 for \nCb and iCbCr = 1 for Cr, the following ordered steps are specified: \ni.  When filterLeftMbEdgeFlag is equal to 1, the left vertical chroma edge is filtered by invoking the \nprocess  specified  in  clause 8.7.1  with  chromaEdgeFlag = 1,  iCbCr,  verticalEdgeFlag = 1, \nfieldModeInFrameFilteringFlag = fieldMbInFrameFlag,  and  (xE , yE ) = (0, k)  with \nk k\n200  Rec. ITU-T H.264 (06/2019) \n \nk = 0..MbHeightC − 1 as the inputs and S′  with C being replaced by Cb for iCbCr = 0 and C being \nC\nreplaced by Cr for iCbCr = 1 as the output. \nii.  When filterInternalEdgesFlag is equal to 1, the filtering of the internal vertical chroma edge is specified \nby the following ordered steps: \n(1)  When ChromaArrayType is not equal to 3 or transform_size_8x8_flag is equal to 0, the process \nspecified  in  clause 8.7.1  is  invoked  with  chromaEdgeFlag = 1,  iCbCr,  verticalEdgeFlag = 1, \nfieldModeInFrameFilteringFlag = fieldMbInFrameFlag,  and  (xE , yE ) = (4, k)  with \nk k\nk = 0..MbHeightC − 1 as the inputs and S′  with C being replaced by Cb for iCbCr = 0 and C being \nC\nreplaced by Cr for iCbCr = 1 as the output. \n(2)  When  ChromaArrayType  is  equal  to 3,  the  process  specified  in  clause 8.7.1  is  invoked  with \nchromaEdgeFlag = 1,  iCbCr,  verticalEdgeFlag = 1,  fieldModeInFrameFilteringFlag = \nfieldMbInFrameFlag, and (xE , yE ) = (8, k) with k = 0..MbHeightC − 1 as the inputs and S′  with \nk k C\nC being replaced by Cb for iCbCr = 0 and C being replaced by Cr for iCbCr = 1 as the output. \n(3)  When ChromaArrayType is equal to 3 and transform_size_8x8_flag is equal to 0, the process \nspecified  in  clause 8.7.1  is  invoked  with  chromaEdgeFlag = 1,  iCbCr,  verticalEdgeFlag = 1, \nfieldModeInFrameFilteringFlag = fieldMbInFrameFlag,  and  (xE , yE ) = (12, k)  with \nk k\nk = 0..MbHeightC − 1 as the inputs and S′  with C being replaced by Cb for iCbCr = 0 and C being \nC\nreplaced by Cr for iCbCr = 1 as the output. \niii.  When filterTopMbEdgeFlag is equal to 1, the filtering of the top horizontal chroma edge is specified \nas follows: \n–  If MbaffFrameFlag is equal to 1, (CurrMbAddr % 2) is equal to 0, CurrMbAddr is greater than or \nequal  to 2 * PicWidthInMbs,  the  macroblock  CurrMbAddr  is  a  frame  macroblock,  and  the \nmacroblock  (CurrMbAddr − 2 * PicWidthInMbs + 1)  is  a  field  macroblock,  the  following \nordered steps are specified: \n(1)  The  process  specified  in  clause 8.7.1  is  invoked  with  chromaEdgeFlag = 1,  iCbCr, \nverticalEdgeFlag = 0,  fieldModeInFrameFilteringFlag = 1,  and  (xE , yE ) = (k,  0)  with \nk k\nk = 0..MbWidthC − 1 as the inputs and S′  with C being replaced by Cb for iCbCr = 0 and C \nC\nbeing replaced by Cr for iCbCr = 1 as the output. \n(2)  The  process  specified  in  clause 8.7.1  is  invoked  with  chromaEdgeFlag = 1,  iCbCr, \nverticalEdgeFlag = 0,  fieldModeInFrameFilteringFlag = 1,  and  (xE , yE ) = (k,  1)  with \nk k\nk = 0..MbWidthC − 1 as the inputs and S′  with C being replaced by Cb for iCbCr = 0 and C \nC\nbeing replaced by Cr for iCbCr = 1 as the output. \n–  Otherwise, the process specified in clause 8.7.1 is invoked with chromaEdgeFlag = 1, iCbCr, \nverticalEdgeFlag = 0,  fieldModeInFrameFilteringFlag = fieldMbInFrameFlag,  and \n(xE , yE ) = (k, 0) with k = 0..MbWidthC − 1 as the inputs and S′  with C being replaced by Cb \nk k C\nfor iCbCr = 0 and C being replaced by Cr for iCbCr = 1 as the output. \niv.  When filterInternalEdgesFlag is equal to 1, the filtering of the internal horizontal chroma edge is \nspecified by the following ordered steps: \n(1)  When ChromaArrayType is not equal to 3 or transform_size_8x8_flag is equal to 0, the process \nspecified  in  clause 8.7.1  is  invoked  with  chromaEdgeFlag = 1,  iCbCr,  verticalEdgeFlag = 0, \nfieldModeInFrameFilteringFlag = fieldMbInFrameFlag,  and  (xE , yE ) = (k,  4)  with \nk k\nk = 0..MbWidthC − 1 as the inputs and S′  with C being replaced by Cb for iCbCr = 0 and C being \nC\nreplaced by Cr for iCbCr = 1 as the output. \n(2)  When ChromaArrayType is not equal to 1, the process specified in clause 8.7.1 is invoked with \nchromaEdgeFlag = 1,  iCbCr,  verticalEdgeFlag = 0,  fieldModeInFrameFilteringFlag = \nfieldMbInFrameFlag, and (xE , yE ) = (k, 8) with k = 0..MbWidthC − 1 as the inputs and S′  with \nk k C\nC being replaced by Cb for iCbCr = 0 and C being replaced by Cr for iCbCr = 1 as the output. \n(3)  When  ChromaArrayType  is  equal  to 2,  the  process  specified  in  clause 8.7.1  is  invoked  with \nchromaEdgeFlag = 1,  iCbCr,  verticalEdgeFlag = 0,  fieldModeInFrameFilteringFlag = \nfieldMbInFrameFlag, and (xE , yE ) = (k, 12) with k = 0..MbWidthC − 1 as the inputs and S′  with \nk k C\nC being replaced by Cb for iCbCr = 0 and C being replaced by Cr for iCbCr = 1 as the output. \n(4)  When ChromaArrayType is equal to 3 and transform_size_8x8_flag is equal to 0, the process \nspecified  in  clause 8.7.1  is  invoked  with  chromaEdgeFlag = 1,  iCbCr,  verticalEdgeFlag = 0, \nfieldModeInFrameFilteringFlag = fieldMbInFrameFlag,  and  (xE , yE ) = (k,  12)  with \nk k\n    Rec. ITU-T H.264 (06/2019)  201 \n \nk = 0..MbWidthC − 1 as the inputs and S′  with C being replaced by Cb for iCbCr = 0 and C being \nC\nreplaced by Cr for iCbCr = 1 as the output. \nNOTE 2 – When field mode filtering (fieldModeInFrameFilteringFlag is equal to 1) is applied across the top \nhorizontal edges of a frame macroblock, this vertical filtering across the top or bottom macroblock boundary may \ninvolve some samples that extend across an internal block edge that is also filtered internally in frame mode. \nNOTE 3 – For example, in 4:2:0 chroma format when transform_size_8x8_flag is equal to 0, the following applies. \n3 horizontal luma edges, 1 horizontal chroma edge for Cb, and 1 horizontal chroma edge for Cr are filtered that are \ninternal to a macroblock. When field mode filtering (fieldModeInFrameFilteringFlag is equal to 1) is applied to the \ntop edges of a frame macroblock, 2 horizontal luma, 2 horizontal chroma edges for Cb, and 2 horizontal chroma \nedges for Cr between the frame macroblock and the above macroblock pair are filtered using field mode filtering, \nfor a total of up to 5 horizontal luma edges, 3 horizontal chroma edges for Cb, and 3 horizontal chroma edges for \nCr filtered that are considered to be controlled by the frame macroblock. In all other cases, at most 4 horizontal \nluma, 2 horizontal chroma edges for Cb, and 2 horizontal chroma edges for Cr are filtered that are considered to be \ncontrolled by a particular macroblock. \nDepending on separate_colour_plane_flag the following applies: \n–  If separate_colour_plane_flag is equal to 0, the arrays S′ , S′ , S′  are assigned to the arrays S , S , S  (which \nL Cb Cr L Cb Cr\nrepresent the decoded picture), respectively. \n–  Otherwise (separate_colour_plane_flag is equal to 1), the following applies: \n–  If colour_plane_id is equal to 0, the arrays S′  is assigned to the array S  (which represent the luma component \nL L\nof the decoded picture). \n–  Otherwise, if colour_plane_id is equal to 1, the arrays S′  is assigned to the array S  (which represents the Cb \nL Cb\ncomponent of the decoded picture). \n–  Otherwise (colour_plane_id is equal to 2), the arrays S′  is assigned to the array S  (which represents the Cr \nL Cr\ncomponent of the decoded picture). \n8.7.1  Filtering process for block edges \nInputs to this process are chromaEdgeFlag, the chroma component index iCbCr (when chromaEdgeFlag is equal to 1), \nverticalEdgeFlag,  fieldModeInFrameFilteringFlag,  and  a  set  of  nE  sample  locations  (xE , yE ),  with  k = 0..nE − 1, \nk k\nexpressed relative to the upper left corner of the macroblock CurrMbAddr. The set of sample locations (xE , yE ) represent \nk k\nthe sample locations immediately to the right of a vertical edge (when verticalEdgeFlag is equal to 1) or immediately below \na horizontal edge (when verticalEdgeFlag is equal to 0). \nThe variable nE is derived as follows: \n–  If chromaEdgeFlag is equal to 0, nE is set equal to 16. \n–  Otherwise (chromaEdgeFlag is equal to 1), nE is set equal to ( verticalEdgeFlag  = =  1 ) ? MbHeightC : MbWidthC. \nLet s′ be a variable specifying a luma or chroma sample array. s′ is derived as follows: \n–  If chromaEdgeFlag is equal to 0, s′ represents the luma sample array S′  of the current picture. \nL\n–  Otherwise, if chromaEdgeFlag is equal to 1 and iCbCr is equal to 0, s′ represents the chroma sample array S′  of the \nCb\nchroma component Cb of the current picture. \n–  Otherwise (chromaEdgeFlag is equal to 1 and iCbCr is equal to 1), s′ represents the chroma sample array S′  of the \nCr\nchroma component Cr of the current picture. \nThe variable dy is set equal to (1 + fieldModeInFrameFilteringFlag). \nThe position of the upper-left luma sample of the macroblock CurrMbAddr is derived by invoking the inverse macroblock \nscanning process in clause 6.4.1 with mbAddr = CurrMbAddr as input and the output being assigned to ( xI, yI ). \nThe variables xP and yP are derived as follows: \n–  If chromaEdgeFlag is equal to 0, xP is set equal to xI and yP is set equal to yI. \n–  Otherwise  (chromaEdgeFlag  is  equal  to  1),  xP  is  set  equal  to  xI  /  SubWidthC  and  yP  is  set  equal  to \n(yI + SubHeightC − 1) / SubHeightC. \n202  Rec. ITU-T H.264 (06/2019) \n \n \np p   p   p   q   q   q   q  \n3  2 1 0 0 1 2 3\nFigure 8-11 – Convention for describing samples across a 4x4 block horizontal or vertical boundary \nFor each sample location ( xE , yE  ), k = 0..(nE − 1), the following ordered steps are specified: \nk k\n1.  The filtering process is applied to a set of eight samples across a 4x4 block horizontal or vertical edge denoted as \np and q with i = 0..3 as shown in Figure 8-11 with the edge lying between p  and q . p and q with i = 0..3 are \ni i 0 0 i i\nspecified as follows: \n–  If verticalEdgeFlag is equal to 1, \nq = s′[ xP + xE  + i, yP + dy * yE  ]    (8-442) \ni k k\np = s′[ xP + xE  − i − 1, yP + dy * yE  ]    (8-443) \ni k k\n–  Otherwise (verticalEdgeFlag is equal to 0), \nq = s′[ xP + xE , yP + dy * ( yE  + i ) − (yE  % 2 ) ]  (8-444) \ni k k k\np = s′[ xP + xE , yP + dy * ( yE  − i − 1 ) − (yE  % 2 ) ]  (8-445) \ni k k k\n2.  The process specified in clause 8.7.2 is invoked with the sample values p and q (i = 0..3), chromaEdgeFlag, and \ni i\nverticalEdgeFlag as the inputs, and the output is assigned to the filtered result sample values p′ and q′ with i = 0..2. \ni i\n3.  The input sample values p and q with i = 0..2 are replaced by the corresponding filtered result sample values p′ \ni i i\nand q′ with i = 0..2 inside the sample array s′ as follows: \ni\n–  If verticalEdgeFlag is equal to 1, \ns′[ xP + xE  + i, yP + dy * yE  ] = q′    (8-446) \nk k i\ns′[ xP + xE  − i − 1, yP + dy * yE  ] = p′    (8-447) \nk k i\n–  Otherwise (verticalEdgeFlag is equal to 0), \ns′[ xP + xE , yP + dy * ( yE  + i ) − ( yE  % 2 ) ] = q′   (8-448) \nk k k i\ns′[ xP + xE , yP + dy * ( yE  − i − 1 ) − ( yE  % 2 ) ] = p′   (8-449) \nk k k i\n8.7.2  Filtering process for a set of samples across a horizontal or vertical block edge \nInputs to this process are the input sample values p  and q with i in the range of 0..3 of a single set of samples across an \ni i\nedge that is to be filtered, chromaEdgeFlag, and verticalEdgeFlag. \nOutputs of this process are the filtered result sample values p′ and q′ with i in the range of 0..2. \ni i\nThe content dependent boundary filtering strength variable bS is derived as follows: \n–  If chromaEdgeFlag is equal to 0, the derivation process for the content dependent boundary filtering strength specified \nin clause 8.7.2.1 is invoked with p , q , and verticalEdgeFlag as input, and the output is assigned to bS. \n0 0\n–  Otherwise (chromaEdgeFlag is equal to 1), the bS used for filtering a set of samples of a horizontal or vertical chroma \nedge is set equal to the value of bS for filtering the set of samples of a horizontal or vertical luma edge, respectively, \nthat contains the luma sample at location ( SubWidthC * x, SubHeightC * y ) inside the luma array of the same field, \nwhere ( x, y ) is the location of the chroma sample q  inside the chroma array for that field. \n0\nLet filterOffsetA and filterOffsetB be the values of FilterOffsetA and FilterOffsetB as specified in clause 7.4.3 for the slice \nthat contains the macroblock containing sample q . \n0\nLet qP  and qP  be variables specifying quantization parameter values for the macroblocks containing the samples p  and \np q 0\nq , respectively. The variables qP  (with z being replaced by p or q) are derived as follows: \n0 z\n–  If chromaEdgeFlag is equal to 0, the following applies: \n    Rec. ITU-T H.264 (06/2019)  203 \n \n–  If the macroblock containing the sample z  is an I_PCM macroblock, qP  is set to 0. \n0 z\n–  Otherwise (the macroblock containing the sample z  is not an I_PCM macroblock), qP  is set to the value of QP  \n0 z Y\nof the macroblock containing the sample z . \n0\n–  Otherwise (chromaEdgeFlag is equal to 1), the following applies: \n–  If the macroblock containing the sample z  is an I_PCM macroblock, qP  is set equal to the value of QP  that \n0 z C\ncorresponds to a value of 0 for QP  as specified in clause 8.5.8. \nY\n–  Otherwise (the macroblock containing the sample z  is not an I_PCM macroblock), qP  is set equal to the value \n0 z\nof QP  that corresponds to the value QP  of the macroblock containing the sample z  as specified in clause 8.5.8. \nC Y 0\nThe process specified in clause 8.7.2.2 is invoked with p , q , p , q , chromaEdgeFlag, bS, filterOffsetA, filterOffsetB, qP , \n0 0 1 1 p\nand qP  as inputs, and the outputs are assigned to filterSamplesFlag, indexA, , and . \nq\nThe variable chromaStyleFilteringFlag is set by \nchromaStyleFilteringFlag = chromaEdgeFlag && ( ChromaArrayType  !=  3 )  (8-450) \nDepending on the variable filterSamplesFlag, the following applies: \n–  If filterSamplesFlag is equal to 1, the following applies: \n–  If bS is less than 4, the process specified in clause 8.7.2.3 is invoked with p and q (i = 0..2), chromaEdgeFlag, \ni i\nchromaStyleFilteringFlag, bS, , and indexA given as input, and the output is assigned to p′ and q′ (i = 0..2). \ni i\n–  Otherwise  (bS  is  equal  to  4),  the  process  specified  in  clause 8.7.2.4  is  invoked  with  p  and  q  (i  =  0..3), \ni i\nchromaEdgeFlag, chromaStyleFilteringFlag, , and  given as input, and the output is assigned to p′ and q′ \ni i\n(i = 0..2). \n–  Otherwise (filterSamplesFlag is equal to 0), the filtered result samples p′ and q′ (i = 0..2) are replaced by the \ni i\ncorresponding input samples p  and q: \ni i\nfor i = 0..2,    p′ = p    (8-451) \ni i\nfor i = 0..2,    q′ = q    (8-452) \ni i\n8.7.2.1  Derivation process for the luma content dependent boundary filtering strength \nInputs to this process are the input sample values p  and q  of a single set of samples across an edge that is to be filtered \n0 0\nand verticalEdgeFlag. \nOutput of this process is the variable bS. \nLet the variable mixedModeEdgeFlag be derived as follows: \n–  If MbaffFrameFlag is equal to 1 and the samples p  and q   are in different macroblock pairs, one of which is a field \n0 0\nmacroblock pair and the other is a frame macroblock pair, mixedModeEdgeFlag is set equal to 1. \n–  Otherwise, mixedModeEdgeFlag is set equal to 0. \nThe variable bS is derived as follows: \n–  If the block edge is also a macroblock edge and any of the following conditions are true, a value of bS equal to 4 is \nthe output: \n–  the samples p  and q  are both in frame macroblocks and either or both of the samples p  or q  is in a macroblock \n0 0 0 0\ncoded using an Intra macroblock prediction mode, \n–  the samples p  and q  are both in frame macroblocks and either or both of the samples p  or q  is in a macroblock \n0 0 0 0\nthat is in a slice with slice_type equal to SP or SI, \n–  MbaffFrameFlag is equal to 1 or field_pic_flag is equal to 1, and verticalEdgeFlag is equal to 1, and either or \nboth of the samples p  or q  is in a macroblock coded using an Intra macroblock prediction mode, \n0 0\n–  MbaffFrameFlag is equal to 1 or field_pic_flag is equal to 1, and verticalEdgeFlag is equal to 1, and either or \nboth of the samples p  or q  is in a macroblock that is in a slice with slice_type equal to SP or SI. \n0 0\n–  Otherwise, if any of the following conditions are true, a value of bS equal to 3 is the output: \n–  mixedModeEdgeFlag is equal to 0 and either or both of the samples p  or q  is in a macroblock coded using an \n0 0\nIntra macroblock prediction mode, \n204  Rec. ITU-T H.264 (06/2019) \n \n–  mixedModeEdgeFlag is equal to 0 and either or both of the samples p  or q  is in a macroblock that is in a slice \n0 0\nwith slice_type equal to SP or SI, \n–  mixedModeEdgeFlag is equal to 1, verticalEdgeFlag is equal to 0, and either or both of the samples p  or q  is in \n0 0\na macroblock coded using an Intra macroblock prediction mode, \n–  mixedModeEdgeFlag is equal to 1, verticalEdgeFlag is equal to 0, and either or both of the samples p  or q  is in \n0 0\na macroblock that is in a slice with slice_type equal to SP or SI. \n–  Otherwise, if any of the following conditions are true, a value of bS equal to 2 is the output: \n–  transform_size_8x8_flag is equal to 1 for the macroblock containing the sample p  and the 8x8 luma transform \n0\nblock associated with the 8x8 luma block containing the sample p  contains non-zero transform coefficient levels, \n0\n–  transform_size_8x8_flag is equal to 0 for the macroblock containing the sample p  and the 4x4 luma transform \n0\nblock associated with the 4x4 luma block containing the sample p  contains non-zero transform coefficient levels, \n0\n–  transform_size_8x8_flag is equal to 1 for the macroblock containing the sample q  and the 8x8 luma transform \n0\nblock associated with the 8x8 luma block containing the sample q  contains non-zero transform coefficient levels, \n0\n–  transform_size_8x8_flag is equal to 0 for the macroblock containing the sample q  and the 4x4 luma transform \n0\nblock associated with the 4x4 luma block containing the sample q  contains non-zero transform coefficient levels. \n0\n–  Otherwise, if any of the following conditions are true, a value of bS equal to 1 is the output: \n–  mixedModeEdgeFlag is equal to 1, \n–  mixedModeEdgeFlag is equal to 0 and for the prediction of the macroblock/sub-macroblock partition containing \nthe sample p  different reference pictures or a different number of motion vectors are used than for the prediction \n0\nof the macroblock/sub-macroblock partition containing the sample q , \n0\nNOTE 1 – The determination of whether the reference pictures used for the two macroblock/sub-macroblock partitions \nare the same or different is based only on which pictures are referenced, without regard to whether a prediction is formed \nusing an index into reference picture list 0 or an index into reference picture list 1, and also without regard to whether \nthe index position within a reference picture list is different. \nNOTE 2 – The number of motion vectors that are used for the prediction of a macroblock partition with macroblock \npartition  index  mbPartIdx,  or  a  sub-macroblock  partition  contained  in  this  macroblock  partition,  is  equal  to \nPredFlagL0[ mbPartIdx ] + PredFlagL1[ mbPartIdx ]. \n–  mixedModeEdgeFlag is equal to 0 and one motion vector is used to predict the macroblock/sub-macroblock \npartition containing the sample p  and one motion vector is used to predict the macroblock/sub-macroblock \n0\npartition containing the sample q  and the absolute difference between the horizontal or vertical components of \n0\nthe motion vectors used is greater than or equal to 4 in units of quarter luma frame samples, \n–  mixedModeEdgeFlag is equal to 0 and two motion vectors and two different reference pictures are used to predict \nthe macroblock/sub-macroblock partition containing the sample p  and two motion vectors for the same two \n0\nreference pictures are used to predict the macroblock/sub-macroblock partition containing the sample q  and, for \n0\neither or both of the two used reference pictures, the absolute difference between the horizontal or vertical \ncomponents of the two motion vectors used in the prediction of the two macroblock/sub-macroblock partitions \nfor the particular reference picture is greater than or equal to 4 in units of quarter luma frame samples, \n–  mixedModeEdgeFlag is equal to 0 and two motion vectors for the same reference picture are used to predict the \nmacroblock/sub-macroblock partition containing the sample p  and two motion vectors for the same reference \n0\npicture are used to predict the macroblock/sub-macroblock partition containing the sample q  and both of the \n0\nfollowing conditions are true: \n–  The absolute difference between the horizontal or vertical components of list 0 motion vectors used in the \nprediction of the two macroblock/sub-macroblock partitions is greater than or equal to 4 in quarter luma \nframe samples or the absolute difference between the horizontal or vertical components of the list 1 motion \nvectors used in the prediction of the two macroblock/sub-macroblock partitions is greater than or equal to 4 \nin units of quarter luma frame samples, \n–  The absolute difference between the horizontal or vertical components of list 0 motion vector used in the \nprediction of the macroblock/sub-macroblock partition containing the sample p  and the list 1 motion vector \n0\nused in the prediction of the macroblock/sub-macroblock partition containing the sample q  is greater than \n0\nor equal to 4 in units of quarter luma frame samples or the absolute difference between the horizontal or \nvertical components of the list 1 motion vector used in the prediction of the macroblock/sub-macroblock \npartition containing the sample p  and list 0 motion vector used in the prediction of the macroblock/sub-\n0\nmacroblock partition containing the sample q  is greater than or equal to 4 in units of quarter luma frame \n0\nsamples. \n    Rec. ITU-T H.264 (06/2019)  205 \n \nNOTE 3 – A vertical difference of 4 in units of quarter luma frame samples is a difference of 2 in units of quarter \nluma field samples. \n–  Otherwise, a value of bS equal to 0 is the output. \n8.7.2.2  Derivation process for the thresholds for each block edge \nInputs to this process are: \n–  the input sample values p , q , p  and q  of a single set of samples across an edge that is to be filtered, \n0 0 1 1\n–  the variables chromaEdgeFlag and bS, for the set of input samples, as specified in clause 8.7.2, \n–  the variables filterOffsetA, filterOffsetB, qP , and qP . \np q\nOutputs of this process are the variable filterSamplesFlag, which indicates whether the input samples are filtered, the value \nof indexA, and the values of the threshold variables  and . \nLet qP  be a variable specifying an average quantization parameter. It is derived as: \nav\nqP  = ( qP  + qP  + 1 ) >> 1    (8-453) \nav p q\nNOTE – In SP and SI slices, qP  is derived in the same way as in other slice types. QS  from Equation 7-31 is not used in the \nav Y\ndeblocking filter. \nLet indexA be a variable that is used to access the  table (Table 8-16) as well as the t  table (Table 8-17), which is used \nC0\nin filtering of edges with bS less than 4 as specified in clause 8.7.2.3, and let indexB be a variable that is used to access the \n table (Table 8-16). The variables indexA and indexB are derived as: \nindexA = Clip3( 0, 51, qP  + filterOffsetA )    (8-454) \nav\nindexB = Clip3( 0, 51, qP  + filterOffsetB )    (8-455) \nav\nThe variables ′ and ′ depending on the values of indexA and indexB are specified in  Table 8-16. Depending on \nchromaEdgeFlag, the corresponding threshold variables  and  are derived as follows: \n–  If chromaEdgeFlag is equal to 0, \n = ′ * (1 << ( BitDepth  − 8 ) )     (8-456) \nY\nβ = β′ * (1 << ( BitDepth  − 8 ) )     (8-457) \nY\n–  Otherwise (chromaEdgeFlag is equal to 1), \n = ′ * (1 << ( BitDepth  − 8 ) )     (8-458) \nC\nβ = β′ * (1 << ( BitDepth  − 8 ) )     (8-459) \nC\nThe variable filterSamplesFlag is derived by: \nfilterSamplesFlag = ( bS != 0  &&  Abs( p  − q  ) <   &&  Abs( p  − p  ) <   &&  Abs( q  − q  ) <  )  (8-460) \n0 0 1 0 1 0\nTable 8-16 – Derivation of offset dependent threshold variables ´ and ´ from indexA and indexB \n \n  indexA (for ′) or indexB (for ′)  \n  0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25 \n′  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  4  4  5  6  7  8  9  10  12  13 \n′  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  2  2  2  3  3  3  3  4  4  4 \n206  Rec. ITU-T H.264 (06/2019) \n \nTable 8-16 (concluded) – Derivation of indexA and indexB from offset dependent threshold variables ′ and ′ \n  indexA (for ′) or indexB (for ′) \n  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51 \n′  15  17  20  22  25  28  32  36  40  45  50  56  63  71  80  90  101  113  127 144  162  182  203 226  255  255 \n′  6  6  7  7  8  8  9  9  10  10  11  11  12  12  13  13  14  14  15  15  16  16  17  17  18  18 \n \n8.7.2.3  Filtering process for edges with bS less than 4 \nInputs to this process are the input sample values p  and q (i = 0..2) of a single set of samples across an edge that is to be \ni i\nfiltered, chromaEdgeFlag, chromaStyleFilteringFlag, bS, , and indexA, for the set of input samples, as specified in \nclause 8.7.2. \nOutputs of this process are the filtered result sample values p′ and q′ (i = 0..2) for the set of input sample values. \ni i\nDepending on the values of indexA and bS, the variable t′  is specified in Table 8-17. Depending on chromaEdgeFlag, \nC0\nthe corresponding threshold variable t  is derived as follows: \nC0\n–  If chromaEdgeFlag is equal to 0, \nt  = t′  * (1 << ( BitDepth  − 8 ) )     (8-461) \nC0 C0 Y\n–  Otherwise (chromaEdgeFlag is equal to 1), \nt  = t′  * (1 << ( BitDepth  − 8 ) )     (8-462) \nC0 C0 C\nTable 8-17 – Value of variable t´  as a function of indexA and bS \nC0\n \n  indexA \n  0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25 \nbS = 1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1 \nbS = 2  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1 \nbS = 3   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1 \nTable 8-17 (concluded) – Value of variable t′  as a function of indexA and bS \nC0\n  indexA \n  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51 \nbS = 1  1  1  1  1  1  1  1  2  2  2  2  3  3  3  4  4  4  5  6  6  7  8  9  10  11  13 \nbS = 2  1  1  1  1  1  2  2  2  2  3  3  3  4  4  5  5  6  7  8  8  10  11  12  13  15  17 \nbS = 3   1  2  2  2  2  3  3  3  4  4  4  5  6  6  7  8  9  10  11  13  14  16  18  20  23  25 \n \nThe threshold variables a  and a  are derived by: \np q\na  = Abs( p  − p  )    (8-463) \np 2 0\na  = Abs( q  − q  )    (8-464) \nq 2 0\nThe threshold variable t  is determined as follows: \nC\n–  If chromaStyleFilteringFlag is equal to 0, \nt  = t  + ( ( a  <  ) ? 1 : 0 ) + ( ( a  <  ) ? 1 : 0 )     (8-465) \nC C0 p q\n–  Otherwise (chromaStyleFilteringFlag is equal to 1), \n    Rec. ITU-T H.264 (06/2019)  207 \n \nt  = t  + 1       (8-466) \nC C0\nLet Clip1( ) be a function that is replaced by Clip1 ( ) when chromaEdgeFlag is equal to 0 and by Clip1 ( ) when \nY C\nchromaEdgeFlag is equal to 1. \nThe filtered result samples p′  and q′  are derived by: \n0 0\n   = Clip3( −t , t , ( ( ( ( q  − p  ) << 2 ) + ( p  − q  ) + 4 ) >> 3 ) )  (8-467) \nC C 0 0 1 1\np′  = Clip1( p  +  )    (8-468) \n0 0\nq′  = Clip1( q  −  )    (8-469) \n0 0\nThe filtered result sample p′  is derived as follows: \n1\n–  If chromaStyleFilteringFlag is equal to 0 and a  is less than , \np\np′  = p  + Clip3( −t , t , ( p  + ( ( p  + q  + 1 ) >> 1 ) − ( p  << 1 ) )  >>  1 )  (8-470) \n1 1 C0 C0 2 0 0 1\n–  Otherwise (chromaStyleFilteringFlag is equal to 1 or a  is greater than or equal to ), \np\np′  = p       (8-471) \n1 1\nThe filtered result sample q′  is derived as follows: \n1\n–  If chromaStyleFilteringFlag is equal to 0 and a  is less than , \nq\nq′  = q  + Clip3( −t , t , ( q  + ( ( p  + q  + 1 ) >> 1 ) − ( q  << 1 ) )  >>  1 )  (8-472) \n1 1 C0 C0 2 0 0 1\n–  Otherwise (chromaStyleFilteringFlag is equal to 1 or a  is greater than or equal to ), \nq\nq′  = q       (8-473) \n1 1\nThe filtered result samples p′  and q′  are always set equal to the input samples p  and q : \n2 2 2 2\np′  = p       (8-474) \n2 2\nq′  = q       (8-475) \n2 2\n8.7.2.4  Filtering process for edges for bS equal to 4 \nInputs to this process are the input sample values p  and q (i = 0..3) of a single set of samples across an edge that is to be \ni i\nfiltered, chromaEdgeFlag, chromaStyleFilteringFlag, and the values of the threshold variables  and  for the set of \nsamples, as specified in clause 8.7.2. \nOutputs of this process are the filtered result sample values p′ and q′ (i = 0..2) for the set of input sample values. \ni i\nLet a  and a  be two threshold variables as specified in Equations 8-463 and 8-464, respectively, in clause 8.7.2.3. \np q\nThe filtered result samples p′ (i = 0..2) are derived as follows: \ni\n–  If chromaStyleFilteringFlag is equal to 0 and the following condition holds, \na  <   &&  Abs( p  − q  ) < ( (  >> 2 ) + 2 )    (8-476) \np 0 0\nthen the variables p′ , p′ , and p′  are derived by: \n0 1 2\np′  = ( p  + 2*p  + 2*p  + 2*q  + q  + 4 ) >> 3    (8-477) \n0 2 1 0 0 1\np′  = ( p  + p  + p  + q  + 2 ) >> 2    (8-478) \n1 2 1 0 0\np′  = ( 2*p  + 3*p  + p  + p  + q  + 4 ) >> 3    (8-479) \n2 3 2 1 0 0\n–  Otherwise (chromaStyleFilteringFlag is equal to 1 or the condition in Equation 8-476 does not hold), the variables \np′ , p′ , and p′  are derived by: \n0 1 2\np′  = ( 2*p  + p  + q  + 2 ) >> 2    (8-480) \n0 1 0 1\np′  = p     (8-481) \n1 1 \n208  Rec. ITU-T H.264 (06/2019) \n \np′  = p       (8-482) \n2 2\nThe filtered result samples q′ (i = 0..2) are derived as follows: \ni\n–  If chromaStyleFilteringFlag is equal to 0 and the following condition holds, \na  <   &&  Abs( p  − q  ) < ( (  >> 2 ) + 2 )    (8-483) \nq 0 0\nthen the variables q′ , q′ , and q′  are derived by \n0 1 2\nq′  = ( p  + 2*p  + 2*q  + 2*q  + q  + 4 ) >> 3    (8-484) \n0 1 0 0 1 2\nq′  = ( p  + q  + q  + q  + 2 ) >> 2    (8-485) \n1 0 0 1 2\nq′  = ( 2*q  + 3*q  + q  + q  + p  + 4 ) >> 3    (8-486) \n2 3 2 1 0 0\n–  Otherwise (chromaStyleFilteringFlag is equal to 1 or the condition in Equation 8-483 does not hold), the variables \nq′ , q′ , and q′  are derived by: \n0 1 2\nq′  = ( 2*q  + q  + p  + 2 ) >> 2    (8-487) \n0 1 0 1\nq′  = q     (8-488) \n1 1 \nq′  = q       (8-489) \n2 2\n9  Parsing process \nInputs to this process are bits from the RBSP. \nOutputs of this process are syntax element values. \nThis process is invoked when the descriptor of a syntax element in the syntax tables in clause 7.3 is equal to ue(v), me(v), \nse(v), te(v) (see clause 9.1), ce(v) (see clause 9.2), or ae(v) (see clause 9.3). \n9.1  Parsing process for Exp-Golomb codes \nThis process is invoked when the descriptor of a syntax element in the syntax tables in clause 7.3 is equal to ue(v), me(v), \nse(v),  or  te(v).  For  syntax  elements  in  clauses 7.3.4  and  7.3.5,  this  process  is  invoked  only  when \nentropy_coding_mode_flag is equal to 0. \nInputs to this process are bits from the RBSP. \nOutputs of this process are syntax element values. \nSyntax elements coded as ue(v), me(v), or se(v) are Exp-Golomb-coded. Syntax elements coded as te(v) are truncated Exp-\nGolomb-coded. The parsing process for these syntax elements begins with reading the bits starting at the current location \nin the bitstream up to and including the first non-zero bit, and counting the number of leading bits that are equal to 0. This \nprocess is specified as follows: \nleadingZeroBits = −1 \nfor( b = 0; !b; leadingZeroBits++ )  (9-1) \n  b = read_bits( 1 ) \nThe variable codeNum is then assigned as follows: \ncodeNum = 2leadingZeroBits − 1 + read_bits( leadingZeroBits )   (9-2) \nwhere the value returned from read_bits( leadingZeroBits ) is interpreted as a binary representation of an unsigned integer \nwith most significant bit written first. \nTable 9-1 illustrates the structure of the Exp-Golomb code by separating the bit string into \"prefix\" and \"suffix\" bits. The \n\"prefix\" bits are those bits that are parsed in the above pseudo-code for the computation of leadingZeroBits, and are shown \nas either 0 or 1 in the bit string column of Table 9-1. The \"suffix\" bits are those bits that are parsed in the computation of \ncodeNum and are shown as x in Table 9-1, with i being in the range 0 to leadingZeroBits − 1, inclusive. Each x can take \ni i\non values 0 or 1. \n    Rec. ITU-T H.264 (06/2019)  209 \n \nTable 9-1 – Bit strings with \"prefix\" and \"suffix\" bits and assignment to codeNum ranges (informative) \nBit string form  Range of codeNum \n          1  0 \n        0 1 x   1..2 \n0\n      0 0 1 x  x   3..6 \n1 0\n    0 0 0 1 x  x  x   7..14 \n2 1 0\n  0 0 0 0 1 x  x  x  x   15..30 \n3 2 1 0\n0 0 0 0 0 1 x  x  x  x  x   31..62 \n4 3 2 1 0\n…  … \n \nTable 9-2 illustrates explicitly the assignment of bit strings to codeNum values. \nTable 9-2 – Exp-Golomb bit strings and codeNum in explicit form and used as ue(v) (informative) \n \nBit string  codeNum \n1  0 \n0 1 0  1 \n0 1 1  2 \n0 0 1 0 0  3 \n0 0 1 0 1  4 \n0 0 1 1 0  5 \n0 0 1 1 1  6 \n0 0 0 1 0 0 0  7 \n0 0 0 1 0 0 1  8 \n0 0 0 1 0 1 0  9 \n…  … \n \nDepending on the descriptor, the value of a syntax element is derived as follows: \n–  If the syntax element is coded as ue(v), the value of the syntax element is equal to codeNum. \n–  Otherwise, if the syntax element is coded as se(v), the value of the syntax element is derived by invoking the mapping \nprocess for signed Exp-Golomb codes as specified in clause 9.1.1 with codeNum as the input. \n–  Otherwise, if the syntax element is coded as me(v), the value of the syntax element is derived by invoking the mapping \nprocess for coded block pattern as specified in clause 9.1.2 with codeNum as the input. \n–  Otherwise (the syntax element is coded as te(v)), the range of possible values for the syntax element is determined \nfirst. The range of this syntax element may be between 0 and x, with x being greater than or equal to 1 and the range \nis used in the derivation of the value of the syntax element value as follows: \n–  If x is greater than 1, codeNum and the value of the syntax element is derived in the same way as for syntax \nelements coded as ue(v). \n–  Otherwise (x is equal to 1), the parsing process for codeNum which is equal to the value of the syntax element \nis given by a process equivalent to: \nb = read_bits( 1 )   (9-3) \ncodeNum = !b \n210  Rec. ITU-T H.264 (06/2019) \n \n9.1.1  Mapping process for signed Exp-Golomb codes \nInput to this process is codeNum as specified in clause 9.1. \nOutput of this process is a value of a syntax element coded as se(v). \nThe syntax element is assigned to the codeNum by ordering the syntax element by its absolute value in increasing order \nand representing the positive value for a given absolute value with the lower codeNum. Table 9-3 provides the assignment \nrule. \nTable 9-3 – Assignment of syntax element to codeNum for signed Exp-Golomb coded syntax elements se(v) \n \ncodeNum  syntax element value \n0  0 \n1  1 \n2  −1 \n3  2 \n4  −2 \n5  3 \n6  −3 \nk  (−1)k+1 Ceil( k÷2 ) \n \n9.1.2  Mapping process for coded block pattern \nInput to this process is codeNum as specified in clause 9.1. \nOutput of this process is a value of the syntax element coded_block_pattern coded as me(v). \nTable 9-4 shows the assignment of coded_block_pattern to codeNum depending on whether the macroblock prediction \nmode is equal to Intra_4x4, Intra_8x8 or Inter. \n    Rec. ITU-T H.264 (06/2019)  211 \n \nTable 9-4 – Assignment of codeNum to values of coded_block_pattern for macroblock prediction modes \n(a) ChromaArrayType is equal to 1 or 2 \ncodeNum  coded_block_pattern \n  Intra_4x4, Intra_8x8  Inter \n0  47  0 \n1  31  16 \n2  15  1 \n3  0  2 \n4  23  4 \n5  27  8 \n6  29  32 \n7  30  3 \n8  7  5 \n9  11  10 \n10  13  12 \n11  14  15 \n12  39  47 \n13  43  7 \n14  45  11 \n15  46  13 \n16  16  14 \n17  3  6 \n18  5  9 \n19  10  31 \n20  12  35 \n21  19  37 \n22  21  42 \n23  26  44 \n24  28  33 \n25  35  34 \n26  37  36 \n27  42  40 \n28  44  39 \n29  1  43 \n30  2  45 \n212  Rec. ITU-T H.264 (06/2019) \n \n(a) ChromaArrayType is equal to 1 or 2 \ncodeNum  coded_block_pattern \n  Intra_4x4, Intra_8x8  Inter \n31  4  46 \n32  8  17 \n33  17  18 \n34  18  20 \n35  20  24 \n36  24  19 \n37  6  21 \n38  9  26 \n39  22  28 \n40  25  23 \n41  32  27 \n42  33  29 \n43  34  30 \n44  36  22 \n45  40  25 \n46  38  38 \n47  41  41 \n \n(b) ChromaArrayType is equal to 0 or 3 \ncodeNum  coded_block_pattern \n  Intra_4x4, Intra_8x8  Inter \n0  15  0 \n1  0  1 \n2  7  2 \n3  11  4 \n4  13  8 \n5  14  3 \n6  3  5 \n7  5  10 \n8  10  12 \n9  12  15 \n    Rec. ITU-T H.264 (06/2019)  213 \n \n(b) ChromaArrayType is equal to 0 or 3 \ncodeNum  coded_block_pattern \n  Intra_4x4, Intra_8x8  Inter \n10  1  7 \n11  2  11 \n12  4  13 \n13  8  14 \n14  6  6 \n15  9  9 \n \n9.2  CAVLC parsing process for transform coefficient levels \nThis  process  is  invoked  for  the  parsing  of  syntax  elements  with  descriptor  equal  to ce(v)  in  clause 7.3.5.3.2  when \nentropy_coding_mode_flag is equal to 0. \nInputs to this process are bits from slice data, a maximum number of non-zero transform coefficient levels maxNumCoeff, \nthe luma block index luma4x4BlkIdx or the chroma block index chroma4x4BlkIdx, cb4x4BlkIdx or cr4x4BlkIdx of the \ncurrent block of transform coefficient levels. \nOutput of this process is the list coeffLevel containing transform coefficient levels of the luma block with block index \nluma4x4BlkIdx or the chroma block with block index chroma4x4BlkIdx, cb4x4BlkIdx or cr4x4BlkIdx. \nThe process is specified in the following ordered steps: \n1.  All transform coefficient level values coeffLevel[ i ], with indices i ranging from 0 to maxNumCoeff − 1, in the \nlist coeffLevel are set equal to 0. \n2.  The total number of non-zero transform coefficient levels TotalCoeff( coeff_token ) and the number of trailing one \ntransform  coefficient  levels  TrailingOnes( coeff_token )  are  derived  by  parsing  coeff_token  as  specified  in \nclause 9.2.1. \n3.  The following then applies: \n–  If  the  number  of  non-zero  transform  coefficient  levels  TotalCoeff( coeff_token )  is  equal  to 0,  the  list \ncoeffLevel (in which all transform coefficient level values are equal to 0) is returned and no further steps are \ncarried out. \n–  Otherwise, the following steps are carried out: \na.  The non-zero transform coefficient levels are derived by parsing trailing_ones_sign_flag, level_prefix, \nand level_suffix as specified in clause 9.2.2. \nb.  The runs of zero transform coefficient levels before each non-zero transform coefficient level are derived \nby parsing total_zeros and run_before as specified in clause 9.2.3. \nc.  The level and run information are combined into the list coeffLevel as specified in clause 9.2.4. \n9.2.1  Parsing process for total number of non-zero transform coefficient levels and number of trailing ones \nInputs to this process are bits from slice data, a maximum number of non-zero transform coefficient levels maxNumCoeff, \nthe luma block index luma4x4BlkIdx or the chroma block index chroma4x4BlkIdx, cb4x4BlkIdx or cr4x4BlkIdx of the \ncurrent block of transform coefficient levels. \nOutputs of this process are TotalCoeff( coeff_token ), TrailingOnes( coeff_token ), and the variable nC. \nThe syntax element coeff_token is decoded using one of the six VLCs specified in the six right-most columns of Table 9-5. \nEach VLC specifies both TotalCoeff( coeff_token ) and TrailingOnes( coeff_token ) for a given codeword coeff_token. \nThe selection of the applicable column of Table 9-5 is determined by a variable nC. The value of nC is derived as follows: \n–  If the CAVLC parsing process is invoked for ChromaDCLevel, nC is derived as follows: \n214  Rec. ITU-T H.264 (06/2019) \n \n–  If ChromaArrayType is equal to 1, nC is set equal to −1, \n–  Otherwise (ChromaArrayType is equal to 2), nC is set equal to −2, \n–  Otherwise, the following ordered steps are performed: \n1.  When the CAVLC parsing process is invoked for Intra16x16DCLevel, luma4x4BlkIdx is set equal to 0. \n2.  When the CAVLC parsing process is invoked for CbIntra16x16DCLevel, cb4x4BlkIdx is set equal to 0. \n3.  When the CAVLC parsing process is invoked for CrIntra16x16DCLevel, cr4x4BlkIdx is set equal to 0. \n4.  The variables blkA and blkB are derived as follows: \n–  If  the  CAVLC  parsing  process  is  invoked  for  Intra16x16DCLevel,  Intra16x16ACLevel,  or \nLumaLevel4x4, the process specified in clause 6.4.11.4 is invoked with luma4x4BlkIdx as the input, and \nthe output is assigned to mbAddrA, mbAddrB, luma4x4BlkIdxA, and luma4x4BlkIdxB. The 4x4 luma \nblock specified by mbAddrA\\luma4x4BlkIdxA is assigned to blkA, and the 4x4 luma block specified by \nmbAddrB\\luma4x4BlkIdxB is assigned to blkB. \n–  Otherwise, if the CAVLC parsing process is invoked for CbIntra16x16DCLevel, CbIntra16x16ACLevel, \nor CbLevel4x4, the process specified in clause 6.4.11.6 is invoked with cb4x4BlkIdx as the input, and \nthe output is assigned to mbAddrA, mbAddrB, cb4x4BlkIdxA, and cb4x4BlkIdxB. The 4x4 Cb block \nspecified  by  mbAddrA\\cb4x4BlkIdxA  is  assigned  to  blkA,  and  the  4x4  Cb  block  specified  by \nmbAddrB\\cb4x4BlkIdxB is assigned to blkB. \n–  Otherwise, if the CAVLC parsing process is invoked for CrIntra16x16DCLevel, CrIntra16x16ACLevel, \nor CrLevel4x4, the process specified in clause 6.4.11.6 is invoked with cr4x4BlkIdx as the input, and the \noutput  is  assigned  to  mbAddrA,  mbAddrB,  cr4x4BlkIdxA,  and  cr4x4BlkIdxB.  The  4x4  Cr  block \nspecified  by  mbAddrA\\cr4x4BlkIdxA  is  assigned  to  blkA,  and  the  4x4  Cr  block  specified  by \nmbAddrB\\cr4x4BlkIdxB is assigned to blkB. \n–  Otherwise  (the  CAVLC  parsing  process  is  invoked  for  ChromaACLevel),  the  process  specified  in \nclause 6.4.11.5 is invoked with chroma4x4BlkIdx as input, and the output is assigned to mbAddrA, \nmbAddrB,  chroma4x4BlkIdxA,  and  chroma4x4BlkIdxB.  The  4x4  chroma  block  specified  by \nmbAddrA\\iCbCr\\chroma4x4BlkIdxA  is  assigned  to  blkA,  and  the  4x4  chroma  block  specified  by \nmbAddrB\\iCbCr\\chroma4x4BlkIdxB is assigned to blkB. \n5.  The variable availableFlagN with N being replaced by A and B is derived as follows: \n–  If any of the following conditions are true, availableFlagN is set equal to 0: \n–  mbAddrN is not available, \n–  the  current  macroblock  is  coded  using  an  Intra  macroblock  prediction  mode, \nconstrained_intra_pred_flag is equal to 1, mbAddrN is coded using an Inter macroblock prediction \nmode, and slice data partitioning is in use (nal_unit_type is in the range of 2 to 4, inclusive). \n–  Otherwise, availableFlagN is set equal to 1. \n6.  For N being replaced by A and B, when availableFlagN is equal to 1, the variable nN is derived as follows: \n–  If any of the following conditions are true, nN is set equal to 0: \n–  The macroblock mbAddrN has mb_type equal to P_Skip or B_Skip, \n–  The  macroblock  mbAddrN  has  mb_type  not  equal  to  I_PCM  and  all  AC  residual  transform \ncoefficient levels of the neighbouring block blkN are equal to 0 due to the corresponding bit of \nCodedBlockPatternLuma or CodedBlockPatternChroma being equal to 0. \n–  Otherwise, if mbAddrN is an I_PCM macroblock, nN is set equal to 16. \n–  Otherwise, nN is set equal to the value TotalCoeff( coeff_token ) of the neighbouring block blkN. \nNOTE 1 – The values nA and nB that are derived using TotalCoeff( coeff_token ) do not include the DC transform \ncoefficient levels in Intra_16x16 macroblocks or DC transform coefficient levels in chroma blocks, because these \ntransform coefficient levels are decoded separately. When the block above or to the left belongs to an Intra_16x16 \nmacroblock, nA or nB is the number of decoded non-zero AC transform coefficient levels for the adjacent 4x4 \nblock in the Intra_16x16 macroblock. When the block above or to the left is a chroma block, nA or nB is the \nnumber of decoded non-zero AC transform coefficient levels for the adjacent chroma block. \nNOTE 2 – When parsing for Intra16x16DCLevel, CbIntra16x16DCLevel, or CrIntra16x16DCLevel, the values \nnA and nB are based on the number of non-zero transform coefficient levels in adjacent 4x4 blocks and not on the \nnumber of non-zero DC transform coefficient levels in adjacent 16x16 blocks. \n    Rec. ITU-T H.264 (06/2019)  215 \n \n7.  The variable nC is derived as follows: \n–  If  availableFlagA  is  equal  to 1  and  availableFlagB  is  equal  to 1,  the  variable  nC  is  set  equal  to \n( nA + nB + 1 ) >> 1. \n–  Otherwise, if availableFlagA is equal to 1 (and availableFlagB is equal to 0), the variable nC is set equal \nto nA. \n–  Otherwise, if availableFlagB is equal to 1 (and availableFlagA is equal to 0), the variable nC is set equal \nto nB. \n–  Otherwise (availableFlagA is equal to 0 and availableFlagB is equal to 0), the variable nC is set equal \nto 0. \nWhen  maxNumCoeff  is  equal  to  15,  it  is  a  requirement  of  bitstream  conformance  that  the  value  of \nTotalCoeff( coeff_token ) resulting from decoding coeff_token shall not be equal to 16. \nTable 9-5 – coeff_token mapping to TotalCoeff( coeff_token ) and TrailingOnes( coeff_token ) \n  e s    ) n   f     ) n\nne fe\nOk ek\no\ng t o C t o 0 <= nC < 2  2 <= nC < 4  4 <= nC < 8  8 <= nC  nC = = −1  nC = = −2 \nn_ l_\nif af\na i l e f o t e f\nro To\nTc c\n   \n( (\n0  0  1  11  1111  0000 11  01  1 \n0  1  0001 01  0010 11  0011 11  0000 00  0001 11  0001 111 \n1  1  01  10  1110  0000 01  1  01 \n0  2  0000 0111  0001 11  0010 11  0001 00  0001 00  0001 110 \n1  2  0001 00  0011 1  0111 1  0001 01  0001 10  0001 101 \n2  2  001  011  1101  0001 10  001  001 \n0  3  0000 0011 1  0000 111  0010 00  0010 00  0000 11  0000 0011 1 \n1  3  0000 0110  0010 10  0110 0  0010 01  0000 011  0001 100 \n2  3  0000 101  0010 01  0111 0  0010 10  0000 010  0001 011 \n3  3  0001 1  0101  1100  0010 11  0001 01  0000 1 \n0  4  0000 0001 11  0000 0111  0001 111  0011 00  0000 10  0000 0011 0 \n1  4  0000 0011 0  0001 10  0101 0  0011 01  0000 0011  0000 0010 1 \n2  4  0000 0101  0001 01  0101 1  0011 10  0000 0010  0001 010 \n3  4  0000 11  0100  1011  0011 11  0000 000  0000 01 \n0  5  0000 0000 111  0000 0100  0001 011  0100 00  -  0000 0001 11 \n1  5  0000 0001 10  0000 110  0100 0  0100 01  -  0000 0001 10 \n2  5  0000 0010 1  0000 101  0100 1  0100 10  -  0000 0010 0 \n3  5  0000 100  0011 0  1010  0100 11  -  0001 001 \n0  6  0000 0000 0111 1  0000 0011 1  0001 001  0101 00  -  0000 0000 111 \n1  6  0000 0000 110  0000 0110  0011 10  0101 01  -  0000 0000 110 \n2  6  0000 0001 01  0000 0101  0011 01  0101 10  -  0000 0001 01 \n3  6  0000 0100  0010 00  1001  0101 11  -  0001 000 \n0  7  0000 0000 0101 1  0000 0001 111  0001 000  0110 00  -  0000 0000 0111 \n1  7  0000 0000 0111 0  0000 0011 0  0010 10  0110 01  -  0000 0000 0110 \n2  7  0000 0000 101  0000 0010 1  0010 01  0110 10  -  0000 0000 101 \n216  Rec. ITU-T H.264 (06/2019) \n \nTable 9-5 – coeff_token mapping to TotalCoeff( coeff_token ) and TrailingOnes( coeff_token ) \n  e s    ) n   f     ) n\nne fe\nOk ek\no\ng\no Co\nt t 0 <= nC < 2  2 <= nC < 4  4 <= nC < 8  8 <= nC  nC = = −1  nC = = −2 \nn_ l_\nif af\na i l e f o t e f\nro To\nTc c\n   \n( (\n3  7  0000 0010 0  0001 00  1000  0110 11  -  0000 0001 00 \n0  8  0000 0000 0100 0  0000 0001 011  0000 1111  0111 00  -  0000 0000 0011 1 \n1  8  0000 0000 0101 0  0000 0001 110  0001 110  0111 01  -  0000 0000 0101 \n2  8  0000 0000 0110 1  0000 0001 101  0001 101  0111 10  -  0000 0000 0100 \n3  8  0000 0001 00  0000 100  0110 1  0111 11  -  0000 0000 100 \n0  9  0000 0000 0011 11  0000 0000 1111  0000 1011  1000 00  -  - \n1  9  0000 0000 0011 10  0000 0001 010  0000 1110  1000 01  -  - \n2  9  0000 0000 0100 1  0000 0001 001  0001 010  1000 10  -  - \n3  9  0000 0000 100  0000 0010 0  0011 00  1000 11  -  - \n0  10  0000 0000 0010 11  0000 0000 1011  0000 0111 1  1001 00  -  - \n1  10  0000 0000 0010 10  0000 0000 1110  0000 1010  1001 01  -  - \n2  10  0000 0000 0011 01  0000 0000 1101  0000 1101  1001 10  -  - \n3  10  0000 0000 0110 0  0000 0001 100  0001 100  1001 11  -  - \n0  11  0000 0000 0001 111  0000 0000 1000  0000 0101 1  1010 00  -  - \n1  11  0000 0000 0001 110  0000 0000 1010  0000 0111 0  1010 01  -  - \n2  11  0000 0000 0010 01  0000 0000 1001  0000 1001  1010 10  -  - \n3  11  0000 0000 0011 00  0000 0001 000  0000 1100  1010 11  -  - \n0  12  0000 0000 0001 011  0000 0000 0111 1  0000 0100 0  1011 00  -  - \n1  12  0000 0000 0001 010  0000 0000 0111 0  0000 0101 0  1011 01  -  - \n2  12  0000 0000 0001 101  0000 0000 0110 1  0000 0110 1  1011 10  -  - \n3  12  0000 0000 0010 00  0000 0000 1100  0000 1000  1011 11  -  - \n0  13  0000 0000 0000 1111  0000 0000 0101 1  0000 0011 01  1100 00  -  - \n1  13  0000 0000 0000 001  0000 0000 0101 0  0000 0011 1  1100 01  -  - \n2  13  0000 0000 0001 001  0000 0000 0100 1  0000 0100 1  1100 10  -  - \n3  13  0000 0000 0001 100  0000 0000 0110 0  0000 0110 0  1100 11  -  - \n0  14  0000 0000 0000 1011  0000 0000 0011 1  0000 0010 01  1101 00  -  - \n1  14  0000 0000 0000 1110  0000 0000 0010 11  0000 0011 00  1101 01  -  - \n2  14  0000 0000 0000 1101  0000 0000 0011 0  0000 0010 11  1101 10  -  - \n3  14  0000 0000 0001 000  0000 0000 0100 0  0000 0010 10  1101 11  -  - \n0  15  0000 0000 0000 0111  0000 0000 0010 01  0000 0001 01  1110 00  -  - \n1  15  0000 0000 0000 1010  0000 0000 0010 00  0000 0010 00  1110 01  -  - \n2  15  0000 0000 0000 1001  0000 0000 0010 10  0000 0001 11  1110 10  -  - \n3  15  0000 0000 0000 1100  0000 0000 0000 1  0000 0001 10  1110 11  -  - \n0  16  0000 0000 0000 0100  0000 0000 0001 11  0000 0000 01  1111 00  -  - \n    Rec. ITU-T H.264 (06/2019)  217 \n \nTable 9-5 – coeff_token mapping to TotalCoeff( coeff_token ) and TrailingOnes( coeff_token ) \n  e s    ) n   f     ) n\nne fe\nOk ek\no\ng\no Co\nt t 0 <= nC < 2  2 <= nC < 4  4 <= nC < 8  8 <= nC  nC = = −1  nC = = −2 \nn_ l_\nif af\na i l e f o t e f\nro To\nTc c\n   \n( (\n1  16  0000 0000 0000 0110  0000 0000 0001 10  0000 0001 00  1111 01  -  - \n2  16  0000 0000 0000 0101  0000 0000 0001 01  0000 0000 11  1111 10  -  - \n3  16  0000 0000 0000 1000  0000 0000 0001 00  0000 0000 10  1111 11  -  - \n \n9.2.2  Parsing process for level information \nInputs  to  this  process  are  bits  from  slice  data,  the  number  of  non-zero  transform  coefficient  levels \nTotalCoeff( coeff_token ), and the number of trailing one transform coefficient levels TrailingOnes( coeff_token ). \nOutput of this process is a list with name levelVal containing transform coefficient levels. \nInitially an index i is set equal to 0. Then, when TrailingOnes( coeff_token ) is not equal to 0, the following ordered steps \nare applied TrailingOnes( coeff_token ) times to decode the trailing one transform coefficient levels: \n1.  A 1-bit syntax element trailing_ones_sign_flag is decoded and evaluated as follows: \n–  If trailing_ones_sign_flag is equal to 0, levelVal[ i ] is set equal to 1. \n–  Otherwise (trailing_ones_sign_flag is equal to 1), levelVal[ i ] is set equal to −1. \n2.  The index i is incremented by 1. \nThen, the variable suffixLength is initialized as follows: \n–  If TotalCoeff( coeff_token ) is greater than 10 and TrailingOnes( coeff_token ) is less than 3, suffixLength is set \nequal to 1. \n–  Otherwise (TotalCoeff( coeff_token ) is less than or equal to 10 or TrailingOnes( coeff_token ) is equal to 3), \nsuffixLength is set equal to 0. \nThen, when TotalCoeff( coeff_token ) − TrailingOnes( coeff_token ) is not equal to 0, the following ordered steps are \napplied TotalCoeff( coeff_token ) − TrailingOnes( coeff_token ) times to decode the remaining non-zero level values: \n1.  The syntax element level_prefix is decoded as specified in clause 9.2.2.1. \n2.  The variable levelSuffixSize is set as follows: \n–  If level_prefix is equal to 14 and suffixLength is equal to 0, levelSuffixSize is set equal to 4. \n–  Otherwise, if level_prefix is greater than or equal to 15, levelSuffixSize is set equal to level_prefix − 3. \n–  Otherwise, levelSuffixSize is set equal to suffixLength. \n3.  The syntax element level_suffix is decoded as follows: \n–  If levelSuffixSize is greater than 0, the syntax element level_suffix is decoded as unsigned integer \nrepresentation u(v) with levelSuffixSize bits. \n–  Otherwise (levelSuffixSize is equal to 0), the syntax element level_suffix is inferred to be equal to 0. \n4.  The variable levelCode is set equal to ( Min( 15, level_prefix ) << suffixLength ) + level_suffix. \n5.  When level_prefix is greater than or equal to 15 and suffixLength is equal to 0, levelCode is incremented by 15. \n6.  When level_prefix is greater than or equal to 16, levelCode is incremented by (1<<( level_prefix − 3 )) − 4096. \n7.  When the index i is equal to TrailingOnes( coeff_token ) and TrailingOnes( coeff_token ) is less than 3, levelCode \nis incremented by 2. \n8.  The variable levelVal[ i ] is derived as follows: \n–  If levelCode is an even number, levelVal[ i ] is set equal to ( levelCode + 2 ) >> 1. \n218  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (levelCode is an odd number), levelVal[ i ] is set equal to ( −levelCode − 1) >> 1. \n9.  When suffixLength is equal to 0, suffixLength is set equal to 1. \n10.  When the absolute value of levelVal[ i ] is greater than ( 3 << ( suffixLength − 1 ) ) and suffixLength is less than 6, \nsuffixLength is incremented by 1. \n11.  The index i is incremented by 1. \n9.2.2.1  Parsing process for level_prefix \nInputs to this process are bits from slice data. \nOutput of this process is level_prefix. \nThe parsing process for this syntax element consists in reading the bits starting at the current location in the bitstream up \nto and including the first non-zero bit, and counting the number of leading bits that are equal to 0. This process is specified \nas follows: \nleadingZeroBits = −1 \nfor( b = 0; !b; leadingZeroBits++ )   (9-4) \n  b = read_bits( 1 ) \nlevel_prefix = leadingZeroBits \nTable 9-6 illustrates the codeword table for level_prefix. \nNOTE – The value of level_prefix is constrained to not exceed 15 in bitstreams conforming to the Baseline, Constrained Baseline, \nMain, and Extended profiles, as specified in clauses A.2.1, A.2.1.1, A.2.2, and A.2.3, respectively. In bitstreams conforming to other \nprofiles, it has been reported that the value of level_prefix cannot exceed 11 + bitDepth with bitDepth being the variable BitDepth  \nY\nfor transform coefficient blocks related to the luma component and being the variable BitDepth  for transform coefficient blocks \nC\nrelated to a chroma component. \nTable 9-6 – Codeword table for level_prefix (informative) \nlevel_prefix  bit string \n0  1 \n1  01 \n2  001 \n3  0001 \n4  0000 1 \n5  0000 01 \n6  0000 001 \n7  0000 0001 \n8  0000 0000 1 \n9  0000 0000 01 \n10  0000 0000 001 \n11  0000 0000 0001 \n12  0000 0000 0000 1 \n13  0000 0000 0000 01 \n14  0000 0000 0000 001 \n15  0000 0000 0000 0001 \n…  … \n    Rec. ITU-T H.264 (06/2019)  219 \n \n9.2.3  Parsing process for run information \nInputs  to  this  process  are  bits  from  slice  data,  the  number  of  non-zero  transform  coefficient  levels \nTotalCoeff( coeff_token ), and the maximum number of non-zero transform coefficient levels maxNumCoeff. \nOutput of this process is a list of runs of zero transform coefficient levels preceding non-zero transform coefficient levels \ncalled runVal. \nInitially, an index i is set equal to 0. \nThe variable zerosLeft is derived as follows: \n–  If the number of non-zero transform coefficient levels TotalCoeff( coeff_token ) is equal to the maximum number of \nnon-zero transform coefficient levels maxNumCoeff, a variable zerosLeft is set equal to 0. \n–  Otherwise (the number of non-zero transform coefficient levels TotalCoeff( coeff_token ) is less than the maximum \nnumber of non-zero transform coefficient levels maxNumCoeff), total_zeros is decoded and zerosLeft is set equal to \nits value. \nThe variable tzVlcIndex is set equal to TotalCoeff( coeff_token ). \nThe VLC used to decode total_zeros is derived as follows: \n–  If maxNumCoeff is equal to 4, one of the VLCs specified in Table 9-9 (a) is used. \n–  Otherwise, if maxNumCoeff is equal to 8, one of the VLCs specified in Table 9-9 (b) is used. \n–  Otherwise (maxNumCoeff is not equal to 4 and not equal to 8), VLCs from Tables 9-7 and 9-8 are used. \nThe following ordered steps are then performed TotalCoeff( coeff_token ) − 1 times: \n1.  The variable runVal[ i ] is derived as follows: \n–  If zerosLeft is greater than zero, a value run_before is decoded based on Table 9-10 and zerosLeft. runVal[ i ] \nis set equal to run_before. \n–  Otherwise (zerosLeft is equal to 0), runVal[ i ] is set equal to 0. \n2.  The value of runVal[ i ] is subtracted from zerosLeft and the result is assigned to zerosLeft. It is a requirement of \nbitstream conformance that the result of the subtraction shall be greater than or equal to 0. \n3.  The index i is incremented by 1. \nFinally the value of zerosLeft is assigned to runVal[ i ]. \n220  Rec. ITU-T H.264 (06/2019) \n \nTable 9-7 – total_zeros tables for 4x4 blocks with tzVlcIndex 1 to 7 \ntotal_zeros  tzVlcIndex \n  1  2  3  4  5  6  7 \n0  1  111  0101  0001 1  0101  0000 01  0000 01 \n1  011  110  111  111  0100  0000 1  0000 1 \n2  010  101  110  0101  0011  111  101 \n3  0011  100  101  0100  111  110  100 \n4  0010  011  0100  110  110  101  011 \n5  0001 1  0101  0011  101  101  100  11 \n6  0001 0  0100  100  100  100  011  010 \n7  0000 11  0011  011  0011  011  010  0001 \n8  0000 10  0010  0010  011  0010  0001  001 \n9  0000 011  0001 1  0001 1  0010  0000 1  001  0000 00 \n10  0000 010  0001 0  0001 0  0001 0  0001  0000 00  - \n11  0000 0011  0000 11  0000 01  0000 1  0000 0  -  - \n12  0000 0010  0000 10  0000 1  0000 0  -  -  - \n13  0000 0001 1  0000 01  0000 00  -  -  -  - \n14  0000 0001 0  0000 00  -  -  -  -  - \n15  0000 0000 1  -  -  -  -  -  - \n \nTable 9-8 – total_zeros tables for 4x4 blocks with tzVlcIndex 8 to 15 \ntotal_zeros  tzVlcIndex \n  8  9  10  11  12  13  14  15 \n0  0000 01  0000 01  0000 1  0000  0000  000  00  0 \n1  0001  0000 00  0000 0  0001  0001  001  01  1 \n2  0000 1  0001  001  001  01  1  1  - \n3  011  11  11  010  1  01  -  - \n4  11  10  10  1  001  -  -  - \n5  10  001  01  011  -  -  -  - \n6  010  01  0001  -  -  -  -  - \n7  001  0000 1  -  -  -  -  -  - \n8  0000 00  -  -  -  -  -  -  - \n \n \n    Rec. ITU-T H.264 (06/2019)  221 \n \nTable 9-9 – total_zeros tables for chroma DC 2x2 and 2x4 blocks \n \n(a) Chroma DC 2x2 block (4:2:0 chroma sampling) \ntzVlcIndex \ntotal_zeros \n1  2  3 \n0  1  1  1 \n1  01  01  0 \n2  001  00  - \n3  000  -  - \n \n(b) Chroma DC 2x4 block (4:2:2 chroma sampling) \ntzVlcIndex \ntotal_zeros \n1  2  3  4  5  6  7 \n0  1  000  000  110  00  00  0 \n1  010  01  001  00  01  01  1 \n2  011  001  01  01  10  1  - \n3  0010  100  10  10  11  -  - \n4  0011  101  110  111  -  -  - \n5  0001  110  111  -  -  -  - \n6  0000 1  111  -  -  -  -  - \n7  0000 0  -  -  -  -  -  - \n \n222  Rec. ITU-T H.264 (06/2019) \n \nTable 9-10 – Tables for run_before \nrun_before  zerosLeft \n \n1  2  3  4  5  6  >6 \n0  1  1  11  11  11  11  111 \n1  0  01  10  10  10  000  110 \n2  -  00  01  01  011  001  101 \n3  -  -  00  001  010  011  100 \n4  -  -  -  000  001  010  011 \n5  -  -  -  -  000  101  010 \n6  -  -  -  -  -  100  001 \n7  -  -  -  -  -  -  0001 \n8    -  -  -  -  -  00001 \n9  -  -  -  -  -  -  000001 \n10  -  -  -  -  -  -  0000001 \n11  -  -  -  -  -  -  00000001 \n12  -  -  -  -  -  -  000000001 \n13  -  -  -  -  -  -  0000000001 \n14  -  -  -  -  -  -  00000000001 \n \n9.2.4  Combining level and run information \nInput to this process are a list of transform coefficient levels called levelVal, a list of runs called runVal, and the number \nof non-zero transform coefficient levels TotalCoeff( coeff_token ). \nOutput of this process is an list coeffLevel of transform coefficient levels. \nA variable coeffNum is set equal to −1 and an index i is set equal to TotalCoeff( coeff_token ) − 1. The following ordered \nsteps are then applied TotalCoeff( coeff_token ) times: \n1.  coeffNum is incremented by runVal[ i ] + 1. \n2.  coeffLevel[ coeffNum ] is set equal to levelVal[ i ]. \n3.  The index i is decremented by 1. \n9.3  CABAC parsing process for slice data \nThis  process  is  invoked  when  parsing  syntax  elements  with  descriptor  ae(v)  in  clauses 7.3.4  and  7.3.5  when \nentropy_coding_mode_flag is equal to 1. \nInputs to this process are a request for a value of a syntax element and values of prior parsed syntax elements. \nOutput of this process is the value of the syntax element. \nWhen starting the parsing of the slice data of a slice in clause 7.3.4, the initialization process of the CABAC parsing process \nis invoked as specified in clause 9.3.1. \nThe parsing of syntax elements proceeds as follows. \nFor each requested value of a syntax element a binarization is derived as described in clause 9.3.2. \nThe binarization for the syntax element and the sequence of parsed bins determines the decoding process flow as described \nin clause 9.3.3. \n    Rec. ITU-T H.264 (06/2019)  223 \n \nFor each bin of the binarization of the syntax element, which is indexed by the variable binIdx, a context index ctxIdx is \nderived as specified in clause 9.3.3.1. \nFor each ctxIdx the arithmetic decoding process is invoked as specified in clause 9.3.3.2. \nThe resulting sequence ( b ..b  ) of parsed bins is compared to the set of bin strings given by the binarization process \n0 binIdx\nafter decoding of each bin. When the sequence matches a bin string in the given set, the corresponding value is assigned \nto the syntax element. \nIn case the request for a value of a syntax element is processed for the syntax element mb_type and the decoded value of \nmb_type is equal to I_PCM, the decoding engine is initialized after the decoding of any pcm_alignment_zero_bit and all \npcm_sample_luma and pcm_sample_chroma data as specified in clause 9.3.1.2. \nThe whole CABAC parsing process is illustrated in the flowchart of Figure 9-1 with the abbreviation SE for syntax element. \n224  Rec. ITU-T H.264 (06/2019) \n \n \nFigure 9-1 – Illustration of CABAC parsing process for a syntax element SE (informative) \n9.3.1  Initialization process \nOutputs of this process are initialized CABAC internal variables. \nThe processes in clauses 9.3.1.1 and 9.3.1.2 are invoked when starting the parsing of the slice data of a slice in clause 7.3.4. \nThe process in clause 9.3.1.2 is also invoked after decoding any pcm_alignment_zero_bit and all pcm_sample_luma and \npcm_sample_chroma data for a macroblock of type I_PCM. \n9.3.1.1  Initialization process for context variables \nOutputs of this process are the initialized CABAC context variables indexed by ctxIdx. \n    Rec. ITU-T H.264 (06/2019)  225 \n \nTables 9-12 to 9-33 contain the values of the variables n and m used in the initialization of context variables that are \nassigned to all syntax elements in clauses 7.3.4 and 7.3.5 except for the end-of-slice flag. \nFor each context variable, the two variables pStateIdx and valMPS are initialized. \nNOTE 1 – The variable pStateIdx corresponds to a probability state index and the variable valMPS corresponds to the value of the \nmost probable symbol as further described in clause 9.3.3.2. \nThe two values assigned to pStateIdx and valMPS for the initialization are derived from SliceQP , which is derived in \nY\nEquation 7-30. Given the two table entries ( m, n ), the initialization is specified by the following pseudo-code process: \npreCtxState = Clip3( 1, 126, ( ( m  Clip3( 0, 51, SliceQP  ) ) >> 4 ) + n ) \nY\nif( preCtxState  <=  63 )  { \n  pStateIdx = 63 − preCtxState \n  valMPS = 0  (9-5) \n} else { \n  pStateIdx = preCtxState − 64 \n  valMPS = 1 \n} \nIn Table 9-11, the ctxIdx for which initialization is needed for each of the slice types are listed. Also listed is the table \nnumber that includes the values of m and n needed for the initialization. For P, SP and B slice type, the initialization \ndepends also on the value of the cabac_init_idc syntax element. Note that the syntax element names do not affect the \ninitialization process. \n226  Rec. ITU-T H.264 (06/2019) \n \nTable 9-11 – Association of ctxIdx and syntax elements for each slice type in the initialization process \nSlice type \n  Syntax element  Table \nSI  I  P, SP  B \nTable 9-13 \nmb_skip_flag      11..13  24..26 \nTable 9-14 \nslice_data( ) \nmb_field_decoding_flag  Table 9-18  70..72  70..72  70..72  70..72 \nTable 9-12 \nmb_type  Table 9-13  0..10  3..10  14..20  27..35 \nTable 9-14 \ntransform_size_8x8_flag  Table 9-16  na  399..401  399..401  399..401 \nmacroblock_layer( ) \ncoded_block_pattern (luma)  Table 9-18  73..76  73..76  73..76  73..76 \ncoded_block_pattern (chroma)  Table 9-18  77..84  77..84  77..84  77..84 \nmb_qp_delta  Table 9-17  60..63  60..63  60..63  60..63 \nprev_intra4x4_pred_mode_flag  Table 9-17  68  68  68  68 \nrem_intra4x4_pred_mode  Table 9-17  69  69  69  69 \nmb_pred( )  prev_intra8x8_pred_mode_flag  Table 9-17  na  68  68  68 \nrem_intra8x8_pred_mode  Table 9-17  na  69  69  69 \nintra_chroma_pred_mode  Table 9-17  64..67  64..67  64..67  64..67 \nref_idx_l0  Table 9-16      54..59  54..59 \nref_idx_l1  Table 9-16        54..59 \nmvd_l0[ ][ ][ 0 ]  Table 9-15      40..46  40..46 \nmb_pred( ) and \nsub_mb_pred( ) \nmvd_l1[ ][ ][ 0 ]  Table 9-15        40..46 \nmvd_l0[ ][ ][ 1 ]  Table 9-15      47..53  47..53 \nmvd_l1[ ][ ][ 1 ]  Table 9-15        47..53 \nTable 9-13 \nsub_mb_pred( )  sub_mb_type[ ]      21..23  36..39 \nTable 9-14 \n    Rec. ITU-T H.264 (06/2019)  227 \n \nTable 9-11 – Association of ctxIdx and syntax elements for each slice type in the initialization process \nSlice type \n  Syntax element  Table \nSI  I  P, SP  B \nTable 9-18  85..104  85..104  85..104  85..104 \ncoded_block_flag  Table 9-25  460..483  460..483  460..483  460..483 \nTable 9-33    1012..1023  1012..1023  1012..1023 \nTable 9-19  105..165  105..165  105..165  105..165 \nTable 9-22  277..337  277..337  277..337  277..337 \nTable 9-24    402..416  402..416  402..416 \nTable 9-24    436..450  436..450  436..450 \nsignificant_coeff_flag[ ] \nTable 9-26    484..571  484..571  484..571 \nTable 9-30    776..863  776..863  776..863 \nTable 9-28    660..689  660..689  660..689 \nTable 9-29    718..747  718..747  718..747 \nresidual_block_cabac( )  Table 9-20  166..226  166..226  166..226  166..226 \nTable 9-23  338..398  338..398  338..398  338..398 \nTable 9-24    417..425  417..425  417..425 \nTable 9-24    451..459  451..459  451..459 \nlast_significant_coeff_flag[ ] \nTable 9-27    572..659  572..659  572..659 \nTable 9-31    864..951  864..951  864..951 \nTable 9-28    690..707  690..707  690..707 \nTable 9-29    748..765  748..765  748..765 \nTable 9-21  227..275  227..275  227..275  227..275 \nTable 9-24    426..435  426..435  426..435 \ncoeff_abs_level_minus1[ ]  Table 9-32    952..1011  952..1011  952..1011 \nTable 9-28    708..717  708..717  708..717 \nTable 9-29    766..775  766..775  766..775 \n \n \nNOTE 2 – ctxIdx equal to 276 is associated with the end_of_slice_flag and the bin of mb_type, which specifies the I_PCM \nmacroblock type. The decoding process specified in clause 9.3.3.2.4 applies to ctxIdx equal to 276. This decoding process, however, \nmay also be implemented by using the decoding process specified in clause 9.3.3.2.1. In this case, the initial values associated with \nctxIdx equal to 276 are specified to be pStateIdx = 63 and valMPS = 0, where pStateIdx = 63 represents a non-adapting probability \nstate. \nTable 9-12 – Values of variables m and n for ctxIdx from 0 to 10 \nctxIdx \nInitialization \nvariables \n0  1  2  3  4  5  6  7  8  9  10 \nm  20  2  3  20  2  3  −28  −23  −6  −1  7 \nn  −15  54  74  −15  54  74  127  104  53  54  51 \n \nTable 9-13 – Values of variables m and n for ctxIdx from 11 to 23 \nctxIdx \nValue of  Initialization \ncabac_init_idc  variables \n11  12  13  14  15  16  17  18  19  20  21  22  23 \n0  m  23  23  21  1  0  −37  5  −13  −11  1  12  −4  17 \nn  33  2  0  9  49  118  57  78  65  62  49  73  50 \n1  m  22  34  16  −2  4  −29  2  −6  −13  5  9  −3  10 \nn  25  0  0  9  41  118  65  71  79  52  50  70  54 \n2  m  29  25  14  −10  −3  −27  26  −4  −24  5  6  −17  14 \nn  16  0  0  51  62  99  16  85  102  57  57  73  57 \n \n228  Rec. ITU-T H.264 (06/2019) \n \n \nTable 9-14 – Values of variables m and n for ctxIdx from 24 to 39 \nctxIdx \nValue of  Initializatio\ncabac_init_idc  n variables \n24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39 \n0  m  9  −4 −2 −1 −1 −1\n18  9  29  26  16  1  1  −6  −6  9 \n6  0  3  1  7 \nn  64  43  0  67  90  104  127  104  67  78  65  62  86  95  61  45 \n1  m  26  −4 −1 −1 −1\n26  19  40  57  41  −4  −6  5  6  0  8 \n5  5  3  3 \nn  34  22  0  2  36  69  127  101  76  71  79  52  69  90  52  43 \n2  m  12  −3 −2 −2 −1\n20  20  29  54  37  −2  −4  5  −6  −6  4 \n2  2  4  4 \nn  40  10  0  0  42  97  127  117  74  85  102  57  93  88  44  55 \n \n \nTable 9-15 – Values of variables m and n for ctxIdx from 40 to 53 \nctxIdx \nValue of  Initialization \ncabac_init_idc  variables \n40  41  42  43  44  45  46  47  48  49  50  51  52  53 \n0  m  −3  −6  −11  6  7  −5  2  0  −3  −10  5  4  −3  0 \nn  69  81  96  55  67  86  88  58  76  94  54  69  81  88 \n1  m  −2  −5  −10  2   2  −3  −3  1  −3  −6  0  −3  −7  −5 \nn  69  82  96  59  75  87  100  56  74  85  59  81  86  95 \n2  m  −11  −15  −21  19  20  4  6  1  −5  −13  5  6  −3  −1 \nn  89  103  116  57  58  84  96  63  85  106  63  75  90  101 \n \n \nTable 9-16 – Values of variables m and n for ctxIdx from 54 to 59, and 399 to 401 \nctxIdx \nValue of cabac_init_idc  Initialization variables \n54  55  56  57  58  59  399  400  401 \nI slices  m  na  na  na  na  na  na  31  31  25 \nn  na  na  na  na  na  na  21  31  50 \n0  m  −7  −5  −4  −5  −7  1  12  11  14 \nn  67  74  74  80  72  58  40  51  59 \n1  m  −1  −1  1  −2  −5  0  25  21  21 \nn  66  77  70  86  72  61  32  49  54 \n2  m  3  −4  −2  −12  −7  1  21  19  17 \nn  55  79  75  97  50  60  33  50  61 \n \n    Rec. ITU-T H.264 (06/2019)  229 \n \nTable 9-17 – Values of variables m and n for ctxIdx from 60 to 69 \nctxIdx \nInitialization \nvariables \n60  61  62  63  64  65  66  67  68  69 \nm  0  0  0  0  −9  4  0  −7  13  3 \nn  41  63  63  63  83  86  97  72  41  62 \n \nTable 9-18 – Values of variables m and n for ctxIdx from 70 to 104 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n70  0  11  0  45  13  15  7  34  88  −11  115  −13  108  −4  92  5  78 \n71  1  55  −4  78  7  51  −9  88  89  −12  63  −3  46  0  39  −6  55 \n72  0  69  −3  96  2  80  −20  127  90  −2  68  −1  65  0  65  4  61 \n73  −17  127  −27  126  −39  127  −36  127  91  −15  84  −1  57  −15  84  −14  83 \n74  −13  102  −28  98  −18  91  −17  91  92  −13  104  −9  93  −35  127  −37  127 \n75  0  82  −25  101  −17  96  −14  95  93  −3  70  −3  74  −2  73  −5  79 \n76  −7  74  −23  67  −26  81  −25  84  94  −8  93  −9  92  −12  104  −11  104 \n77  −21  107  −28  82  −35  98  −25  86  95  −10  90  −8  87  −9  91  −11  91 \n78  −27  127  −20  94  −24  102  −12  89  96  −30  127  −23  126  −31  127  −30  127 \n79  −31  127  −16  83  −23  97  −17  91  97  −1  74  5  54  3  55  0  65 \n80  −24  127  −22  110  −27  119  −31  127  98  −6  97  6  60  7  56  −2  79 \n81  −18  95  −21  91  −24  99  −14  76  99  −7  91  6  59  7  55  0  72 \n82  −27  127  −18  102  −21  110  −18  103  100  −20  127  6  69  8  61  −4  92 \n83  −21  114  −13  93  −18  102  −13  90  101  −4  56  −1  48  −3  53  −6  56 \n84  −30  127  −29  127  −36  127  −37  127  102  −5  82  0  68  0  68  3  68 \n85  −17  123  −7  92  0  80  11  80  103  −7  76  −4  69  −7  74  −8  71 \n86  −12  115  −5  89  −5  89  5  76  104  −22  125  −8  88  −9  88  −13  98 \n87  −16  122  −7  96  −7  94  2  84                   \n \n230  Rec. ITU-T H.264 (06/2019) \n \nTable 9-19 – Values of variables m and n for ctxIdx from 105 to 165 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n105  −7  93  −2  85  −13  103  −4  86  136  −13  101  5  53  0  58  −5  75 \n106  −11  87  −6  78  −13  91  −12  88  137  −13  91  −2  61  −1  60  −8  80 \n107  −3  77  −1  75  −9  89  −5  82  138  −12  94  0  56  −3  61  −21  83 \n108  −5  71  −7  77  −14  92  −3  72  139  −10  88  0  56  −8  67  −21  64 \n109  −4  63  2  54  −8  76  −4  67  140  −16  84  −13  63  −25  84  −13  31 \n110  −4  68  5  50  −12  87  −8  72  141  −10  86  −5  60  −14  74  −25  64 \n111  −12  84  −3  68  −23  110  −16  89  142  −7  83  −1  62  −5  65  −29  94 \n112  −7  62  1  50  −24  105  −9  69  143  −13  87  4  57  5  52  9  75 \n113  −7  65  6  42  −10  78  −1  59  144  −19  94  −6  69  2  57  17  63 \n114  8  61  −4  81  −20  112  5  66  145  1  70  4  57  0  61  −8  74 \n115  5  56  1  63  −17  99  4  57  146  0  72  14  39  −9  69  −5  35 \n116  −2  66  −4  70  −78  127  −4  71  147  −5  74  4  51  −11  70  −2  27 \n117  1  64  0  67  −70  127  −2  71  148  18  59  13  68  18  55  13  91 \n118  0  61  2  57  −50  127  2  58  149  −8  102  3  64  −4  71  3  65 \n119  −2  78  −2  76  −46  127  −1  74  150  −15  100  1  61  0  58  −7  69 \n120  1  50  11  35  −4  66  −4  44  151  0  95  9  63  7  61  8  77 \n121  7  52  4  64  −5  78  −1  69  152  −4  75  7  50  9  41  −10  66 \n122  10  35  1  61  −4  71  0  62  153  2  72  16  39  18  25  3  62 \n123  0  44  11  35  −8  72  −7  51  154  −11  75  5  44  9  32  −3  68 \n124  11  38  18  25  2  59  −4  47  155  −3  71  4  52  5  43  −20  81 \n125  1  45  12  24  −1  55  −6  42  156  15  46  11  48  9  47  0  30 \n126  0  46  13  29  −7  70  −3  41  157  −13  69  −5  60  0  44  1  7 \n127  5  44  13  36  −6  75  −6  53  158  0  62  −1  59  0  51  −3  23 \n128  31  17  −10  93  −8  89  8  76  159  0  65  0  59  2  46  −21  74 \n129  1  51  −7  73  −34  119  −9  78  160  21  37  22  33  19  38  16  66 \n130  7  50  −2  73  −3  75  −11  83  161  −15  72  5  44  −4  66  −23  124 \n131  28  19  13  46  32  20  9  52  162  9  57  14  43  15  38  17  37 \n132  16  33  9  49  30  22  0  67  163  16  54  −1  78  12  42  44  −18 \n133  14  62  −7  100  −44  127  −5  90  164  0  62  0  60  9  34  50  −34 \n134  −13  108  9  53  0  54  1  67  165  12  72  9  69  0  89  −22  127 \n135  −15  100  2  53  −5  61  −15  72                   \n \n \n    Rec. ITU-T H.264 (06/2019)  231 \n \nTable 9-20 – Values of variables m and n for ctxIdx from 166 to 226 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n166  24  0  11  28  4  45  4  39  197  26  −17  28  3  36  −28  28  −3 \n167  15  9  2  40  10  28  0  42  198  30  −25  28  4  38  −28  24  10 \n168  8  25  3  44  10  31  7  34  199  28  −20  32  0  38  −27  27  0 \n169  13  18  0  49  33  −11  11  29  200  33  −23  34  −1  34  −18  34  −14 \n170  15  9  0  46  52  −43  8  31  201  37  −27  30  6  35  −16  52  −44 \n171  13  19  2  44  18  15  6  37  202  33  −23  30  6  34  −14  39  −24 \n172  10  37  2  51  28  0  7  42  203  40  −28  32  9  32  −8  19  17 \n173  12  18  0  47  35  −22  3  40  204  38  −17  31  19  37  −6  31  25 \n174  6  29  4  39  38  −25  8  33  205  33  −11  26  27  35  0  36  29 \n175  20  33  2  62  34  0  13  43  206  40  −15  26  30  30  10  24  33 \n176  15  30  6  46  39  −18  13  36  207  41  −6  37  20  28  18  34  15 \n177  4  45  0  54  32  −12  4  47  208  38  1  28  34  26  25  30  20 \n178  1  58  3  54  102  −94  3  55  209  41  17  17  70  29  41  22  73 \n179  0  62  2  58  0  0  2  58  210  30  −6  1  67  0  75  20  34 \n180  7  61  4  63  56  −15  6  60  211  27  3  5  59  2  72  19  31 \n181  12  38  6  51  33  −4  8  44  212  26  22  9  67  8  77  27  44 \n182  11  45  6  57  29  10  11  44  213  37  −16  16  30  14  35  19  16 \n183  15  39  7  53  37  −5  14  42  214  35  −4  18  32  18  31  15  36 \n184  11  42  6  52  51  −29  7  48  215  38  −8  18  35  17  35  15  36 \n185  13  44  6  55  39  −9  4  56  216  38  −3  22  29  21  30  21  28 \n186  16  45  11  45  52  −34  4  52  217  37  3  24  31  17  45  25  21 \n187  12  41  14  36  69  −58  13  37  218  38  5  23  38  20  42  30  20 \n188  10  49  8  53  67  −63  9  49  219  42  0  18  43  18  45  31  12 \n189  30  34  −1  82  44  −5  19  58  220  35  16  20  41  27  26  27  16 \n190  18  42  7  55  32  7  10  48  221  39  22  11  63  16  54  24  42 \n191  10  55  −3  78  55  −29  12  45  222  14  48  9  59  7  66  0  93 \n192  17  51  15  46  32  1  0  69  223  27  37  9  64  16  56  14  56 \n193  17  46  22  31  0  0  20  33  224  21  60  −1  94  11  73  15  57 \n194  0  89  −1  84  27  36  8  63  225  12  68  −2  89  10  67  26  38 \n195  26  −19  25  7  33  −25  35  −18  226  2  97  −9  108  −10  116  −24  127 \n196  22  −17  30  −7  34  −30  33  −25                   \n \n232  Rec. ITU-T H.264 (06/2019) \n \nTable 9-21 – Values of variables m and n for ctxIdx from 227 to 275 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n227  −3  71  −6  76  −23  112  −24  115  252  −12  73  −6  55  −16  72  −14  75 \n228  −6  42  −2  44  −15  71  −22  82  253  −8  76  0  58  −7  69  −10  79 \n229  −5  50  0  45  −7  61  −9  62  254  −7  80  0  64  −4  69  −9  83 \n230  −3  54  0  52  0  53  0  53  255  −9  88  −3  74  −5  74  −12  92 \n231  −2  62  −3  64  −5  66  0  59  256  −17  110  −10  90  −9  86  −18  108 \n232  0  58  −2  59  −11  77  −14  85  257  −11  97  0  70  2  66  −4  79 \n233  1  63  −4  70  −9  80  −13  89  258  −20  84  −4  29  −9  34  −22  69 \n234  −2  72  −4  75  −9  84  −13  94  259  −11  79  5  31  1  32  −16  75 \n235  −1  74  −8  82  −10  87  −11  92  260  −6  73  7  42  11  31  −2  58 \n236  −9  91  −17  102  −34  127  −29  127  261  −4  74  1  59  5  52  1  58 \n237  −5  67  −9  77  −21  101  −21  100  262  −13  86  −2  58  −2  55  −13  78 \n238  −5  27  3  24  −3  39  −14  57  263  −13  96  −3  72  −2  67  −9  83 \n239  −3  39  0  42  −5  53  −12  67  264  −11  97  −3  81  0  73  −4  81 \n240  −2  44  0  48  −7  61  −11  71  265  −19  117  −11  97  −8  89  −13  99 \n241  0  46  0  55  −11  75  −10  77  266  −8  78  0  58  3  52  −13  81 \n242  −16  64  −6  59  −15  77  −21  85  267  −5  33  8  5  7  4  −6  38 \n243  −8  68  −7  71  −17  91  −16  88  268  −4  48  10  14  10  8  −13  62 \n244  −10  78  −12  83  −25  107  −23  104  269  −2  53  14  18  17  8  −6  58 \n245  −6  77  −11  87  −25  111  −15  98  270  −3  62  13  27  16  19  −2  59 \n246  −10  86  −30  119  −28  122  −37  127  271  −13  71  2  40  3  37  −16  73 \n247  −12  92  1  58  −11  76  −10  82  272  −10  79  0  58  −1  61  −10  76 \n248  −15  55  −3  29  −10  44  −8  48  273  −12  86  −3  70  −5  73  −13  86 \n249  −10  60  −1  36  −10  52  −8  61  274  −13  90  −6  79  −1  70  −9  83 \n250  −6  62  1  38  −10  57  −8  66  275  −14  97  −8  85  −4  78  −10  87 \n251  −4  65  2  43  −9  58  −7  70                   \n \n    Rec. ITU-T H.264 (06/2019)  233 \n \nTable 9-22 – Values of variables m and n for ctxIdx from 277 to 337 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n277  −6  93  −13  106  −21  126  −22  127  308  −16  96  −1  51  −16  77  −10  67 \n278  −6  84  −16  106  −23  124  −25  127  309  −7  88  7  49  −2  64  1  68 \n279  −8  79  −10  87  −20  110  −25  120  310  −8  85  8  52  2  61  0  77 \n280  0  66  −21  114  −26  126  −27  127  311  −7  85  9  41  −6  67  2  64 \n281  −1  71  −18  110  −25  124  −19  114  312  −9  85  6  47  −3  64  0  68 \n282  0  62  −14  98  −17  105  −23  117  313  −13  88  2  55  2  57  −5  78 \n283  −2  60  −22  110  −27  121  −25  118  314  4  66  13  41  −3  65  7  55 \n284  −2  59  −21  106  −27  117  −26  117  315  −3  77  10  44  −3  66  5  59 \n285  −5  75  −18  103  −17  102  −24  113  316  −3  76  6  50  0  62  2  65 \n286  −3  62  −21  107  −26  117  −28  118  317  −6  76  5  53  9  51  14  54 \n287  −4  58  −23  108  −27  116  −31  120  318  10  58  13  49  −1  66  15  44 \n288  −9  66  −26  112  −33  122  −37  124  319  −1  76  4  63  −2  71  5  60 \n289  −1  79  −10  96  −10  95  −10  94  320  −1  83  6  64  −2  75  2  70 \n290  0  71  −12  95  −14  100  −15  102  321  −7  99  −2  69  −1  70  −2  76 \n291  3  68  −5  91  −8  95  −10  99  322  −14  95  −2  59  −9  72  −18  86 \n292  10  44  −9  93  −17  111  −13  106  323  2  95  6  70  14  60  12  70 \n293  −7  62  −22  94  −28  114  −50  127  324  0  76  10  44  16  37  5  64 \n294  15  36  −5  86  −6  89  −5  92  325  −5  74  9  31  0  47  −12  70 \n295  14  40  9  67  −2  80  17  57  326  0  70  12  43  18  35  11  55 \n296  16  27  −4  80  −4  82  −5  86  327  −11  75  3  53  11  37  5  56 \n297  12  29  −10  85  −9  85  −13  94  328  1  68  14  34  12  41  0  69 \n298  1  44  −1  70  −8  81  −12  91  329  0  65  10  38  10  41  2  65 \n299  20  36  7  60  −1  72  −2  77  330  −14  73  −3  52  2  48  −6  74 \n300  18  32  9  58  5  64  0  71  331  3  62  13  40  12  41  5  54 \n301  5  42  5  61  1  67  −1  73  332  4  62  17  32  13  41  7  54 \n302  1  48  12  50  9  56  4  64  333  −1  68  7  44  0  59  −6  76 \n303  10  62  15  50  0  69  −7  81  334  −13  75  7  38  3  50  −11  82 \n304  17  46  18  49  1  69  5  64  335  11  55  13  50  19  40  −2  77 \n305  9  64  17  54  7  69  15  57  336  5  64  10  57  3  66  −2  77 \n306  −12  104  10  41  −7  69  1  67  337  12  70  26  43  18  50  25  42 \n307  −11  97  7  46  −6  67  0  68                   \n \n234  Rec. ITU-T H.264 (06/2019) \n \nTable 9-23 – Values of variables m and n for ctxIdx from 338 to 398 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n338  15  6  14  11  19  −6  17  −13  369  32  −26  31  −4  40  −37  37  −17 \n339  6  19  11  14  18  −6  16  −9  370  37  −30  27  6  38  −30  32  1 \n340  7  16  9  11  14  0  17  −12  371  44  −32  34  8  46  −33  34  15 \n341  12  14  18  11  26  −12  27  −21  372  34  −18  30  10  42  −30  29  15 \n342  18  13  21  9  31  −16  37  −30  373  34  −15  24  22  40  −24  24  25 \n343  13  11  23  −2  33  −25  41  −40  374  40  −15  33  19  49  −29  34  22 \n344  13  15  32  −15  33  −22  42  −41  375  33  −7  22  32  38  −12  31  16 \n345  15  16  32  −15  37  −28  48  −47  376  35  −5  26  31  40  −10  35  18 \n346  12  23  34  −21  39  −30  39  −32  377  33  0  21  41  38  −3  31  28 \n347  13  23  39  −23  42  −30  46  −40  378  38  2  26  44  46  −5  33  41 \n348  15  20  42  −33  47  −42  52  −51  379  33  13  23  47  31  20  36  28 \n349  14  26  41  −31  45  −36  46  −41  380  23  35  16  65  29  30  27  47 \n350  14  44  46  −28  49  −34  52  −39  381  13  58  14  71  25  44  21  62 \n351  17  40  38  −12  41  −17  43  −19  382  29  −3  8  60  12  48  18  31 \n352  17  47  21  29  32  9  32  11  383  26  0  6  63  11  49  19  26 \n353  24  17  45  −24  69  −71  61  −55  384  22  30  17  65  26  45  36  24 \n354  21  21  53  −45  63  −63  56  −46  385  31  −7  21  24  22  22  24  23 \n355  25  22  48  −26  66  −64  62  −50  386  35  −15  23  20  23  22  27  16 \n356  31  27  65  −43  77  −74  81  −67  387  34  −3  26  23  27  21  24  30 \n357  22  29  43  −19  54  −39  45  −20  388  34  3  27  32  33  20  31  29 \n358  19  35  39  −10  52  −35  35  −2  389  36  −1  28  23  26  28  22  41 \n359  14  50  30  9  41  −10  28  15  390  34  5  28  24  30  24  22  42 \n360  10  57  18  26  36  0  34  1  391  32  11  23  40  27  34  16  60 \n361  7  63  20  27  40  −1  39  1  392  35  5  24  32  18  42  15  52 \n362  −2  77  0  57  30  14  30  17  393  34  12  28  29  25  39  14  60 \n363  −4  82  −14  82  28  26  20  38  394  39  11  23  42  18  50  3  78 \n364  −3  94  −5  75  23  37  18  45  395  30  29  19  57  12  70  −16  123 \n365  9  69  −19  97  12  55  15  54  396  34  26  22  53  21  54  21  53 \n366  −12  109  −35  125  11  65  0  79  397  29  39  22  61  14  71  22  56 \n367  36  −35  27  0  37  −33  36  −16  398  19  66  11  86  11  83  25  61 \n368  36  −34  28  0  39  −36  37  −14                   \n \n    Rec. ITU-T H.264 (06/2019)  235 \n \nTable 9-24 – Values of variables m and n for ctxIdx from 402 to 459 \nI   Value of cabac_init_idc  Value of cabac_init_idc \nI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n402  −17  120  −4  79  −5  85  −3  78  431  −2  55  −12  56  −9  57  −12  59 \n403  −20  112  −7  71  −6  81  −8  74  432  0  61  −6  60  −6  63  −8  63 \n404  −18  114  −5  69  −10  77  −9  72  433  1  64  −5  62  −4  65  −9  67 \n405  −11  85  −9  70  −7  81  −10  72  434  0  68  −8  66  −4  67  −6  68 \n406  −15  92  −8  66  −17  80  −18  75  435  −9  92  −8  76  −7  82  −10  79 \n407  −14  89  −10  68  −18  73  −12  71  436  −14  106  −5  85  −3  81  −3  78 \n408  −26  71  −19  73  −4  74  −11  63  437  −13  97  −6  81  −3  76  −8  74 \n409  −15  81  −12  69  −10  83  −5  70  438  −15  90  −10  77  −7  72  −9  72 \n410  −14  80  −16  70  −9  71  −17  75  439  −12  90  −7  81  −6  78  −10  72 \n411  0  68  −15  67  −9  67  −14  72  440  −18  88  −17  80  −12  72  −18  75 \n412  −14  70  −20  62  −1  61  −16  67  441  −10  73  −18  73  −14  68  −12  71 \n413  −24  56  −19  70  −8  66  −8  53  442  −9  79  −4  74  −3  70  −11  63 \n414  −23  68  −16  66  −14  66  −14  59  443  −14  86  −10  83  −6  76  −5  70 \n415  −24  50  −22  65  0  59  −9  52  444  −10  73  −9  71  −5  66  −17  75 \n416  −11  74  −20  63  2  59  −11  68  445  −10  70  −9  67  −5  62  −14  72 \n417  23  −13  9  −2  17  −10  9  −2  446  −10  69  −1  61  0  57  −16  67 \n418  26  −13  26  −9  32  −13  30  −10  447  −5  66  −8  66  −4  61  −8  53 \n419  40  −15  33  −9  42  −9  31  −4  448  −9  64  −14  66  −9  60  −14  59 \n420  49  −14  39  −7  49  −5  33  −1  449  −5  58  0  59  1  54  −9  52 \n421  44  3  41  −2  53  0  33  7  450  2  59  2  59  2  58  −11  68 \n422  45  6  45  3  64  3  31  12  451  21  −10  21  −13  17  −10  9  −2 \n423  44  34  49  9  68  10  37  23  452  24  −11  33  −14  32  −13  30  −10 \n424  33  54  45  27  66  27  31  38  453  28  −8  39  −7  42  −9  31  −4 \n425  19  82  36  59  47  57  20  64  454  28  −1  46  −2  49  −5  33  −1 \n426  −3  75  −6  66  −5  71  −9  71  455  29  3  51  2  53  0  33  7 \n427  −1  23  −7  35  0  24  −7  37  456  29  9  60  6  64  3  31  12 \n428  1  34  −7  42  −1  36  −8  44  457  35  20  61  17  68  10  37  23 \n429  1  43  −8  45  −2  42  −11  49  458  29  36  55  34  66  27  31  38 \n430  0  54  −5  48  −2  52  −10  56  459  14  67  42  62  47  57  20  64 \n \n236  Rec. ITU-T H.264 (06/2019) \n \nTable 9-25 – Values of variables m and n for ctxIdx from 460 to 483 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n460  −17  123  −7  92  0  80  11  80  472  −17  123  −7  92  0  80  11  80 \n461  −12  115  −5  89  −5  89  5  76  473  −12  115  −5  89  −5  89  5  76 \n462  −16  122  −7  96  −7  94  2  84  474  −16  122  −7  96  −7  94  2  84 \n463  −11  115  −13  108  −4  92  5  78  475  −11  115  −13  108  −4  92  5  78 \n464  −12  63  −3  46  0  39  −6  55  476  −12  63  −3  46  0  39  −6  55 \n465  −2  68  −1  65  0  65  4  61  477  −2  68  −1  65  0  65  4  61 \n466  −15  84  −1  57  −15  84  −14  83  478  −15  84  −1  57  −15  84  −14  83 \n467  −13  104  −9  93  −35  127  −37  127  479  −13  104  −9  93  −35  127  −37  127 \n468  −3  70  −3  74  −2  73  −5  79  480  −3  70  −3  74  −2  73  −5  79 \n469  −8  93  −9  92  −12  104  −11  104  481  −8  93  −9  92  −12  104  −11  104 \n470  −10  90  −8  87  −9  91  −11  91  482  −10  90  −8  87  −9  91  −11  91 \n471  −30  127  −23  126  −31  127  −30  127  483  −30  127  −23  126  −31  127  −30  127 \n \nTable 9-26 – Values of variables m and n for ctxIdx from 484 to 571 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n484  −7  93  −2  85  −13  103  −4  86  528  −7  93  −2  85  −13  103  −4  86 \n485  −11  87  −6  78  −13  91  −12  88  529  −11  87  −6  78  −13  91  −12  88 \n486  −3  77  −1  75  −9  89  −5  82  530  −3  77  −1  75  −9  89  −5  82 \n487  −5  71  −7  77  −14  92  −3  72  531  −5  71  −7  77  −14  92  −3  72 \n488  −4  63  2  54  −8  76  −4  67  532  −4  63  2  54  −8  76  −4  67 \n489  −4  68  5  50  −12  87  −8  72  533  −4  68  5  50  −12  87  −8  72 \n490  −12  84  −3  68  −23  110  −16  89  534  −12  84  −3  68  −23  110  −16  89 \n491  −7  62  1  50  −24  105  −9  69  535  −7  62  1  50  −24  105  −9  69 \n492  −7  65  6  42  −10  78  −1  59  536  −7  65  6  42  −10  78  −1  59 \n493  8  61  −4  81  −20  112  5  66  537  8  61  −4  81  −20  112  5  66 \n494  5  56  1  63  −17  99  4  57  538  5  56  1  63  −17  99  4  57 \n495  −2  66  −4  70  −78  127  −4  71  539  −2  66  −4  70  −78  127  −4  71 \n496  1  64  0  67  −70  127  −2  71  540  1  64  0  67  −70  127  −2  71 \n497  0  61  2  57  −50  127  2  58  641  0  61  2  57  −50  127  2  58 \n498  −2  78  −2  76  −46  127  −1  74  542  −2  78  −2  76  −46  127  −1  74 \n    Rec. ITU-T H.264 (06/2019)  237 \n \nTable 9-26 – Values of variables m and n for ctxIdx from 484 to 571 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n499  1  50  11  35  −4  66  −4  44  543  1  50  11  35  −4  66  −4  44 \n500  7  52  4  64  −5  78  −1  69  544  7  52  4  64  −5  78  −1  69 \n501  10  35  1  61  −4  71  0  62  545  10  35  1  61  −4  71  0  62 \n502  0  44  11  35  −8  72  −7  51  546  0  44  11  35  −8  72  −7  51 \n503  11  38  18  25  2  59  −4  47  547  11  38  18  25  2  59  −4  47 \n504  1  45  12  24  −1  55  −6  42  548  1  45  12  24  −1  55  −6  42 \n505  0  46  13  29  −7  70  −3  41  549  0  46  13  29  −7  70  −3  41 \n506  5  44  13  36  −6  75  −6  53  550  5  44  13  36  −6  75  −6  53 \n507  31  17  −10  93  −8  89  8  76  551  31  17  −10  93  −8  89  8  76 \n508  1  51  −7  73  −34  119  −9  78  552  1  51  −7  73  −34  119  −9  78 \n509  7  50  −2  73  −3  75  −11  83  553  7  50  −2  73  −3  75  −11  83 \n510  28  19  13  46  32  20  9  52  554  28  19  13  46  32  20  9  52 \n511  16  33  9  49  30  22  0  67  555  16  33  9  49  30  22  0  67 \n512  14  62  −7  100  −44  127  −5  90  556  14  62  −7  100  −44  127  −5  90 \n513  −13  108  9  53  0  54  1  67  557  −13  108  9  53  0  54  1  67 \n514  −15  100  2  53  −5  61  −15  72  558  −15  100  2  53  −5  61  −15  72 \n515  −13  101  5  53  0  58  −5  75  559  −13  101  5  53  0  58  −5  75 \n516  −13  91  −2  61  −1  60  −8  80  560  −13  91  −2  61  −1  60  −8  80 \n517  −12  94  0  56  −3  61  −21  83  561  −12  94  0  56  −3  61  −21  83 \n518  −10  88  0  56  −8  67  −21  64  562  −10  88  0  56  −8  67  −21  64 \n519  −16  84  −13  63  −25  84  −13  31  563  −16  84  −13  63  −25  84  −13  31 \n520  −10  86  −5  60  −14  74  −25  64  564  −10  86  −5  60  −14  74  −25  64 \n521  −7  83  −1  62  −5  65  −29  94  565  −7  83  −1  62  −5  65  −29  94 \n522  −13  87  4  57  5  52  9  75  566  −13  87  4  57  5  52  9  75 \n523  −19  94  −6  69  2  57  17  63  567  −19  94  −6  69  2  57  17  63 \n524  1  70  4  57  0  61  −8  74  568  1  70  4  57  0  61  −8  74 \n525  0  72  14  39  −9  69  −5  35  569  0  72  14  39  −9  69  −5  35 \n526  −5  74  4  51  −11  70  −2  27  570  −5  74  4  51  −11  70  −2  27 \n527  18  59  13  68  18  55  13  91  571  18  59  13  68  18  55  13  91 \n \n \n238  Rec. ITU-T H.264 (06/2019) \n \nTable 9-27 – Values of variables m and n for ctxIdx from 572 to 659 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n572  24  0  11  28  4  45  4  39  616  24  0  11  28  4  45  4  39 \n573  15  9  2  40  10  28  0  42  617  15  9  2  40  10  28  0  42 \n574  8  25  3  44  10  31  7  34  618  8  25  3  44  10  31  7  34 \n575  13  18  0  49  33  −11  11  29  619  13  18  0  49  33  −11  11  29 \n576  15  9  0  46  52  −43  8  31  620  15  9  0  46  52  −43  8  31 \n577  13  19  2  44  18  15  6  37  621  13  19  2  44  18  15  6  37 \n578  10  37  2  51  28  0  7  42  622  10  37  2  51  28  0  7  42 \n579  12  18  0  47  35  −22  3  40  623  12  18  0  47  35  −22  3  40 \n580  6  29  4  39  38  −25  8  33  624  6  29  4  39  38  −25  8  33 \n581  20  33  2  62  34  0  13  43  625  20  33  2  62  34  0  13  43 \n582  15  30  6  46  39  −18  13  36  626  15  30  6  46  39  −18  13  36 \n583  4  45  0  54  32  −12  4  47  627  4  45  0  54  32  −12  4  47 \n584  1  58  3  54  102  −94  3  55  628  1  58  3  54  102  −94  3  55 \n585  0  62  2  58  0  0  2  58  629  0  62  2  58  0  0  2  58 \n586  7  61  4  63  56  −15  6  60  630  7  61  4  63  56  −15  6  60 \n587  12  38  6  51  33  −4  8  44  631  12  38  6  51  33  −4  8  44 \n588  11  45  6  57  29  10  11  44  632  11  45  6  57  29  10  11  44 \n589  15  39  7  53  37  −5  14  42  633  15  39  7  53  37  −5  14  42 \n590  11  42  6  52  51  −29  7  48  634  11  42  6  52  51  −29  7  48 \n591  13  44  6  55  39  −9  4  56  635  13  44  6  55  39  −9  4  56 \n592  16  45  11  45  52  −34  4  52  636  16  45  11  45  52  −34  4  52 \n593  12  41  14  36  69  −58  13  37  637  12  41  14  36  69  −58  13  37 \n594  10  49  8  53  67  −63  9  49  638  10  49  8  53  67  −63  9  49 \n595  30  34  −1  82  44  −5  19  58  639  30  34  −1  82  44  −5  19  58 \n596  18  42  7  55  32  7  10  48  640  18  42  7  55  32  7  10  48 \n597  10  55  −3  78  55  −29  12  45  641  10  55  −3  78  55  −29  12  45 \n598  17  51  15  46  32  1  0  69  642  17  51  15  46  32  1  0  69 \n599  17  46  22  31  0  0  20  33  643  17  46  22  31  0  0  20  33 \n600  0  89  −1  84  27  36  8  63  644  0  89  −1  84  27  36  8  63 \n601  26  −19  25  7  33  −25  35  −18  645  26  −19  25  7  33  −25  35  −18 \n602  22  −17  30  −7  34  −30  33  −25  646  22  −17  30  −7  34  −30  33  −25 \n    Rec. ITU-T H.264 (06/2019)  239 \n \nTable 9-27 – Values of variables m and n for ctxIdx from 572 to 659 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n603  26  −17  28  3  36  −28  28  −3  647  26  −17  28  3  36  −28  28  −3 \n604  30  −25  28  4  38  −28  24  10  648  30  −25  28  4  38  −28  24  10 \n605  28  −20  32  0  38  −27  27  0  649  28  −20  32  0  38  −27  27  0 \n606  33  −23  34  −1  34  −18  34  −14  650  33  −23  34  −1  34  −18  34  −14 \n607  37  −27  30  6  35  −16  52  −44  651  37  −27  30  6  35  −16  52  −44 \n608  33  −23  30  6  34  −14  39  −24  652  33  −23  30  6  34  −14  39  −24 \n609  40  −28  32  9  32  −8  19  17  653  40  −28  32  9  32  −8  19  17 \n610  38  −17  31  19  37  −6  31  25  654  38  −17  31  19  37  −6  31  25 \n611  33  −11  26  27  35  0  36  29  655  33  −11  26  27  35  0  36  29 \n612  40  −15  26  30  30  10  24  33  656  40  −15  26  30  30  10  24  33 \n613  41  −6  37  20  28  18  34  15  657  41  −6  37  20  28  18  34  15 \n614  38  1  28  34  26  25  30  20  658  38  1  28  34  26  25  30  20 \n615  41  17  17  70  29  41  22  73  659  41  17  17  70  29  41  22  73 \n \n240  Rec. ITU-T H.264 (06/2019) \n \nTable 9-28 – Values of variables m and n for ctxIdx from 660 to 717 \nI   Value of cabac_init_idc  Value of cabac_init_idc \nI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n660  −17  120  −4  79  −5  85  −3  78  689  2  59  2  59  2  58  −11  68 \n661  −20  112  −7  71  −6  81  −8  74  690  23  −13  9  −2  17  −10  9  −2 \n662  −18  114  −5  69  −10  77  −9  72  691  26  −13  26  −9  32  −13  30  −10 \n663  −11  85  −9  70  −7  81  −10  72  692  40  −15  33  −9  42  −9  31  −4 \n664  −15  92  −8  66  −17  80  −18  75  693  49  −14  39  −7  49  −5  33  −1 \n665  −14  89  −10  68  −18  73  −12  71  694  44  3  41  −2  53  0  33  7 \n666  −26  71  −19  73  −4  74  −11  63  695  45  6  45  3  64  3  31  12 \n667  −15  81  −12  69  −10  83  −5  70  696  44  34  49  9  68  10  37  23 \n668  −14  80  −16  70  −9  71  −17  75  697  33  54  45  27  66  27  31  38 \n669  0  68  −15  67  −9  67  −14  72  698  19  82  36  59  47  57  20  64 \n670  −14  70  −20  62  −1  61  −16  67  699  21  −10  21  −13  17  −10  9  −2 \n671  −24  56  −19  70  −8  66  −8  53  700  24  −11  33  −14  32  −13  30  −10 \n672  −23  68  −16  66  −14  66  −14  59  701  28  −8  39  −7  42  −9  31  −4 \n673  −24  50  −22  65  0  59  −9  52  702  28  −1  46  −2  49  −5  33  −1 \n674  −11  74  −20  63  2  59  −11  68  703  29  3  51  2  53  0  33  7 \n675  −14  106  −5  85  −3  81  −3  78  704  29  9  60  6  64  3  31  12 \n676  −13  97  −6  81  −3  76  −8  74  705  35  20  61  17  68  10  37  23 \n677  −15  90  −10  77  −7  72  −9  72  706  29  36  55  34  66  27  31  38 \n678  −12  90  −7  81  −6  78  −10  72  707  14  67  42  62  47  57  20  64 \n679  −18  88  -17  80  −12  72  −18  75  708  −3  75  −6  66  −5  71  −9  71 \n680  −10  73  −18  73  −14  68  −12  71  709  −1  23  −7  35  0  24  −7  37 \n681  −9  79  −4  74  −3  70  −11  63  710  1  34  −7  42  −1  36  −8  44 \n682  −14  86  −10  83  −6  76  −5  70  711  1  43  −8  45  −2  42  −11  49 \n683  −10  73  −9  71  −5  66  −17  75  712  0  54  −5  48  −2  52  −10  56 \n684  −10  70  −9  67  −5  62  −14  72  713  −2  55  −12  56  −9  57  −12  59 \n685  −10  69  −1  61  0  57  −16  67  714  0  61  −6  60  −6  63  −8  63 \n686  −5  66  −8  66  −4  61  −8  53  715  1  64  −5  62  −4  65  −9  67 \n687  −9  64  −14  66  −9  60  −14  59  716  0  68  −8  66  −4  67  −6  68 \n688  −5  58  0  59  1  54  −9  52  717  −9  92  −8  76  −7  82  −10  79 \n \n    Rec. ITU-T H.264 (06/2019)  241 \n \nTable 9-29 – Values of variables m and n for ctxIdx from 718 to 775 \nI   Value of cabac_init_idc  Value of cabac_init_idc \nI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n718  −17  120  −4  79  −5  85  −3  78  747  2  59  2  59  2  58  −11  68 \n719  −20  112  −7  71  −6  81  −8  74  748  23  −13  9  −2  17  −10  9  −2 \n720  −18  114  −5  69  −10  77  −9  72  749  26  −13  26  −9  32  −13  30  −10 \n721  −11  85  −9  70  −7  81  −10  72  750  40  −15  33  −9  42  −9  31  −4 \n722  −15  92  −8  66  −17  80  −18  75  751  49  −14  39  −7  49  −5  33  −1 \n723  −14  89  −10  68  −18  73  −12  71  752  44  3  41  −2  53  0  33  7 \n724  −26  71  −19  73  −4  74  −11  63  753  45  6  45  3  64  3  31  12 \n725  −15  81  −12  69  −10  83  −5  70  754  44  34  49  9  68  10  37  23 \n726  −14  80  −16  70  −9  71  −17  75  755  33  54  45  27  66  27  31  38 \n727  0  68  −15  67  −9  67  −14  72  756  19  82  36  59  47  57  20  64 \n728  −14  70  −20  62  −1  61  −16  67  757  21  −10  21  −13  17  −10  9  −2 \n729  −24  56  −19  70  −8  66  −8  53  758  24  −11  33  −14  32  −13  30  −10 \n730  −23  68  −16  66  −14  66  −14  59  759  28  −8  39  −7  42  −9  31  −4 \n731  −24  50  −22  65  0  59  −9  52  760  28  −1  46  −2  49  −5  33  −1 \n732  −11  74  −20  63  2  59  −11  68  761  29  3  51  2  53  0  33  7 \n733  −14  106  −5  85  −3  81  −3  78  762  29  9  60  6  64  3  31  12 \n734  −13  97  −6  81  −3  76  −8  74  763  35  20  61  17  68  10  37  23 \n735  −15  90  −10  77  −7  72  −9  72  764  29  36  55  34  66  27  31  38 \n736  −12  90  −7  81  −6  78  −10  72  765  14  67  42  62  47  57  20  64 \n737  −18  88  −17  80  −12  72  −18  75  766  −3  75  −6  66  −5  71  −9  71 \n738  −10  73  −18  73  −14  68  −12  71  767  −1  23  −7  35  0  24  −7  37 \n739  −9  79  −4  74  −3  70  −11  63  768  1  34  −7  42  −1  36  −8  44 \n740  −14  86  −10  83  −6  76  −5  70  769  1  43  −8  45  −2  42  −11  49 \n741  −10  73  −9  71  −5  66  −17  75  770  0  54  −5  48  −2  52  −10  56 \n742  −10  70  −9  67  −5  62  −14  72  771  −2  55  −12  56  −9  57  −12  59 \n743  −10  69  −1  61  0  57  −16  67  772  0  61  −6  60  −6  63  −8  63 \n744  −5  66  −8  66  −4  61  −8  53  773  1  64  −5  62  −4  65  −9  67 \n745  −9  64  −14  66  −9  60  −14  59  774  0  68  −8  66  −4  67  −6  68 \n746  −5  58  0  59  1  54  −9  52  775  −9  92  −8  76  −7  82  −10  79 \n \n242  Rec. ITU-T H.264 (06/2019) \n \nTable 9-30 – Values of variables m and n for ctxIdx from 776 to 863 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n776  −6  93  −13  106  −21  126  −22  127  820  −6  93  −13  106  −21  126  −22  127 \n777  −6  84  −16  106  −23  124  −25  127  821  −6  84  −16  106  −23  124  −25  127 \n778  −8  79  −10  87  −20  110  −25  120  822  −8  79  −10  87  −20  110  −25  120 \n779  0  66  −21  114  −26  126  −27  127  823  0  66  −21  114  −26  126  −27  127 \n780  −1  71  −18  110  −25  124  −19  114  824  −1  71  −18  110  −25  124  −19  114 \n781  0  62  −14  98  −17  105  −23  117  825  0  62  −14  98  −17  105  −23  117 \n782  −2  60  −22  110  −27  121  −25  118  826  −2  60  −22  110  −27  121  −25  118 \n783  −2  59  −21  106  −27  117  −26  117  827  −2  59  −21  106  −27  117  −26  117 \n784  −5  75  −18  103  −17  102  −24  113  828  −5  75  −18  103  −17  102  −24  113 \n785  −3  62  −21  107  −26  117  −28  118  829  −3  62  −21  107  −26  117  −28  118 \n786  −4  58  −23  108  −27  116  −31  120  830  −4  58  −23  108  −27  116  −31  120 \n787  −9  66  −26  112  −33  122  −37  124  831  −9  66  −26  112  −33  122  −37  124 \n788  −1  79  −10  96  −10  95  −10  94  832  −1  79  −10  96  −10  95  −10  94 \n789  0  71  −12  95  −14  100  −15  102  833  0  71  −12  95  −14  100  −15  102 \n790  3  68  −5  91  −8  95  −10  99  834  3  68  −5  91  −8  95  −10  99 \n791  10  44  −9  93  −17  111  −13  106  835  10  44  −9  93  −17  111  −13  106 \n792  −7  62  −22  94  −28  114  −50  127  836  −7  62  −22  94  −28  114  −50  127 \n793  15  36  −5  86  −6  89  −5  92  837  15  36  −5  86  −6  89  −5  92 \n794  14  40  9  67  −2  80  17  57  838  14  40  9  67  −2  80  17  57 \n795  16  27  −4  80  −4  82  −5  86  839  16  27  −4  80  −4  82  −5  86 \n796  12  29  −10  85  −9  85  −13  94  840  12  29  −10  85  −9  85  −13  94 \n797  1  44  −1  70  −8  81  −12  91  841  1  44  −1  70  −8  81  −12  91 \n798  20  36  7  60  −1  72  −2  77  842  20  36  7  60  −1  72  −2  77 \n799  18  32  9  58  5  64  0  71  843  18  32  9  58  5  64  0  71 \n800  5  42  5  61  1  67  −1  73  844  5  42  5  61  1  67  −1  73 \n801  1  48  12  50  9  56  4  64  845  1  48  12  50  9  56  4  64 \n802  10  62  15  50  0  69  −7  81  846  10  62  15  50  0  69  −7  81 \n803  17  46  18  49  1  69  5  64  847  17  46  18  49  1  69  5  64 \n804  9  64  17  54  7  69  15  57  848  9  64  17  54  7  69  15  57 \n805  −12  104  10  41  −7  69  1  67  849  −12  104  10  41  −7  69  1  67 \n806  −11  97  7  46  −6  67  0  68  850  −11  97  7  46  −6  67  0  68 \n    Rec. ITU-T H.264 (06/2019)  243 \n \nTable 9-30 – Values of variables m and n for ctxIdx from 776 to 863 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n807  −16  96  −1  51  −16  77  −10  67  851  −16  96  −1  51  −16  77  −10  67 \n808  −7  88  7  49  −2  64  1  68  852  −7  88  7  49  −2  64  1  68 \n809  −8  85  8  52  2  61  0  77  853  −8  85  8  52  2  61  0  77 \n810  −7  85  9  41  −6  67  2  64  854  −7  85  9  41  −6  67  2  64 \n811  −9  85  6  47  −3  64  0  68  855  −9  85  6  47  −3  64  0  68 \n812  −13  88  2  55  2  57  −5  78  856  −13  88  2  55  2  57  −5  78 \n813  4  66  13  41  −3  65  7  55  857  4  66  13  41  −3  65  7  55 \n814  −3  77  10  44  −3  66  5  59  858  −3  77  10  44  −3  66  5  59 \n815  −3  76  6  50  0  62  2  65  859  −3  76  6  50  0  62  2  65 \n816  −6  76  5  53  9  51  14  54  860  −6  76  5  53  9  51  14  54 \n817  10  58  13  49  −1  66  15  44  861  10  58  13  49  −1  66  15  44 \n818  −1  76  4  63  −2  71  5  60  862  −1  76  4  63  −2  71  5  60 \n819  −1  83  6  64  −2  75  2  70  863  −1  83  6  64  −2  75  2  70 \n \n244  Rec. ITU-T H.264 (06/2019) \n \nTable 9-31 – Values of variables m and n for ctxIdx from 864 to 951 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n864  15  6  14  11  19  −6  17  −13  908  15  6  14  11  19  −6  17  −13 \n865  6  19  11  14  18  −6  16  −9  909  6  19  11  14  18  −6  16  −9 \n866  7  16  9  11  14  0  17  −12  910  7  16  9  11  14  0  17  −12 \n867  12  14  18  11  26  −12  27  −21  911  12  14  18  11  26  −12  27  −21 \n868  18  13  21  9  31  −16  37  −30  912  18  13  21  9  31  −16  37  −30 \n869  13  11  23  −2  33  −25  41  −40  913  13  11  23  −2  33  −25  41  −40 \n870  13  15  32  −15  33  −22  42  −41  914  13  15  32  −15  33  −22  42  −41 \n871  15  16  32  −15  37  −28  48  −47  915  15  16  32  −15  37  −28  48  −47 \n872  12  23  34  −21  39  −30  39  −32  916  12  23  34  −21  39  −30  39  −32 \n873  13  23  39  −23  42  −30  46  −40  917  13  23  39  −23  42  −30  46  −40 \n874  15  20  42  −33  47  −42  52  −51  918  15  20  42  −33  47  −42  52  −51 \n875  14  26  41  −31  45  −36  46  −41  919  14  26  41  −31  45  −36  46  −41 \n876  14  44  46  −28  49  −34  52  −39  920  14  44  46  −28  49  −34  52  −39 \n877  17  40  38  −12  41  −17  43  −19  921  17  40  38  −12  41  −17  43  −19 \n878  17  47  21  29  32  9  32  11  922  17  47  21  29  32  9  32  11 \n879  24  17  45  −24  69  −71  61  −55  923  24  17  45  −24  69  −71  61  −55 \n880  21  21  53  −45  63  −63  56  −46  924  21  21  53  −45  63  −63  56  −46 \n881  25  22  48  −26  66  −64  62  −50  925  25  22  48  −26  66  −64  62  −50 \n882  31  27  65  −43  77  −74  81  −67  926  31  27  65  −43  77  −74  81  −67 \n883  22  29  43  −19  54  −39  45  −20  927  22  29  43  −19  54  −39  45  −20 \n884  19  35  39  −10  52  −35  35  −2  928  19  35  39  −10  52  −35  35  −2 \n885  14  50  30  9  41  −10  28  15  929  14  50  30  9  41  −10  28  15 \n886  10  57  18  26  36  0  34  1  930  10  57  18  26  36  0  34  1 \n887  7  63  20  27  40  −1  39  1  931  7  63  20  27  40  −1  39  1 \n888  −2  77  0  57  30  14  30  17  932  −2  77  0  57  30  14  30  17 \n889  −4  82  −14  82  28  26  20  38  933  −4  82  −14  82  28  26  20  38 \n890  −3  94  −5  75  23  37  18  45  934  −3  94  −5  75  23  37  18  45 \n891  9  69  −19  97  12  55  15  54  935  9  69  −19  97  12  55  15  54 \n892  −12  109  −35  125  11  65  0  79  936  −12  109  −35  125  11  65  0  79 \n893  36  −35  27  0  37  −33  36  −16  937  36  −35  27  0  37  −33  36  −16 \n894  36  −34  28  0  39  −36  37  −14  938  36  −34  28  0  39  −36  37  −14 \n    Rec. ITU-T H.264 (06/2019)  245 \n \nTable 9-31 – Values of variables m and n for ctxIdx from 864 to 951 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n895  32  −26  31  −4  40  −37  37  −17  939  32  −26  31  −4  40  −37  37  −17 \n896  37  −30  27  6  38  −30  32  1  940  37  −30  27  6  38  −30  32  1 \n897  44  −32  34  8  46  −33  34  15  941  44  −32  34  8  46  −33  34  15 \n898  34  −18  30  10  42  −30  29  15  942  34  −18  30  10  42  −30  29  15 \n899  34  −15  24  22  40  −24  24  25  943  34  −15  24  22  40  −24  24  25 \n900  40  −15  33  19  49  −29  34  22  944  40  −15  33  19  49  −29  34  22 \n901  33  −7  22  32  38  −12  31  16  945  33  −7  22  32  38  −12  31  16 \n902  35  −5  26  31  40  −10  35  18  946  35  −5  26  31  40  −10  35  18 \n903  33  0  21  41  38  −3  31  28  947  33  0  21  41  38  −3  31  28 \n904  38  2  26  44  46  −5  33  41  948  38  2  26  44  46  −5  33  41 \n905  33  13  23  47  31  20  36  28  949  33  13  23  47  31  20  36  28 \n906  23  35  16  65  29  30  27  47  950  23  35  16  65  29  30  27  47 \n907  13  58  14  71  25  44  21  62  951  13  58  14  71  25  44  21  62 \n \n246  Rec. ITU-T H.264 (06/2019) \n \nTable 9-32 – Values of variables m and n for ctxIdx from 952 to 1011 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  n  m  n \n952  −3  71  −6  76  −23  112  −24  115  982  −3  71  −6  76  −23  112  −24  115 \n953  −6  42  −2  44  −15  71  −22  82  983  −6  42  −2  44  −15  71  −22  82 \n954  −5  50  0  45  −7  61  −9  62  984  −5  50  0  45  −7  61  −9  62 \n955  −3  54  0  52  0  53  0  53  985  −3  54  0  52  0  53  0  53 \n956  −2  62  −3  64  −5  66  0  59  986  −2  62  −3  64  −5  66  0  59 \n957  0  58  −2  59  −11  77  −14  85  987  0  58  −2  59  −11  77  −14  85 \n958  1  63  −4  70  −9  80  −13  89  988  1  63  −4  70  −9  80  −13  89 \n959  −2  72  −4  75  −9  84  −13  94  989  −2  72  −4  75  −9  84  −13  94 \n960  −1  74  −8  82  −10  87  −11  92  990  −1  74  −8  82  −10  87  −11  92 \n961  −9  91  −17  102  −34  127  −29  127  991  −9  91  −17  102  −34  127  −29  127 \n962  −5  67  −9  77  −21  101  −21  100  992  −5  67  −9  77  −21  101  −21  100 \n963  −5  27  3  24  −3  39  −14  57  993  −5  27  3  24  −3  39  −14  57 \n964  −3  39  0  42  −5  53  −12  67  994  −3  39  0  42  −5  53  −12  67 \n965  −2  44  0  48  −7  61  −11  71  995  −2  44  0  48  −7  61  −11  71 \n966  0  46  0  55  −11  75  −10  77  996  0  46  0  55  −11  75  −10  77 \n967  −16  64  −6  59  −15  77  −21  85  997  −16  64  −6  59  −15  77  −21  85 \n968  −8  68  −7  71  −17  91  −16  88  998  −8  68  −7  71  −17  91  −16  88 \n969  −10  78  −12  83  −25  107  −23  104  999  −10  78  −12  83  −25  107  −23  104 \n970  −6  77  −11  87  −25  111  −15  98  1000  −6  77  −11  87  −25  111  −15  98 \n971  −10  86  −30  119  −28  122  −37  127  1001  −10  86  −30  119  −28  122  −37  127 \n972  −12  92  1  58  −11  76  −10  82  1002  −12  92  1  58  −11  76  −10  82 \n973  −15  55  −3  29  −10  44  −8  48  1003  −15  55  −3  29  −10  44  −8  48 \n974  −10  60  −1  36  −10  52  −8  61  1004  −10  60  −1  36  −10  52  −8  61 \n975  −6  62  1  38  −10  57  −8  66  1005  −6  62  1  38  −10  57  −8  66 \n976  −4  65  2  43  −9  58  −7  70  1006  −4  65  2  43  −9  58  −7  70 \n977  −12  73  −6  55  −16  72  −14  75  1007  −12  73  −6  55  −16  72  −14  75 \n978  −8  76  0  58  −7  69  −10  79  1008  −8  76  0  58  −7  69  −10  79 \n979  −7  80  0  64  −4  69  −9  83  1009  −7  80  0  64  −4  69  −9  83 \n980  −9  88  −3  74  −5  74  −12  92  1010  −9  88  −3  74  −5  74  −12  92 \n981  −17  110  −10  90  −9  86  −18  108  1011  −17  110  −10  90  −9  86  −18  108 \n \n    Rec. ITU-T H.264 (06/2019)  247 \n \nTable 9-33 – Values of variables m and n for ctxIdx from 1012 to 1023 \nI and SI   Value of cabac_init_idc  Value of cabac_init_idc \nI and SI  \nslices \nslices \nctxIdx  0  1  2  ctxIdx  0  1  2 \nm  n  m  n  m  n  m  n  m  n  m  n  m  N  m  n \n1012  −3  70  −3  74  −2  73  −5  79  1018  −10  90  −8  87  −9  91  −11  91 \n1013  −8  93  −9  92  −12  104  −11  104  1019  −30  127  −23  126  −31  127  −30  127 \n1014  −10  90  −8  87  −9  91  −11  91  1020  −3  70  −3  74  −2  73  −5  79 \n1015  −30  127  −23  126  −31  127  −30  127  1021  −8  93  −9  92  −12  104  −11  104 \n1016  −3  70  −3  74  −2  73  −5  79  1022  −10  90  −8  87  −9  91  −11  91 \n1017  −8  93  −9  92  −12  104  −11  104  1023  −30  127  −23  126  −31  127  −30  127 \n \n9.3.1.2  Initialization process for the arithmetic decoding engine \nThis  process  is  invoked  before  decoding  the  first  macroblock  of  a  slice  or  after  the  decoding  of  any \npcm_alignment_zero_bit and all pcm_sample_luma and pcm_sample_chroma data for a macroblock of type I_PCM. \nOutputs of this process are the initialized decoding engine registers codIRange and codIOffset both in 16 bit register \nprecision. \nThe status of the arithmetic decoding engine is represented by the variables codIRange and codIOffset. In the initialization \nprocedure of the arithmetic decoding process, codIRange is set equal to 510 and codIOffset is set equal to the value returned \nfrom read_bits( 9 ) interpreted as a 9 bit binary representation of an unsigned integer with most significant bit written first. \nThe bitstream shall not contain data that result in a value of codIOffset being equal to 510 or 511. \nNOTE – The description of the arithmetic decoding engine in this Recommendation | International Standard utilizes 16 bit register \nprecision. However, a minimum register precision of 9 bits is required for storing the values of the variables codIRange and \ncodIOffset after invocation of the arithmetic decoding process (DecodeBin) as specified in clause 9.3.3.2. The arithmetic decoding \nprocess for a binary decision (DecodeDecision) as specified in clause 9.3.3.2.1 and the decoding process for a binary decision before \ntermination (DecodeTerminate) as specified in clause 9.3.3.2.4 require a minimum register precision of 9 bits for the variables \ncodIRange and codIOffset. The bypass decoding process for binary decisions (DecodeBypass) as specified in clause 9.3.3.2.3 \nrequires a minimum register precision of 10 bits for the variable codIOffset and a minimum register precision of 9 bits for the \nvariable codIRange. \n9.3.2  Binarization process \nInput to this process is a request for a syntax element. \nOutput of this process is the binarization of the syntax element, maxBinIdxCtx, ctxIdxOffset, and bypassFlag. \nTable 9-34  specifies  the  type  of  binarization  process,  maxBinIdxCtx,  and  ctxIdxOffset  associated  with  each  syntax \nelement. \nThe specification of the unary (U) binarization process, the truncated unary (TU) binarization process, the concatenated \nunary / k-th order Exp-Golomb (UEGk) binarization process, and the fixed-length (FL) binarization process are given in \nclauses 9.3.2.1 to 9.3.2.4, respectively. Other binarizations are specified in clauses 9.3.2.5 to 9.3.2.7. \nExcept for I slices, the binarizations for the syntax element mb_type as specified in clause 9.3.2.5 consist of bin strings \ngiven by a concatenation of prefix and suffix bit strings. The UEGk binarization as specified in clause 9.3.2.3, which is \nused for the binarization of the syntax elements mvd_lX (X = 0, 1) and coeff_abs_level_minus1, and the binarization of \nthe coded_block_pattern also consist of a concatenation of prefix and suffix bit strings. For these binarization processes, \nthe prefix and the suffix bit string are separately indexed using the binIdx variable as specified further in clause 9.3.3. The \ntwo sets of prefix bit strings and suffix bit strings are referred to as the binarization prefix part and the binarization suffix \npart, respectively. \nAssociated with each binarization or binarization part of a syntax element is a specific value of the context index offset \n(ctxIdxOffset) variable and a specific value of the maxBinIdxCtx variable as given in Table 9-34. When two values for \neach of these variables are specified for one syntax element in Table 9-34, the value in the upper row is related to the prefix \npart while the value in the lower row is related to the suffix part of the binarization of the corresponding syntax element. \nThe use of the DecodeBypass process and the variable bypassFlag is derived as follows: \n248  Rec. ITU-T H.264 (06/2019) \n \n–  If no value is assigned to ctxIdxOffset for the corresponding binarization or binarization part in Table 9-34 labelled \nas \"na\", all bins of the bit strings of the corresponding binarization or of the binarization prefix/suffix part are decoded \nby invoking the DecodeBypass process as specified in clause 9.3.3.2.3. In such a case, bypassFlag is set equal to 1, \nwhere bypassFlag is used to indicate that for parsing the value of the bin from the bitstream the DecodeBypass process \nis applied. \n–  Otherwise, for each possible value of binIdx up to the specified value of maxBinIdxCtx given in Table 9-34, a specific \nvalue of the variable ctxIdx is further specified in clause 9.3.3. bypassFlag is set equal to 0. \nThe possible values of the context index ctxIdx are in the range 0 to 1023, inclusive. The value assigned to ctxIdxOffset \nspecifies the lower value of the range of ctxIdx assigned to the corresponding binarization or binarization part of a syntax \nelement. \nctxIdx = ctxIdxOffset = 276 is assigned to the syntax element end_of_slice_flag and the bin of mb_type, which specifies \nthe I_PCM macroblock type as further specified in clause 9.3.3.1. For parsing the value of the corresponding bin from the \nbitstream,  the  arithmetic  decoding  process  for  decisions  before  termination  (DecodeTerminate)  as  specified  in \nclause 9.3.3.2.4 is applied. \nNOTE – The bins of mb_type in I slices and the bins of the suffix for mb_type in SI slices that correspond to the same value of \nbinIdx share the same ctxIdx. The last bin of the prefix of mb_type and the first bin of the suffix of mb_type in P, SP, and B slices \nmay share the same ctxIdx. \nTable 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset \nSyntax element  Type of binarization  maxBinIdxCtx  ctxIdxOffset \nmb_type  prefix and suffix   prefix: 0  prefix: 0 \n(SI slices only)  as specified in clause 9.3.2.5  suffix: 6  suffix: 3 \nmb_type (I slices only)  as specified in clause 9.3.2.5  6  3 \nmb_skip_flag \nFL, cMax=1  0  11 \n(P, SP slices only) \nprefix and suffix  prefix: 2  prefix: 14 \nmb_type (P, SP slices only) \nas specified in clause 9.3.2.5  suffix: 5  suffix: 17 \nsub_mb_type[ ] \nas specified in clause 9.3.2.5  2  21 \n(P, SP slices only) \nmb_skip_flag \nFL, cMax=1  0  24 \n(B slices only) \nprefix and suffix  prefix: 3  prefix: 27 \nmb_type (B slices only) \nas specified in clause 9.3.2.5  suffix: 5  suffix: 32 \nsub_mb_type[ ] (B slices only)  as specified in clause 9.3.2.5  3  36 \nprefix: 4  prefix: 40 \nmvd_l0[ ][ ][ 0 ], mvd_l1[ ][ ][ 0 ] \nsuffix: na  suffix: na (uses DecodeBypass) \nprefix and suffix as given by UEG3  \nwith signedValFlag=1, uCoff=9 \nprefix: 4  prefix: 47 \nmvd_l0[ ][ ][ 1 ], mvd_l1[ ][ ][ 1 ] \nsuffix: na  suffix: na (uses DecodeBypass) \nref_idx_l0, ref_idx_l1  U  2  54 \nmb_qp_delta  as specified in clause 9.3.2.7  2  60 \nintra_chroma_pred_mode  TU, cMax=3  1  64 \nprev_intra4x4_pred_mode_flag,  0  68 \nFL, cMax=1 \nprev_intra8x8_pred_mode_flag \nrem_intra4x4_pred_mode,  0  69 \nFL, cMax=7 \nrem_intra8x8_pred_mode \nmb_field_decoding_flag  FL, cMax=1  0  70 \n    Rec. ITU-T H.264 (06/2019)  249 \n \nTable 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset \nSyntax element  Type of binarization  maxBinIdxCtx  ctxIdxOffset \nprefix and suffix   prefix: 3  prefix: 73 \ncoded_block_pattern \nas specified in clause 9.3.2.6  suffix: 1  suffix: 77 \ncoded_block_flag  0  85 \nFL, cMax=1 \n(blocks with ctxBlockCat < 5) \nsignificant_coeff_flag  \nFL, cMax=1  0  105 \n(frame coded blocks with ctxBlockCat < 5) \nlast_significant_coeff_flag  \nFL, cMax=1  0  166 \n(frame coded blocks with ctxBlockCat < 5) \ncoeff_abs_level_minus1   prefix and suffix as given by UEG0  prefix: 1  prefix: 227 \n(blocks with ctxBlockCat < 5)  with signedValFlag=0, uCoff=14  suffix: na  suffix: na, (uses DecodeBypass) \ncoeff_sign_flag  FL, cMax=1  0  na, (uses DecodeBypass) \nend_of_slice_flag  FL, cMax=1  0  276 \nsignificant_coeff_flag \nFL, cMax=1  0  277 \n(field coded blocks with ctxBlockCat < 5) \nlast_significant_coeff_flag  \nFL, cMax=1  0  338 \n(field coded blocks with ctxBlockCat < 5) \ntransform_size_8x8_flag  FL, cMax=1  0  399 \nsignificant_coeff_flag  \nFL, cMax=1  0  402 \n(frame coded blocks with ctxBlockCat  = =  5) \nlast_significant_coeff_flag  \nFL, cMax=1  0  417 \n(frame coded blocks with ctxBlockCat  = =  5) \ncoeff_abs_level_minus1   prefix and suffix as given by UEG0  prefix: 1  prefix: 426 \n(blocks with ctxBlockCat  = =  5)  with signedValFlag=0, uCoff=14  suffix: na  suffix: na, (uses DecodeBypass) \nsignificant_coeff_flag  \nFL, cMax=1  0  436 \n(field coded blocks with ctxBlockCat  = =  5) \nlast_significant_coeff_flag  \nFL, cMax=1  0  451 \n(field coded blocks with ctxBlockCat  = =  5) \ncoded_block_flag \nFL, cMax=1  0  460 \n(5 < ctxBlockCat < 9) \ncoded_block_flag \nFL, cMax=1  0  472 \n(9 < ctxBlockCat < 13) \ncoded_block_flag \nFL, cMax=1  0  1012 \n(ctxBlockCat  = =  5, 9, or 13) \nsignificant_coeff_flag \n(frame coded blocks  FL, cMax=1  0  484 \nwith 5 < ctxBlockCat < 9) \nsignificant_coeff_flag \n(frame coded blocks with  FL, cMax=1  0  528 \n9 < ctxBlockCat < 13) \nlast_significant_coeff_flag \n(frame coded blocks with  FL, cMax=1  0  572 \n5 < ctxBlockCat < 9) \n250  Rec. ITU-T H.264 (06/2019) \n \nTable 9-34 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset \nSyntax element  Type of binarization  maxBinIdxCtx  ctxIdxOffset \nlast_significant_coeff_flag \n(frame coded blocks with  FL, cMax=1  0  616 \n9 < ctxBlockCat < 13) \ncoeff_abs_level_minus1  prefix and suffix as given by UEG0  prefix: 1  prefix: 952 \n(blocks with 5 < ctxBlockCat < 9)  with signedValFlag=0, uCoff=14  suffix: na  suffix: na, (uses DecodeBypass) \ncoeff_abs_level_minus1  prefix and suffix as given by UEG0  prefix: 1  prefix: 982 \n(blocks with 9 < ctxBlockCat < 13)  with signedValFlag=0, uCoff=14  suffix: na  suffix: na, (uses DecodeBypass) \nsignificant_coeff_flag \nFL, cMax=1  0  776 \n(field coded blocks with 5 < ctxBlockCat < 9) \nsignificant_coeff_flag \n(field coded blocks with  FL, cMax=1  0  820 \n9 < ctxBlockCat < 13) \nlast_significant_coeff_flag  \nFL, cMax=1  0  864 \n(field coded blocks with 5 < ctxBlockCat < 9) \nlast_significant_coeff_flag  \n(field coded blocks with  FL, cMax=1  0  908 \n9 < ctxBlockCat < 13) \nsignificant_coeff_flag  \nFL, cMax=1  0  660 \n(frame coded blocks with ctxBlockCat  = =  9) \nsignificant_coeff_flag  \n(frame coded blocks with  FL, cMax=1  0  718 \nctxBlockCat  = =  13) \nlast_significant_coeff_flag  \nFL, cMax=1  0  690 \n(frame coded blocks with ctxBlockCat  = =  9) \nlast_significant_coeff_flag  \n(frame coded blocks with  FL, cMax=1  0  748 \nctxBlockCat  = =  13) \ncoeff_abs_level_minus1   prefix and suffix as given by UEG0  prefix: 1  prefix: 708 \n(blocks with ctxBlockCat  = =  9)  with signedValFlag=0, uCoff=14  suffix: na  suffix: na, (uses DecodeBypass) \ncoeff_abs_level_minus1   prefix and suffix as given by UEG0  prefix: 1  prefix: 766 \n(blocks with ctxBlockCat  = =  13)  with signedValFlag=0, uCoff=14  suffix: na  suffix: na, (uses DecodeBypass) \nsignificant_coeff_flag  \nFL, cMax=1  0  675 \n(field coded blocks with ctxBlockCat  = =  9) \nsignificant_coeff_flag  \nFL, cMax=1  0  733 \n(field coded blocks with ctxBlockCat  = =  13) \nlast_significant_coeff_flag  \nFL, cMax=1  0  699 \n(field coded blocks with ctxBlockCat  = =  9) \nlast_significant_coeff_flag  \nFL, cMax=1  0  757 \n(field coded blocks with ctxBlockCat  = =  13) \n \n9.3.2.1  Unary (U) binarization process \nInput to this process is a request for a U binarization for a syntax element. \nOutput of this process is the U binarization of the syntax element. \nThe bin string of a syntax element having (unsigned integer) value synElVal is a bit string of length synElVal + 1 indexed \nby binIdx. The bins for binIdx less than synElVal are equal to 1. The bin with binIdx equal to synElVal is equal to 0. \nTable 9-35 illustrates the bin strings of the unary binarization for a syntax element. \n    Rec. ITU-T H.264 (06/2019)  251 \n \nTable 9-35 – Bin string of the unary binarization (informative) \nValue of syntax element  Bin string \n0 (I_NxN)  0           \n1  1  0         \n2  1  1  0       \n3  1  1  1  0     \n4  1  1  1  1  0   \n5  1  1  1  1  1  0 \n…             \nbinIdx  0  1  2  3  4  5 \n \n9.3.2.2  Truncated unary (TU) binarization process \nInput to this process is a request for a TU binarization for a syntax element and cMax. \nOutput of this process is the TU binarization of the syntax element. \nFor syntax element (unsigned integer) values less than cMax, the U binarization process as specified in clause 9.3.2.1 is \ninvoked. For the syntax element value equal to cMax the bin string is a bit string of length cMax with all bins being equal \nto 1. \nNOTE – TU binarization is always invoked with a cMax value equal to the largest possible value of the syntax element being \ndecoded. \n9.3.2.3  Concatenated unary/ k-th order Exp-Golomb (UEGk) binarization process \nInput to this process is a request for a UEGk binarization for a syntax element, signedValFlag and uCoff. \nOutput of this process is the UEGk binarization of the syntax element. \nA UEGk bin string is a concatenation of a prefix bit string and a suffix bit string. The prefix of the binarization is specified \nby invoking the TU binarization process for the prefix part Min( uCoff, Abs( synElVal ) ) of a syntax element value \nsynElVal as specified in clause 9.3.2.2 with cMax = uCoff, where uCoff > 0. \nThe variable k for a UEGk bin string is dependent on the syntax element for which a UEGk binarization is requested. \nTable 9-34 specifies the associated types of binarization for syntax elements, including the value of k for syntax elements \nthat use UEGk binarization. \nNOTE 1 – For the syntax elements mvd_l0[ ][ ][ ] and mvd_l1[ ][ ][ ] a UEG3 binarization is used (k is equal to 3). For the syntax \nelement coeff_abs_level_minus1 a UEG0 binarization is used (k is equal to 0). \nThe UEGk bin string is derived as follows: \n–  If one of the following is true, the bin string of a syntax element having value synElVal consists only of a prefix bit \nstring: \n–  signedValFlag is equal to 0 and the prefix bit string is not equal to the bit string of length uCoff with all bits \nequal to 1, \n–  signedValFlag is equal to 1 and the prefix bit string is equal to the bit string that consists of a single bit with \nvalue equal to 0. \n252  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise, the bin string of the UEGk suffix part of a syntax element value synElVal is specified by a process \nequivalent to the following pseudo-code with k being initialized to the value that is specified in Table 9-34 for the \nrequested UEGk binarization process. At the beginning of the following pseudo-code, the bin string of a syntax \nelement having value synElVal is set equal to the empty string. Each call of the function put( X ), with X being equal \nto 0 or 1, adds the binary value X at the end of the bin string. \nif( Abs( synElVal )  >=  uCoff ) { \n  sufS = Abs( synElVal ) − uCoff \n  stopLoop = 0 \n  do { \n    if( sufS  >=  ( 1 << k ) ) { \n      put( 1 ) \n      sufS = sufS − ( 1<<k ) \n      k++ \n    } else { \n      put( 0 )                 (9-6) \n      while( k− − )  \n        put( ( sufS >> k )  &  1 ) \n      stopLoop = 1 \n    } \n  } while( !stopLoop ) \n} \nif( signedValFlag  &&  synElVal  ! =  0) \n  if( synElVal  >  0 ) \n    put( 0 ) \n  else \n    put( 1 ) \n \nNOTE 2 – The specification for the k-th order Exp-Golomb (EGk) code uses 1's and 0's in reverse meaning for the unary part of the \nExp-Golomb code of 0-th order as specified in clause 9.1. \n9.3.2.4  Fixed-length (FL) binarization process \nInput to this process is a request for a FL binarization for a syntax element and cMax. \nOutput of this process is the FL binarization of the syntax element. \nFL binarization is constructed by using a fixedLength-bit unsigned integer bin string of the syntax element value, where \nfixedLength = Ceil( Log2( cMax + 1 ) ). The indexing of bins for the FL binarization is such that the binIdx = 0 relates to \nthe least significant bit with increasing values of binIdx towards the most significant bit. \n9.3.2.5  Binarization process for macroblock type and sub-macroblock type \nInput to this process is a request for a binarization for syntax elements mb_type or sub_mb_type[ ]. \nOutput of this process is the binarization of the syntax element. \nThe binarization scheme for decoding of macroblock type in I slices is specified in Table 9-36. \nFor macroblock types in SI slices, the binarization consists of bin strings specified as a concatenation of a prefix and a \nsuffix bit string as follows. \nThe prefix bit string consists of a single bit, which is specified by b  = ( ( mb_type  = =  SI )  ?  0 : 1 ). For the syntax \n0\nelement value for which b  is equal to 0, the bin string only consists of the prefix bit string. For the syntax element value \n0\nfor which b  is equal to 1, the binarization is given by concatenating the prefix b  and the suffix bit string as specified in \n0 0\nTable 9-36 for macroblock type in I slices indexed by subtracting 1 from the value of mb_type in SI slices. \n    Rec. ITU-T H.264 (06/2019)  253 \n \nTable 9-36 – Binarization for macroblock types in I slices \nValue (name) of mb_type  Bin string \n0 (I_NxN)  0             \n1 (I_16x16_0_0_0)  1  0  0  0  0  0   \n2 (I_16x16_1_0_0)  1  0  0  0  0  1   \n3 (I_16x16_2_0_0)  1  0  0  0  1  0   \n4 (I_16x16_3_0_0)  1  0  0  0  1  1   \n5 (I_16x16_0_1_0)  1  0  0  1  0  0  0 \n6 (I_16x16_1_1_0)  1  0  0  1  0  0  1 \n7 (I_16x16_2_1_0)  1  0  0  1  0  1  0 \n8 (I_16x16_3_1_0)  1  0  0  1  0  1  1 \n9 (I_16x16_0_2_0)  1  0  0  1  1  0  0 \n10 (I_16x16_1_2_0)  1  0  0  1  1  0  1 \n11 (I_16x16_2_2_0)  1  0  0  1  1  1  0 \n12 (I_16x16_3_2_0)  1  0  0  1  1  1  1 \n13 (I_16x16_0_0_1)  1  0  1  0  0  0   \n14 (I_16x16_1_0_1)  1  0  1  0  0  1   \n15 (I_16x16_2_0_1)  1  0  1  0  1  0   \n16 (I_16x16_3_0_1)  1  0  1  0  1  1   \n17 (I_16x16_0_1_1)  1  0  1  1  0  0  0 \n18 (I_16x16_1_1_1)  1  0  1  1  0  0  1 \n19 (I_16x16_2_1_1)  1  0  1  1  0  1  0 \n20 (I_16x16_3_1_1)  1  0  1  1  0  1  1 \n21 (I_16x16_0_2_1)  1  0  1  1  1  0  0 \n22 (I_16x16_1_2_1)  1  0  1  1  1  0  1 \n23 (I_16x16_2_2_1)  1  0  1  1  1  1  0 \n24 (I_16x16_3_2_1)  1  0  1  1  1  1  1 \n25 (I_PCM)  1  1           \nbinIdx  0  1  2  3  4  5  6 \n \nThe binarization schemes for P macroblock types in P and SP slices and for B macroblocks in B slices are specified in \nTable 9-37. \nThe bin string for I macroblock types in P and SP slices corresponding to mb_type values 5 to 30 consists of a concatenation \nof a prefix, which consists of a single bit with value equal to 1 as specified in Table 9-37 and a suffix as specified in \nTable 9-36, indexed by subtracting 5 from the value of mb_type. \nmb_type equal to 4 (P_8x8ref0) is not allowed. \nFor I macroblock types in B slices (mb_type values 23 to 48) the binarization consists of bin strings specified as a \nconcatenation of a prefix bit string as specified in Table 9-37 and suffix bit strings as specified in Table 9-36, indexed by \nsubtracting 23 from the value of mb_type. \n254  Rec. ITU-T H.264 (06/2019) \n \nTable 9-37 – Binarization for macroblock types in P, SP, and B slices \nSlice type  Value (name) of mb_type  Bin string \n0 (P_L0_16x16)  0  0  0         \n1 (P_L0_L0_16x8)  0  1  1         \n2 (P_L0_L0_8x16)  0  1  0         \nP, SP slice \n3 (P_8x8)  0  0  1         \n4 (P_8x8ref0)  na \n5 to 30 (Intra, prefix only)  1             \n0 (B_Direct_16x16)  0             \n1 (B_L0_16x16)  1  0  0         \n2 (B_L1_16x16)  1  0  1         \n3 (B_Bi_16x16)  1  1  0  0  0  0   \n4 (B_L0_L0_16x8)  1  1  0  0  0  1   \n5 (B_L0_L0_8x16)  1  1  0  0  1  0   \n6 (B_L1_L1_16x8)  1  1  0  0  1  1   \n7 (B_L1_L1_8x16)  1  1  0  1  0  0   \n8 (B_L0_L1_16x8)  1  1  0  1  0  1   \n9 (B_L0_L1_8x16)  1  1  0  1  1  0   \n10 (B_L1_L0_16x8)  1  1  0  1  1  1   \n11 (B_L1_L0_8x16)  1  1  1  1  1  0   \nB slice \n12 (B_L0_Bi_16x8)  1  1  1  0  0  0  0 \n13 (B_L0_Bi_8x16)  1  1  1  0  0  0  1 \n14 (B_L1_Bi_16x8)  1  1  1  0  0  1  0 \n15 (B_L1_Bi_8x16)  1  1  1  0  0  1  1 \n16 (B_Bi_L0_16x8)  1  1  1  0  1  0  0 \n17 (B_Bi_L0_8x16)  1  1  1  0  1  0  1 \n18 (B_Bi_L1_16x8)  1  1  1  0  1  1  0 \n19 (B_Bi_L1_8x16)  1  1  1  0  1  1  1 \n20 (B_Bi_Bi_16x8)  1  1  1  1  0  0  0 \n21 (B_Bi_Bi_8x16)  1  1  1  1  0  0  1 \n22 (B_8x8)  1  1  1  1  1  1   \n23 to 48 (Intra, prefix only)  1  1  1  1  0   1   \nbinIdx  0  1  2  3  4  5  6 \n \nFor P, SP, and B slices the specification of the binarization for sub_mb_type[ ] is given in Table 9-38. \n    Rec. ITU-T H.264 (06/2019)  255 \n \nTable 9-38 – Binarization for sub-macroblock types in P, SP, and B slices \nSlice type  Value (name) of sub_mb_type[ ]  Bin string \n0 (P_L0_8x8)  1           \n1 (P_L0_8x4)  0  0         \nP, SP slice \n2 (P_L0_4x8)  0  1  1       \n3 (P_L0_4x4)  0  1  0       \n0 (B_Direct_8x8)  0           \n1 (B_L0_8x8)  1  0  0       \n2 (B_L1_8x8)  1  0  1       \n3 (B_Bi_8x8)  1  1  0  0  0   \n4 (B_L0_8x4)  1  1  0  0  1   \n5 (B_L0_4x8)  1  1  0  1  0   \nB slice  6 (B_L1_8x4)  1  1  0  1  1   \n7 (B_L1_4x8)  1  1  1  0  0  0 \n8 (B_Bi_8x4)  1  1  1  0  0  1 \n9 (B_Bi_4x8)  1  1  1  0  1  0 \n10 (B_L0_4x4)  1  1  1  0  1  1 \n11 (B_L1_4x4)  1  1  1  1  0   \n12 (B_Bi_4x4)  1  1  1  1  1   \nbinIdx  0  1  2  3  4  5 \n \n9.3.2.6  Binarization process for coded block pattern \nInput to this process is a request for a binarization for the syntax element coded_block_pattern. \nOutput of this process is the binarization of the syntax element. \nThe binarization of coded_block_pattern consists of a prefix part and (when present) a suffix part. The prefix part of the \nbinarization is given by the FL binarization of CodedBlockPatternLuma with cMax = 15. When ChromaArrayType is not \nequal to 0 or 3, the suffix part is present and consists of the TU binarization of CodedBlockPatternChroma with cMax = 2. \nThe relationship between the value of the syntax element coded_block_pattern and the values of CodedBlockPatternLuma \nand CodedBlockPatternChroma is given as specified in clause 7.4.5. \n9.3.2.7  Binarization process for mb_qp_delta \nInput to this process is a request for a binarization for the syntax element mb_qp_delta. \nOutput of this process is the binarization of the syntax element. \nThe bin string of mb_qp_delta is derived by the U binarization of the mapped value of the syntax element mb_qp_delta, \nwhere the assignment rule between the signed value of mb_qp_delta and its mapped value is given as specified in Table 9-3. \n9.3.3  Decoding process flow \nInput to this process is a binarization of the requested syntax element, maxBinIdxCtx, bypassFlag and ctxIdxOffset as \nspecified in clause 9.3.2. \nOutput of this process is the value of the syntax element. \nThis process specifies how each bit of a bit string is parsed for each syntax element. \n256  Rec. ITU-T H.264 (06/2019) \n \nAfter parsing each bit, the resulting bit string is compared to all bin strings of the binarization of the syntax element and \nthe following applies: \n–  If the bit string is equal to one of the bin strings, the corresponding value of the syntax element is the output. \n–  Otherwise (the bit string is not equal to one of the bin strings), the next bit is parsed. \nWhile parsing each bin, the variable binIdx is incremented by 1 starting with binIdx being set equal to 0 for the first bin. \nWhen the binarization of the corresponding syntax element consists of a prefix and a suffix binarization part,, the variable \nbinIdx is set equal to 0 for the first bin of each part of the bin string (prefix part or suffix part). In this case, after parsing \nthe prefix bit string, the parsing process of the suffix bit string related to the binarizations specified in clauses 9.3.2.3 and \n9.3.2.5 is invoked depending on the resulting prefix bit string as specified in clauses 9.3.2.3 and 9.3.2.5. Note that for the \nbinarization of the syntax element coded_block_pattern, the suffix bit string is present regardless of the prefix bit string of \nlength 4 as specified in clause 9.3.2.6. \nDepending on the variable bypassFlag, the following applies: \n–  If bypassFlag is equal to 1, the bypass decoding process as specified in clause 9.3.3.2.3 is applied for parsing the value \nof the bins from the bitstream. \n–  Otherwise (bypassFlag is equal to 0), the parsing of each bin is specified by the following two ordered steps: \n1.  Given binIdx, maxBinIdxCtx and ctxIdxOffset, ctxIdx is derived as specified in clause 9.3.3.1. \n2.  Given ctxIdx, the value of the bin from the bitstream as specified in clause 9.3.3.2 is decoded. \n9.3.3.1  Derivation process for ctxIdx \nInputs to this process are binIdx, maxBinIdxCtx and ctxIdxOffset. \nOutput of this process is ctxIdx. \nTable 9-39 shows the assignment of ctxIdx increments (ctxIdxInc) to binIdx for all ctxIdxOffset values except those related \nto the syntax elements coded_block_flag, significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1. \nThe ctxIdx to be used with a specific binIdx is specified by first determining the ctxIdxOffset associated with the given \nbin string or part thereof. The ctxIdx is determined as follows: \n–  If the ctxIdxOffset is listed in Table 9-39, the ctxIdx for a binIdx is the sum of ctxIdxOffset and ctxIdxInc, which is \nfound in Table 9-39. When more than one value is listed in Table 9-39 for a binIdx, the assignment process for \nctxIdxInc for that binIdx is further specified in the clauses given in parenthesis of the corresponding table entry. \n–  Otherwise (ctxIdxOffset is not listed in Table 9-39), the ctxIdx is specified to be the sum of the following terms: \nctxIdxOffset  and  ctxIdxBlockCatOffset(ctxBlockCat)  as  specified  in  Table 9-40  and  ctxIdxInc(ctxBlockCat). \nClause 9.3.3.1.3  specifies  which  ctxBlockCat  is  used.  Clause 9.3.3.1.1.9  specifies  the  assignment  of \nctxIdxInc(ctxBlockCat)  for  coded_block_flag,  and  clause 9.3.3.1.3  specifies  the  assignment  of \nctxIdxInc(ctxBlockCat) for significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1. \nAll bins with binIdx greater than maxBinIdxCtx are parsed using the value of ctxIdx being assigned to binIdx equal to \nmaxBinIdxCtx. \nAll entries in Table 9-39 labelled with \"na\" correspond to values of binIdx that do not occur for the corresponding \nctxIdxOffset. \nctxIdx = 276 is assigned to the binIdx of mb_type indicating the I_PCM mode. For parsing the value of the corresponding \nbins from the bitstream, the arithmetic decoding process for decisions before termination as specified in clause 9.3.3.2.4 is \napplied. \n    Rec. ITU-T H.264 (06/2019)  257 \n \nTable 9-39 – Assignment of ctxIdxInc to binIdx for all ctxIdxOffset values except those related to the syntax \nelements coded_block_flag, significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1 \nbinIdx \nctxIdxOffset \n0  1  2  3  4   5  >= 6 \n0,1,2 \n0   na  na  na  na  na  na \n(clause 9.3.3.1.1.3) \n5,6  6,7 \n0,1,2 \n3   ctxIdx=276  3  4  (clause   (clause   7 \n(clause 9.3.3.1.1.3) \n9.3.3.1.2)  9.3.3.1.2) \n0,1,2 \n11   na  na  na  na  na  na \n(clause 9.3.3.1.1.1) \n2,3 \n14   0  1  (clause   na  na  na  na \n9.3.3.1.2) \n2,3 \n17   0  ctxIdx=276  1  2  (clause   3  3 \n9.3.3.1.2) \n21  0  1  2  na  na  na  na \n0,1,2 \n24   na  na  na  na  na  na \n(clause 9.3.3.1.1.1) \n4,5 \n0,1,2 \n27   3  (clause   5  5  5  5 \n(clause 9.3.3.1.1.3) \n9.3.3.1.2) \n2,3 \n32   0  ctxIdx=276  1  2  (clause   3  3 \n9.3.3.1.2) \n2,3 \n36   0  1  (clause   3  3  3  na \n9.3.3.1.2) \n0,1,2 \n40   3  4  5  6  6  6 \n(clause 9.3.3.1.1.7) \n0,1,2 \n47   3  4  5  6  6  6 \n(clause 9.3.3.1.1.7) \n0,1,2,3 \n54   4  5  5  5  5  5 \n(clause 9.3.3.1.1.6) \n0,1 \n60   2  3  3  3  3  3 \n(clause 9.3.3.1.1.5) \n0,1,2 \n64   3  3  na  na  na  na \n(clause 9.3.3.1.1.8) \n68   0  na  na  na  na  na  na \n69   0  0  0  na  na  na  na \n0,1,2 \n70   na  na  na  na  na  na \n(clause 9.3.3.1.1.2) \n0,1,2,3  0,1,2,3  0,1,2,3 \n0,1,2,3 \n73   (clause   (clause   (clause   na  na  na \n(clause 9.3.3.1.1.4) \n9.3.3.1.1.4)  9.3.3.1.1.4)  9.3.3.1.1.4) \n4,5,6,7 \n0,1,2,3 \n77   (clause   na  na  na  na  na \n(clause 9.3.3.1.1.4) \n9.3.3.1.1.4) \n276   0  na  na  na  na  na  na \n0,1,2 \n399  na  na  na  na  na  na \n(clause 9.3.3.1.1.10) \n \n258  Rec. ITU-T H.264 (06/2019) \n \nTable 9-40  shows  the  values  of  ctxIdxBlockCatOffset  depending  on  ctxBlockCat  for  the  syntax  elements \ncoded_block_flag, significant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1. The specification of \nctxBlockCat is given in Table 9-42. \nTable 9-40 – Assignment of ctxIdxBlockCatOffset to ctxBlockCat for syntax elements coded_block_flag, \nsignificant_coeff_flag, last_significant_coeff_flag, and coeff_abs_level_minus1 \n \nctxBlockCat (as specified in Table 9-42) \nSyntax element \n0  1  2  3  4  5  6  7  8  9  10  11  12  13 \ncoded_block_flag  0  4  8  12  16  0  0  4  8  4  0  4  8  8 \nsignificant_coeff_flag  0  15  29  44  47   0   0  15  29  0   0  15  29  0  \nlast_significant_coeff_flag  0  15  29  44  47  0  0  15  29  0  0  15  29  0 \ncoeff_abs_level_minus1  0   10  20  30  39  0  0   10  20  0  0   10  20  0 \n \n9.3.3.1.1 Assignment process of ctxIdxInc using neighbouring syntax elements \nClause 9.3.3.1.1.1 specifies the derivation process of ctxIdxInc for the syntax element mb_skip_flag. \nClause 9.3.3.1.1.2 specifies the derivation process of ctxIdxInc for the syntax element mb_field_decoding_flag. \nClause 9.3.3.1.1.3 specifies the derivation process of ctxIdxInc for the syntax element mb_type. \nClause 9.3.3.1.1.4 specifies the derivation process of ctxIdxInc for the syntax element coded_block_pattern. \nClause 9.3.3.1.1.5 specifies the derivation process of ctxIdxInc for the syntax element mb_qp_delta. \nClause 9.3.3.1.1.6 specifies the derivation process of ctxIdxInc for the syntax elements ref_idx_l0 and ref_idx_l1. \nClause 9.3.3.1.1.7 specifies the derivation process of ctxIdxInc for the syntax elements mvd_l0 and mvd_l1. \nClause 9.3.3.1.1.8 specifies the derivation process of ctxIdxInc for the syntax element intra_chroma_pred_mode. \nClause 9.3.3.1.1.9 specifies the derivation process of ctxIdxInc for the syntax element coded_block_flag. \nClause 9.3.3.1.1.10 specifies the derivation process of ctxIdxInc for the syntax element transform_size_8x8_flag. \n9.3.3.1.1.1  Derivation process of ctxIdxInc for the syntax element mb_skip_flag \nOutput of this process is ctxIdxInc. \nWhen MbaffFrameFlag is equal to 1 and mb_field_decoding_flag has not been decoded (yet) for the current macroblock \npair  with  top  macroblock  address  2 * ( CurrMbAddr / 2 ),  the  inference  rule  for  the  syntax  element \nmb_field_decoding_flag as specified in clause 7.4.4 is applied. \nThe derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to \nmbAddrA and mbAddrB. \nLet the variable condTermFlagN (with N being either A or B) be derived as follows: \n–  If mbAddrN is not available or mb_skip_flag for the macroblock mbAddrN is equal to 1, condTermFlagN is set equal \nto 0. \n–  Otherwise (mbAddrN is available and mb_skip_flag for the macroblock mbAddrN is equal to 0), condTermFlagN is \nset equal to 1. \nThe variable ctxIdxInc is derived by: \nctxIdxInc = condTermFlagA + condTermFlagB    (9-7) \n9.3.3.1.1.2  Derivation process of ctxIdxInc for the syntax element mb_field_decoding_flag \nOutput of this process is ctxIdxInc. \n    Rec. ITU-T H.264 (06/2019)  259 \n \nThe derivation process for neighbouring macroblock addresses and their availability in MBAFF frames as specified in \nclause 6.4.10 is invoked and the output is assigned to mbAddrA and mbAddrB. \nWhen both macroblocks mbAddrN and mbAddrN + 1 have mb_type equal to P_Skip or B_Skip, the inference rule for the \nsyntax element mb_field_decoding_flag as specified in clause 7.4.4 is applied for the macroblock mbAddrN. \nLet the variable condTermFlagN (with N being either A or B) be derived as follows: \n–  If any of the following conditions are true, condTermFlagN is set equal to 0: \n–  mbAddrN is not available, \n–  the macroblock mbAddrN is a frame macroblock. \n–  Otherwise, condTermFlagN is set equal to 1. \nThe variable ctxIdxInc is derived by \nctxIdxInc = condTermFlagA + condTermFlagB    (9-8) \n9.3.3.1.1.3  Derivation process of ctxIdxInc for the syntax element mb_type \nInput to this process is ctxIdxOffset. \nOutput of this process is ctxIdxInc. \nThe derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to \nmbAddrA and mbAddrB. \nLet the variable condTermFlagN (with N being either A or B) be derived as follows: \n–  If any of the following conditions are true, condTermFlagN is set equal to 0: \n–  mbAddrN is not available, \n–  ctxIdxOffset is equal to 0 and mb_type for the macroblock mbAddrN is equal to SI, \n–  ctxIdxOffset is equal to 3 and mb_type for the macroblock mbAddrN is equal to I_NxN, \n–  ctxIdxOffset is equal to 27 and mb_type for the macroblock mbAddrN is equal to B_Skip or B_Direct_16x16. \n–  Otherwise, condTermFlagN is set equal to 1. \nThe variable ctxIdxInc is derived as \nctxIdxInc = condTermFlagA + condTermFlagB    (9-9) \n9.3.3.1.1.4  Derivation process of ctxIdxInc for the syntax element coded_block_pattern \nInputs to this process are ctxIdxOffset and binIdx. \nOutput of this process is ctxIdxInc. \nDepending on the value of the variable ctxIdxOffset, the following ordered steps are specified: \n–  If ctxIdxOffset is equal to 73, the following applies: \n1.  The  derivation  process  for  neighbouring  8x8  luma  blocks  specified  in  clause 6.4.11.2  is  invoked  with \nluma8x8BlkIdx = binIdx as input and the output is assigned to mbAddrA, mbAddrB, luma8x8BlkIdxA, and \nluma8x8BlkIdxB. \n2.  Let the variable condTermFlagN (with N being either A or B) be derived as follows: \n–  If any of the following conditions are true, condTermFlagN is set equal to 0: \n–  mbAddrN is not available, \n–  mb_type for the macroblock mbAddrN is equal to I_PCM, \n–  the macroblock mbAddrN is not the current macroblock CurrMbAddr and the macroblock mbAddrN \ndoes  not  have  mb_type  equal  to  P_Skip  or  B_Skip,  and \n( ( CodedBlockPatternLuma >> luma8x8BlkIdxN ) & 1 )  is  not  equal  to 0  for  the  value  of \nCodedBlockPatternLuma for the macroblock mbAddrN, \n260  Rec. ITU-T H.264 (06/2019) \n \n–  the macroblock mbAddrN is the current macroblock CurrMbAddr and the prior decoded bin value b  \nk\nof coded_block_pattern with k = luma8x8BlkIdxN is not equal to 0. \n–  Otherwise, condTermFlagN is set equal to 1. \n3.  The variable ctxIdxInc is derived as \nctxIdxInc = condTermFlagA + 2 * condTermFlagB  (9-10) \n–  Otherwise (ctxIdxOffset is equal to 77), the following ordered steps are specified: \n1.  The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is \nassigned to mbAddrA and mbAddrB. \n2.  Let the variable condTermFlagN (with N being either A or B) be derived as follows: \n–  If mbAddrN is available and mb_type for the macroblock mbAddrN is equal to I_PCM, condTermFlagN is \nset equal to 1. \n–  Otherwise, if any of the following conditions are true, condTermFlagN is set equal to 0: \n–  mbAddrN is not available or the macroblock mbAddrN has mb_type equal to P_Skip or B_Skip, \n–  binIdx is equal to 0 and CodedBlockPatternChroma for the macroblock mbAddrN is equal to 0, \n–  binIdx is equal to 1 and CodedBlockPatternChroma for the macroblock mbAddrN is not equal to 2. \n–  Otherwise, condTermFlagN is set equal to 1. \n3.  The variable ctxIdxInc is derived as \nctxIdxInc = condTermFlagA + 2 * condTermFlagB + ( ( binIdx  = =  1 ) ? 4 : 0 )  (9-11) \nNOTE – When a macroblock is coded in Intra_16x16 macroblock prediction mode, the values of CodedBlockPatternLuma and \nCodedBlockPatternChroma for the macroblock are derived from mb_type as specified in Table 7-11. \n9.3.3.1.1.5  Derivation process of ctxIdxInc for the syntax element mb_qp_delta \nOutput of this process is ctxIdxInc. \nLet prevMbAddr be the macroblock address of the macroblock that precedes the current macroblock in decoding order. \nWhen the current macroblock is the first macroblock of a slice, prevMbAddr is marked as not available. \nLet the variable ctxIdxInc be derived as follows: \n–  If any of the following conditions are true, ctxIdxInc is set equal to 0: \n–  prevMbAddr is not available or the macroblock prevMbAddr has mb_type equal to P_Skip or B_Skip, \n–  mb_type of the macroblock prevMbAddr is equal to I_PCM, \n–  The  macroblock  prevMbAddr  is  not  coded  in  Intra_16x16  macroblock  prediction  mode  and  both \nCodedBlockPatternLuma and CodedBlockPatternChroma for the macroblock prevMbAddr are equal to 0, \n–  mb_qp_delta for the macroblock prevMbAddr is equal to 0. \n–  Otherwise, ctxIdxInc is set equal to 1. \n9.3.3.1.1.6  Derivation process of ctxIdxInc for the syntax elements ref_idx_l0 and ref_idx_l1 \nInput to this process is mbPartIdx. \nOutput of this process is ctxIdxInc. \nThe interpretation of ref_idx_lX and Pred_LX within this clause is specified as follows: \n–  If this process is invoked for the derivation of ref_idx_l0, ref_idx_lX is interpreted as ref_idx_l0 and Pred_LX is \ninterpreted as Pred_L0. \n–  Otherwise (this process is invoked for the derivation of ref_idx_l1), ref_idx_lX is interpreted as ref_idx_l1 and \nPred_LX is interpreted as Pred_L1. \nThe derivation process for neighbouring partitions specified in clause 6.4.11.7 is invoked with mbPartIdx, currSubMbType \nset  equal  to  sub_mb_type[ mbPartIdx ],  and  subMbPartIdx = 0  as  input  and  the  output  is  assigned  to \nmbAddrA\\mbPartIdxA and mbAddrB\\mbPartIdxB. \n    Rec. ITU-T H.264 (06/2019)  261 \n \nWith ref_idx_lX[ mbPartIdxN ] (with N being either A or B) specifying the syntax element for the macroblock mbAddrN, \nlet the variable refIdxZeroFlagN be derived as follows: \n–  If MbaffFrameFlag is equal to 1, the current macroblock is a frame macroblock, and the macroblock mbAddrN is a \nfield macroblock, \nrefIdxZeroFlagN = ( ( ref_idx_lX[ mbPartIdxN ] > 1 ) ? 0 : 1 )   (9-12) \n–  Otherwise, \nrefIdxZeroFlagN = ( ( ref_idx_lX[ mbPartIdxN ] > 0 ) ? 0 : 1 )   (9-13) \nLet the variable predModeEqualFlagN be specified as follows: \n–  If mb_type for the macroblock mbAddrN is equal to B_Direct_16x16 or B_Skip, predModeEqualFlagN is set equal \nto 0. \n–  Otherwise, if the macroblock mbAddrN has mb_type equal to P_8x8 or B_8x8, the following applies: \n–  If  SubMbPredMode( sub_mb_type[ mbPartIdxN ] )  is  not  equal  to  Pred_LX  and  not  equal  to  BiPred, \npredModeEqualFlagN is set equal to 0, where sub_mb_type specifies the syntax element list for the macroblock \nmbAddrN. \n–  Otherwise, predModeEqualFlagN is set equal to 1. \n–  Otherwise, the following applies: \n–  If  MbPartPredMode( mb_type, mbPartIdxN )  is  not  equal  to  Pred_LX  and  not  equal  to  BiPred, \npredModeEqualFlagN  is  set  equal  to  0,  where  mb_type  specifies  the  syntax  element  for  the  macroblock \nmbAddrN. \n–  Otherwise, predModeEqualFlagN is set equal to 1. \nLet the variable condTermFlagN (with N being either A or B) be derived as follows: \n–  If any of the following conditions are true, condTermFlagN is set equal to 0: \n–  mbAddrN is not available, \n–  the macroblock mbAddrN has mb_type equal to P_Skip or B_Skip, \n–  the macroblock mbAddrN is coded in an Intra macroblock prediction mode, \n–  predModeEqualFlagN is equal to 0, \n–  refIdxZeroFlagN is equal to 1. \n–  Otherwise, condTermFlagN is set equal to 1. \nThe variable ctxIdxInc is derived as \nctxIdxInc = condTermFlagA + 2 * condTermFlagB   (9-14) \n9.3.3.1.1.7  Derivation process of ctxIdxInc for the syntax elements mvd_l0 and mvd_l1 \nInputs to this process are mbPartIdx, subMbPartIdx, and ctxIdxOffset. \nOutput of this process is ctxIdxInc. \nThe interpretation of mvd_lX and Pred_LX within this clause is specified as follows: \n–  If this process is invoked for the derivation of mvd_l0, mvd_lX is interpreted as mvd_l0 and Pred_LX is interpreted \nas Pred_L0. \n–  Otherwise (this process is invoked for the derivation of mvd_l1), mvd_lX is interpreted as mvd_l1 and Pred_LX is \ninterpreted as Pred_L1. \nThe derivation process for neighbouring partitions specified in clause 6.4.11.7 is invoked with mbPartIdx, currSubMbType \nset  equal  to  sub_mb_type[ mbPartIdx ],  and  subMbPartIdx  as  input  and  the  output  is  assigned  to \nmbAddrA\\mbPartIdxA\\subMbPartIdxA and mbAddrB\\mbPartIdxB\\subMbPartIdxB. \nLet the variable compIdx be derived as follows: \n–  If ctxIdxOffset is equal to 40, compIdx is set equal to 0. \n262  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (ctxIdxOffset is equal to 47), compIdx is set equal to 1. \nLet the variable predModeEqualFlagN be specified as follows: \n–  If mb_type for the macroblock mbAddrN is equal to B_Direct_16x16 or B_Skip, predModeEqualFlagN is set equal \nto 0. \n–  Otherwise, if the macroblock mbAddrN has mb_type equal to P_8x8 or B_8x8, the following applies: \n–  If  SubMbPredMode( sub_mb_type[ mbPartIdxN ] )  is  not  equal  to  Pred_LX  and  not  equal  to  BiPred, \npredModeEqualFlagN is set equal to 0, where sub_mb_type specifies the syntax element list for the macroblock \nmbAddrN. \n–  Otherwise, predModeEqualFlagN is set equal to 1. \n–  Otherwise, the following applies: \n–  If  MbPartPredMode( mb_type, mbPartIdxN )  is  not  equal  to  Pred_LX  and  not  equal  to  BiPred, \npredModeEqualFlagN  is  set  equal  to  0,  where  mb_type  specifies  the  syntax  element  for  the  macroblock \nmbAddrN. \n–  Otherwise, predModeEqualFlagN is set equal to 1. \nLet the variable absMvdCompN (with N being either A or B) be derived as follows: \n–  If any of the following conditions are true, absMvdCompN is set equal to 0: \n–  mbAddrN is not available, \n–  the macroblock mbAddrN has mb_type equal to P_Skip or B_Skip, \n–  the macroblock mbAddrN is coded in an Intra macroblock prediction mode, \n–  predModeEqualFlagN is equal to 0. \n–  Otherwise, the following applies: \n–  If compIdx is equal to 1, MbaffFrameFlag is equal to 1, the current macroblock is a frame macroblock, and the \nmacroblock mbAddrN is a field macroblock, \nabsMvdCompN = Abs( mvd_lX[ mbPartIdxN ][ subMbPartIdxN ][ compIdx ] ) * 2  (9-15) \n–  Otherwise, if compIdx is equal to 1, MbaffFrameFlag is equal to 1, the current macroblock is a field macroblock, \nand the macroblock mbAddrN is a frame macroblock, \nabsMvdCompN = Abs( mvd_lX[ mbPartIdxN ][ subMbPartIdxN ][ compIdx ] ) / 2  (9-16) \n–  Otherwise, \nabsMvdCompN = Abs( mvd_lX[ mbPartIdxN ][ subMbPartIdxN ][ compIdx ] )  (9-17) \nThe variable ctxIdxInc is derived as follows: \n–  If absMvdCompA is greater than 32 or absMvdCompA is greater than 32, ctxIdxInc is set equal to 2. \n–  Otherwise, if absMvdCompA + absMvdCompB is greater than 32, ctxIdxInc is set equal to 2. \n–  Otherwise, if absMvdCompA + absMvdCompB is greater than 2, ctxIdxInc is set equal to 1. \n–  Otherwise (absMvdCompA + absMvdCompB is less than or equal to 2), ctxIdxInc is set equal to 0. \nNOTE – Although the above form of expression for the derivation of ctxIdxInc could have been somewhat simplified, the form \nshown above was selected to assist the reader in avoiding a potential dynamic range problem in the derivation process. \n9.3.3.1.1.8  Derivation process of ctxIdxInc for the syntax element intra_chroma_pred_mode \nOutput of this process is ctxIdxInc. \nThe derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to \nmbAddrA and mbAddrB. \nLet the variable condTermFlagN (with N being replaced by either A or B) be derived as follows: \n–  If any of the following conditions are true, condTermFlagN is set equal to 0: \n    Rec. ITU-T H.264 (06/2019)  263 \n \n–  mbAddrN is not available, \n–  The macroblock mbAddrN is coded in an Inter macroblock prediction mode, \n–  mb_type for the macroblock mbAddrN is equal to I_PCM, \n–  intra_chroma_pred_mode for the macroblock mbAddrN is equal to 0. \n–  Otherwise, condTermFlagN is set equal to 1. \nThe variable ctxIdxInc is derived by: \nctxIdxInc = condTermFlagA + condTermFlagB    (9-18) \n9.3.3.1.1.9  Derivation process of ctxIdxInc for the syntax element coded_block_flag \nInput to this process is ctxBlockCat and additional input is specified as follows: \n–  If ctxBlockCat is equal to 0, 6, or 10, no additional input. \n–  Otherwise, if ctxBlockCat is equal to 1 or 2, luma4x4BlkIdx. \n–  Otherwise, if ctxBlockCat is equal to 3, the chroma component index iCbCr. \n–  Otherwise, if ctxBlockCat is equal to 4, chroma4x4BlkIdx and the chroma component index iCbCr. \n–  Otherwise, if ctxBlockCat is equal to 5, luma8x8BlkIdx. \n–  Otherwise, if ctxBlockCat is equal to 7 or 8, cb4x4BlkIdx. \n–  Otherwise, if ctxBlockCat is equal to 9, cb8x8BlkIdx. \n–  Otherwise, if ctxBlockCat is equal to 11 or 12, cr4x4BlkIdx. \n–  Otherwise (ctxBlockCat is equal to 13), cr8x8BlkIdx. \nOutput of this process is ctxIdxInc( ctxBlockCat ). \nLet the variable transBlockN (with N being either A or B) be derived as follows: \n–  If ctxBlockCat is equal to 0, 6, or 10, the following ordered steps are specified: \n1.  The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is \nassigned to mbAddrN (with N being either A or B). \n2.  The variable transBlockN is derived as follows: \n–  If mbAddrN is available and the macroblock mbAddrN is coded in Intra_16x16 macroblock prediction \nmode, the following applies: \n–  If ctxBlockCat is equal to 0, the luma DC block of macroblock mbAddrN is assigned to transBlockN. \n–  Otherwise, if ctxBlockCat is equal to 6, the Cb DC block of macroblock mbAddrN is assigned to \ntransBlockN. \n–  Otherwise (ctxBlockCat is equal to 10), the Cr DC block of macroblock mbAddrN is assigned to \ntransBlockN. \n–  Otherwise, transBlockN is marked as not available. \n–  Otherwise, if ctxBlockCat is equal to 1 or 2, the following ordered steps are specified: \n1.  The  derivation  process  for  neighbouring  4x4  luma  blocks  specified  in  clause 6.4.11.4  is  invoked  with \nluma4x4BlkIdx as input and the output is assigned to mbAddrN, luma4x4BlkIdxN (with N being either A or B). \n2.  The variable transBlockN is derived as follows: \n–  If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or \nI_PCM,  (  ( CodedBlockPatternLuma >> ( luma4x4BlkIdxN >>2 ) )  &  1  )  is  not  equal  to 0  for  the \nmacroblock mbAddrN, and transform_size_8x8_flag is equal to 0 for the macroblock mbAddrN, the 4x4 \nluma block with index luma4x4BlkIdxN of macroblock mbAddrN is assigned to transBlockN. \n–  Otherwise, if mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip or \nB_Skip,  ( ( CodedBlockPatternLuma >> ( luma4x4BlkIdxN >>2 ) )  &  1 )  is  not  equal  to 0  for  the \nmacroblock mbAddrN, and transform_size_8x8_flag is equal to 1 for the macroblock mbAddrN, the 8x8 \nluma block with index ( luma4x4BlkIdxN >> 2 ) of macroblock mbAddrN is assigned to transBlockN. \n264  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise, transBlockN is marked as not available. \n–  Otherwise, if ctxBlockCat is equal to 3, the following ordered steps are specified: \n1.  The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is \nassigned to mbAddrN (with N being either A or B). \n2.  The variable transBlockN is derived as follows: \n–  If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or \nI_PCM, and CodedBlockPatternChroma is not equal to 0 for the macroblock mbAddrN, the chroma DC \nblock of chroma component iCbCr of macroblock mbAddrN is assigned to transBlockN. \n–  Otherwise, transBlockN is marked as not available. \n–  Otherwise, if ctxBlockCat is equal to 4, the following ordered steps are specified: \n1.  The  derivation  process  for  neighbouring  4x4  chroma  blocks  specified  in  clause 6.4.11.5  is  invoked  with \nchroma4x4BlkIdx as input and the output is assigned to mbAddrN, chroma4x4BlkIdxN (with N being either A \nor B). \n2.  The variable transBlockN is derived as follows: \n–  If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or \nI_PCM, and CodedBlockPatternChroma is equal to 2 for the macroblock mbAddrN, the 4x4 chroma block \nwith  chroma4x4BlkIdxN  of  the  chroma  component  iCbCr  of  macroblock  mbAddrN  is  assigned  to \ntransBlockN. \n–  Otherwise, transBlockN is marked as not available. \n–  Otherwise, if ctxBlockCat is equal to 5, the following ordered steps are specified: \n1.  The  derivation  process  for  neighbouring  8x8  luma  blocks  specified  in  clause 6.4.11.2  is  invoked  with \nluma8x8BlkIdx as input and the output is assigned to mbAddrN, luma8x8BlkIdxN (with N being either A or B). \n2.  The variable transBlockN is derived as follows: \n–  If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or \nI_PCM,  (  ( CodedBlockPatternLuma >>luma8x8BlkIdx)  &  1  )  is  not  equal  to 0  for  the  macroblock \nmbAddrN, and transform_size_8x8_flag is equal to 1 for the macroblock mbAddrN, the 8x8 luma block \nwith index luma8x8BlkIdxN of macroblock mbAddrN is assigned to transBlockN. \n–  Otherwise, transBlockN is marked as not available. \n–  Otherwise, if ctxBlockCat is equal to7 or 8, the following ordered steps are specified: \n1.  The  derivation  process  for  neighbouring  4x4  Cb  blocks  specified  in  clause 6.4.11.5  is  invoked  with \ncb4x4BlkIdx as input and the output is assigned to mbAddrN, cb4x4BlkIdxN (with N being either A or B). \n2.  The variable transBlockN is derived as follows: \n–  If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or \nI_PCM, (( CodedBlockPatternLuma >> ( cb4x4BlkIdxN >>2 ) ) & 1 ) is not equal to 0 for the macroblock \nmbAddrN, and transform_size_8x8_flag is equal to 0 for the macroblock mbAddrN, the 4x4 Cb block \nwith index cb4x4BlkIdxN of macroblock mbAddrN is assigned to transBlockN. \n–  Otherwise, if mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip or \nB_Skip,  ( ( CodedBlockPatternLuma >> ( cb4x4BlkIdxN >>2 ) )  &  1 )  is  not  equal  to 0  for  the \nmacroblock mbAddrN, and transform_size_8x8_flag is equal to 1 for the macroblock mbAddrN, the 8x8 \nCb block with index ( cb4x4BlkIdxN >> 2 ) of macroblock mbAddrN is assigned to transBlockN. \n–  Otherwise, transBlockN is marked as not available. \n–  Otherwise, if ctxBlockCat is equal to 9, the following ordered steps are specified: \n1.  The  derivation  process  for  neighbouring  8x8  Cb  blocks  specified  in  clause 6.4.11.3  is  invoked  with \ncb8x8BlkIdx as input and the output is assigned to mbAddrN, cb8x8BlkIdxN (with N being either A or B). \n2.  The variable transBlockN is derived as follows: \n–  If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or \nI_PCM,  (  ( CodedBlockPatternLuma >>cb8x8BlkIdx)  &  1  )  is  not  equal  to 0  for  the  macroblock \n    Rec. ITU-T H.264 (06/2019)  265 \n \nmbAddrN, and transform_size_8x8_flag is equal to 1 for the macroblock mbAddrN, the 8x8 Cb block \nwith index cb8x8BlkIdxN of macroblock mbAddrN is assigned to transBlockN. \n–  Otherwise, transBlockN is marked as not available. \n–  Otherwise, if ctxBlockCat is equal to 11 or 12, the following ordered steps are specified: \n1.  The derivation process for neighbouring 4x4 Cr blocks specified in clause 6.4.11.5 is invoked with cr4x4BlkIdx \nas input and the output is assigned to mbAddrN, cr4x4BlkIdxN (with N being either A or B). \n2.  The variable transBlockN is derived as follows: \n–  If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or \nI_PCM, ( ( CodedBlockPatternLuma >> ( cr4x4BlkIdxN >>2 ) ) & 1 ) is not equal to 0 for the macroblock \nmbAddrN, and transform_size_8x8_flag is equal to 0 for the macroblock mbAddrN, the 4x4 Cr block with \nindex cr4x4BlkIdxN of macroblock mbAddrN is assigned to transBlockN. \n–  Otherwise, if mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip or \nB_Skip, ( ( CodedBlockPatternLuma >> ( cr4x4BlkIdxN >>2 ) ) & 1 ) is not equal to 0 for the macroblock \nmbAddrN, and transform_size_8x8_flag is equal to 1 for the macroblock mbAddrN, the 8x8 Cr block with \nindex ( cr4x4BlkIdxN >> 2 ) of macroblock mbAddrN is assigned to transBlockN. \n–  Otherwise, transBlockN is marked as not available. \n–  Otherwise (ctxBlockCat is equal to 13), the following ordered steps are specified: \n1.  The derivation process for neighbouring 8x8 Cr blocks specified in clause 6.4.11.3 is invoked with cr8x8BlkIdx \nas input and the output is assigned to mbAddrN, cr8x8BlkIdxN (with N being either A or B). \n2.  The variable transBlockN is derived as follows: \n–  If mbAddrN is available, the macroblock mbAddrN does not have mb_type equal to P_Skip, B_Skip, or \nI_PCM,,  (  ( CodedBlockPatternLuma >>cr8x8BlkIdx)  &  1  )  is  not  equal  to 0  for  the  macroblock \nmbAddrN, and transform_size_8x8_flag is equal to 1 for the macroblock mbAddrN, the 8x8 Cr block with \nindex cr8x8BlkIdxN of macroblock mbAddrN is assigned to transBlockN. \n–  Otherwise, transBlockN is marked as not available. \nLet the variable condTermFlagN (with N being either A or B) be derived as follows: \n–  If any of the following conditions are true, condTermFlagN is set equal to 0: \n–  mbAddrN is not available and the current macroblock is coded in an Inter macroblock prediction mode, \n–  mbAddrN is available and transBlockN is not available and mb_type for the macroblock mbAddrN is not equal \nto I_PCM, \n–  The current macroblock is coded in an Intra macroblock prediction mode, constrained_intra_pred_flag is equal \nto 1, the macroblock mbAddrN is available and coded in an Inter macroblock prediction mode, and slice data \npartitioning is in use (nal_unit_type is in the range of 2 through 4, inclusive). \n–  Otherwise, if any of the following conditions are true, condTermFlagN is set equal to 1: \n–  mbAddrN is not available and the current macroblock is coded in an Intra macroblock prediction mode, \n–  mb_type for the macroblock mbAddrN is equal to I_PCM. \n–  Otherwise, condTermFlagN is set equal to the value of the coded_block_flag of the transform block transBlockN that \nwas decoded for the macroblock mbAddrN. \nThe variable ctxIdxInc( ctxBlockCat ) is derived by \nctxIdxInc( ctxBlockCat ) = condTermFlagA + 2 * condTermFlagB  (9-19) \n9.3.3.1.1.10  Derivation process of ctxIdxInc for the syntax element transform_size_8x8_flag \nOutput of this process is ctxIdxInc. \nThe derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to \nmbAddrA and mbAddrB. \nLet the variable condTermFlagN (with N being either A or B) be derived as follows: \n–  If any of the following conditions are true, condTermFlagN is set equal to 0: \n266  Rec. ITU-T H.264 (06/2019) \n \n–  mbAddrN is not available, \n–  transform_size_8x8_flag for the macroblock mbAddrN is equal to 0. \n–  Otherwise, condTermFlagN is set equal to 1. \nThe variable ctxIdxInc is derived by \nctxIdxInc = condTermFlagA + condTermFlagB    (9-20) \n9.3.3.1.2 Assignment process of ctxIdxInc using prior decoded bin values \nInputs to this process are ctxIdxOffset and binIdx. \nOutput of this process is ctxIdxInc. \nTable 9-41 contains the specification of ctxIdxInc for the given values of ctxIdxOffset and binIdx. \nFor each value of ctxIdxOffset and binIdx, ctxIdxInc is derived by using some of the values of prior decoded bin values \n( b , b , b ,…, b  ), where the value of the index k is less than the value of binIdx. \n0 1 2 k\nTable 9-41 – Specification of ctxIdxInc for specific values of ctxIdxOffset and binIdx \nValue (name) of ctxIdxOffset  binIdx  ctxIdxInc \n4  (b   !=  0) ? 5: 6 \n3\n3  \n5  (b   !=  0) ? 6: 7 \n3\n14   2  (b   !=  1) ? 2: 3 \n1\n17   4  (b   !=  0) ? 2: 3 \n3\n27   2  (b   !=  0) ? 4: 5 \n1\n32   4  (b   !=  0) ? 2: 3 \n3\n36   2  (b   !=  0) ? 2: 3 \n1\n \n9.3.3.1.3 Assignment process of ctxIdxInc for syntax elements significant_coeff_flag, last_significant_coeff_flag, \nand coeff_abs_level_minus1 \nInputs to this process are ctxIdxOffset and binIdx. \nOutput of this process is ctxIdxInc. \nThe  assignment  process  of  ctxIdxInc  for  syntax  elements  significant_coeff_flag,  last_significant_coeff_flag,  and \ncoeff_abs_level_minus1 as well as for coded_block_flag depends on categories of different blocks denoted by the variable \nctxBlockCat. The specification of these block categories is given in Table 9-42. \n    Rec. ITU-T H.264 (06/2019)  267 \n \nTable 9-42 – Specification of ctxBlockCat for the different blocks \nBlock description  maxNumCoeff  ctxBlockCat \nblock of luma DC transform coefficient levels \n16  0 \n(i.e., list Intra16x16DCLevel as described in clause 7.4.5.3) \nblock of luma AC transform coefficient levels \n15  1 \n(i.e., list Intra16x16ACLevel[ i ] as described in clause 7.4.5.3) \nblock of 16 luma transform coefficient levels \n16  2 \n(i.e., list LumaLevel4x4[ i ] as described in clause 7.4.5.3) \nblock of chroma DC transform coefficient levels when ChromaArrayType is equal to 1 or 2 \n4 * NumC8x8  3 \n(i.e., list ChromaDCLevel as described in clause 7.4.5.3) \nblock of chroma AC transform coefficient levels when ChromaArrayType is equal to 1 or 2 \n15  4 \n(i.e., list ChromaACLevel as described in clause 7.4.5.3) \nblock of 64 luma transform coefficient levels \n64  5 \n(i.e., list LumaLevel8x8[ i ] as described in clause 7.4.5.3) \nblock of Cb DC transform coefficient levels when ChromaArrayType is equal to 3 \n16  6 \n(i.e., list CbIntra16x16DCLevel as described in clause 7.4.5.3) \nblock of Cb AC transform coefficient levels when ChromaArrayType is equal to 3 \n15  7 \n(i.e., list CbIntra16x16ACLevel[ i ] as described in clause 7.4.5.3) \nblock of 16 Cb transform coefficient levels when ChromaArrayType is equal to 3 \n16  8 \n(i.e., list CbLevel4x4[ i ] as described in clause 7.4.5.3) \nblock of 64 Cb transform coefficient levels when ChromaArrayType is equal to 3 \n64  9 \n(i.e., list CbLevel8x8[ i ] as described in clause 7.4.5.3) \nblock of Cr DC transform coefficient levels when ChromaArrayType is equal to 3 \n16  10 \n(i.e., list CrIntra16x16DCLevel as described in clause 7.4.5.3) \nblock of Cr AC transform coefficient levels when ChromaArrayType is equal to 3 \n15  11 \n(i.e., list CrIntra16x16ACLevel[ i ] as described in clause 7.4.5.3) \nblock of 16 Cr transform coefficient levels when ChromaArrayType is equal to 3 \n16  12 \n(i.e., list CrLevel4x4[ i ] as described in clause 7.4.5.3) \nblock of 64 Cr transform coefficient levels when ChromaArrayType is equal to 3 \n64  13 \n(i.e., list CrLevel8x8[ i ] as described in clause 7.4.5.3) \n \nLet the variable levelListIdx be set equal to the index of the list of transform coefficient levels as specified in clause 7.4.5.3. \nFor the syntax elements significant_coeff_flag and last_significant_coeff_flag in blocks with ctxBlockCat not equal to 3, \n5, 9, and 13, the variable ctxIdxInc is derived by \nctxIdxInc = levelListIdx    (9-21) \nwhere levelListIdx ranges from 0 to maxNumCoeff  2, inclusive. \nFor the syntax elements significant_coeff_flag and last_significant_coeff_flag in blocks with ctxBlockCat  = =  3, the \nvariable ctxIdxInc is derived by \nctxIdxInc = Min( levelListIdx / NumC8x8, 2 )    (9-22) \nwhere levelListIdx ranges from 0 to 4 * NumC8x8  2, inclusive. \nFor  the  syntax  elements  significant_coeff_flag  and  last_significant_coeff_flag  in  8x8  luma,  Cb,  or  Cr  blocks  with \nctxBlockCat  = =  5, 9, or 13, Table 9-43 contains the specification of ctxIdxInc for the given values of levelListIdx, where \nlevelListIdx ranges from 0 to 62, inclusive. \n268  Rec. ITU-T H.264 (06/2019) \n \nTable 9-43 – Mapping of scanning position to ctxIdxInc for ctxBlockCat  = =  5, 9, or 13 \ns\n) \n)  g   s\n) \n)  g  \nk s a k s a\n  g c   g k l   g c   g k l\nd\nx \nf o\nr  \ne f f\n_ f l a\nc r\no b l o\nf o\nr  \ne f f\n_ f l a\nr o\nb l o c\nf o\nr  \nc o\ne f f _ f\nd\nx \nf o\nr  \ne f f\n_ f l a\nc r\no b l o\nf o\nr  \ne f f\n_ f l a\nr o\nb l o c\nf o\nr  \nc o\ne f f _ f\nl e v e l L i s t I c t x I d x I n c   c a g n n t i _ f i c o m e   c o d e d   m a c t x I d x I n c   g n i f i c a n t _ c o d   c o d e d   m a c c t x I d x I n c   _ s i g n i f i c a n t _ l e v e l L i s t I c t x I d x I n c   g n i f i c a n t _ c o m e   c o d e d   m a c t x I d x I n c   g n i f i c a n t _ c o d   c o d e d   m a c c t x I d x I n c   _ s i g n i f i c a n t _\ns i r a s i f i e l a s t s i r a s i f i e l a s t\nf ( l f ( l\n( (\n0  0  0  0  32  7  9  3 \n1  1  1  1  33  6  9  3 \n2  2  1  1  34  11  10  3 \n3  3  2  1  35  12  10  3 \n4  4  2  1  36  13  8  3 \n5  5  3  1  37  11  11  3 \n6  5  3  1  38  6  12  3 \n7  4  4  1  39  7  11  3 \n8  4  5  1  40  8  9  4 \n9  3  6  1  41  9  9  4 \n10  3  7  1  42  14  10  4 \n11  4  7  1  43  10  10  4 \n12  4  7  1  44  9  8  4 \n13  4  8  1  45  8  13  4 \n14  5  4  1  46  6  13  4 \n15  5  5  1  47  11  9  4 \n16  4  6  2  48  12  9  5 \n17  4  9  2  49  13  10  5 \n18  4  10  2  50  11  10  5 \n19  4  10  2  51  6  8  5 \n20  3  8  2  52  9  13  6 \n21  3  11  2  53  14  13  6 \n22  6  12  2  54  10  9  6 \n23  7  11  2  55  9  9  6 \n24  7  9  2  56  11  10  7 \n25  7  9  2  57  12  10  7 \n26  8  10  2  58  13  14  7 \n27  9  10  2  59  11  14  7 \n    Rec. ITU-T H.264 (06/2019)  269 \n \nTable 9-43 – Mapping of scanning position to ctxIdxInc for ctxBlockCat  = =  5, 9, or 13 \ns\n) \n)  g   s\n) \n)  g  \nk s a k s a\n  g c   g k l   g c   g k l\nd\nx \nf o\nr  \ne f f\n_ f l a\nc r\no b l o\nf o\nr  \ne f f\n_ f l a\nr o\nb l o c\nf o\nr  \nc o\ne f f _ f\nd\nx \nf o\nr  \ne f f\n_ f l a\nc r\no b l o\nf o\nr  \ne f f\n_ f l a\nr o\nb l o c\nf o\nr  \nc o\ne f f _ f\nl e v e l L i s t I c t x I d x I n c   c a g n n t i _ f i c o m e   c o d e d   m a c t x I d x I n c   g n i f i c a n t _ c o d   c o d e d   m a c c t x I d x I n c   _ s i g n i f i c a n t _ l e v e l L i s t I c t x I d x I n c   g n i f i c a n t _ c o m e   c o d e d   m a c t x I d x I n c   g n i f i c a n t _ c o d   c o d e d   m a c c t x I d x I n c   _ s i g n i f i c a n t _\ns i r a s i f i e l a s t s i r a s i f i e l a s t\nf ( l f ( l\n( (\n28  10  8  2  60  14  14  8 \n29  9  11  2  61  10  14  8 \n30  8  12  2  62  12  14  8 \n31  7  11  2         \n \nLet numDecodAbsLevelEq1 denote the accumulated number of decoded transform coefficient levels with absolute value \nequal to 1, and let numDecodAbsLevelGt1 denote the accumulated number of decoded transform coefficient levels with \nabsolute value greater than 1. Both numbers are related to the same transform coefficient block, where the current decoding \nprocess takes place. Then, for decoding of coeff_abs_level_minus1, ctxIdxInc for coeff_abs_level_minus1 is specified \ndepending on binIdx as follows: \n–  If binIdx is equal to 0, ctxIdxInc is derived by \nctxIdxInc = ( ( numDecodAbsLevelGt1  !=  0 ) ? 0: Min( 4, 1 + numDecodAbsLevelEq1 ) )  (9-23) \n–  Otherwise (binIdx is greater than 0), ctxIdxInc is derived by \nctxIdxInc = 5 + Min( 4 − ( ( ctxBlockCat  = =  3 )  ?  1  :  0 ), numDecodAbsLevelGt1 )  (9-24) \n9.3.3.2  Arithmetic decoding process \nInputs to this process are the bypassFlag, ctxIdx as derived in clause 9.3.3.1, and the state variables codIRange and \ncodIOffset of the arithmetic decoding engine. \nOutput of this process is the value of the bin. \nFigure 9-2 illustrates the whole arithmetic decoding process for a single bin. For decoding the value of a bin, the context \nindex ctxIdx is passed to the arithmetic decoding process DecodeBin(ctxIdx), which is specified as follows: \n–  If bypassFlag is equal to 1, DecodeBypass( ) as specified in clause 9.3.3.2.3 is invoked. \n–  Otherwise, if bypassFlag is equal to 0 and ctxIdx is equal to 276, DecodeTerminate( ) as specified in clause 9.3.3.2.4 \nis invoked. \n–  Otherwise (bypassFlag is equal to 0 and ctxIdx is not equal to 276), DecodeDecision( ) as specified in clause 9.3.3.2.1 \nis applied. \n270  Rec. ITU-T H.264 (06/2019) \n \nDecodeBin(ctxIdx)\nbypassFlag Yes\n == 1?\nDecodeBypass\nNo\nYes\nctxIdx==276?\nDecodeTerminate\nNo\nDecodeDecision(ctxIdx)\nDone\n \nFigure 9-2 – Overview of the arithmetic decoding process for a single bin (informative) \nNOTE – Arithmetic coding is based on the principle of recursive interval subdivision. Given a probability estimation p( 0 ) and \np( 1 ) = 1  p( 0 ) of a binary decision ( 0, 1 ), an initially given code sub-interval with the range codIRange will be subdivided into \ntwo sub-intervals having range p( 0 ) * codIRange and codIRange  p( 0 ) * codIRange, respectively. Depending on the decision, \nwhich has been observed, the corresponding sub-interval will be chosen as the new code interval, and a binary code string pointing \ninto that interval will represent the sequence of observed binary decisions. It is useful to distinguish between the most probable \nsymbol (MPS) and the least probable symbol (LPS), so that binary decisions have to be identified as either MPS or LPS, rather than \n0 or 1. Given this terminology, each context is specified by the probability p  of the LPS and the value of MPS (valMPS), which \nLPS\nis either 0 or 1. \nThe arithmetic core engine in this Recommendation | International Standard has three distinct properties: \n–  The probability estimation is performed by means of a finite-state machine with a table-based transition process between 64 \ndifferent  representative  probability  states  { p (pStateIdx) | 0 <= pStateIdx < 64 }  for  the  LPS  probability  p .  The \nLPS LPS\nnumbering of the states is arranged in such a way that the probability state with index pStateIdx = 0 corresponds to an LPS \nprobability value of 0.5, with decreasing LPS probability towards higher state indices. \n–  The range codIRange representing the state of the coding engine is quantized to a small set {Q ,…,Q } of pre-set quantization \n1 4\nvalues prior to the calculation of the new interval range. Storing a table containing all 64x4 pre-computed product values of \nQ * p (pStateIdx) allows a multiplication-free approximation of the product codIRange * p (pStateIdx). \ni LPS LPS\n–  For syntax elements or parts thereof for which an approximately uniform probability distribution is assumed to be given a \nseparate simplified encoding and decoding bypass process is used. \n9.3.3.2.1 Arithmetic decoding process for a binary decision \nInputs to this process are ctxIdx, codIRange, and codIOffset. \nOutputs of this process are the decoded value binVal, and the updated variables codIRange and codIOffset. \nFigure 9-3 shows the flowchart for decoding a single decision (DecodeDecision): \n1.  The value of the variable codIRangeLPS is derived as follows: \n–  Given the current value of codIRange, the variable qCodIRangeIdx is derived by \nqCodIRangeIdx =( codIRange  >>  6 ) & 3    (9-25) \n–  Given  qCodIRangeIdx  and  pStateIdx  associated  with  ctxIdx,  the  value  of  the  variable  rangeTabLPS  as \nspecified in Table 9-44 is assigned to codIRangeLPS: \ncodIRangeLPS = rangeTabLPS[ pStateIdx ][ qCodIRangeIdx ]  (9-26) \n    Rec. ITU-T H.264 (06/2019)  271 \n \n2.  The variable codIRange is set equal to codIRange  codIRangeLPS and the following applies: \n–  If codIOffset is greater than or equal to codIRange, the variable binVal is set equal to 1 − valMPS, codIOffset \nis decremented by codIRange, and codIRange is set equal to codIRangeLPS. \n–  Otherwise, the variable binVal is set equal to valMPS. \nGiven the value of binVal, the state transition is performed as specified in clause 9.3.3.2.1.1. Depending on the current \nvalue of codIRange, renormalization is performed as specified in clause 9.3.3.2.2. \n9.3.3.2.1.1  State transition process \nInputs to this process are the current pStateIdx, the decoded value binVal and valMPS values of the context variable \nassociated with ctxIdx. \nOutputs of this process are the updated pStateIdx and valMPS of the context variable associated with ctxIdx. \nDepending on the decoded value binVal, the update of the two variables pStateIdx and valMPS associated with ctxIdx is \nderived as specified by the following pseudo-code: \nif( binVal  = =  valMPS )  \n  pStateIdx = transIdxMPS( pStateIdx ) \nelse {        (9-27) \n  if( pStateIdx  = =  0 ) \n    valMPS = 1  valMPS \n  pStateIdx = transIdxLPS( pStateIdx ) \n} \nTable 9-45 specifies the transition rules transIdxMPS( ) and transIdxLPS( ) after decoding the value of valMPS and \n1  valMPS, respectively. \n272  Rec. ITU-T H.264 (06/2019) \n \n \nFigure 9-3 – Flowchart for decoding a decision \n    Rec. ITU-T H.264 (06/2019)  273 \n \nTable 9-44 – Specification of rangeTabLPS depending on pStateIdx and qCodIRangeIdx \nqCodIRangeIdx  qCodIRangeIdx \npStateIdx  pStateIdx \n0  1  2  3  0  1  2  3 \n0  128  176  208  240  32  27  33  39  45 \n1  128  167  197  227  33  26  31  37  43 \n2  128  158  187  216  34  24  30  35  41 \n3  123  150  178  205  35  23  28  33  39 \n4  116  142  169  195  36  22  27  32  37 \n5  111  135  160  185  37  21  26  30  35 \n6  105  128  152  175  38  20  24  29  33 \n7  100  122  144  166  39  19  23  27  31 \n8  95  116  137  158  40  18  22  26  30 \n9  90  110  130  150  41  17  21  25  28 \n10  85  104  123  142  42  16  20  23  27 \n11  81  99  117  135  43  15  19  22  25 \n12  77  94  111  128  44  14  18  21  24 \n13  73  89  105  122  45  14  17  20  23 \n14  69  85  100  116  46  13  16  19  22 \n15  66  80  95  110  47  12  15  18  21 \n16  62  76  90  104  48  12  14  17  20 \n17  59  72  86  99  49  11  14  16  19 \n18  56  69  81  94  50  11  13  15  18 \n19  53  65  77  89  51  10  12  15  17 \n20  51  62  73  85  52  10  12  14  16 \n21  48  59  69  80  53  9  11  13  15 \n22  46  56  66  76  54  9  11  12  14 \n23  43  53  63  72  55  8  10  12  14 \n24  41  50  59  69  56  8  9  11  13 \n25  39  48  56  65  57  7  9  11  12 \n26  37  45  54  62  58  7  9  10  12 \n27  35  43  51  59  59  7  8  10  11 \n28  33  41  48  56  60  6  8  9  11 \n29  32  39  46  53  61  6  7  9  10 \n30  30  37  43  50  62  6  7  8  9 \n31  29  35  41  48  63  2  2  2  2 \n \n274  Rec. ITU-T H.264 (06/2019) \n \nTable 9-45 – State transition table \npStateIdx  0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15 \ntransIdxLPS  0  0  1  2  2  4  4  5  6  7  8  9  9  11  11  12 \ntransIdxMPS  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16 \npStateIdx  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31 \ntransIdxLPS  13  13  15  15  16  16  18  18  19  19  21  21  22  22  23  24 \ntransIdxMPS  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32 \npStateIdx  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47 \ntransIdxLPS  24  25  26  26  27  27  28  29  29  30  30  30  31  32  32  33 \ntransIdxMPS  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48 \npStateIdx  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63 \ntransIdxLPS  33  33  34  34  35  35  35  36  36  36  37  37  37  38  38  63 \ntransIdxMPS  49  50  51  52  53  54  55  56  57  58  59  60  61  62  62  63 \n \n9.3.3.2.2 Renormalization process in the arithmetic decoding engine \nInputs to this process are bits from slice data and the variables codIRange and codIOffset. \nOutputs of this process are the updated variables codIRange and codIOffset. \nA flowchart of the renormalization is shown in Figure 9-4. The current value of codIRange is first compared to 256 and \nfurther steps are specified as follows: \n–  If codIRange is greater than or equal to 256, no renormalization is needed and the RenormD process is finished; \n–  Otherwise (codIRange is less than 256), the renormalization loop is entered. Within this loop, the value of codIRange \nis doubled, i.e., left-shifted by 1 and a single bit is shifted into codIOffset by using read_bits( 1 ). \nThe bitstream shall not contain data that result in a value of codIOffset being greater than or equal to codIRange upon \ncompletion of this process. \nRenormD\ncodIRange <  256\nYes\ncodIRange = codIRange << 1 No\ncodIOffset = codIOffset << 1\ncodIOffset = codIOffset | read_bits(1)\nDone\n \nFigure 9-4 – Flowchart of renormalization \n    Rec. ITU-T H.264 (06/2019)  275 \n \n9.3.3.2.3 Bypass decoding process for binary decisions \nInputs to this process are bits from slice data and the variables codIRange and codIOffset. \nOutputs of this process are the updated variable codIOffset and the decoded value binVal. \nThe bypass decoding process is invoked when bypassFlag is equal to 1. Figure 9-5 shows a flowchart of the corresponding \nprocess. \nFirst, the  value of codIOffset is doubled, i.e., left-shifted by 1 and a single bit is shifted into codIOffset by  using \nread_bits( 1 ). Then, the value of codIOffset is compared to the value of codIRange and further steps are specified as \nfollows: \n–  If codIOffset is greater than or equal to codIRange, the variable binVal is set equal to 1 and codIOffset is decremented \nby codIRange. \n–  Otherwise (codIOffset is less than codIRange), the variable binVal is set equal to 0. \nThe bitstream shall not contain data that result in a value of codIOffset being greater than or equal to codIRange upon \ncompletion of this process. \n \nFigure 9-5 – Flowchart of bypass decoding process \n9.3.3.2.4 Decoding process for binary decisions before termination \nInputs to this process are bits from slice data and the variables codIRange and codIOffset. \nOutputs of this process are the updated variables codIRange and codIOffset, and the decoded value binVal. \nThis special decoding routine applies to decoding of end_of_slice_flag and of the bin indicating  the I_PCM  mode \ncorresponding to ctxIdx equal to 276. Figure 9-6 shows the flowchart of the corresponding decoding process, which is \nspecified as follows. \nFirst, the value of codIRange is decremented by 2. Then, the value of codIOffset is compared to the value of codIRange \nand further steps are specified as follows: \n–  If codIOffset is greater than or equal to codIRange, the variable binVal is set equal to 1, no renormalization is carried \nout, and CABAC decoding is terminated. The last bit inserted in register codIOffset is equal to 1. When decoding \nend_of_slice_flag, this last bit inserted in register codIOffset is interpreted as rbsp_stop_one_bit. \n–  Otherwise (codIOffset is less than codIRange), the variable binVal is set equal to 0 and renormalization is performed \nas specified in clause 9.3.3.2.2. \nNOTE – This procedure may also be implemented using DecodeDecision(ctxIdx) with ctxIdx = 276. In the case where \nthe decoded value is equal to 1, seven more bits would be read by DecodeDecision(ctxIdx) and a decoding process would \nhave to adjust its bitstream pointer accordingly to properly decode following syntax elements. \n276  Rec. ITU-T H.264 (06/2019) \n \nDecodeTerminate\ncodIRange = codIRange-2\nYes No\ncodIOffset >= codIRange\nbinVal = 1 binVal = 0\nRenormD\nDone\n \nFigure 9-6 – Flowchart of decoding a decision before termination \n9.3.4  Arithmetic encoding process (informative) \nThis clause does not form an integral part of this Recommendation | International Standard. \nInputs to this process are decisions that are to be encoded and written. \nOutputs of this process are bits that are written to the RBSP. \nThis informative clause describes an arithmetic encoding engine that matches the arithmetic decoding engine described in \nclause 9.3.3.2. The encoding engine is essentially symmetric with the decoding engine, i.e., procedures are called in the \nsame  order.  The  following  procedures  are  described  in  this  section:  InitEncoder,  EncodeDecision,  EncodeBypass, \nEncodeTerminate,  which  correspond  to  InitDecoder,  DecodeDecision,  DecodeBypass,  and  DecodeTerminate, \nrespectively. The state of the arithmetic encoding engine is represented by a value of the variable codILow pointing to the \nlower end of a sub-interval and a value of the variable codIRange specifying the corresponding range of that sub-interval. \n9.3.4.1  Initialization process for the arithmetic encoding engine (informative) \nThis clause does not form an integral part of this Recommendation | International Standard. \nThis process is invoked before encoding the first macroblock of a slice, and after encoding any pcm_alignment_zero_bit \nand all pcm_sample_luma and pcm_sample_chroma data for a macroblock of type I_PCM. \nOutputs of this process are the values codILow, codIRange, firstBitFlag, bitsOutstanding, and BinCountsInNALunits of \nthe arithmetic encoding engine. \nIn the initialization procedure of the encoder, codILow is set equal to 0, and codIRange is set equal to 510. Furthermore, \nfirstBitFlag is set equal to 1 and the counter bitsOutstanding is set equal to 0. \nDepending on whether the current slice is the first slice of a coded picture, the following applies: \n–  If the current slice is the first slice of a coded picture, the counter BinCountsInNALunits is set equal to 0. \n–  Otherwise (the current slice is not the first slice of a coded picture), the counter BinCountsInNALunits is not modified. \nThe value of BinCountsInNALunits is the result of encoding all the slices of a coded picture that precede the current \nslice  in  decoding  order.  After  initializing  for  the  first  slice  of  a  coded  picture  as  specified  in  this  clause, \nBinCountsInNALunits is incremented as specified in clauses 9.3.4.2, 9.3.4.4, and 9.3.4.5. \nNOTE – The minimum register precision required for storing the values of the variables codILow and codIRange after invocation \nof any of the arithmetic encoding processes specified in clauses 9.3.4.2, 9.3.4.4, and 9.3.4.5 is 10 bits and 9 bits, respectively. The \nencoding process for a binary decision (EncodeDecision) as specified in clause 9.3.4.2 and the encoding process for a binary decision \nbefore termination (EncodeTerminate) as specified in clause 9.3.4.5 require a minimum register precision of 10 bits for the variable \ncodILow and a minimum register precision of 9 bits for the variable codIRange. The bypass encoding process for binary decisions \n    Rec. ITU-T H.264 (06/2019)  277 \n \n(EncodeBypass) as specified in clause 9.3.4.4 requires a minimum register precision of 11 bits for the variable codILow and a \nminimum register precision of 9 bits for the variable codIRange. The precision required for the counters bitsOutstanding and \nBinCountsInNALunits should be sufficiently large to prevent overflow of the related registers. When maxBinCountInSlice denotes \nthe maximum total number of binary decisions to encode in one slice and maxBinCountInPic denotes the maximum total number of \nbinary  decisions  to  encode  a  picture,  the  minimum  register  precision  required  for  the  variables  bitsOutstanding  and \nBinCountsInNALunits  is  given  by  Ceil( Log2( maxBinCountInSlice + 1 ) )  and  Ceil( Log2( maxBinCountInPic + 1 ) ), \nrespectively. \n9.3.4.2  Encoding process for a binary decision (informative) \nThis clause does not form an integral part of this Recommendation | International Standard. \nInputs to this process are the context index ctxIdx, the value of binVal to be encoded, and the variables codIRange, codILow \nand BinCountsInNALunits. \nOutputs of this process are the variables codIRange, codILow, and BinCountsInNALunits. \nFigure 9-7 shows the flowchart for encoding a single decision. In a first step, the variable codIRangeLPS is derived as \nfollows. \nGiven  the  current  value  of  codIRange,  codIRange  is  mapped  to  the  index  qCodIRangeIdx  of  a  quantized  value  of \ncodIRange by using Equation 9-25. The value of qCodIRangeIdx and the value of pStateIdx associated with ctxIdx are \nused to determine the value of the variable rangeTabLPS as specified in Table 9-44, which is assigned to codIRangeLPS. \nThe value of codIRange − codIRangeLPS is assigned to codIRange. \nIn a second step, the value of binVal is compared to valMPS associated with ctxIdx. When binVal is different from valMPS, \ncodIRange is added to codILow and codIRange is set equal to the value codIRangeLPS. Given the encoded decision, the \nstate  transition  is  performed  as  specified  in  clause 9.3.3.2.1.1.  Depending  on  the  current  value  of  codIRange, \nrenormalization is performed as specified in clause 9.3.4.3. Finally, the variable BinCountsInNALunits is incremented \nby 1. \n278  Rec. ITU-T H.264 (06/2019) \n \nEncodeDecision(ctxIdx,binVal)\nqCodIRangeIdx = (codIRange >> 6) & 3\ncodIRangeLPS = rangeTabLPS[pStateIdx][qCodIRangeIdx]\ncodIRange = codIRange  codIRangeLPS\nYes binVal != No\nvalMPS\ncodILow = codILow + codIRange\ncodIRange = codIRangeLPS\nNo\npStateIdx != 0\nvalMPS = 1 – valMPS\nYes\npStateIdx = transIdxLPS[pStateIdx] pStateIdx = transIdxMPS[pStateIdx]\nRenormE\nBinCountsInNALunits = BinCountsInNALunits + 1 \nDone\n \nFigure 9-7 – Flowchart for encoding a decision \n9.3.4.3  Renormalization process in the arithmetic encoding engine (informative) \nThis clause does not form an integral part of this Recommendation | International Standard. \nInputs to this process are the variables codIRange, codILow, firstBitFlag, and bitsOutstanding. \nOutputs of this process are zero or more bits written to the RBSP and the updated variables codIRange, codILow, \nfirstBitFlag, and bitsOutstanding. \n    Rec. ITU-T H.264 (06/2019)  279 \n \nRenormalization is illustrated in Figure 9-8. \nRenormE\nNo Yes\ncodIRange < 256\nYes No\ncodILow < 256\nNo Yes\ncodILow >= 512\ncodILow = codILow 256\ncodILow = codILow  512\nbitsOutstanding = bitsOutstanding + 1\nPutBit(0) PutBit(1)\ncodIRange = codIRange << 1\ncodILow = codILow << 1\nDone\n \nFigure 9-8 – Flowchart of renormalization in the encoder \nThe PutBit( ) procedure described in Figure 9-9 provides carry over control. It uses the function WriteBits( B, N ) that \nwrites N bits with value B to the bitstream and advances the bitstream pointer by N bit positions. This function assumes \nthe existence of a bitstream pointer with an indication of the position of the next bit to be written to the bitstream by the \nencoding process. \n280  Rec. ITU-T H.264 (06/2019) \n \nYes\nfirstBitFlag = 0 WriteBits(B, 1)\nYes\nbitsOutstanding > 0\nWriteBits(1  B, 1)\nbitsOutstanding = bitsOutstanding – 1\n \nFigure 9-9 – Flowchart of PutBit(B) \n9.3.4.4  Bypass encoding process for binary decisions (informative) \nThis clause does not form an integral part of this Recommendation | International Standard. \nInputs to this process are the variables binVal, codILow, codIRange, bitsOutstanding, and BinCountsInNALunits. \nOutput  of  this  process  is  a  bit  written  to  the  RBSP  and  the  updated  variables  codILow,  bitsOutstanding,  and \nBinCountsInNALunits. \nThis encoding process applies to all binary decisions with bypassFlag equal to 1. Renormalization is included in the \nspecification of this process as given in Figure 9-10. \n    Rec. ITU-T H.264 (06/2019)  281 \n \nEncodeBypass(binVal)\ncodILow = codILow << 1\nYes No\nbinVal != 0\ncodILow = codILow + codIRange\nNo codILow >= Yes\n1024\nYes No\ncodILow < 512\ncodILow = codILow  1024\ncodILow = codILow  512\nbitsOutstanding = bitsOutstanding + 1\nDone\n \nFigure 9-10 – Flowchart of encoding bypass \n9.3.4.5  Encoding process for a binary decision before termination (informative) \nThis clause does not form an integral part of this Recommendation | International Standard. \nInputs to this process are the variables binVal, codIRange, codILow, bitsOutstanding, and BinCountsInNALunits. \nOutputs of this process are zero or more bits written to the RBSP and the updated variables codILow, codIRange, \nbitsOutstanding, and BinCountsInNALunits. \nThis encoding routine shown in Figure 9-11 applies to encoding of the end_of_slice_flag and of the bin indicating the \nI_PCM mb_type both associated with ctxIdx equal to 276. \n282  Rec. ITU-T H.264 (06/2019) \n \n \nFigure 9-11 – Flowchart of encoding a decision before termination \nWhen the value of binVal to encode is equal to 1, CABAC encoding is terminated and the flushing procedure shown in \nFigure 9-12 is applied. In this flushing procedure, the last bit written by WriteBits( B, N )  is equal to 1. When encoding \nend_of_slice_flag, this last bit is interpreted as the rbsp_stop_one_bit. \nEncodeFlush\ncodIRange = 2\nRenormE\nPutBit((codILow >> 9) & 1)\nWriteBits(((codILow >> 7) & 3) | 1, 2)\nDone\n \nFigure 9-12 – Flowchart of flushing at termination \n \n \n \n    Rec. ITU-T H.264 (06/2019)  283 \n \n9.3.4.6  Byte stuffing process (informative) \nThis clause does not form an integral part of this Recommendation | International Standard. \nThis process is invoked after encoding the last macroblock of the last slice of a picture and after encapsulation. \nInputs to this process are the number of bytes NumBytesInVclNALunits of all VCL NAL units of a picture, the number of \nmacroblocks  PicSizeInMbs  in  the  picture,  and  the  number  of  binary  symbols  BinCountsInNALunits  resulting  from \nencoding the contents of all VCL NAL units of the picture. \nNOTE – The value of BinCountsInNALunits is the result of encoding all slices of a coded picture. After initializing for the first slice \nof a coded picture as specified in clause 9.3.4.1, BinCountsInNALunits is incremented as specified in clauses 9.3.4.2, 9.3.4.4, and \n9.3.4.5. \nOutputs of this process are zero or more bytes appended to the NAL unit. \nLet the variable k be set equal to Ceil( ( Ceil( 3 * ( 32 * BinCountsInNALunits − RawMbBits * PicSizeInMbs ) ÷ 1024 ) − \nNumBytesInVclNALunits ) ÷ 3 ). Depending on the variable k the following applies: \n–  If k is less than or equal to 0, no cabac_zero_word is appended to the NAL unit. \n–  Otherwise (k is greater than 0), the 3-byte sequence 0x000003 is appended k times to the NAL unit after encapsulation, \nwhere  the  first  two  bytes  0x0000  represent  a  cabac_zero_word  and  the  third  byte  0x03  represents  an \nemulation_prevention_three_byte. \n284  Rec. ITU-T H.264 (06/2019) \n \nAnnex A \n \nProfiles and levels \n \n(This annex forms an integral part of this Recommendation | International Standard.) \nProfiles and levels specify restrictions on bitstreams and hence limits on the capabilities needed to decode the bitstreams. \nProfiles and levels may also be used to indicate interoperability points between individual decoder implementations. \nNOTE 1 – This Recommendation | International Standard does not include individually selectable \"options\" at the decoder, as this \nwould increase interoperability difficulties. \nEach profile specifies a subset of algorithmic features and limits that shall be supported by all decoders conforming to that \nprofile. \nNOTE 2 – Encoders are not required to make use of any particular subset of features supported in a profile. \nEach  level  specifies  a  set  of  limits  on  the  values  that  may  be  taken  by  the  syntax  elements  of  this \nRecommendation | International Standard.  The  same  set  of  level  definitions  is  used  with  all  profiles,  but  individual \nimplementations may support a different level for each supported profile. For any given profile, levels generally correspond \nto decoder processing load and memory capability. \nThe profiles that are specified in clause A.2 are also referred to as the profiles specified in Annex A.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "P",
          "Annex"
        ],
        [
          "A",
          "A"
        ]
      ],
      "type": "Annex"
    },
    {
      "section_title": "A.1  Requirements on video decoder capability",
      "section_text": "Capabilities of video decoders conforming to this Recommendation | International Standard are specified in terms of the \nability to decode video streams conforming to the constraints of profiles and levels specified in this annex. For each such \nprofile, the level supported for that profile shall also be expressed. \nSpecific values are specified in this annex for the syntax elements profile_idc and level_idc. All other values of profile_idc \nand level_idc are reserved for future use by ITU-T | ISO/IEC. \nNOTE – Decoders should not infer that when a reserved value of profile_idc or level_idc falls between the values specified in this \nRecommendation | International Standard that this indicates intermediate capabilities between the specified profiles or levels, as \nthere are no restrictions on the method to be chosen by ITU-T | ISO/IEC for the use of such future reserved values.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          1
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2  Profiles",
      "section_text": "All constraints for picture parameter sets that are specified in clauses A.2.1 to A.2.11 are constraints for picture parameter \nsets that are activated in the bitstream. All constraints for sequence parameter sets that are specified in clauses A.2.1 to \nA.2.11 are constraints for sequence parameter sets that are activated in the bitstream.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.1  Baseline profile",
      "section_text": "Bitstreams conforming to the Baseline profile shall obey the following constraints: \n–  Only I and P slice types may be present. \n–  NAL unit streams shall not contain nal_unit_type values in the range of 2 to 4, inclusive. \n–  Sequence parameter sets shall have frame_mbs_only_flag equal to 1. \n–  The  syntax  elements  chroma_format_idc,  bit_depth_luma_minus8,  bit_depth_chroma_minus8, \nqpprime_y_zero_transform_bypass_flag,  and  seq_scaling_matrix_present_flag  shall  not  be  present  in  sequence \nparameter sets. \n–  Picture parameter sets shall have weighted_pred_flag and weighted_bipred_idc both equal to 0. \n–  Picture parameter sets shall have entropy_coding_mode_flag equal to 0. \n–  Picture parameter sets shall have num_slice_groups_minus1 in the range of 0 to 7, inclusive. \n–  The  syntax  elements  transform_8x8_mode_flag,  pic_scaling_matrix_present_flag,  and \nsecond_chroma_qp_index_offset shall not be present in picture parameter sets. \n–  The syntax element level_prefix shall not be greater than 15 (when present). \n–  The  syntax  elements  pcm_sample_luma[ i ],  with  i = 0..255,  and  pcm_sample_chroma[ i ],  with \ni = 0..2 * MbWidthC * MbHeightC − 1, shall not be equal to 0 (when present). \n–  The level constraints specified for the Baseline profile in clause A.3 shall be fulfilled. \nConformance of a bitstream to the Baseline profile is indicated by profile_idc being equal to 66. \n    Rec. ITU-T H.264 (06/2019)  285 \n \nDecoders conforming to the Baseline profile at a specific level shall be capable of decoding all bitstreams in which \nprofile_idc is equal to 66 or constraint_set0_flag is equal to 1 and in which level_idc and constraint_set3_flag represent a \nlevel less than or equal to the specified level.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          1
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.1.1  Constrained Baseline profile",
      "section_text": "Bitstreams conforming to the Constrained Baseline profile shall obey all constraints specified in clause A.2.1 for the \nBaseline profile and all constraints specified in clause A.2.2 for the Main profile. \nConformance of a bitstream  to the  Constrained Baseline  profile is  indicated by profile_idc being equal to 66  with \nconstraint_set1_flag being equal to 1. \nNOTE – This specification of the Constrained Baseline profile is technically identical to specification of the use of the Baseline \nprofile  with  constraint_set1_flag  equal  to 1.  Thus,  any  existing  specifications  (in  other  documents  that  reference  this \nRecommendation | International Standard) that have referred to the use of the Baseline profile with constraint_set1_flag equal to 1 \nshould thus be interpreted as continuing in force as being technically identical to referring to the use of the Constrained Baseline \nprofile (without any need for revision of these existing specifications to instead refer explicitly to the use of the Constrained Baseline \nprofile). \nDecoders conforming to the Constrained Baseline profile at a specific level shall be capable of decoding all bitstreams in \nwhich all of the following are true: \n–  profile_idc is equal to 66 or constraint_set0_flag is equal to 1, \n–  constraint_set1_flag is equal to 1, \n–  level_idc and constraint_set3_flag represent a level less than or equal to the specified level.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          1
        ],
        [
          "N",
          1
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.2  Main profile",
      "section_text": "Bitstreams conforming to the Main profile shall obey the following constraints: \n–  Only I, P, and B slice types may be present. \n–  NAL unit streams shall not contain nal_unit_type values in the range of 2 to 4, inclusive. \n–  Arbitrary slice order is not allowed. \n–  The  syntax  elements  chroma_format_idc,  bit_depth_luma_minus8,  bit_depth_chroma_minus8, \nqpprime_y_zero_transform_bypass_flag,  and  seq_scaling_matrix_present_flag  shall  not  be  present  in  sequence \nparameter sets. \n–  Picture parameter sets shall have num_slice_groups_minus1 equal to 0 only. \n–  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0 only. \n–  The  syntax  elements  transform_8x8_mode_flag,  pic_scaling_matrix_present_flag,  and \nsecond_chroma_qp_index_offset shall not be present in picture parameter sets. \n–  The syntax element level_prefix shall not be greater than 15 (when present). \n–  The  syntax  elements  pcm_sample_luma[ i ],  with  i = 0..255,  and  pcm_sample_chroma[ i ],  with \ni = 0..2 * MbWidthC * MbHeightC − 1, shall not be equal to 0 (when present). \n–  The level constraints specified for the Main profile in clause A.3 shall be fulfilled. \nConformance of a bitstream to the Main profile is indicated by profile_idc being equal to 77. \nDecoders conforming to the Main profile at a specified level shall be capable of decoding all bitstreams in which profile_idc \nis equal to 77 or constraint_set1_flag is equal to 1 and in which level_idc and constraint_set3_flag represent a level less \nthan or equal to the specified level.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          2
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.3  Extended profile",
      "section_text": "Bitstreams conforming to the Extended profile shall obey the following constraints: \n–  Sequence parameter sets shall have direct_8x8_inference_flag equal to 1. \n–  The  syntax  elements  chroma_format_idc,  bit_depth_luma_minus8,  bit_depth_chroma_minus8, \nqpprime_y_zero_transform_bypass_flag,  and  seq_scaling_matrix_present_flag  shall  not  be  present  in  sequence \nparameter sets. \n–  Picture parameter sets shall have entropy_coding_mode_flag equal to 0. \n–  Picture parameter sets shall have num_slice_groups_minus1 in the range of 0 to 7, inclusive. \n–  The  syntax  elements  transform_8x8_mode_flag,  pic_scaling_matrix_present_flag,  and \nsecond_chroma_qp_index_offset shall not be present in picture parameter sets. \n–  The syntax element level_prefix shall not be greater than 15 (when present). \n286  Rec. ITU-T H.264 (06/2019) \n \n–  The  syntax  elements  pcm_sample_luma[ i ],  with  i = 0..255,  and  pcm_sample_chroma[ i ],  with \ni = 0..2 * MbWidthC * MbHeightC − 1, shall not be equal to 0 (when present). \n–  The level constraints specified for the Extended profile in clause A.3 shall be fulfilled. \nConformance of a bitstream to the Extended profile is indicated by profile_idc being equal to 88. \nDecoders conforming to the Extended profile at a specified level shall be capable of decoding all bitstreams in which \nprofile_idc is equal to 88 or constraint_set2_flag is equal to 1 and in which level_idc represents a level less than or equal \nto specified level. \nDecoders conforming to the Extended profile at a specified level shall also be capable of decoding all bitstreams in which \nprofile_idc is equal to 66 or constraint_set0_flag is equal to 1, in which level_idc and constraint_set3_flag represent a level \nless than or equal to the specified level.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          3
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.4  High profile",
      "section_text": "Bitstreams conforming to the High profile shall obey the following constraints: \n–  Only I, P, and B slice types may be present. \n–  NAL unit streams shall not contain nal_unit_type values in the range of 2 to 4, inclusive. \n–  Arbitrary slice order is not allowed. \n–  Picture parameter sets shall have num_slice_groups_minus1 equal to 0 only. \n–  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0 only. \n–  Sequence parameter sets shall have chroma_format_idc in the range of 0 to 1 inclusive. \n–  Sequence parameter sets shall have bit_depth_luma_minus8 equal to 0 only. \n–  Sequence parameter sets shall have bit_depth_chroma_minus8 equal to 0 only. \n–  Sequence parameter sets shall have qpprime_y_zero_transform_bypass_flag equal to 0 only. \n–  The level constraints specified for the High profile in clause A.3 shall be fulfilled. \nConformance of a bitstream to the High profile is indicated by profile_idc being equal to 100. Decoders conforming to the \nHigh profile at a specific level shall be capable of decoding all bitstreams in which either or both of the following conditions \nare true: \n–  (profile_idc  is  equal  to 77  or  constraint_set1_flag  is  equal  to  1)  and  the  combination  of  level_idc  and \nconstraint_set3_flag represent a level less than or equal to the specified level, \n–  profile_idc is equal to 100 and level_idc represents a level less than or equal to the specified level. \nNOTE – The value 100 for profile_idc indicates that the bitstream conforms to the High profile as specified in this clause. When \nprofile_idc is equal to 100 and constraint_set3_flag is equal to 1, this indicates that the bitstream conforms to the High profile and \nadditionally conforms to the constraints specified for the High 10 Intra profile in clause A.2.8. For example, such a bitstream must \nhave bit_depth_luma_minus8 equal to 0, have bit_depth_chroma_minus8 equal to 0, obey the MinCR, MaxBR and MaxCPB \nconstraints of the High profile, contain only IDR pictures, have max_num_ref_frames equal to 0, have dpb_output_delay equal to 0, \nand obey the maximum slice size constraint of the High 10 Intra profile.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          4
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.4.1  Progressive High profile",
      "section_text": "Bitstreams conforming to the Progressive High profile shall obey all constraints specified in clause A.2.4 for the High \nprofile, and shall additionally obey the constraint that sequence parameter sets shall have frame_mbs_only_flag equal to 1. \nConformance  of  a  bitstream  to  the  Progressive High  profile  is  indicated  by  profile_idc  being  equal  to 100  with \nconstraint_set4_flag being equal to 1. \nDecoders conforming to the Progressive High profile at a specific level shall be capable of decoding all bitstreams in which \none or more of the following conditions are true: \n–  (profile_idc is equal to 66 or constraint_set0_flag is equal to 1), constraint_set1_flag is equal to 1, and the combination \nof level_idc and constraint_set3_flag represents a level less than or equal to the specified level. \n–  profile_idc is equal to 77, constraint_set0_flag is equal to 1, and the combination of level_idc and constraint_set3_flag \nrepresents a level less than or equal to the specified level. \n–  profile_idc is equal to 77, constraint_set4_flag is equal to 1, and the combination of level_idc and constraint_set3_flag \nrepresents a level less than or equal to the specified level. \n–  profile_idc is equal to 88, constraint_set1_flag is equal to 1, constraint_set4_flag is equal to 1, and the combination of \nlevel_idc and constraint_set3_flag represents a level less than or equal to the specified level. \n–  profile_idc is equal to 100, constraint_set4_flag is equal to 1, and level_idc represents a level less than or equal to the \nspecified level. \n    Rec. ITU-T H.264 (06/2019)  287",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          4
        ],
        [
          "N",
          1
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.4.2  Constrained High profile",
      "section_text": "Bitstreams  conforming  to  the  Constrained High  profile  shall  obey  all  constraints  specified  in  clause A.2.4.1  for  the \nProgressive High profile, and shall additionally obey the constraint that B slice types shall not be present. \nConformance of a bitstream to the Constrained High profile is indicated by profile_idc being equal to 100 with both \nconstraint_set4_flag and constraint_set5_flag being equal to 1. \nDecoders conforming to the Constrained High profile at a specific level shall be capable of decoding all bitstreams in \nwhich one or more of the following conditions are true: \n–  (profile_idc is equal to 66 or constraint_set0_flag is equal to 1), constraint_set1_flag is equal to 1, and the combination \nof level_idc and constraint_set3_flag represents a level less than or equal to the specified level. \n–  profile_idc is equal to 77, constraint_set0_flag is equal to 1, and the combination of level_idc and constraint_set3_flag \nrepresents a level less than or equal to the specified level. \n–  profile_idc is equal to 77, constraint_set4_flag is equal to 1, constraint_set5_flag is equal to 1, and level_idc represents \na level less than or equal to the specified level. \n–  profile_idc is equal to 88, constraint_set1_flag is equal to 1, constraint_set4_flag is equal to 1, constraint_set5_flag is \nequal to 1, and the combination of level_idc and constraint_set3_flag represents a level less than or equal to the \nspecified level. \n–  profile_idc is equal to 100, constraint_set4_flag  is equal  to 1, constraint_set5_flag is  equal to 1, and  level_idc \nrepresents a level less than or equal to the specified level.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          4
        ],
        [
          "N",
          2
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.5  High 10 profile",
      "section_text": "Bitstreams conforming to the High 10 profile shall obey the following constraints: \n–  Only I, P, and B slice types may be present. \n–  NAL unit streams shall not contain nal_unit_type values in the range of 2 to 4, inclusive. \n–  Arbitrary slice order is not allowed. \n–  Picture parameter sets shall have num_slice_groups_minus1 equal to 0 only. \n–  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0 only. \n–  Sequence parameter sets shall have chroma_format_idc in the range of 0 to 1 inclusive. \n–  Sequence parameter sets shall have bit_depth_luma_minus8 in the range of 0 to 2 inclusive. \n–  Sequence parameter sets shall have bit_depth_chroma_minus8 in the range of 0 to 2 inclusive. \n–  Sequence parameter sets shall have qpprime_y_zero_transform_bypass_flag equal to 0 only. \n–  The level constraints specified for the High 10 profile in clause A.3 shall be fulfilled. \nConformance of a bitstream to the High 10 profile is indicated by profile_idc being equal to 110. Decoders conforming to \nthe High 10 profile at a specific level shall be capable of decoding all bitstreams in which either or both of the following \nconditions are true: \n–  (profile_idc  is  equal  to 77  or  constraint_set1_flag  is  equal  to  1)  and  the  combination  of  level_idc  and \nconstraint_set3_flag represent a level less than or equal to the specified level, \n–  profile_idc is equal to 100 or 110 and level_idc represents a level less than or equal to the specified level.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          5
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.5.1  Progressive High 10 profile",
      "section_text": "Bitstreams conforming to the Progressive High 10 profile shall obey all constraints specified in clause A.2.5 for the \nHigh 10 profile, and shall additionally obey the constraint that sequence parameter sets shall have frame_mbs_only_flag \nequal to 1. \nConformance  of  a  bitstream  to  the  Progressive High 10  profile  is  indicated  by  profile_idc  being  equal  to  110  with \nconstraint_set4_flag being equal to 1. \nDecoders conforming to the Progressive High 10 profile at a specific level shall be capable of decoding all bitstreams in \nwhich one or more of the following conditions are true: \n–  (profile_idc is equal to 66 or constraint_set0_flag is equal to 1), constraint_set1_flag is equal to 1, and the combination \nof level_idc and constraint_set3_flag represents a level less than or equal to the specified level. \n–  profile_idc is equal to 77, constraint_set0_flag is equal to 1, and the combination of level_idc and constraint_set3_flag \nrepresents a level less than or equal to the specified level. \n288  Rec. ITU-T H.264 (06/2019) \n \n–  profile_idc is equal to 77, constraint_set4_flag is equal to 1, and the combination of level_idc and constraint_set3_flag \nrepresents a level less than or equal to the specified level. \n–  profile_idc is equal to 88, constraint_set1_flag is equal to 1, constraint_set4_flag is equal to 1, and the combination \nof level_idc and constraint_set3_flag represents a level less than or equal to the specified level. \n–  profile_idc is equal to 100 or 110, constraint_set4_flag is equal to 1, and level_idc represents a level less than or equal \nto the specified level.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          5
        ],
        [
          "N",
          1
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.6  High 4:2:2 profile",
      "section_text": "Bitstreams conforming to the High 4:2:2 profile shall obey the following constraints: \n–  Only I, P, and B slice types may be present. \n–  NAL unit streams shall not contain nal_unit_type values in the range of 2 to 4, inclusive. \n–  Arbitrary slice order is not allowed. \n–  Picture parameter sets shall have num_slice_groups_minus1 equal to 0 only. \n–  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0 only. \n–  Sequence parameter sets shall have chroma_format_idc in the range of 0 to 2 inclusive. \n–  Sequence parameter sets shall have bit_depth_luma_minus8 in the range of 0 to 2 inclusive. \n–  Sequence parameter sets shall have bit_depth_chroma_minus8 in the range of 0 to 2 inclusive. \n–  Sequence parameter sets shall have qpprime_y_zero_transform_bypass_flag equal to 0 only. \n–  The level constraints specified for the High 4:2:2 profile in clause A.3 shall be fulfilled. \nConformance of a bitstream to the High 4:2:2 profile is indicated by profile_idc being equal to 122. Decoders conforming \nto the High 4:2:2 profile at a specific level shall be capable of decoding all bitstreams in which either or both of the \nfollowing conditions are true: \n–  (profile_idc  is  equal  to 77  or  constraint_set1_flag  is  equal  to  1)  and  the  combination  of  level_idc  and \nconstraint_set3_flag represent a level less than or equal to the specified level, \n–  profile_idc is equal to 100, 110, or 122 and level_idc represents a level less than or equal to the specified level.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          6
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.7  High 4:4:4 Predictive profile",
      "section_text": "Bitstreams conforming to the High 4:4:4 Predictive profile shall obey the following constraints: \n–  Only I, P, B slice types may be present. \n–  NAL unit streams shall not contain nal_unit_type values in the range of 2 to 4, inclusive. \n–  Arbitrary slice order is not allowed. \n–  Picture parameter sets shall have num_slice_groups_minus1 equal to 0 only. \n–  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0 only. \n–  Sequence parameter sets shall have bit_depth_luma_minus8 in the range of 0 to 6 inclusive. \n–  Sequence parameter sets shall have bit_depth_chroma_minus8 in the range of 0 to 6 inclusive. \n–  The level constraints specified for the High 4:4:4 Predictive profile in clause A.3 shall be fulfilled. \nConformance of a bitstream to the High 4:4:4 Predictive profile is indicated by profile_idc being equal to 244. Decoders \nconforming to the High 4:4:4 Predictive profile at a specific level shall be capable of decoding all bitstreams in which \neither or both of the following conditions are true: \n–  (profile_idc  is  equal  to  77  or  constraint_set1_flag  is  equal  to  1)  and  the  combination  of  level_idc  and \nconstraint_set3_flag represent a level less than or equal to the specified level, \n–  profile_idc is equal to 44, 100, 110, 122, or 244 and the value of level_idc represents a level less than or equal to the \nspecified level.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          7
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.8  High 10 Intra profile",
      "section_text": "Bitstreams conforming to the High 10 Intra profile shall obey the following constraints: \n–  All constraints specified in clause A.2.5 for the High 10 profile shall be obeyed. \n–  All pictures shall be IDR pictures. \n–  Sequence parameter sets shall have max_num_ref_frames equal to 0. \n    Rec. ITU-T H.264 (06/2019)  289 \n \n–  When vui_parameters_present_flag is equal to 1 and bitstream_restriction_flag is equal to 1, sequence parameter sets \nshall have max_num_reorder_frames equal to 0. \n–  When vui_parameters_present_flag is equal to 1 and bitstream_restriction_flag is equal to 1, sequence parameter sets \nshall have max_dec_frame_buffering equal to 0. \n–  Picture timing SEI messages, whether present in the bitstream (by non-VCL NAL units) or conveyed equivalently by \nother means not specified in this Recommendation | International Standard, shall have dpb_output_delay equal to 0. \n–  The level constraints specified for the High 10 Intra profile in clause A.3 shall be fulfilled. \nConformance  of  a  bitstream  to  the  High 10 Intra  profile  is  indicated  by  constraint_set3_flag  being  equal  to 1  with \nprofile_idc equal to 110. Decoders conforming to the High 10 Intra profile at a specific level shall be capable of decoding \nall bitstreams in which all of the following conditions are true: \n–  profile_idc is equal to 100 or 110, \n–  constraint_set3_flag is equal to 1, \n–  level_idc represents a level less than or equal to the specified level. \nNOTE 1 – The value 100 for profile_idc indicates that the bitstream conforms to the High profile as specified in clause A.2.4. When \nprofile_idc is equal to 100 and constraint_set3_flag is equal to 1, this indicates that the bitstream conforms to the High profile and \nadditionally conforms to the constraints specified for the High 10 Intra profile in this clause. For example, such a bitstream must \nhave bit_depth_luma_minus8 equal to 0, have bit_depth_chroma_minus8 equal to 0, obey the MinCR, MaxBR and MaxCPB \nconstraints of the High profile, contain only IDR pictures, have max_num_ref_frames equal to 0, have dpb_output_delay equal to 0, \nand obey the maximum slice size constraint of the High 10 Intra profile. \nThe operation of the deblocking filter process specified in clause 8.7 is not required for decoder conformance to the \nHigh 10 Intra profile. \nNOTE 2 – The deblocking filter process specified in clause 8.7 or some similar post-processing filter should be performed, although \nthis is not a requirement for decoder conformance to the High 10 Intra profile. The syntax elements sent by an encoder for control \nof the deblocking filter process specified in clause 8.7 are considered only as advisory information for decoders conformance to the \nHigh 10 Intra profile. However, the application of the deblocking filter process specified in clause 8.7 is required for decoder \nconformance to the High 10, High 4:2:2, and High 4:4:4 Predictive profiles when decoding bitstreams that conform to the High 10 \nIntra profile.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          8
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.9  High 4:2:2 Intra profile",
      "section_text": "Bitstreams conforming to the High 4:2:2 Intra profile shall obey the following constraints: \n–  All constraints specified in clause A.2.6 for the High 4:2:2 profile shall be obeyed. \n–  All pictures shall be IDR pictures. \n–  Sequence parameter sets shall have max_num_ref_frames equal to 0. \n–  When vui_parameters_present_flag is equal to 1 and bitstream_restriction_flag is equal to 1, sequence parameter sets \nshall have max_num_reorder_frames equal to 0. \n–  When vui_parameters_present_flag is equal to 1 and bitstream_restriction_flag is equal to 1, sequence parameter sets \nshall have max_dec_frame_buffering equal to 0. \n–  Picture timing SEI messages, whether present in the bitstream (by non-VCL NAL units) or conveyed equivalently by \nother means not specified in this Recommendation | International Standard, shall have dpb_output_delay equal to 0. \n–  The level constraints specified for the High 4:2:2 Intra profile in clause A.3 shall be fulfilled. \nConformance of a bitstream to the High 4:2:2 Intra profile is indicated by constraint_set3_flag being equal to 1 with \nprofile_idc equal to 122. Decoders conforming to the High 4:2:2 Intra profile at a specific level shall be capable of decoding \nall bitstreams in which all of the following conditions are true: \n–  profile_idc is equal to 100, 110, or 122, \n–  constraint_set3_flag is equal to 1, \n–  level_idc represents a level less than or equal to the specified level. \nThe operation of the deblocking filter process specified in clause 8.7 is not required for decoder conformance to the \nHigh 4:2:2 Intra profile. \nNOTE – The deblocking filter process specified in clause 8.7 or some similar post-processing filter should be performed, although \nthis is not a requirement for decoder conformance to the High 4:2:2 Intra profile. The syntax elements sent by an encoder for control \nof the deblocking filter process specified in clause 8.7 are considered only as advisory information for decoders conformance to the \nHigh 4:2:2 Intra profile. However, the application of the deblocking filter process specified in clause 8.7 is required for decoder \nconformance to the High 4:2:2, and High 4:4:4 Predictive profiles when decoding bitstreams that conform to the High 4:2:2 Intra \nprofile. \n290  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          9
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.10  High 4:4:4 Intra profile",
      "section_text": "Bitstreams conforming to the High 4:4:4 Intra profile shall obey the following constraints: \n–  All constraints specified in clause A.2.7 for the High 4:4:4 Predictive profile shall be obeyed. \n–  All pictures shall be IDR pictures. \n–  Sequence parameter sets shall have max_num_ref_frames equal to 0. \n–  When vui_parameters_present_flag is equal to 1 and bitstream_restriction_flag is equal to 1, sequence parameter sets \nshall have max_num_reorder_frames equal to 0. \n–  When vui_parameters_present_flag is equal to 1 and bitstream_restriction_flag is equal to 1, sequence parameter sets \nshall have max_dec_frame_buffering equal to 0. \n–  Picture timing SEI messages, whether present in the bitstream (by non-VCL NAL units) or conveyed equivalently by \nother means not specified in this Recommendation | International Standard, shall have dpb_output_delay equal to 0. \n–  The level constraints specified for the High 4:4:4 Intra profile in clause A.3 shall be fulfilled. \nConformance of a bitstream to the High 4:4:4 Intra profile is indicated by constraint_set3_flag being equal to 1 with \nprofile_idc equal to 244. Decoders conforming to the High 4:4:4 Intra profile at a specific level shall be capable of \ndecoding all bitstreams in which all of the following conditions are true: \n–  profile_idc is equal to 44, 100, 110, 122, or 244, \n–  constraint_set3_flag is equal to 1, \n–  level_idc represents a level less than or equal to the specified level. \nThe operation of the deblocking filter process specified in clause 8.7 is not required for decoder conformance to the \nHigh 4:4:4 Intra profile. \nNOTE – The deblocking filter process specified in clause 8.7 or some similar post-processing filter should be performed, although \nthis is not a requirement for decoder conformance to the High 4:4:4 Intra and CAVLC 4:4:4 Intra profiles. The syntax elements sent \nby an encoder for control of the deblocking filter process specified in clause 8.7 are considered only as advisory information for \ndecoders conformance to the High 4:4:4 Intra and CAVLC 4:4:4 Intra profiles. However, the application of the deblocking filter \nprocess specified in clause 8.7 is required for decoder conformance to the High 4:4:4 Predictive profile when decoding bitstreams \nthat conform to the High 4:4:4 Intra and CAVLC 4:4:4 Intra profiles.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          10
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.2.11  CAVLC 4:4:4 Intra profile",
      "section_text": "Bitstreams conforming to the CAVLC 4:4:4 Intra profile shall obey the following constraints: \n–  All constraints specified in clause A.2.10 for the High 4:4:4 Intra profile shall be obeyed. \n–  Picture parameter sets shall have entropy_coding_mode_flag equal to 0. \n–  The level constraints specified for the CAVLC 4:4:4 Intra profile in clause A.3 shall be fulfilled. \nConformance of a bitstream to the CAVLC 4:4:4 Intra profile is indicated by profile_idc being equal to 44. Decoders \nconforming to the CAVLC 4:4:4 Intra profile at a specific level shall be capable of decoding all bitstreams in which all of \nthe following conditions are true: \n–  profile_idc is equal to 44, \n–  level_idc represents a level less than or equal to the specified level. \nThe operation of the deblocking filter process specified in clause 8.7 is not required for decoder conformance to the \nCAVLC 4:4:4 Intra profile. \nNOTE – The deblocking filter process specified in clause 8.7 or some similar post-processing filter should be performed, although \nthis is not a requirement for decoder conformance to the High 4:4:4 Intra and CAVLC 4:4:4 Intra profiles. The syntax elements sent \nby an encoder for control of the deblocking filter process specified in clause 8.7 are considered only as advisory information for \ndecoders conformance to the High 4:4:4 Intra and CAVLC 4:4:4 Intra profiles. However, the application of the deblocking filter \nprocess specified in clause 8.7 is required for decoder conformance to the High 4:4:4 Predictive profile when decoding bitstreams \nthat conform to the High 4:4:4 Intra and CAVLC 4:4:4 Intra profiles.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          2
        ],
        [
          "N",
          11
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.3  Levels",
      "section_text": "The following is specified for expressing the constraints in this annex. \n–  Let access unit n be the n-th access unit in decoding order with the first access unit being access unit 0. \n–  Let picture n be the primary coded picture or the corresponding decoded picture of access unit n. \n    Rec. ITU-T H.264 (06/2019)  291 \n \nLet the variable fR be derived as follows: \n–  If the level number is equal to 6.0, 6.1, or 6.2, fR is set equal to 1 ÷ 300. \n–  Otherwise, if picture n is a frame, fR is set equal to 1 ÷ 172. \n–  Otherwise (picture n is a field), fR is set equal to 1 ÷ (172 * 2).",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          3
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.3.1  Level limits common to the Baseline, Constrained Baseline, Main, and Extended profiles",
      "section_text": "Bitstreams conforming to the Baseline, Constrained Baseline, Main, or Extended profiles at a specified level shall obey \nthe following constraints: \na)  The nominal removal time of access unit n with n > 0 from the CPB as specified in clause C.1.2, satisfies the \nconstraint  that  t ( n ) − t ( n − 1 )  is  greater  than  or  equal  to  Max( PicSizeInMbs ÷ MaxMBPS, fR  ),  where \nr,n r\nMaxMBPS is the value specified in Table A-1 that applies to picture n − 1 and PicSizeInMbs is the number of \nmacroblocks in picture n − 1. \nb)  The difference between consecutive output times of pictures from the DPB as specified in clause C.2.2, satisfies \nthe constraint that t ( n ) >= Max( PicSizeInMbs ÷ MaxMBPS, fR ), where MaxMBPS is the value specified \no,dpb\nin Table A-1 for picture n and PicSizeInMbs is the number of macroblocks of picture n, provided that picture n is \na picture that is output and is not the last picture of the bitstream that is output. \nc)  The  sum  of  the  NumBytesInNALunit  variables  for  access  unit  0  is  less  than  or  equal  to \n384 *( Max( PicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * ( t ( 0 ) − t ( 0 ) ) ) ÷ MinCR,  where  MaxMBPS \nr r,n\nand MinCR are the values specified in Table A-1 that apply to picture 0 and PicSizeInMbs is the number of \nmacroblocks in picture 0. \nd)  The  sum  of  the  NumBytesInNALunit  variables  for  access  unit  n  with  n  >  0  is  less  than  or  equal  to \n384 * MaxMBPS * ( t ( n ) − t ( n − 1 ) ) ÷ MinCR, where MaxMBPS and MinCR are the values specified in \nr r\nTable A-1 that apply to picture n. \ne)  PicWidthInMbs * FrameHeightInMbs <= MaxFS, where MaxFS is specified in Table A-1 \nf)  PicWidthInMbs <= Sqrt( MaxFS * 8 ) \ng)  FrameHeightInMbs <= Sqrt( MaxFS * 8 ) \nh)  max_dec_frame_buffering <= MaxDpbFrames,  where  MaxDpbFrames  is  equal  to \nMin( MaxDpbMbs / ( PicWidthInMbs * FrameHeightInMbs ), 16 ) and MaxDpbMbs is given in Table A-1. \ni)  For the VCL HRD parameters, BitRate[ SchedSelIdx ] <= 1000 * MaxBR and CpbSize[ SchedSelIdx ] <= 1000 \n* MaxCPB for at least one value of SchedSelIdx, where BitRate[ SchedSelIdx ] and CpbSize[ SchedSelIdx ] are \ngiven as follows: \n–  If vcl_hrd_parameters_present_flag is equal to 1, BitRate[ SchedSelIdx ] and CpbSize[ SchedSelIdx ] are \ngiven by Equations E-53 and E-54, respectively, using the syntax elements of the hrd_parameters( ) syntax \nstructure that immediately follows vcl_hrd_parameters_present_flag. \n–  Otherwise  (vcl_hrd_parameters_present_flag  is  equal  to  0),  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are inferred as specified in clause E.2.2 for VCL HRD parameters. \nMaxBR and MaxCPB are specified in Table A-1 in units of 1000 bits/s and 1000 bits, respectively. The bitstream \nshall satisfy these conditions for at least one value of SchedSelIdx in the range 0 to cpb_cnt_minus1, inclusive. \nj)  For the NAL HRD parameters, BitRate[ SchedSelIdx ] <= 1200 * MaxBR and CpbSize[ SchedSelIdx ] <= 1200 \n* MaxCPB for at least one value of SchedSelIdx, where BitRate[ SchedSelIdx ] and CpbSize[ SchedSelIdx ] are \ngiven as follows: \n–  If nal_hrd_parameters_present_flag is equal to 1, BitRate[ SchedSelIdx ] and CpbSize[ SchedSelIdx ] are \ngiven by Equations E-53 and E-54, respectively, using the syntax elements of the hrd_parameters( ) syntax \nstructure that immediately follows nal_hrd_parameters_present_flag. \n–  Otherwise  (nal_hrd_parameters_present_flag  is  equal  to  0),  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are inferred as specified in clause E.2.2 for NAL HRD parameters. \nMaxBR and MaxCPB are specified in Table A-1 in units of 1200 bits/s and 1200 bits, respectively. The bitstream \nshall satisfy these conditions for at least one value of SchedSelIdx in the range 0 to cpb_cnt_minus1. \nk)  The vertical motion vector component range for luma motion vectors does not exceed the range from −MaxVmvR \nto ( MaxVmvR − 0.25 ) in units of luma frame samples, where MaxVmvR is specified in Table A-1 \n292  Rec. ITU-T H.264 (06/2019) \n \nNOTE 1 – When chroma_format_idc is equal to 1 and the current macroblock is a field macroblock, the motion vector \ncomponent range for chroma motion vectors may exceed the range from −MaxVmvR to ( MaxVmvR − 0.25 ) in units of \nluma frame samples, due to the method of deriving chroma motion vectors as specified in clause 8.4.1.4. \nl)  The horizontal motion vector component range for luma motion vectors does not exceed the following range: \n–  If the level number is less than 6.0, the specified range is from −2048 to 2047.75, inclusive, in units of luma \nsamples. \n–  Otherwise, the specified range is from −8192 to 8191.75, inclusive, in units of luma samples. \nm)  Let setOf2Mb be the set of unsorted pairs of macroblocks that contains the unsorted pairs of macroblocks \n(mbA, mbB) of a coded video sequence for which any of the following conditions are true: \n–  mbA and mbB are macroblocks that belong to the same slice and are consecutive in decoding order, \n–  arbitrary slice order is not allowed, mbA is the last macroblock (in decoding order) of a slice, and mbB is \nthe first macroblock (in decoding order) of the next slice in decoding order, \nNOTE 2 – The macroblocks mbA and mbB can belong to different pictures. \n–  arbitrary slice order is allowed, mbA is the last macroblock (in decoding order) of a slice of a particular \npicture, and mbB is the first macroblock (in decoding order) of any other slice of the same picture, \n–  arbitrary slice order is allowed, mbA is the last macroblock (in decoding order) of a slice of a particular \npicture, and mbB is the first macroblock (in decoding order) of any slice of the next picture in decoding \norder. \nFor each unsorted pair of macroblocks (mbA, mbB) of the set setOf2Mb, the total number of motion vectors \n(given by the sum of the number of motion vectors for macroblock mbA and the number of motion vectors for \nmacroblock mbB) does not exceed MaxMvsPer2Mb, where MaxMvsPer2Mb is specified in Table A-1. The \nnumber of motion vectors for each macroblock is the value of the variable MvCnt after the completion of the intra \nor inter prediction process for the macroblock. \nNOTE 3 – The constraint specifies that the total number of motion vectors for two consecutive macroblocks in \ndecoding order must not exceed MaxMvsPer2Mb. When arbitrary slice order is allowed, it is specified that this \nconstraint must also be obeyed when slices of a picture are reordered, e.g., during transmission. \nn)  The number of bits of macroblock_layer( ) data for any macroblock is not greater than 3200. Depending on \nentropy_coding_mode_flag, the bits of macroblock_layer( ) data are counted as follows: \n–  If entropy_coding_mode_flag is equal to 0, the number of bits of macroblock_layer( ) data is given by the \nnumber of bits in the macroblock_layer( ) syntax structure for a macroblock. \n–  Otherwise (entropy_coding_mode_flag is equal to 1), the number of bits of macroblock_layer( ) data for a \nmacroblock is given by the number of times read_bits( 1 ) is called in clauses 9.3.3.2.2 and 9.3.3.2.3 when \nparsing the macroblock_layer( ) associated with the macroblock. \n \nTable A-1 specifies the limits for each level. A definition of all levels identified in the \"Level number\" column of Table A-1 \nis specified for the Baseline, Constrained Baseline, Main, and Extended profiles. Each entry in Table A-1 indicates, for the \nlevel corresponding to the row of the table, the absence or value of a limit that is imposed by the variable corresponding \nto the column of the table, as follows: \n–  If the table entry is marked as \"-\", no limit is imposed by the value of the variable as a requirement of bitstream \nconformance to the profile at the specified level. \n–  Otherwise, the table entry specifies the value of the variable for the associated limit that is imposed as a requirement \nof bitstream conformance to the profile at the specified level. \nFor purposes of comparison of level capabilities, a level shall be considered to be a lower (higher) level than some other \nlevel if the level appears nearer to the top (bottom) row of Table A-1 than the other level. \nIn bitstreams conforming to the Baseline, Constrained Baseline, Main, or Extended profiles, the conformance of the \nbitstream to a specified level is indicated by the syntax elements level_idc and constraint_set3_flag as follows: \n–  If level_idc is equal to 11 and constraint_set3_flag is equal to 1, the indicated level is level 1b. \n–  Otherwise (level_idc is not equal to 11 or constraint_set3_flag is not equal to 1), level_idc is equal to a value of ten \ntimes the level number (of the indicated level) specified in Table A-1. \n \n    Rec. ITU-T H.264 (06/2019)  293 \n \nTable A-1 – Level limits \n \nLevel  Max  Max  Max decoded  Max   Max  Vertical MV  Min  Max number of \nnumber  macroblock  frame size picture buffer  video  CPB size  component limit  compression  motion vectors \n  processing rate  MaxFS  size  bit rate MaxBR   MaxCPB  MaxVmvR  ratio MinCR  per two \n  MaxMBPS  (MBs)  MaxDpbMbs  (1000 bits/s,  (1000 bits,  (luma frame    consecutive MBs  \n  (MB/s)    (MBs)  1200 bits/s,  1200 bits,  samples)    MaxMvsPer2Mb \n        cpbBrVclFactor  cpbBrVclFactor       \n        bits/s, or  bits, or       \n        cpbBrNalFactor  cpbBrNalFactor       \n  bits/s)  bits)   \n1  1 485  99  396  64  175  64  2  - \n1b  1 485  99  396  128  350  64  2  - \n1.1  3 000  396  900  192  500  128  2  - \n1.2  6 000  396  2 376  384  1 000  128  2  - \n1.3  11 880  396  2 376  768  2 000  128  2  - \n2  11 880  396  2 376  2 000  2 000  128  2  - \n2.1  19 800  792  4 752  4 000  4 000  256  2  - \n2.2  20 250  1 620  8 100  4 000  4 000  256  2  - \n3  40 500  1 620  8 100  10 000  10 000  256  2  32 \n3.1  108 000  3 600  18 000  14 000  14 000  512  4  16 \n3.2  216 000  5 120  20 480  20 000  20 000  512  4  16 \n4  245 760  8 192  32 768  20 000  25 000  512  4  16 \n4.1  245 760  8 192  32 768  50 000  62 500  512  2  16 \n4.2  522 240  8 704  34 816  50 000  62 500  512  2  16 \n5  589 824  22 080  110 400  135 000  135 000  512  2  16 \n5.1  983 040  36 864  184 320  240 000  240 000  512  2  16 \n5.2  2 073 600  36 864  184 320  240 000  240 000  512  2  16 \n6  4 177 920  139 264  696 320  240 000  240 000  8 192  2  16 \n6.1  8 355 840  139 264  696 320  480 000  480 000  8 192  2  16 \n6.2  16 711 680  139 264  696 320  800 000  800 000  8 192  2  16 \n \nLevels with non-integer level numbers in Table A-1 are referred to as \"intermediate levels\". \nNOTE 4 – All levels have the same status, but some applications may choose to use only the integer-numbered levels. \nInformative clause A.3.4 shows the effect of these limits on frame rates for several example picture formats.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          3
        ],
        [
          "N",
          1
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.3.2  Level  limits  common  to  the  High,  Progressive High,  Constrained High,  High 10,  Progressive High 10,",
      "section_text": "High 4:2:2,  High 4:4:4 Predictive,  High 10 Intra,  High 4:2:2 Intra,  High 4:4:4 Intra,  and \nCAVLC 4:4:4 Intra profiles \nBitstreams  conforming  to  the  High,  Progressive High,  Constrained High,  High 10,  Progressive High 10,  High 4:2:2, \nHigh 4:4:4 Predictive, High 10 Intra, High 4:2:2 Intra, High 4:4:4 Intra, or CAVLC 4:4:4 Intra profiles at a specified level \nshall obey the following constraints: \na)  The nominal removal time of access unit n (with n > 0) from the CPB as specified in clause C.1.2, satisfies the \nconstraint  that  t ( n ) − t ( n − 1 )  is  greater  than  or  equal  to Max( PicSizeInMbs ÷ MaxMBPS, fR  ),  where \nr,n r\nMaxMBPS is the value specified in Table A-1 that applies to picture n − 1, and PicSizeInMbs is the number of \nmacroblocks in picture n − 1. \nb)  The difference between consecutive output times of pictures from the DPB as specified in clause C.2.2, satisfies \nthe constraint that t ( n ) >= Max( PicSizeInMbs ÷ MaxMBPS, fR ), where MaxMBPS is the value specified \no,dpb\nin Table A-1 for picture n, and PicSizeInMbs is the number of macroblocks of picture n, provided that picture n \nis a picture that is output and is not the last picture of the bitstream that is output. \nc)  PicWidthInMbs * FrameHeightInMbs <= MaxFS, where MaxFS is specified in Table A-1 \n294  Rec. ITU-T H.264 (06/2019) \n \nd)  PicWidthInMbs <= Sqrt( MaxFS * 8 ) \ne)  FrameHeightInMbs <= Sqrt( MaxFS * 8 ) \nf)  max_dec_frame_buffering <= MaxDpbFrames,  where  MaxDpbFrames  is  equal  to \nMin( MaxDpbMbs / ( PicWidthInMbs * FrameHeightInMbs ), 16 ) and MaxDpbMbs is specified in Table A-1. \ng)  The vertical motion vector component range for luma motion vectors does not exceed the range from −MaxVmvR \nto ( MaxVmvR − 0.25 ) in units of luma frame samples, where MaxVmvR is specified in Table A-1. \nh)  The horizontal motion vector component range for luma motion vectors does not exceed the following range: \n–  If the level number is less than 6.0, the specified range is from −2048 to 2047.75, inclusive, in units of luma \nsamples. \n–  Otherwise, the specified range is from −8192 to 8191.75, inclusive, in units of luma samples. \ni)  Let setOf2Mb be the set of unsorted pairs of macroblocks that contains the unsorted pairs of macroblocks \n(mbA, mbB) of a coded video sequence for which any of the following conditions are true: \n–  mbA and mbB are macroblocks that belong to the same slice and are consecutive in decoding order, \n–  separate_colour_plane_flag is equal to 0, mbA is the last macroblock (in decoding order) of a slice, and \nmbB is the first macroblock (in decoding order) of the next slice in decoding order, \n–  separate_colour_plane_flag is equal to 1, mbA is the last macroblock (in decoding order) of a slice with a \nparticular value of colour_plane_id, and mbB is the first macroblock (in decoding order) of the next slice \nwith the same value of colour_plane_id in decoding order. \nNOTE 1 – In the two above conditions, the macroblocks mbA and mbB can belong to different pictures. \nFor each unsorted pair of macroblocks (mbA, mbB) of the set setOf2Mb, the total number of motion vectors \n(given by the sum of the number of motion vectors for macroblock mbA and the number of motion vectors for \nmacroblock mbB) does not exceed MaxMvsPer2Mb, where MaxMvsPer2Mb is specified in Table A-1. The \nnumber of motion vectors for each macroblock is the value of the variable MvCnt after the completion of the intra \nor inter prediction process for the macroblock. \nNOTE 2 – When separate_colour_plane_flag is equal to 0, the constraint specifies that the total number of motion \nvectors  for  two  consecutive  macroblocks  in  decoding  order  must  not  exceed  MaxMvsPer2Mb.  When \nseparate_colour_plane_flag is equal to 1, the constraint specifies that the total number of motion vectors for two \nconsecutive  macroblocks  (in  decoding  order)  with  the  same  value  of  colour_plane_id  must  not  exceed \nMaxMvsPer2Mb. For macroblocks that are consecutive in decoding order but are associated with a different value \nof colour_plane_id, no constraint for the total number of motion vectors is specified. \nj)  The number of bits of macroblock_layer( ) data for any macroblock is not greater than 128 + RawMbBits. \nDepending on entropy_coding_mode_flag, the bits of macroblock_layer( ) data are counted as follows: \n–  If entropy_coding_mode_flag is equal to 0, the number of bits of macroblock_layer( ) data is given by the \nnumber of bits in the macroblock_layer( ) syntax structure for a macroblock. \n–  Otherwise (entropy_coding_mode_flag is equal to 1), the number of bits of macroblock_layer( ) data for a \nmacroblock is given by the number of times read_bits( 1 ) is called in clauses 9.3.3.2.2 and 9.3.3.2.3 when \nparsing the macroblock_layer( ) associated with the macroblock. \n \nTable A-1 specifies the limits for each level. A definition of all levels identified in the \"Level number\" column of Table A-1 \nis  specified  for  the  High,  Progressive High,  Constrained High,  High 10,  Progressive High 10,  High 4:2:2, \nHigh 4:4:4 Predictive, High 10 Intra, High 4:2:2 Intra, High 4:4:4 Intra, and CAVLC 4:4:4 Intra profiles. Each entry in \nTable A-1 indicates, for the level corresponding to the row of the table, the absence or value of a limit that is imposed by \nthe variable corresponding to the column of the table, as follows: \n–  If the table entry is marked as \"-\", no limit is imposed by the value of the variable as a requirement of bitstream \nconformance to the profile at the specified level. \n–  Otherwise, the table entry specifies the value of the variable for the associated limit that is imposed as a requirement \nof bitstream conformance to the profile at the specified level. \nThe  use  of  the  MinCR  parameter  column  of  Table A-1  for  the  High,  High 10,  High 4:2:2,  High 4:4:4 Predictive, \nHigh 10 Intra, High 4:2:2 Intra, High 4:4:4 Intra, and CAVLC 4:4:4 Intra profiles is specified in clause A.3.3. \n    Rec. ITU-T H.264 (06/2019)  295 \n \nIn  bitstreams  conforming  to  the  High,  High 10,  High 4:2:2,  High 4:4:4 Predictive,  High 10 Intra,  High 4:2:2 Intra, \nHigh 4:4:4 Intra, or CAVLC 4:4:4 Intra profiles, the conformance of the bitstream to a specified level is indicated by the \nsyntax element level_idc as follows: \n–  If level_idc is equal to 9, the indicated level is level 1b. \n–  Otherwise (level_idc is not equal to 9), level_idc is equal to a value of ten times the level number (of the indicated \nlevel) specified in Table A-1.",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.3.3  Profile-specific level limits",
      "section_text": "a)  In bitstreams conforming to the Main, High, Progressive High, Constrained High, High 10, Progressive High 10, \nHigh 4:2:2,  High 4:4:4 Predictive,  High 10 Intra,  High 4:2:2 Intra,  High 4:4:4 Intra,  or  CAVLC 4:4:4 Intra \nprofiles, the removal time of access unit 0 shall satisfy the constraint that the number of slices in picture 0 is less \nthan or equal to ( Max( PicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * ( t ( 0 ) − t ( 0 ) ) ) ÷ SliceRate, where \nr r,n\nMaxMBPS and SliceRate are the values specified in Tables A-1 and A-4, respectively, that apply to picture 0 and \nPicSizeInMbs is the number of macroblocks in picture 0. \nb)  In bitstreams conforming to the Main, High, Progressive High, Constrained High, High 10, Progressive High 10, \nHigh 4:2:2,  High 4:4:4 Predictive,  High 10 Intra,  High 4:2:2 Intra,  High 4:4:4 Intra,  or  CAVLC 4:4:4 Intra \nprofiles, the difference between consecutive removal times of access units n and n − 1 with n > 0 shall satisfy the \nconstraint  that  the  number  of  slices  in  picture  n  is  less  than  or  equal \nto MaxMBPS * ( t ( n ) − t ( n − 1 ) ) ÷ SliceRate, where MaxMBPS and SliceRate are the values specified in \nr r\nTables A-1 and A-4, respectively, that apply to picture n. \nc)  In  bitstreams  conforming  to  the  Main,  High,  Progressive High,  High 10,  Progressive High 10,  High 4:2:2, \nHigh 4:4:4 Predictive profiles, sequence parameter sets shall have direct_8x8_inference_flag equal to 1 for the \nlevels specified in Table A-4. \nNOTE 1  –  direct_8x8_inference_flag  is  not  relevant  to  the  Baseline,  Constrained Baseline,  Constrained High, \nHigh 10 Intra, High 4:2:2 Intra, High 4:4:4 Intra, and CAVLC 4:4:4 Intra profiles as these profiles do not allow B slice \ntypes, and direct_8x8_inference_flag is equal to 1 for all levels of the Extended profile. \nd)  In  bitstreams  conforming  to  the  Main,  High,  High 10,  High 4:2:2,  High 4:4:4 Predictive,  High 10 Intra, \nHigh 4:2:2 Intra, High 4:4:4 Intra, CAVLC 4:4:4 Intra, or Extended profiles, sequence parameter sets shall have \nframe_mbs_only_flag equal to 1 for the levels specified in Table A-4 for the Main, High, High 10, High 4:2:2, \nHigh 4:4:4 Predictive, High 10 Intra, High 4:2:2 Intra, High 4:4:4 Intra, or CAVLC 4:4:4 Intra profiles and in \nTable A-5 for the Extended profile. \nNOTE 2 – frame_mbs_only_flag is equal to 1 for all levels of the Baseline, Constrained Baseline, Progressive High, \nConstrained High, and Progressive High 10 profiles (specified in clauses A.2.1, A.2.1.1, A.2.4.1, A.2.4.2, and A.2.5.1, \nrespectively). \ne)  In  bitstreams  conforming  to  the  Main,  High,  Progressive High,  High 10,  Progressive High 10,  High 4:2:2, \nHigh 4:4:4 Predictive, or Extended profiles, the value of sub_mb_type[ mbPartIdx ] with mbPartIdx = 0..3 in B \nmacroblocks with mb_type equal to B_8x8 shall not be equal to B_Bi_8x4, B_Bi_4x8, or B_Bi_4x4 for the levels \nin which MinLumaBiPredSize is shown as 8x8 in Table A-4 for the Main, High, Progressive High, High 10, \nProgressive High 10, High 4:2:2, High 4:4:4 Predictive profiles and in Table A-5 for the Extended profile. \nf)  In bitstreams conforming to the Baseline, Constrained Baseline, or Extended profiles, ( xInt  − xInt  + 6 ) * \nmax min\n( yInt  − yInt  + 6 ) <= MaxSubMbRectSize in macroblocks coded with mb_type equal to P_8x8, P_8x8ref0 \nmax min\nor B_8x8 for all invocations of the process specified in clause 8.4.2.2.1 used to generate the predicted luma sample \narray for a single reference picture list (reference picture list 0 or reference picture list 1) for each 8x8 sub-\nmacroblock  with  the  macroblock  partition  index  mbPartIdx,  where \nNumSubMbPart( sub_mb_type[ mbPartIdx ] ) > 1, where MaxSubMbRectSize is specified in Table A-3 for the \nBaseline and Constrained Baseline profiles and in Table A-5 for the Extended profile and \n–  xInt  is the minimum value of xInt  among all luma sample predictions for the sub-macroblock \nmin L\n–  xInt  is the maximum value of xInt  among all luma sample predictions for the sub-macroblock \nmax L\n–  yInt  is the minimum value of yInt  among all luma sample predictions for the sub-macroblock \nmin L\n–  yInt  is the maximum value of yInt  among all luma sample predictions for the sub-macroblock \nmax L\ng)  In  bitstreams  conforming  to  the  High,  Progressive High,  Constrained High,  High 10,  Progressive High 10, \nHigh 4:2:2,  High 4:4:4 Predictive,  High 10 Intra,  High 4:2:2 Intra,  High 4:4:4 Intra,  or  CAVLC 4:4:4 Intra \nprofiles,  for  the  VCL  HRD  parameters,  BitRate[ SchedSelIdx ]  <=  cpbBrVclFactor  *  MaxBR  and \nCpbSize[ SchedSelIdx ]  <=  cpbBrVclFactor  *  MaxCPB  for  at  least  one  value  of  SchedSelIdx,  where \ncpbBrVclFactor is specified in Table A-2 and BitRate[ SchedSelIdx ] and CpbSize[ SchedSelIdx ] are given as \nfollows: \n296  Rec. ITU-T H.264 (06/2019) \n \n–  If vcl_hrd_parameters_present_flag is equal to 1, BitRate[ SchedSelIdx ] and CpbSize[ SchedSelIdx ] are \ngiven by Equations E-53 and E-54, respectively, using the syntax elements of the hrd_parameters( ) syntax \nstructure that immediately follows vcl_hrd_parameters_present_flag. \n–  Otherwise  (vcl_hrd_parameters_present_flag  is  equal  to  0),  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are inferred as specified in clause E.2.2 for VCL HRD parameters. \nMaxBR and MaxCPB are specified in Table A-1 in units of cpbBrVclFactor bits/s and cpbBrVclFactor bits, \nrespectively. The bitstream shall satisfy these conditions for at least one value of SchedSelIdx in the range 0 to \ncpb_cnt_minus1, inclusive. \nh)  In  bitstreams  conforming  to  the  High,  Progressive High,  Constrained High,  High 10,  Progressive High 10, \nHigh 4:2:2,  High 4:4:4 Predictive,  High 10 Intra,  High 4:2:2 Intra,  High 4:4:4 Intra,  or  CAVLC 4:4:4 Intra \nprofiles,  for  the  NAL  HRD  parameters,  BitRate[ SchedSelIdx ] <= cpbBrNalFactor * MaxBR  and \nCpbSize[ SchedSelIdx ]  <=  cpbBrNalFactor  *  MaxCPB  for  at  least  one  value  of  SchedSelIdx,  where \ncpbBrNalFactor is specified in Table A-2 and BitRate[ SchedSelIdx ] and CpbSize[ SchedSelIdx ] are given as \nfollows: \n–  If nal_hrd_parameters_present_flag is equal to 1, BitRate[ SchedSelIdx ] and CpbSize[ SchedSelIdx ] are \ngiven by Equations E-53 and E-54, respectively, using the syntax elements of the hrd_parameters( ) syntax \nstructure that immediately follows nal_hrd_parameters_present_flag. \n–  Otherwise  (nal_hrd_parameters_present_flag  is  equal  to  0),  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are inferred as specified in clause E.2.2 for NAL HRD parameters. \nMaxBR and MaxCPB are specified in Table A-1 in units of cpbBrNalFactor bits/s and cpbBrNalFactor bits, \nrespectively. The bitstream shall satisfy these conditions for at least one value of SchedSelIdx in the range 0 to \ncpb_cnt_minus1, inclusive. \ni)  In  bitstreams  conforming  to  the  High,  Progressive High,  or  Constrained High  profiles,  the  sum  of  the \nNumBytesInNALunit  variables  for  access  unit  0  is  less  than  or  equal  to \n384 * ( Max( PicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * ( t ( 0 ) − t ( 0 ) ) ) ÷ MinCR,  where  MaxMBPS \nr r,n\nand MinCR are the values specified in Table A-1 that apply to picture 0 and PicSizeInMbs is the number of \nmacroblocks in picture 0. \nNOTE  3  –  Such  a  limit  involving  MinCR  is  not  imposed  for  bitstream  conformance  to  the  High 10, \nProgressive High 10,  High 4:2:2,  High 4:4:4 Predictive,  High 10 Intra,  High 4:2:2 Intra,  High 4:4:4 Intra,  and \nCAVLC 4:4:4 Intra profiles. \nj)  In  bitstreams  conforming  to  the  High,  Progressive High,  or  Constrained High  profiles,  the  sum  of  the \nNumBytesInNALunit  variables  for  access  unit n  with  n  >  0  is  less  than  or  equal  to \n384 * MaxMBPS * ( t ( n ) − t ( n − 1 ) ) ÷ MinCR, where MaxMBPS and MinCR are the values specified in \nr r\nTable A-1 that apply to picture n. \nNOTE  4  –  Such  a  limit  involving  MinCR  is  not  imposed  for  bitstream  conformance  to  the  High 10, \nProgressive High 10,  High 4:2:2,  High 4:4:4 Predictive,  High 10 Intra,  High 4:2:2 Intra,  High 4:4:4 Intra,  and \nCAVLC 4:4:4 Intra profiles. \nk)  In bitstreams conforming to the High 10, Progressive High 10, High 4:2:2, High 4:4:4 Predictive, High 10 Intra, \nHigh 4:2:2 Intra, High 4:4:4 Intra, or CAVLC 4:4:4 Intra profiles, when the level number is less than 6.0 and \nPicSizeInMbs is greater than 1620, the number of macroblocks in any coded slice shall not exceed MaxFS / 4, \nwhere MaxFS is specified in Table A-1. \nTable A-2 – Specification of cpbBrVclFactor  \nand cpbBrNalFactor \n \nProfile  cpbBrVclFactor cpbBrNalFactor \nHigh \nProgressive High  1 250  1 500 \nConstrained High \nHigh 10 \nProgressive High 10  3 000  3 600 \nHigh 10 Intra \nHigh 4:2:2 \n4 000  4 800 \nHigh 4:2:2 Intra \nHigh 4:4:4 Predictive \nHigh 4:4:4 Intra  4 000  4 800 \nCAVLC 4:4:4 Intra  \n    Rec. ITU-T H.264 (06/2019)  297",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          3
        ],
        [
          "N",
          3
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.3.3.1  Level limits of the Baseline and Constrained Baseline profile",
      "section_text": "Table A-3 specifies limits for each level that are specific to bitstreams conforming to the Baseline or Constrained Baseline \nprofiles. Each entry in Table A-3 indicates, for the level corresponding to the row of the table, the absence or value of a \nlimit that is imposed by the variable corresponding to the column of the table, as follows: \n–  If the table entry is marked as \"-\", no limit is imposed by the value of the variable as a requirement of bitstream \nconformance to the profile at the specified level. \n–  Otherwise, the table entry specifies the value of the variable for the associated limit that is imposed as a requirement \nof bitstream conformance to the profile at the specified level. \nTable A-3 – Baseline and Constrained  \nBaseline profile level limits \nLevel  number  MaxSubMbRectSize \n1  576 \n1b  576 \n1.1  576 \n1.2  576 \n1.3  576 \n2  576 \n2.1  576 \n2.2  576 \n3  576 \n3.1  - \n3.2  - \n4  - \n4.1  - \n4.2  - \n5  - \n5.1  - \n5.2  - \n6.0  - \n6.1  - \n6.2  -",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          3
        ],
        [
          "N",
          3
        ],
        [
          "N",
          1
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.3.3.2  Level  limits  of  the  Main,  High,  Progressive High,  Constrained High,  High 10,  Progressive High 10,",
      "section_text": "High 4:2:2,  High 4:4:4 Predictive,  High 10 Intra,  High 4:2:2 Intra,  High 4:4:4 Intra,  and \nCAVLC 4:4:4 Intra profile \nTable A-4 specifies limits for each level that are specific to bitstreams conforming to the Main, High, Progressive High, \nConstrained High,  High 10,  Progressive High 10,  High 4:2:2,  High 4:4:4 Predictive,  High 10 Intra,  High 4:2:2 Intra, \nHigh 4:4:4 Intra, or CAVLC 4:4:4 Intra profiles. Each entry in Table A-4 indicates, for the level corresponding to the row \nof the table, the absence or value of a limit that is imposed by the variable corresponding to the column of the table, as \nfollows: \n–  If the table entry is marked as \"-\", no limit is imposed by the value of the variable as a requirement of bitstream \nconformance to the profile at the specified level. \n–  Otherwise, the table entry specifies the value of the variable for the associated limit that is imposed as a requirement \nof bitstream conformance to the profile at the specified level. \n298  Rec. ITU-T H.264 (06/2019) \n \nNOTE  –  The  constraints  for  MinLumaBiPredSize  and  direct_8x8_inference_flag  are  not  relevant  to  the \nConstrained High, High 10 Intra, High 4:2:2 Intra, High 4:4:4 Intra, and CAVLC 4:4:4 Intra profiles, as these profiles \ndo not support B slices. \nTable A-4 – Main, High, Progressive High, Constrained High, High 10, Progressive High 10, High 4:2:2, \nHigh 4:4:4 Predictive, High 10 Intra, High 4:2:2 Intra, High 4:4:4 Intra, and CAVLC 4:4:4 Intra profile level \nlimits \nLevel number  SliceRate  MinLumaBiPredSize  direct_8x8_inference_flag  frame_mbs_only_flag \n1  -  -  -  1 \n1b  -  -  -  1 \n1.1  -  -  -  1 \n1.2  -  -  -  1 \n1.3  -  -  -  1 \n2  -  -  -  1 \n2.1  -  -  -  - \n2.2  -  -  -  - \n3  22  -  1  - \n3.1  60  8x8  1  - \n3.2  60  8x8  1  - \n4  60  8x8  1  - \n4.1  24  8x8  1  - \n4.2  24  8x8  1  1 \n5  24  8x8  1  1 \n5.1  24  8x8  1  1 \n5.2  24  8x8  1  1 \n6  24  8x8  1  1 \n6.1  24  8x8  1  1 \n6.2  24  8x8  1  1",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          3
        ],
        [
          "N",
          3
        ],
        [
          "N",
          2
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.3.3.3  Level limits of the Extended profile",
      "section_text": "Table A-5 specifies limits for each level that are specific to bitstreams conforming to the Extended profile. Each entry in \nTable A-5 indicates, for the level corresponding to the row of the table, the absence or value of a limit that is imposed by \nthe variable corresponding to the column of the table, as follows: \n–  If the table entry is marked as \"-\", no limit is imposed by the value of the variable as a requirement of bitstream \nconformance to the profile at the specified level. \n–  Otherwise, the table entry specifies the value of the variable for the associated limit that is imposed as a requirement \nof bitstream conformance to the profile at the specified level. \n \n    Rec. ITU-T H.264 (06/2019)  299 \n \nTable A-5 – Extended profile level limits \nLevel number  MaxSubMbRectSize  MinLumaBiPredSize  frame_mbs_only_flag \n1  576  -  1 \n1b  576  -  1 \n1.1  576  -  1 \n1.2  576  -  1 \n1.3  576  -  1 \n2  576  -  1 \n2.1  576  -  - \n2.2  576  -  - \n3  576  -  - \n3.1  -  8x8  - \n3.2  -  8x8  - \n4  -  8x8  - \n4.1  -  8x8  - \n4.2  -  8x8  1 \n5  -  8x8  1 \n5.1  -  8x8  1 \n5.2  -  8x8  1 \n6  -  8x8  1 \n6.1  -  8x8  1 \n6.2  -  8x8  1 \n \n300  Rec. ITU-T H.264 (06/2019)",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          3
        ],
        [
          "N",
          3
        ],
        [
          "N",
          3
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.3.4  Effect of level limits on frame rate (informative)",
      "section_text": "This clause does not form an integral part of this Recommendation | International Standard. \nTable A-6 – Maximum frame rates (frames per second) for some example frame sizes \n \nLevel:          1  1b  1.1  1.2  1.3  2  2.1 \nMax frame size (macroblocks):          99  99  396  396  396  396  792 \nMax macroblocks/second:          1 485  1 485  3 000  6 000  11 880  11 880  19 800 \n                       \nMax frame size (samples):          25 344  25 344  101 376  101 376  101 376  101 376  202 752 \nMax samples/second:          380 160  380 160  768 000  1 536 000  3 041 280  3 041 280  5 068 800 \nLuma  Luma  MBs  Luma     \nFormat  Width  Height  Total  Samples           \nSQCIF  128  96  48  12 288  30.9  30.9  62.5  125.0  172.0  172.0  172.0 \nQCIF  176  144  99  25 344  15.0  15.0  30.3  60.6  120.0  120.0  172.0 \nQVGA  320  240  300  76 800  -  -  10.0  20.0  39.6  39.6  66.0 \n525 SIF  352  240  330  84 480  -  -  9.1  18.2  36.0  36.0  60.0 \nCIF  352  288  396  101 376  -  -  7.6  15.2  30.0  30.0  50.0 \n525 HHR  352  480  660  168 960  -  -  -  -  -  -  30.0 \n625 HHR  352  576  792  202 752  -  -  -  -  -  -  25.0 \nVGA  640  480  1 200  307 200  -  -  -  -  -  -  - \n525 4SIF  704  480  1 320  337 920  -  -  -  -  -  -  - \n525 SD  720  480  1 350  345 600  -  -  -  -  -  -  - \n4CIF  704  576  1 584  405 504  -  -  -  -  -  -  - \n625 SD  720  576  1 620  414 720  -  -  -  -  -  -  - \nSVGA  800  600  1 900  486 400  -  -  -  -  -  -  - \nXGA  1024  768  3 072  786 432  -  -  -  -  -  -  - \n720p HD  1280  720  3 600  921 600  -  -  -  -  -  -  - \n4VGA  1280  960  4 800  1 228 800  -  -  -  -  -  -  - \nSXGA  1280  1024  5 120  1 310 720  -  -  -  -  -  -  - \n525 16SIF  1408  960  5 280  1 351 680  -  -  -  -  -  -  - \n16CIF  1408  1152  6 336  1 622 016  -  -  -  -  -  -  - \n4SVGA  1600  1200  7 500  1 920 000  -  -  -  -  -  -  - \n1080 HD  1920  1088  8 160  2 088 960  -  -  -  -  -  -  - \n2Kx1K  2048  1024  8 192  2 097 152  -  -  -  -  -  -  - \n2Kx1080  2048  1088  8 704  2 228 224  -  -  -  -  -  -  - \n4XGA  2048  1536  12 288  3 145 728  -  -  -  -  -  -  - \n16VGA  2560  1920  19 200  4 915 200  -  -  -  -  -  -  - \n3616x1536 (2.35:1)  3616  1536  21 696  5 554 176  -  -  -  -  -  -  - \n3672x1536 (2.39:1)  3680  1536  22 080  5 652 480  -  -  -  -  -  -  - \n3840x2160  3840  2160  31 035  7 948 800  -  -  -  -  -  -  - \n4Kx2K  4096  2048  32 768  8 388 608  -  -  -  -  -  -  - \n4096x2160  4096  2160  34 560  8 847 360  -  -  -  -  -  -  - \n4096x2304 (16:9)  4096  2304  36 864  9 437 184  -  -  -  -  -  -  - \n7680x4320  7680  4320  129 600  33 177 600  -  -  -  -  -  -  - \n8192x4096  8192  4096  131 072  33 554 432  -  -  -  -  -  -  - \n8192x4320  8192  4320  138 240  35 389 440  -  -  -  -  -  -  - \n \n    Rec. ITU-T H.264 (06/2019)  301 \n \nTable A-6 (continued) – Maximum frame rates (frames per second) for some example frame sizes \n \nLevel:          2.2  3  3.1  3.2  4  4.1  4.2 \nMax frame size (macroblocks):          1 620  1 620  3 600  5 120  8 192  8 192  8 704 \nMax macroblocks/second:          20 250  40 500  108 000  216 000  245 760  245 760  522 240 \n                       \nMax frame size (samples):          414 720  414 720  921 600  1 310 720  2 097 152  2 097 152  2 228 224 \nMax samples/second:          5 184 000  10 368 000  27 648 000  55 296 000  62 914 560  62 914 560  133 693 440 \nLuma  Luma  MBs  Luma   \nFormat  Width  Height  Total  Samples             \nSQCIF  128  96  48  12 288  172.0  172.0  172.0  172.0  172.0  172.0  172.0 \nQCIF  176  144  99  25 344  172.0  172.0  172.0  172.0  172.0  172.0  172.0 \nQVGA  320  240  300  76 800  67.5  135.0  172.0  172.0  172.0  172.0  172.0 \n525 SIF  352  240  330  84 480  61.4  122.7  172.0  172.0  172.0  172.0  172.0 \nCIF  352  288  396  101 376  51.1  102.3  172.0  172.0  172.0  172.0  172.0 \n525 HHR  352  480  660  168 960  30.7  61.4  163.6  172.0  172.0  172.0  172.0 \n625 HHR  352  576  792  202 752  25.6  51.1  136.4  172.0  172.0  172.0  172.0 \nVGA  640  480  1 200  307 200  16.9  33.8  90.0  172.0  172.0  172.0  172.0 \n525 4SIF  704  480  1 320  337 920  15.3  30.7  81.8  163.6  172.0  172.0  172.0 \n525 SD  720  480  1 350  345 600  15.0  30.0  80.0  160.0  172.0  172.0  172.0 \n4CIF  704  576  1 584  405 504  12.8  25.6  68.2  136.4  155.2  155.2  172.0 \n625 SD  720  576  1 620  414 720  12.5  25.0  66.7  133.3  151.7  151.7  172.0 \nSVGA  800  600  1 900  486 400  -  -  56.8  113.7  129.3  129.3  172.0 \nXGA  1024  768  3 072  786 432  -  -  35.2  70.3  80.0  80.0  170.0 \n720p HD  1280  720  3 600  921 600  -  -  30.0  60.0  68.3  68.3  145.1 \n4VGA  1280  960  4 800  1 228 800  -  -  -  45.0  51.2  51.2  108.8 \nSXGA  1280  1024  5 120  1 310 720  -  -  -  42.2  48.0  48.0  102.0 \n525 16SIF  1408  960  5 280  1 351 680  -  -  -  -  46.5  46.5  98.9 \n16CIF  1408  1152  6 336  1 622 016  -  -  -  -  38.8  38.8  82.4 \n4SVGA  1600  1200  7 500  1 920 000  -  -  -  -  32.8  32.8  69.6 \n1080 HD  1920  1088  8 160  2 088 960  -  -  -  -  30.1  30.1  64.0 \n2Kx1K  2048  1024  8 192  2 097 152  -  -  -  -  30.0  30.0  63.8 \n2Kx1080  2048  1088  8 704  2 228 224  -  -  -  -  -  -  60.0 \n4XGA  2048  1536  12 288  3 145 728  -  -  -  -  -  -  - \n16VGA  2560  1920  19 200  4 915 200  -  -  -  -  -  -  - \n3616x1536 (2.35:1)  3616  1536  21 696  5 554 176  -  -  -  -  -  -  - \n3672x1536 (2.39:1)  3680  1536  22 080  5 652 480  -  -  -  -  -  -  - \n3840x2160  3840  2160  31 035  7 948 800  -  -  -  -  -  -  - \n4Kx2K  4096  2048  32 768  8 388 608  -  -  -  -  -  -  - \n4096x2160  4096  2160  34 560  8 847 360  -  -  -  -  -  -  - \n4096x2304 (16:9)  4096  2304  36 864  9 437 184  -  -  -  -  -  -  - \n7680x4320  7680  4320  129 600  33 177 600  -  -  -  -  -  -  - \n8192x4096  8192  4096  131 072  33 554 432  -  -  -  -  -  -  - \n8192x4320  8192  4320  138 240  35 389 440  -  -  -  -  -  -  - \n \n302  Rec. ITU-T H.264 (06/2019) \n \nTable A-6 (concluded) – Maximum frame rates (frames per second) for some example frame sizes \nLevel:          5  5.1  5.2  6  6.1  6.2 \nMax frame size (macroblocks):          22 080  36 864  36 864  139 264  139 264  139 264 \nMax macroblocks/second:          589 824  983 040  2 073 600  4 177 920  8 355 840  16 711 680 \n                     \nMax frame size (samples):          5 652 480  9 437 184  9 437 184  35 651 584  35 651 584  35 651 584 \nMax samples/second:          150 994 944  251 658 240  530 841 600  1 069 547 520  2 139 095 040  4 278 190 080 \nLuma  Luma  MBs  Luma         \nFormat  Width  Height  Total  Samples     \nSQCIF  128  96  48  12 288  172.0  172.0  172.0  300.0  300.0  300.0 \nQCIF  176  144  99  25 344  172.0  172.0  172.0  300.0  300.0  300.0 \nQVGA  320  240  300  76 800  172.0  172.0  172.0  300.0  300.0  300.0 \n525 SIF  352  240  330  84 480  172.0  172.0  172.0  300.0  300.0  300.0 \nCIF  352  288  396  101 376  172.0  172.0  172.0  300.0  300.0  300.0 \n525 HHR  352  480  660  168 960  172.0  172.0  172.0  300.0  300.0  300.0 \n625 HHR  352  576  792  202 752  172.0  172.0  172.0  300.0  300.0  300.0 \nVGA  640  480  1 200  307 200  172.0  172.0  172.0  300.0  300.0  300.0 \n525 4SIF  704  480  1 320  337 920  172.0  172.0  172.0  300.0  300.0  300.0 \n525 SD  720  480  1 350  345 600  172.0  172.0  172.0  300.0  300.0  300.0 \n4CIF  704  576  1 584  405 504  172.0  172.0  172.0  300.0  300.0  300.0 \n625 SD  720  576  1 620  414 720  172.0  172.0  172.0  300.0  300.0  300.0 \nSVGA  800  600  1 900  486 400  172.0  172.0  172.0  300.0  300.0  300.0 \nXGA  1024  768  3 072  786 432  172.0  172.0  172.0  300.0  300.0  300.0 \n720p HD  1280  720  3 600  921 600  163.8  172.0  172.0  300.0  300.0  300.0 \n4VGA  1280  960  4 800  1 228 800  122.9  172.0  172.0  300.0  300.0  300.0 \nSXGA  1280  1024  5 120  1 310 720  115.2  172.0  172.0  300.0  300.0  300.0 \n525 16SIF  1408  960  5 280  1 351 680  111.7  172.0  172.0  300.0  300.0  300.0 \n16CIF  1408  1152  6 336  1 622 016  93.1  155.2  172.0  300.0  300.0  300.0 \n4SVGA  1600  1200  7 500  1 920 000  78.6  131.1  172.0  300.0  300.0  300.0 \n1080 HD  1920  1088  8 160  2 088 960  72.3  120.5  172.0  300.0  300.0  300.0 \n2Kx1K  2048  1024  8 192  2 097 152  72.0  120.0  172.0  300.0  300.0  300.0 \n2Kx1080  2048  1088  8 704  2 228 224  67.8  112.9  172.0  300.0  300.0  300.0 \n4XGA  2048  1536  12 288  3 145 728  48.0  80.0  168.8  300.0  300.0  300.0 \n16VGA  2560  1920  19 200  4 915 200  30.7  51.2  108.0  217.6  300.0  300.0 \n3616x1536 (2.35:1)  3616  1536  21 696  5 554 176  27.2  45.3  95.6  192.6  300.0  300.0 \n3672x1536 (2.39:1)  3680  1536  22 080  5 652 480  26.7  44.5  93.9  189.2  300.0  300.0 \n3840x2160  3840  2160  31 035  7 948 800  -  30.3  64.0  128.9  257.9  300.0 \n4Kx2K  4096  2048  32 768  8 388 608  -  30.0  63.3  127.5  255.0  300.0 \n4096x2160  4096  2160  34 560  8 847 360  -  28.4  60.0  120.9  241.8  300.0 \n4096x2304 (16:9)  4096  2304  36 864  9 437 184  -  26.7  56.3  113.3  226.7  300.0 \n7680x4320  7680  4320  129 600  33 177 600  -  -  -  32.2  64.5  128.9 \n8192x4096  8192  4096  131 072  33 554 432  -  -  -  31.9  63.8  127.5 \n8192x4320  8192  4320  138 240  35 389 440  -  -  -  30.2  60.4  120.9 \n \n \nThe following should be noted: \n–  This Recommendation | International Standard is a variable-frame-size specification. The specific frame sizes in \nTable A-6 are illustrative examples only. \n–  As  used  in  Table A-6,  \"525\"  refers  to  typical  use  for  environments  using  525  analogue  scan  lines  (of  which \napproximately 480 lines contain the visible picture region), and \"625\" refers to environments using 625 analogue scan \nlines (of which approximately 576 lines contain the visible picture region). \n–  XGA is also known as (aka) XVGA, 4SVGA aka UXGA, 16XGA aka 4Kx3K, CIF aka 625 SIF, 625 HHR aka 2CIF \naka half 625 D-1, aka half 625 ITU-R BT.601, 525 SD aka 525 D-1 aka 525 ITU-R BT.601, 625 SD aka 625 D-1 aka \n625 ITU-R BT.601. \n–  The given maximum frame rate values that have a zero to the right of the decimal point are exact. Others have been \nrounded to the nearest 0.1 frames per second, i.e., the precise maximum frame rates may be higher or lower within a \nmargin of plus or minus 0.05 frames per second. For example, for Level 4, the maximum frame rate for 720p HD has \nbeen rounded up to 68.3 from a value of 68.2666…, and the maximum frame rate for 1080 HD has been rounded \ndown to 30.1 from a value of 30.1176…. \n–  Frame rates given are correct for progressive scan modes. The frame rates are also correct for interlaced video coding \nfor the cases of frame height divisible by 32. \n    Rec. ITU-T H.264 (06/2019)  303",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          3
        ],
        [
          "N",
          4
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "A.3.5  Effect of level limits on maximum DPB size in units of frames (informative)",
      "section_text": "This clause does not form an integral part of this Recommendation | International Standard. \nTable A-7 – Maximum DPB size (frames) for some example frame sizes \n \nLevel:        1  1b  1.1  1.2  1.3  2  2.1  2.2 \nMax frame size (macroblocks):        99  99  396  396  396  396  792  1 620 \nMax DPB size (macroblocks):        396  396  900  2 376  2 376  2 376  4 752  8 100 \nFormat  Luma Width  Luma Height  MBs Total                 \nSQCIF  128  96  48  8  8  16  16  16  16  16  16 \nQCIF  176  144  99  4  4  9  16  16  16  16  16 \nQVGA  320  240  300  -  -  3  7  7  7  15  16 \n525 SIF  352  240  330  -  -  2  7  7  7  14  16 \nCIF  352  288  396  -  -  2  6  6  6  12  16 \n525 HHR  352  480  660  -  -  -  -  -  -  7  12 \n625 HHR  352  576  792  -  -  -  -  -  -  6  10 \nVGA  640  480  1 200  -  -  -  -  -  -  -  6 \n525 4SIF  704  480  1 320  -  -  -  -  -  -  -  6 \n525 SD  720  480  1 350  -  -  -  -  -  -  -  6 \n4CIF  704  576  1 584  -  -  -  -  -  -  -  5 \n625 SD  720  576  1 620  -  -  -  -  -  -  -  5 \nSVGA  800  600  1 900  -  -  -  -  -  -  -  - \nXGA  1024  768  3 072  -  -  -  -  -  -  -  - \n720p HD  1280  720  3 600  -  -  -  -  -  -  -  - \n4VGA  1280  960  4 800  -  -  -  -  -  -  -  - \nSXGA  1280  1024  5 120  -  -  -  -  -  -  -  - \n525 16SIF  1408  960  5 280  -  -  -  -  -  -  -  - \n16CIF  1408  1152  6 336  -  -  -  -  -  -  -  - \n4SVGA  1600  1200  7 500  -  -  -  -  -  -  -  - \n1080 HD  1920  1088  8 160  -  -  -  -  -  -  -  - \n2Kx1K  2048  1024  8 192  -  -  -  -  -  -  -  - \n2Kx1080  2048  1088  8 704  -  -  -  -  -  -  -  - \n4XGA  2048  1536  12 288  -  -  -  -  -  -  -  - \n16VGA  2560  1920  19 200  -  -  -  -  -  -  -  - \n3616x1536 (2.35:1)  3616  1536  21 696  -  -  -  -  -  -  -  - \n3672x1536 (2.39:1)  3680  1536  22 080  -  -  -  -  -  -  -  - \n3840x2160  3840  2160  31 035  -  -  -  -  -  -  -  - \n4Kx2K  4096  2048  32 768  -  -  -  -  -  -  -  - \n4096x2160  4096  2160  34 560  -  -  -  -  -  -  -  - \n4096x2304 (16:9)  4096  2304  36 864  -  -  -  -  -  -  -  - \n7680x4320  7680  4320  129 600  -  -  -  -  -  -  -  - \n8192x4096  8192  4096  131 072  -  -  -  -  -  -  -  - \n8192x4320  8192  4320  138 240  -  -  -  -  -  -  -  - \n \n304  Rec. ITU-T H.264 (06/2019) \n \nTable A-7 (continued) – Maximum DPB size (frames) for some example frame sizes \n \nLevel:        3  3.1  3.2  4  4.1  4.2 \nMax frame size (macroblocks):        1 620  3 600  5 120  8 192  8 192  8 704 \nMax DPB size (macroblocks):        8 100  18 000  20 480  32 768  32 768  34 816 \nMBs \n           \nFormat  Luma Width  Luma Height  Total \nSQCIF  128  96  48  16  16  16  16  16  16 \nQCIF  176  144  99  16  16  16  16  16  16 \nQVGA  320  240  300  16  16  16  16  16  16 \n525 SIF  352  240  330  16  16  16  16  16  16 \nCIF  352  288  396  16  16  16  16  16  16 \n525 HHR  352  480  660  12  16  16  16  16  16 \n625 HHR  352  576  792  10  16  16  16  16  16 \nVGA  640  480  1 200  6  15  16  16  16  16 \n525 4SIF  704  480  1 320  6  13  15  16  16  16 \n525 SD  720  480  1 350  6  13  15  16  16  16 \n4CIF  704  576  1 584  5  11  12  16  16  16 \n625 SD  720  576  1 620  5  11  12  16  16  16 \nSVGA  800  600  1 900  -  9  10  16  16  16 \nXGA  1024  768  3 072  -  5  6  10  10  11 \n720p HD  1280  720  3 600  -  5  5  9  9  9 \n4VGA  1280  960  4 800  -  -  4  6  6  7 \nSXGA  1280  1024  5 120  -  -  4  6  6  6 \n525 16SIF  1408  960  5 280  -  -  -  6  6  6 \n16CIF  1408  1152  6 336  -  -  -  5  5  5 \n4SVGA  1600  1200  7 500  -  -  -  4  4  4 \n1080 HD  1920  1088  8 160  -  -  -  4  4  4 \n2Kx1K  2048  1024  8 192  -  -  -  4  4  4 \n2Kx1080  2048  1088  8 704  -  -  -  -  -  4 \n4XGA  2048  1536  12 288  -  -  -  -  -  - \n16VGA  2560  1920  19 200  -  -  -  -  -  - \n3616x1536 (2.35:1)  3616  1536  21 696  -  -  -  -  -  - \n3672x1536 (2.39:1)  3680  1536  22 080  -  -  -  -  -  - \n3840x2160  3840  2160  31 035  -  -  -  -  -  - \n4Kx2K  4096  2048  32 768  -  -  -  -  -  - \n4096x2160  4096  2160  34 560  -  -  -  -  -  - \n4096x2304 (16:9)  4096  2304  36 864  -  -  -  -  -  - \n7680x4320  7680  4320  129 600  -  -  -  -  -  - \n8192x4096  8192  4096  131 072  -  -  -  -  -  - \n8192x4320  8192  4320  138 240  -  -  -  -  -  - \nTable A-7 (concluded) – Maximum DPB size (frames) for some example frame sizes \nLevel:        5  5.1  5.2  6  6.1  6.2 \nMax frame size (macroblocks):        22 080  36 864  36 864  129 600  131 072  138 240 \nMax DPB size (macroblocks):        110 400  184 320  184 320  696 320  696 320  696 320 \nFormat  Luma Width  Luma Height  MBs Total             \nSQCIF  128  96  48  16  16  16  16  16  16 \nQCIF  176  144  99  16  16  16  16  16  16 \nQVGA  320  240  300  16  16  16  16  16  16 \n525 SIF  352  240  330  16  16  16  16  16  16 \nCIF  352  288  396  16  16  16  16  16  16 \n525 HHR  352  480  660  16  16  16  16  16  16 \n625 HHR  352  576  792  16  16  16  16  16  16 \nVGA  640  480  1 200  16  16  16  16  16  16 \n525 4SIF  704  480  1 320  16  16  16  16  16  16 \n525 SD  720  480  1 350  16  16  16  16  16  16 \n4CIF  704  576  1 584  16  16  16  16  16  16 \n625 SD  720  576  1 620  16  16  16  16  16  16 \nSVGA  800  600  1 900  16  16  16  16  16  16 \nXGA  1024  768  3 072  16  16  16  16  16  16 \n720p HD  1280  720  3 600  16  16  16  16  16  16 \n4VGA  1280  960  4 800  16  16  16  16  16  16 \nSXGA  1280  1024  5 120  16  16  16  16  16  16 \n525 16SIF  1408  960  5 280  16  16  16  16  16  16 \n16CIF  1408  1152  6 336  16  16  16  16  16  16 \n4SVGA  1600  1200  7 500  14  16  16  16  16  16 \n1080 HD  1920  1088  8 160  13  16  16  16  16  16 \n2Kx1K  2048  1024  8 192  13  16  16  16  16  16 \n2Kx1080  2048  1088  8 704  12  16  16  16  16  16 \n4XGA  2048  1536  12 288  8  15  15  16  16  16 \n16VGA  2560  1920  19 200  5  9  9  16  16  16 \n3616x1536 (2.35:1)  3616  1536  21 696  5  8  8  16  16  16 \n3672x1536 (2.39:1)  3680  1536  22 080  5  8  8  16  16  16 \n3840x2160  3840  2160  31 035  -  5  5  16  16  16 \n4Kx2K  4096  2048  32 768  -  5  5  16  16  16 \n4096x2160  4096  2160  34 560  -  5  5  16  16  16 \n4096x2304 (16:9)  4096  2304  36 864  -  5  5  16  16  16 \n7680x4320  7680  4320  129 600  -  -  -  5  5  5 \n8192x4096  8192  4096  131 072  -  -  -  5  5  5 \n8192x4320  8192  4320  138 240  -  -  -  5  5  5 \n \n    Rec. ITU-T H.264 (06/2019)  305 \n \nThe following should be noted: \n–  As  used  in  Table A-7,  \"525\"  refers  to  typical  use  for  environments  using  525  analogue  scan  lines  (of  which \napproximately 480 lines contain the visible picture region), and \"625\" refers to environments using 625 analogue scan \nlines (of which approximately 576 lines contain the visible picture region). \n–  XGA is also known as (aka) XVGA, 4SVGA aka UXGA, 16XGA aka 4Kx3K, CIF aka 625 SIF, 625 HHR aka 2CIF \naka half 625 D-1, aka half 625 ITU-R BT.601, 525 SD aka 525 D-1 aka 525 ITU-R BT.601, 625 SD aka 625 D-1 aka \n625 ITU-R BT.601. \n306  Rec. ITU-T H.264 (06/2019) \n \nAnnex B \n \nByte stream format \n \n(This annex forms an integral part of this Recommendation | International Standard.) \nThis annex specifies syntax and semantics of a byte stream format specified for use by applications that deliver some or \nall of the NAL unit stream as an ordered stream of bytes or bits within which the locations of NAL unit boundaries need \nto be identifiable from patterns in the data, such as Rec. ITU-T H.222.0 | ISO/IEC 13818-1 systems or Rec. ITU-T H.320 \nsystems. For bit-oriented delivery, the bit order for the byte stream format is specified to start with the MSB of the first \nbyte, proceed to the LSB of the first byte, followed by the MSB of the second byte, etc. \nThe byte stream format consists of a sequence of byte stream NAL unit syntax structures. Each byte stream NAL unit \nsyntax structure contains one start code prefix followed by one nal_unit( NumBytesInNALunit ) syntax structure. It may \n(and under some circumstances, it shall) also contain an additional zero_byte syntax element. It may also contain one or \nmore additional trailing_zero_8bits syntax elements. When it is the first byte stream NAL unit in the bitstream, it may also \ncontain one or more additional leading_zero_8bits syntax elements. \nB.1  Byte stream NAL unit syntax and semantics \nB.1.1  Byte stream NAL unit syntax \n \nbyte_stream_nal_unit( NumBytesInNALunit ) {  C  Descriptor \n  while( next_bits( 24 )  !=  0x000001 &&     \n        next_bits( 32 ) != 0x00000001 ) \n    leading_zero_8bits  /* equal to 0x00 */    f(8) \n  if( next_bits( 24 ) != 0x000001 )     \n    zero_byte  /* equal to 0x00 */    f(8) \n  start_code_prefix_one_3bytes  /* equal to 0x000001 */    f(24) \n  nal_unit( NumBytesInNALunit )     \n  while( more_data_in_byte_stream( ) &&     \n        next_bits( 24 ) != 0x000001 && \n        next_bits( 32 ) != 0x00000001 ) \n    trailing_zero_8bits  /* equal to 0x00 */    f(8) \n}     \nB.1.2  Byte stream NAL unit semantics \nThe order of byte stream NAL units in the byte stream shall follow the decoding order of the NAL units contained in the \nbyte stream NAL units (see clause 7.4.1.2). The content of each byte stream NAL unit is associated with the same access \nunit as the NAL unit contained in the byte stream NAL unit (see clause 7.4.1.2.3). \nleading_zero_8bits is a byte equal to 0x00. \nNOTE – The leading_zero_8bits syntax element can only be present in the first byte stream NAL unit of the bitstream, because (as \nshown in the syntax diagram of clause B.1.1) any bytes equal to 0x00 that follow a NAL unit syntax structure and precede the four-\nbyte sequence 0x00000001 (which is to be interpreted as  a zero_byte followed by a  start_code_prefix_one_3bytes)  will be \nconsidered to be trailing_zero_8bits syntax elements that are part of the preceding byte stream NAL unit. \nzero_byte is a single byte equal to 0x00. \nWhen any of the following conditions are true, the zero_byte syntax element shall be present: \n–  the nal_unit_type within the nal_unit( ) is equal to 7 (sequence parameter set) or 8 (picture parameter set), \n–  the byte stream NAL unit syntax structure contains the first NAL unit of an access unit in decoding order, as specified \nin clause 7.4.1.2.3. \nstart_code_prefix_one_3bytes is a fixed-value sequence of 3 bytes equal to 0x000001. This syntax element is called a \nstart code prefix. \ntrailing_zero_8bits is a byte equal to 0x00. \n    Rec. ITU-T H.264 (06/2019)  307 \n \nB.2  Byte stream NAL unit decoding process \nInput to this process consists of an ordered stream of bytes consisting of a sequence of byte stream NAL unit syntax \nstructures. \nOutput of this process consists of a sequence of NAL unit syntax structures. \nAt the beginning of the decoding process, the decoder initializes its current position in the byte stream to the beginning of \nthe byte stream. It then extracts and discards each leading_zero_8bits syntax element (if present), moving the current \nposition in the byte stream forward one byte at a time, until the current position in the byte stream is such that the next four \nbytes in the bitstream form the four-byte sequence 0x00000001. \nThe decoder then performs the following step-wise process repeatedly to extract and decode each NAL unit syntax structure \nin the byte stream until the end of the byte stream has been encountered (as determined by unspecified means) and the last \nNAL unit in the byte stream has been decoded: \n1.  When the next four bytes in the bitstream form the four-byte sequence 0x00000001, the next byte in the byte \nstream (which is a zero_byte syntax element) is extracted and discarded and the current position in the byte stream \nis set equal to the position of the byte following this discarded byte. \n2.  The next three-byte sequence in the byte stream (which is a start_code_prefix_one_3bytes) is extracted and \ndiscarded and the current position in the byte stream is set equal to the position of the byte following this three-byte \nsequence. \n3.  NumBytesInNALunit is set equal to the number of bytes starting with the byte at the current position in the byte \nstream up to and including the last byte that precedes the location of any of the following: \n–  A subsequent byte-aligned three-byte sequence equal to 0x000000, \n–  A subsequent byte-aligned three-byte sequence equal to 0x000001, \n–  The end of the byte stream, as determined by unspecified means. \n4.  NumBytesInNALunit bytes are removed from the bitstream and the current position in the byte stream is advanced \nby NumBytesInNALunit bytes. This sequence of bytes is nal_unit( NumBytesInNALunit ) and is decoded using \nthe NAL unit decoding process. \n5.  When the current position in the byte stream is not at the end of the byte stream (as determined by unspecified \nmeans) and the next bytes in the byte stream do not start with a three-byte sequence equal to 0x000001 and the \nnext bytes in the byte stream do not start with a four byte sequence equal to 0x00000001, the decoder extracts and \ndiscards each trailing_zero_8bits syntax element, moving the current position in the byte stream forward one byte \nat a time, until the current position in the byte stream is such that the next bytes in the byte stream form the four-\nbyte sequence 0x00000001 or the end of the byte stream has been encountered (as determined by unspecified \nmeans). \nB.3  Decoder byte-alignment recovery (informative) \nThis clause does not form an integral part of this Recommendation | International Standard. \nMany applications provide data to a decoder in a manner that is inherently byte aligned, and thus have no need for the bit-\noriented byte alignment detection procedure described in this clause. \nA decoder is said to have byte-alignment with a bitstream when the decoder is able to determine whether or not the positions \nof data in the bitstream are byte-aligned. When a decoder does not have byte alignment with the encoder's byte stream, the \ndecoder may examine the incoming bitstream  for the binary pattern  '00000000 00000000 00000000 00000001' (31 \nconsecutive bits equal to 0 followed by a bit equal to 1). The bit immediately following this pattern is the first bit of an \naligned byte following a start code prefix. Upon detecting this pattern, the decoder will be byte aligned with the encoder \nand positioned at the start of a NAL unit in the byte stream. \nOnce byte aligned with the encoder, the decoder can examine the incoming byte stream for subsequent three-byte sequences \n0x000001 and 0x000003. \nWhen the three-byte sequence 0x000001 is detected, this is a start code prefix. \nWhen the three-byte sequence 0x000003 is detected, the third byte (0x03) is an emulation_prevention_three_byte to be \ndiscarded as specified in clause 7.4.1. \nWhen an error in the bitstream syntax is detected (e.g., a non-zero value of the forbidden_zero_bit or one of the three-byte \nor four-byte sequences that are prohibited in clause 7.4.1), the decoder may consider the detected condition as an indication \nthat byte alignment may have been lost and may discard all bitstream data until the detection of byte alignment at a later \nposition in the bitstream as described in this clause.   \n308  Rec. ITU-T H.264 (06/2019) \n \nAnnex C \n \nHypothetical reference decoder \n \n(This annex forms an integral part of this Recommendation | International Standard.) \nThis annex specifies the hypothetical reference decoder (HRD) and its use to check bitstream and decoder conformance. \nTwo types of bitstreams are subject to HRD conformance checking for this Recommendation | International Standard. The \nfirst such type of bitstream, called Type I bitstream, is a NAL unit stream containing only the VCL NAL units and filler \ndata NAL units for all access units in the bitstream. The second type of bitstream, called a Type II bitstream, contains, in \naddition to the VCL NAL units and filler data NAL units for all access units in the bitstream, at least one of the following: \n–  additional non-VCL NAL units other than filler data NAL units, \n–  all leading_zero_8bits, zero_byte, start_code_prefix_one_3bytes, and trailing_zero_8bits syntax elements that form a \nbyte stream from the NAL unit stream (as specified in Annex B). \nFigure C-1 shows the types of bitstream conformance points checked by the HRD. \nNon-VCL NAL units other\nVCL NAL units than filter data NAL units\nFilter data NAL units\nByte stream format\nencapsulation\n(see Annex B)\nH.264(09)_FC-1  \nFigure C-1 – Structure of byte streams and NAL unit streams for HRD conformance checks \nThe syntax elements of non-VCL NAL units (or their default values for some of the syntax elements), required for the \nHRD, are specified in the semantics subclauses of clause 7, Annexes D and E, and clauses G.7, G.13, G.14, H.7, H.13, \nH.14, I.7, I.13, and I.14. \nTwo types of HRD parameter sets (NAL HRD parameters and VCL HRD parameters) are used. The HRD parameter sets \nare signalled as follows: \n–  When the coded video sequence conforms to one or more of the profiles specified in Annex A and the decoding \nprocess specified in clauses 2 to 9 is applied, the HRD parameter sets are signalled through video usability information \nas specified in clauses E.1 and E.2, which is part of the sequence parameter set syntax structure. \n–  When the coded video sequence conforms to one or more of the profiles specified in Annex G and the decoding \nprocess specified in Annex G is applied, the HRD parameter sets are signalled through the SVC video usability \ninformation extension as specified in clauses G.14.1 and G.14.2, which is part of the subset sequence parameter set \nsyntax structure. \nNOTE 1 – For coded video sequences that conform to both, one or more of the profiles specified in Annex A and one or more of the \nprofiles specified in Annex G, the signalling of the applicable HRD parameter sets is depending on whether the decoding process \nspecified in clauses 2 to 9 or the decoding process specified in Annex G is applied. \n–  When the coded video sequence conforms to one or more of the profiles specified in Annex H and the decoding \nprocess specified in Annex H is applied, the HRD parameter sets are signalled through the MVC video usability \ninformation extension as specified in clauses H.14.1 and H.14.2, which is part of the subset sequence parameter set \nsyntax structure. \n    Rec. ITU-T H.264 (06/2019)  309 \n \nNOTE 2 – For coded video sequences that conform to both, one or more of the profiles specified in Annex A and one or more of the \nprofiles specified in Annex H, the signalling of the applicable HRD parameter sets is depending on whether the decoding process \nspecified in clauses 2 to 9 or the decoding process specified in Annex H is applied. \n–  When the coded video sequence conforms to one or more of the profiles specified in Annex I and the decoding process \nspecified in Annex I is applied, the HRD parameter sets are signalled through the MVC video usability information \nextension as specified in clause I.14, which is part of the subset sequence parameter set syntax structure. \nNOTE 3 – For coded video sequences that conform to one or more of the profiles specified in Annex A, one or more of the profiles \nspecified in Annex H and one or more of the profiles specified in Annex I, the signalling of the applicable HRD parameter sets is \ndependent on whether the decoding process specified in clauses 2-9, the decoding process specified in Annex H, or the decoding \nprocess specified in Annex I is applied. \nAll sequence parameter sets and picture parameter sets referred to in the VCL NAL units, and corresponding buffering \nperiod and picture timing SEI messages shall be conveyed to the HRD, in a timely manner, either in the bitstream (by non-\nVCL NAL units), or by other means not specified in this Recommendation | International Standard. \nIn Annexes C, D, and E and clauses G.12, G.13, G.14, H.12, H.13, H.14, I.13 and I.14 the specification for \"presence\" of \nnon-VCL NAL units is also satisfied when those NAL units (or just some of them) are conveyed to decoders (or to the \nHRD) by other means not specified by this Recommendation | International Standard. For the purpose of counting bits, \nonly the appropriate bits that are actually present in the bitstream are counted. \nNOTE 4 – As an example, synchronization of a non-VCL NAL unit, conveyed by means other than presence in the bitstream, with \nthe NAL units that are present in the bitstream, can be achieved by indicating two points in the bitstream, between which the \nnon-VCL NAL unit would have been present in the bitstream, had the encoder decided to convey it in the bitstream. \nWhen the content of a non-VCL NAL unit is conveyed for the application by some means other than presence within the \nbitstream, the representation of the content of the non-VCL NAL unit is not required to use the same syntax specified in \nthis annex. \nNOTE 5 – When HRD information is contained within the bitstream, it is possible to verify the conformance of a bitstream to the \nrequirements of this clause based solely on information contained in the bitstream. When the HRD information is not present in the \nbitstream, as is the case for all \"stand-alone\" Type I bitstreams, conformance can only be verified when the HRD data is supplied \nby some other means not specified in this Recommendation | International Standard. \nThe HRD contains a coded picture buffer (CPB), an instantaneous decoding process, a decoded picture buffer (DPB), and \noutput cropping as shown in Figure C-2. \n310  Rec. ITU-T H.264 (06/2019) \n \nHypothetical\nstream scheduler\n(HSS)\nType I or Type II bitstream\nCoded picture\nbuffer (CPB)\nAccess units\nDecoding process\n(instantaneous)\nReference Pictures\nfields or frames\nDecoded picture\nbuffer (DPB)\nPictures\nOutput cropping\nOutput cropped pictures\nH.264(13)_FC-2  \nFigure C-2 – HRD buffer model \nThe  CPB  size  (number  of  bits)  is  CpbSize[ SchedSelIdx ].  The  DPB  size  (number  of  frame  buffers)  is \nMax( 1, max_dec_frame_buffering ). When the coded video sequence conforms to one or more of the profiles specified in \nAnnex H and the decoding process specified in Annex H is applied, the DPB size is specified in units of view components. \nWhen the coded video sequence conforms to one or more of the profiles specified in Annex I and the decoding process \nspecified in Annex I is applied, the DPB is operated separately for texture view components and depth view components \nand the terms texture DPB and depth DPB are used, respectively. The texture DPB size is specified in units of texture view \ncomponents and the depth DPB size is specified in units of depth view components. \nThe HRD operates as follows. Data associated with access units that flow into the CPB according to a specified arrival \nschedule are delivered by the HSS. The data associated with each access unit are removed and decoded instantaneously by \nthe instantaneous decoding process at CPB removal times. Each decoded picture is placed in the DPB at its CPB removal \ntime unless it is output at its CPB removal time and is a non-reference picture. When a picture is placed in the DPB it is \nremoved from the DPB at the later of the DPB output time or the time that it is marked as \"unused for reference\". \nFor each picture in the bitstream, the variable OutputFlag for the decoded picture and, when applicable, the reference base \npicture, is set as follows: \n–  If the coded video sequence containing the picture conforms to one or more of the profiles specified in Annex A and \nthe decoding process specified in clauses 2 to 9 is applied, OutputFlag is set equal to 1. \n–  Otherwise, if the coded video sequence containing the picture conforms to one or more of the profiles specified in \nAnnex G and the decoding process specified in Annex G is applied, the following applies: \n–  For a reference base picture, OutputFlag is set equal to 0. \n–  For a decoded picture, OutputFlag is set equal to the value of the output_flag syntax element of the target layer \nrepresentation. \n–  Otherwise, if the coded video sequence containing the picture conforms to one or more of the profiles specified in \nAnnex H and the decoding process specified in Annex H is applied, the following applies: \n–  For the decoded view components of the target output views, OutputFlag is set equal to 1. \n–  For the decoded view components of other views, OutputFlag is set equal to 0. \n–  Otherwise (the coded video sequence containing the picture conforms to one or more of the profiles specified in \nAnnex I and the decoding process specified in Annex I is applied), the following applies: \n    Rec. ITU-T H.264 (06/2019)  311 \n \n–  For the decoded texture view components and corresponding depth view components with the same VOIdx as \nthe target output views, OutputFlag is set equal to 1. \n–  For the decoded texture view components and corresponding depth view components with the same VOIdx as \nother views, OutputFlag is set equal to 0. \nThe operation of the CPB is specified in clause C.1. The instantaneous decoder operation is specified in clauses 2 to 9 (for \ncoded video sequences conforming to one or more of the profiles specified in Annex A) and in Annex G (for coded video \nsequences conforming to one or more of the profiles specified in Annex G) and in Annex H (for coded video sequences \nconforming to one or more of the profiles specified in Annex H) and in Annex I (for coded video sequences conforming \nto one or more of the profiles specified in Annex I). The operation of the DPB is specified in clause C.2. The output \ncropping is specified in clause C.2.2. \nNOTE 6 – Coded video sequences that conform to one or more of the profiles specified in Annex A, and at the same time, one or \nmore of the profiles specified in Annex G can be decoded either by the decoding process specified in clauses 2 to 9 or by the decoding \nprocess specified in Annex G. The decoding result and the HRD operation may be dependent on which of the decoding processes is \napplied. \nNOTE 7 – Coded video sequences that conform to one or more of the profiles specified in Annex A, and at the same time, one or \nmore of the profiles specified in Annex H can be decoded either by the decoding process specified in clauses 2 to 9 or by the decoding \nprocess specified in Annex H. The decoding result and the HRD operation may be dependent on which of the decoding processes is \napplied. \nNOTE 8 – Coded video sequences that conform to one or more of the profiles specified in Annex A, one or more of the profiles \nspecified in Annex H, and one or more of the profiles specified in Annex I, can be decoded either by the decoding process specified \nin clauses 2 to 9, by the decoding process specified in Annex H or by the decoding process specified in Annex I. The decoding result \nand the HRD operation may be dependent on which of the decoding processes is applied. \nHSS and HRD information concerning the number of enumerated delivery schedules and their associated bit rates and \nbuffer sizes is specified in clauses E.1.1, E.1.2, E.2.1, E.2.2, G.14.1, G.14.2, H.14.1, H.14.2 and I.14. The HRD is initialized \nas specified by the buffering period SEI message as specified in clauses D.1.2 and D.2.1. The removal timing of access \nunits from the CPB and output timing from the DPB are specified in the picture timing SEI message as specified in \nclauses D.1.3 and D.2.3. All timing information relating to a specific access unit shall arrive prior to the CPB removal time \nof the access unit. \nWhen the coded video sequence conforms to one or more of the profiles specified in Annex G and the decoding process \nspecified in Annex G is applied, the following is specified: \n(a)  When an access unit contains one or more buffering period SEI messages that are included in scalable nesting \nSEI  messages  and  are  associated  with  values  of  DQId  in  the  range  of  ( ( DQIdMax >> 4) << 4 )  to \n( ( ( DQIdMax >> 4 ) << 4 ) + 15 ), inclusive, the last of these buffering period SEI messages in decoding order \nis  the  buffering  period  SEI  message  that  initializes  the  HRD.  Let  hrdDQId  be  the  largest  value  of \n16 * sei_dependency_id[ i ] + sei_quality_id[ i ]  that  is  associated  with  the  scalable  nesting  SEI  message \ncontaining  the  buffering  period  SEI  message  that  initializes  the  HRD,  let  hrdDId  and  hrdQId  be equal  to \nhrdDQId >> 4 and hrdDQId & 15, respectively, and let hrdTId be the value of sei_temporal_id that is associated \nwith the scalable nesting SEI message containing the buffering period SEI message that initializes the HRD. \n(b)  The picture timing SEI messages that specify the removal timing of access units from the CPB and output timing \nfrom the DPB are the picture timing SEI messages that are included in scalable nesting SEI messages associated \nwith values of sei_dependency_id[ i ], sei_quality_id[ i ], and sei_temporal_id equal to hrdDId, hrdQId, and \nhrdTId, respectively. \n(c)  The HRD parameters that are used for conformance checking are the HRD parameters included in the SVC video \nusability information extension of the active SVC sequence parameter set that are associated with values of \nvui_ext_dependency_id[ i ], vui_ext_quality_id[ i ], and vui_ext_temporal_id[ i ] equal to hrdDId, hrdQId, and \nhrdTId, respectively. For the specification in this annex, num_units_in_tick, time_scale, fixed_frame_rate_flag, \nnal_hrd_parameters_present_flag,  vcl_hrd_parameters_present_flag,  low_delay_hrd_flag,  and \npic_struct_present_flag  are  substituted  with  the  values  of  vui_ext_num_units_in_tick[ i ], \nvui_ext_time_scale[ i ],  vui_ext_fixed_frame_rate_flag[ i ],  vui_ext_nal_hrd_parameters_present_flag[ i ], \nvui_ext_vcl_hrd_parameters_present_flag[ i ],  vui_ext_low_delay_hrd_flag[ i ],  and \nvui_ext_pic_struct_present_flag[ i ], respectively, with i being the value for which vui_ext_dependency_id[ i ], \nvui_ext_quality_id[ i ], and vui_ext_temporal_id[ i ] are equal to hrdDId, hrdQId, and hrdTId, respectively. \nWhen the coded video sequence conforms to one or more of the profiles specified in Annex H and the decoding process \nspecified in Annex H is applied, the following is specified: \n(a)  When an access unit contains one or more buffering period SEI messages that are included in MVC scalable \nnesting SEI messages, the buffering period SEI message that is associated with the operation point being decoded \nis the buffering period SEI message that initializes the HRD. Let hrdVId[ i ] be equal to sei_op_view_id[ i ] for \nall  i  in  the  range  of  0  to  num_view_components_op_minus1,  inclusive,  and  let  hrdTId  be  the  value  of \n312  Rec. ITU-T H.264 (06/2019) \n \nsei_op_temporal_id, that are associated with the MVC scalable nesting SEI message containing the buffering \nperiod SEI message that initializes the HRD. \n(b)  The picture timing SEI messages that specify the removal timing of access units from the CPB and output timing \nfrom the DPB are the picture timing SEI messages that are included in MVC scalable nesting SEI messages \nassociated  with  values  of  sei_op_view_id[ i ]  equal  to  hrdVId[ i ]  for  all  i  in  the  range  of  0  to \nnum_view_components_op_minus1, inclusive, and sei_temporal_id equal to hrdTId. \n(c)  The HRD parameters that are used for conformance checking are the HRD parameters included in the MVC \nvideo usability information extension of the active MVC sequence parameter set that are associated with values \nof  vui_mvc_view_id[ i ][ j ]  for  all  j  in  the  range  of  0  to  vui_mvc_num_target_output_views_minus1[ i ], \ninclusive, equal to hrdVId[ j ], and the value of vui_mvc_temporal_id[ i ] equal to hrdTId. For the specification \nin  this  annex,  num_units_in_tick,  time_scale,  fixed_frame_rate_flag,  nal_hrd_parameters_present_flag, \nvcl_hrd_parameters_present_flag,  low_delay_hrd_flag,  and  pic_struct_present_flag  are  substituted  with  the \nvalues  of  vui_mvc_num_units_in_tick[ i ],  vui_mvc_time_scale[ i ],  vui_mvc_fixed_frame_rate_flag[ i ], \nvui_mvc_nal_hrd_parameters_present_flag[ i ],  vui_mvc_vcl_hrd_parameters_present_flag[ i ], \nvui_mvc_low_delay_hrd_flag[ i ], and vui_mvc_pic_struct_present_flag[ i ], respectively, with i being the value \nfor  which  vui_mvc_view_id[ i ]  is  equal  to  hrdVId[ j ]  for  all  j  in  the  range  of  0  to \nvui_mvc_num_traget_output_views_minus1[ i ], inclusive, and vui_mvc_temporal_id[ i ] equal to hrdTId. \nWhen the coded video sequence conforms to one or more of the profiles specified in Annex I and the decoding process \nspecified in Annex I is applied, the following is specified: \n(a)  When an access unit contains one or more buffering period SEI messages that are included in MVCD scalable \nnesting SEI messages, the buffering period SEI message that is associated with the operation point being decoded \nis the buffering period SEI message that initializes the HRD. Let hrdVId[ i ] be equal to sei_op_view_id[ i ] for \nall  i  in  the  range  of  0  to  num_view_components_op_minus1,  inclusive,  and  let  hrdTId  be  the  value  of \nsei_op_temporal_id, that are associated with the MVCD scalable nesting SEI message containing the buffering \nperiod SEI message that initializes the HRD. \n(b)  The picture timing SEI messages that specify the removal timing of access units from the CPB and output timing \nfrom the DPB are the picture timing SEI messages that are included in MVCD scalable nesting SEI messages \nassociated  with  values  of  sei_op_view_id[ i ]  equal  to  hrdVId[ i ]  for  all  i  in  the  range  of  0  to \nnum_view_components_op_minus1, inclusive, and sei_temporal_id equal to hrdTId. \n(c)  The HRD parameter sets that are used for conformance checking are the HRD parameter sets, included in the \nMVC video usability information extension of the active MVCD sequence parameter set, that are associated with \nvalues of vui_mvc_view_id[ i ][ j ] for all j in the range of 0 to vui_mvc_num_target_output_views_minus1[ i ], \ninclusive, equal to hrdVId[ j ], and the value of vui_mvc_temporal_id[ i ] equal to hrdTId. For the specification \nin  this  annex,  num_units_in_tick,  time_scale,  fixed_frame_rate_flag,  nal_hrd_parameters_present_flag, \nvcl_hrd_parameters_present_flag,  low_delay_hrd_flag,  and  pic_struct_present_flag  are  substituted  with  the \nvalues  of  vui_mvc_num_units_in_tick[ i ],  vui_mvc_time_scale[ i ],  vui_mvc_fixed_frame_rate_flag[ i ], \nvui_mvc_nal_hrd_parameters_present_flag[ i ],  vui_mvc_vcl_hrd_parameters_present_flag[ i ], \nvui_mvc_low_delay_hrd_flag[ i ], and vui_mvc_pic_struct_present_flag[ i ], respectively, with i being the value \nfor  which  vui_mvc_view_id[ i ]  is  equal  to  hrdVId[ j ]  for  all  j  in  the  range  of  0  to \nvui_mvc_num_traget_output_views_minus1[ i ], inclusive, and vui_mvc_temporal_id[ i ] equal to hrdTId. \nThe HRD is used to check conformance of bitstreams and decoders as specified in clauses C.3 and C.4, respectively. \nNOTE 9 – While conformance is guaranteed under the assumption that all frame-rates and clocks used to generate the bitstream \nmatch exactly the values signalled in the bitstream, in a real system each of these may vary from the signalled or specified value. \nAll the arithmetic in this annex is done with real values, so that no rounding errors can propagate. For example, the number \nof bits in a CPB just prior to or after removal of an access unit is not necessarily an integer. \nThe variable t  is derived as follows and is called a clock tick: \nc\nt  = num_units_in_tick ÷ time_scale    (C-1) \nc\nThe following is specified for expressing the constraints in this annex: \n–  Let access unit n be the n-th access unit in decoding order with the first access unit being access unit 0. \n–  Let picture n be the primary coded picture or the decoded primary picture of access unit n. \nC.1  Operation of coded picture buffer (CPB) \nThe specifications in this clause apply independently to each set of CPB parameters that is present and to both the Type I \nand Type II conformance points shown in Figure C-1. \n    Rec. ITU-T H.264 (06/2019)  313 \n \nC.1.1  Timing of bitstream arrival \nThe HRD may be initialized at any one of the buffering period SEI messages. Prior to initialization, the CPB is empty. \nNOTE – After initialization, the HRD is not initialized again by subsequent buffering period SEI messages. \nEach access unit is referred to as access unit n, where the number n identifies the particular access unit. The access unit \nthat is associated with the buffering period SEI message that initializes the CPB is referred to as access unit 0. The value \nof n is incremented by 1 for each subsequent access unit in decoding order. \nThe time at which the first bit of access unit n begins to enter the CPB is referred to as the initial arrival time t ( n ). \nai\nThe initial arrival time of access units is derived as follows: \n–  If the access unit is access unit 0, t ( 0 ) = 0, \nai\n–  Otherwise (the access unit is access unit n with n > 0), the following applies: \n–  If cbr_flag[ SchedSelIdx ] is equal to 1, the initial arrival time for access unit n, is equal to the final arrival time \n(which is derived below) of access unit n − 1, i.e., \nt ( n ) = t ( n − 1 )    (C-2) \nai af\n–  Otherwise (cbr_flag[ SchedSelIdx ] is equal to 0), the initial arrival time for access unit n is derived by \nt ( n ) = Max( t ( n − 1 ), t ( n ) )    (C-3) \nai af ai,earliest\nwhere t ( n ) is derived as follows: \nai,earliest\n–  If access unit n is not the first access unit of a subsequent buffering period, t ( n ) is derived as \nai,earliest\nt ( n ) = t ( n ) − ( initial_cpb_removal_delay[ SchedSelIdx ] + \nai,earliest r,n\n                                       initial_cpb_removal_delay_offset[ SchedSelIdx ] ) ÷ 90000  (C-4) \nwith t ( n ) being the nominal removal time of access unit n from the CPB as specified in clause C.1.2 and \nr,n\ninitial_cpb_removal_delay[ SchedSelIdx ]  and  initial_cpb_removal_delay_offset[ SchedSelIdx ]  being \nspecified in the previous buffering period SEI message. \n–  Otherwise (access unit n is the first access unit of a subsequent buffering period), t ( n ) is derived as \nai,earliest\nt ( n ) = t ( n ) − ( initial_cpb_removal_delay[ SchedSelIdx ] ÷ 90000 )  (C-5) \nai,earliest r,n\nwith  initial_cpb_removal_delay[ SchedSelIdx ]  being  specified  in  the  buffering  period  SEI  message \nassociated with access unit n. \nThe final arrival time for access unit n is derived by \nt ( n ) = t ( n ) + b( n ) ÷ BitRate[ SchedSelIdx ]    (C-6) \naf ai\nwhere b( n ) is the size in bits of access unit n, counting the bits of the VCL NAL units and the filler data NAL units for \nthe Type I conformance point or all bits of the Type II bitstream for the Type II conformance point, where the Type I and \nType II conformance points are as shown in Figure C-1. \nThe values of SchedSelIdx, BitRate[ SchedSelIdx ], and CpbSize[ SchedSelIdx ] are constrained as follows: \n–  If the content of the active sequence parameter sets for access unit n and access unit n − 1 differ, the HSS selects a \nvalue SchedSelIdx1 of SchedSelIdx from among the values of SchedSelIdx provided in the active sequence parameter \nset for access unit n that results in a BitRate[ SchedSelIdx1 ] or CpbSize[ SchedSelIdx1 ] for access unit n. The value \nof BitRate[ SchedSelIdx1 ] or CpbSize[ SchedSelIdx1 ] may differ from the value of BitRate[ SchedSelIdx0 ] or \nCpbSize[ SchedSelIdx0 ] for the value SchedSelIdx0 of SchedSelIdx that was in use for access unit n − 1. \n–  Otherwise, the HSS continues to operate  with the previous  values of  SchedSelIdx,  BitRate[ SchedSelIdx ] and \nCpbSize[ SchedSelIdx ]. \nWhen the HSS selects values of BitRate[ SchedSelIdx ] or CpbSize[ SchedSelIdx ] that differ from those of the previous \naccess unit, the following applies: \n–  the variable BitRate[ SchedSelIdx ] comes into effect at time t ( n ) \nai\n–  the variable CpbSize[ SchedSelIdx ] comes into effect as follows: \n314  Rec. ITU-T H.264 (06/2019) \n \n–  If the new value of CpbSize[ SchedSelIdx ] exceeds the old CPB size, it comes into effect at time t ( n ), \nai\n–  Otherwise, the new value of CpbSize[ SchedSelIdx ] comes into effect at the time t ( n ). \nr\nC.1.2  Timing of coded picture removal \nWhen an access unit n is the access unit with n equal to 0 (the access unit that initializes the HRD), the nominal removal \ntime of the access unit from the CPB is specified by \nt ( 0 ) = initial_cpb_removal_delay[ SchedSelIdx ] ÷ 90000  (C-7) \nr,n\nWhen an access unit n is the first access unit of a buffering period that does not initialize the HRD, the nominal removal \ntime of the access unit from the CPB is specified by \nt ( n ) = t ( n  ) + t  * cpb_removal_delay( n )    (C-8) \nr,n r,n b c\nwhere  t ( n  )  is  the  nominal  removal  time  of  the  first  access  unit  of  the  previous  buffering  period  and \nr,n b\ncpb_removal_delay( n ) is the value of cpb_removal_delay specified in the picture timing SEI message associated with \naccess unit n. \nThe nominal removal time t (n) of an access unit n that is not the first access unit of a buffering period is given by \nr,n\nt ( n ) = t ( n  ) + t  * cpb_removal_delay( n )    (C-9) \nr,n r,n b c\nwhere  t ( n  )  is  the  nominal  removal  time  of  the  first  access  unit  of  the  current  buffering  period  and \nr,n b\ncpb_removal_delay( n ) is the value of cpb_removal_delay specified in the picture timing SEI message associated with \naccess unit n. \nThe removal time of access unit n is specified as follows: \n–  If low_delay_hrd_flag is equal to 0 or t ( n ) >= t ( n ), the removal time of access unit n is specified by \nr,n af\nt ( n ) = t ( n )    (C-10) \nr r,n\n–  Otherwise (low_delay_hrd_flag is equal to 1 and t ( n ) < t ( n )), the removal time of access unit n is specified by \nr,n af\nt ( n ) = t ( n ) + t  * Ceil( ( t ( n ) − t ( n ) ) ÷t  )    (C-11) \nr r,n c af r,n c\nNOTE – The latter case indicates that the size of access unit n, b( n ), is so large that it prevents removal at the nominal removal \ntime. \nWhen an access unit n is the first access unit of a buffering period, n  is set equal to n at the removal time t ( n ) of the \nb r\naccess unit n. \nC.2  Operation of the decoded picture buffer (DPB) \nThe decoded picture buffer contains frame buffers. When a coded video sequence conforming to one or more of the profiles \nspecified in Annex A is decoded by applying the decoding process specified in clauses 2 to 9, each of the frame buffers \nmay contain a decoded frame, a decoded complementary field pair or a single (non-paired) decoded field that is marked as \n\"used for reference\" (reference pictures) or is held for future output (reordered or delayed pictures). When a coded video \nsequence conforming to one or more of the profiles specified in Annex G is decoded by applying the decoding process \nspecified in Annex G, each frame buffer may contain a decoded frame, a decoded complementary field pair, a single (non-\npaired) decoded field, a decoded reference base frame, a decoded reference base complementary field pair or a single (non-\npaired) decoded reference base field that is marked as \"used for reference\" (reference pictures) or is held for future output \n(reordered or delayed pictures). When a coded video sequence conforming to one or more of the profiles specified in \nAnnex H is decoded by applying the decoding process specified in Annex H, each of the frame buffers may contain a \ndecoded frame view component, a decoded complementary field view component pair, or a single (non-paired) decoded \nfield view component that is marked as \"used for reference\" (reference pictures) or is held for future output (reordered or \ndelayed pictures) or is held as reference for inter-view prediction (inter-view only reference components). When a coded \nvideo sequence conforming to one or more of the profiles specified in Annex I is decoded by applying the decoding process \nspecified in Annex I, each of the frame buffers of the texture DPB may contain: a decoded depth frame view component, \na  decoded  complementary  texture  field  view  component  pair,  or  a  single  (non-paired)  decoded  texture  field  view \ncomponent that is marked as \"used for reference\" (reference pictures) or is held for future output (reordered or delayed \npictures) or is held as reference for inter-view prediction (inter-view only reference components). When a coded video \nsequence conforming to one or more of the profiles specified in Annex I is decoded by applying the decoding process \nspecified in Annex I, each of the frame buffers of the depth DPB may contain a decoded depth frame view component, a \ndecoded complementary depth field view component pair, or a single (non-paired) decoded depth field view component \n    Rec. ITU-T H.264 (06/2019)  315 \n \nthat is marked as \"used for reference\" (reference pictures) or is held for future output (reordered or delayed pictures) or is \nheld as reference for inter-view prediction (inter-view only reference components). \nPrior to initialization, the DPB is empty (the DPB fullness is set to zero). The following steps specified in this clause all \nhappen instantaneously at t ( n ) and in the order listed. When the decoding process specified in Annex H or Annex I is \nr\napplied, the view components of the current primary coded picture are processed by applying the ordered steps to each \nview component in increasing order of the associated view order index VOIdx. During the invocation of the process for a \nparticular texture view, only the texture view components of the particular view are considered. During the invocation of \nthe process for a particular depth view, only the depth view components of the particular view are considered. For each \nview component of the current primary coded picture, the corresponding depth view component with the same view order \nindex VOIdx, if present, is processed after the texture view component. \n1.  The process of decoding gaps in frame_num and storing \"non-existing\" frames as specified in clause C.2.1 is \ninvoked. \n2.  The picture decoding and output process as specified in clause C.2.2 is invoked. \n3.  The process of removing pictures from the DPB before possible insertion of the current picture as specified in \nclause C.2.3 is invoked. \n4.  The process of marking and storing the current decoded picture as specified in clause C.2.4 is invoked. \nNOTE – When the decoding process specified in Annex G is applied, the DPB is only operated for decoded pictures and \nreference base pictures associated with decoded pictures. The DPB is not operated for layer pictures with dependency_id less \nthan DependencyIdMax (and associated reference base pictures). All decoded pictures and associated reference base pictures are \ndecoded pictures and associated reference base pictures for dependency_id equal to DependencyIdMax, which represent the \nresults of the decoding process specified in clause G.8. \nC.2.1  Decoding of gaps in frame_num and storage of \"non-existing\" frames \nWhen the decoding process specified in Annex H is applied, the process specified in this clause is invoked for a particular \nview with view order index VOIdx, with \"picture\" being replaced by \"view component\", \"frame\" being replaced by \"frame \nview component\", and \"field\" being replaced by \"field view component\". During the invocation of the process for a \nparticular view, only view components of the particular view are considered and view components of other views are not \nmarked as \"unused for reference\" or removed from the DPB. When the decoding process specified in Annex I is applied, \nthe process specified in this clause for Annex H is invoked for particular texture view or depth view with view order index \nVOIdx, with each \"view component\" being replaced by \"texture view component\" or \"depth view component\", \"frame \nview component\" being replaced by \"texture frame view component\" or \"depth frame view component\", and \"field view \ncomponent\" being replaced by \"texture field view component\". During the invocation of the process for a particular texture \nview, only the texture view components of the particular view are considered and during the invocation of the process for \na particular depth view, only the depth view components of the particular view are considered and view components of \nother views are not marked as \"unused for reference\" or removed from the DPB. \nThe DPB fullness represents the total number of non-empty frame buffers. When the decoding process specified in \nAnnex H is applied; this includes frame buffers that contain view components of other views. When the decoding process \nspecified in Annex I is applied, this includes frame buffers that contain texture or depth view components of other views. \nWhen applicable, gaps in frame_num are detected by the decoding process and the generated frames are marked and \ninserted into the DPB as specified below. \nGaps  in  frame_num  are  detected  by  the  decoding  process  and  the  generated  frames  are  marked  as  specified  in \nclauses 8.2.5.2 and G.8.2.5. \nAfter the marking of each generated frame, each picture m marked by the \"sliding window\" process as \"unused for \nreference\" is removed from the DPB when it is also marked as \"non-existing\" or its DPB output time is less than or equal \nto the CPB removal time of the current picture n; i.e., t ( m ) <= t ( n ), or it has OutputFlag equal to 0. When a frame or \no,dpb r\nthe last field in a frame buffer is removed from the DPB, the DPB fullness is decremented by one. The \"non-existing\" \ngenerated frame is inserted into the DPB and the DPB fullness is incremented by one. \nC.2.2  Picture decoding and output \nWhen the decoding process specified in Annex H is applied, the process specified in this clause is invoked for a particular \nview with view order index VOIdx. \nWhen the decoding process specified in Annex I is applied, the process specified in this clause is invoked for a particular \ntexture view or depth view with view order index VOIdx. \nThe decoding of the current picture or view component (when applying the decoding process specified in Annex H or \nAnnex I) and the derivation of the DPB output time (if applicable) is specified as follows: \n–  If the decoding process specified in clause 8 or Annex G is applied, the following applies: \n316  Rec. ITU-T H.264 (06/2019) \n \n–  The current primary coded picture n is decoded. \n–  When picture n has OutputFlag equal to 1, its DPB output time t ( n ) is derived by \no,dpb\nt ( n ) = t ( n ) + t  * dpb_output_delay( n )   (C-12) \no,dpb r c\nwhere dpb_output_delay( n ) is the value of dpb_output_delay specified in the picture timing SEI message \nassociated with access unit n. \n–  Otherwise (the decoding process specified in Annex H or Annex I is applied), the following applies: \n–  The view component with view order index VOIdx of the current primary coded picture n is decoded. \n–  When VOIdx is equal to VOIdxMin and any of the view components of picture n has OutputFlag equal to 1, the \nDPB output time t ( n ) for picture n is derived by Equation C-12, where dpb_output_delay( n ) is the value \no,dpb\nof dpb_output_delay specified in the picture timing SEI message associated with access unit n. \nThe output of the current picture or view component (when applying the decoding process specified in Annex H) is \nspecified as follows: \n–  If OutputFlag is equal to 1 and t ( n ) = t ( n ), the current picture or view component is output. \no,dpb r\nNOTE 1 – When the current picture or view component has nal_ref_idc greater than 0 (when using the decoding process \nspecified in Annex G, nal_ref_idc is the syntax element of the target layer representation), it will be stored in the DPB. \n–  Otherwise, if OutputFlag is equal to 0, the current picture or view component is not output, but it may be stored in the \nDPB as specified in clause C.2.4. \n–  Otherwise (OutputFlag is equal to 1 and t ( n ) > t ( n ) ), the current picture or view component is output later and \no,dpb r\nwill be stored in the DPB (as specified in clause C.2.4) and is output at time t ( n ) unless indicated not to be output \no,dpb\nby the decoding or inference of no_output_of_prior_pics_flag equal to 1 at a time that precedes t ( n ). \no,dpb\nNOTE 2 – When the coded video sequence conforms to a profile specified in Annex H and the decoding process specified in \nAnnex H is used, the view components of all the target output views of a picture are output at the same time instant and in \nincreasing order of the view order index VOIdx. \nNOTE 3 – When the coded video sequence conforms to a profile specified in Annex I and the decoding process specified in \nAnnex I is used, the view components of all the target output views of a picture are output at the same time instant and in \nincreasing order of the view order index VOIdx. A depth view component, if present, follows the texture view component \nwithin the same view component. \nWhen output, the picture or view component shall be cropped, using the cropping rectangle specified in the active sequence \nparameter set for the picture or view component. \nWhen the decoding process specified in clause 8 or Annex G is applied, the current picture n is a picture that is output and \nis not the last picture of the bitstream that is output, the value of t ( n ) is derived by \no,dpb\nt ( n ) = t ( n  ) − t ( n )    (C-13) \no,dpb o,dpb n o,dpb\nwhere n  indicates the picture that follows after picture n in output order and has OutputFlag equal to 1. \nn\nWhen the decoding process specified in Annex H or Annex I is applied, the current picture n is a picture that contains at \nleast one view component that is output and the current picture is not the last picture of the bitstream that contains at least \none view component that is output and VOIdx is equal to VOIdxMin, the value of t ( n ) is derived by Equation C-13, \no,dpb\nwhere n  indicates the picture that follows after picture n in output order and contains at least one any view component \nn\nwith OutputFlag equal to 1. \nThe decoded picture or view component is temporarily stored (not in the DPB). \nC.2.3  Removal of pictures from the DPB before possible insertion of the current picture \nWhen the decoding process specified in Annex H is applied, the process specified in this clause is invoked for a particular \nview with view order index VOIdx, with \"picture\" being replaced by \"view component\", \"frame\" being replaced by \"frame \nview component\", and \"field\" being replaced by \"field view component\". \nWhen the decoding process specified in Annex I is applied, the process specified in this clause for Annex I is invoked for \nparticular texture view and depth view with view order index VOIdx, with each \"view component\" being replaced by \n\"texture view component\" or \"depth view component\", \"frame view component\" being replaced by \"texture frame view \ncomponent\"  or  \"depth  frame  view  component\",  and  \"field  view  component\"  being  replaced  by  \"texture  field  view \ncomponent\". During the invocation of the process for a particular texture view, only the texture view components of the \nparticular view are considered and during the invocation of the process for a particular depth view, only the depth view \ncomponents of the particular view are considered. \n    Rec. ITU-T H.264 (06/2019)  317 \n \nWhen the decoding process specified in Annex H or Annex I is applied, the following process is specified for removing \ninter-view only reference components of the current access unit from the DPB. By this process, view components of the \ncurrent view with view order index VOIdx are not removed from the DPB, but inter-view only reference components of \nother views may be removed. The removal of inter-view only reference components is specified as follows: \n–  If the view order index VOIdx of the current view is equal to VOIdxMax, all inter-view only reference components \nm for which any of the following conditions are true are removed from the DPB: \n–  OutputFlag is equal to 0, \n–  The DPB output time t ( m ) of the picture containing the view component m is less than or equal to the CPB \no,dpb\nremoval time t ( n ) of the current picture. \nr\n–  Otherwise (the view order index VOIdx of the current view is less than VOIdxMax), all inter-view only reference \ncomponents m for which both of the following conditions are true are removed from the DPB: \n–  OutputFlag is equal to 0 or the DPB output time t ( m ) of the picture containing the view component m is \no,dpb\nless than or equal to the CPB removal time t ( n ) of the current picture, \nr\n–  One of the following conditions is true: \n–  The current view component is a view component of an anchor picture and the view_id of the inter-view \nonly reference component m is not equal to any value of anchor_ref_lX[ k ][ j ], with X being equal to 0 \nor 1, k being any integer value greater than the view order index VOIdx of the current view, and j being any \ninteger value in the range of 0 to Max( 0, num_anchor_refs_lX[ k ] − 1 ), inclusive, \n–  The current view component is not a view component of an anchor picture and the view_id of the inter-view \nonly reference component m is not equal to any value of non_anchor_ref_lX[ k ][ j ], with X being equal \nto 0 or 1, k being any integer value greater than the view order index VOIdx of the current view, and j being \nany integer value in the range of 0 to Max( 0, num_non_anchor_refs_lX[ k ] − 1 ), inclusive. \nWhen the decoding process specified in Annex H is applied, for the following processes specified in this clause, only view \ncomponents of the particular view for which this clause is invoked are considered, and view components of other views \nare not marked as \"unused for reference\" or removed from the DPB. When the decoding process specified in Annex I is \napplied, for the following processes specified for Annex I in this clause, during the invocation of the process for a particular \ntexture view, only texture view components of the particular texture view are considered and during the invocation of the \nprocess for a particular depth view, only depth view components of the particular depth view are considered, and view \ncomponents of other views are not marked as \"unused for reference\" or removed from the DPB. \nThe DPB fullness represents the total number of non-empty frame buffers. When the decoding process specified in \nAnnex H is applied, this includes frame buffers that contain texture view components of other views. When the decoding \nprocess specified in Annex I is applied, this includes frame buffers that contain texture or depth view components of other \nviews. \nThe removal of pictures from the DPB before possible insertion of the current picture proceeds as follows: \n–  If the decoded picture is an IDR picture the following applies: \n1.  All reference pictures in the DPB are marked as \"unused for reference\" as specified in clause 8.2.5.1 when a coded \nvideo sequence conforming to one or more of the profiles specified in Annex A is decoded by applying the \ndecoding process specified in clauses 2 to 9, or as specified in clause G.8.2.4 when a coded video sequence \nconforming to one or more of the profiles specified in Annex G is decoded by applying the decoding process \nspecified in Annex G, or as specified in clause H.8.3 when a coded video sequence conforming to one or more of \nthe profiles specified in Annex H is decoded by applying the decoding process specified in Annex H, or as \nspecified in clause I.8.3 when a coded video sequence conforming to one or more of the profiles specified in \nAnnex I is decoded by applying the decoding process specified in Annex I. \n2.  When the IDR picture is not the first IDR picture decoded and the value of PicWidthInMbs or FrameHeightInMbs \nor max_dec_frame_buffering derived from the active sequence parameter set is different from the value of \nPicWidthInMbs or FrameHeightInMbs or max_dec_frame_buffering derived from the sequence parameter set \nthat was active for the preceding picture, respectively, no_output_of_prior_pics_flag is inferred to be equal to 1 \nby the HRD, regardless of the actual value of no_output_of_prior_pics_flag. \nNOTE – Decoder implementations should try to handle frame or DPB size changes more gracefully than the HRD in \nregard to changes in PicWidthInMbs or FrameHeightInMbs. \n3.  When no_output_of_prior_pics_flag is equal to 1 or is inferred to be equal to 1, all frame buffers in the DPB are \nemptied without output of the pictures they contain, and DPB fullness is set to 0. \n–  Otherwise (the decoded picture is not an IDR picture), the following applies: \n318  Rec. ITU-T H.264 (06/2019) \n \n–  If  the  slice  header  of  the  current  picture  includes  memory_management_control_operation  equal  to  5,  all \nreference pictures in the DPB are marked as \"unused for reference\". \n–  Otherwise (the slice header of the current picture does not include memory_management_control_operation \nequal to 5), the decoded reference picture marking process specified in clause 8.2.5 is invoked when a coded \nvideo sequence conforming to one or more of the profiles specified in Annex A is decoded by applying the \ndecoding process specified in clauses 2 to 9, or the decoded reference picture marking process specified in \nclause G.8.2.4 is invoked when a coded video sequence conforming to one or more of the profiles specified in \nAnnex G is decoded by applying the decoding process specified in Annex G, or the decoded reference picture \nmarking process specified in clause H.8.3 is invoked when a coded video sequence conforming to one or more \nof the profiles specified in Annex H is decoded by applying the decoding process specified in Annex H, or the \ndecoded reference picture marking process specified in clause I.8.3 is invoked when a coded video sequence \nconforming to one or more of the profiles specified in Annex I is decoded by applying the decoding process \nspecified in Annex I. \nAll pictures m in the DPB, for which all of the following conditions are true, are removed from the DPB: \n–  picture m is marked as \"unused for reference\" or picture m is a non-reference picture. When a picture is a reference \nframe, it is considered to be marked as \"unused for reference\" only when both of its fields have been marked as \n\"unused for reference\", \n–  picture m is marked as \"non-existing\" or it has OutputFlag equal to 0 or its DPB output time t ( m ) is less than or \no,dpb\nequal to the CPB removal time t ( n ) of the current picture n. \nr\nWhen a frame or the last field in a frame buffer is removed from the DPB, the DPB fullness is decremented by one. \nC.2.4  Current decoded picture marking and storage \nWhen the decoding process specified in Annex H is applied, the process specified in this clause is invoked for a particular \nview with view order index VOIdx, with \"picture\" being replaced by \"view component\", \"frame\" being replaced by \"frame \nview component\", and \"field\" being replaced by \"field view component\". When the decoding process specified in Annex I \nis applied, the process specified in this clause for Annex I is invoked for particular texture view and depth view with view \norder  index  VOIdx,  with  each  \"view  component\"  being  replaced  by  \"texture  view  component\"  and  \"depth  view \ncomponent\",  \"frame  view  component\"  being  replaced  by  \"texture  frame  view  component\"  and  \"depth  frame  view \ncomponent\", and \"field view component\" being replaced by \"texture field view component\". In clause C.2.4.2, the DPB \noutput time t (n) and the CPB removal time t (n) of a view component are the DPB output time and the CPB removal \no,dpb r\ntime of the picture n containing the view component. \nThe marking and storage of the current decoded picture is specified as follows: \n–  If the current picture is a reference picture, the marking and storage process for reference pictures as specified in \nclause C.2.4.1 is invoked. \n–  Otherwise (the current picture is a non-reference picture), the storage process for non-reference pictures as specified \nin clause C.2.4.2 is invoked. \nC.2.4.1  Marking and storage of a reference picture into the DPB \nThe current picture is stored in the DPB as follows: \n–  If the current decoded picture is a second field (in decoding order) of a complementary reference field pair, and the \nfirst field of the pair is still in the DPB, the current decoded picture is stored in the same frame buffer as the first field \nof the pair. \n–  Otherwise, the current decoded picture is stored in an empty frame buffer, and the DPB fullness is incremented by \none. \nWhen the coded video sequence conforms to one or more of the profiles specified in Annex G and the decoding process \nspecified in Annex G is applied and the current picture has store_ref_base_pic_flag equal to 1 (i.e., the current picture is \nassociated with a reference base picture), the associated reference base picture is stored in the DPB as follows: \n–  If the reference base picture is a second field (in decoding order) of a complementary reference base field pair, and \nthe first field of the pair is still in the DPB, the reference base picture is stored in the same frame buffer as the first \nfield of the pair. \n–  Otherwise, the reference base picture is stored in an empty frame buffer, and the DPB fullness is incremented by one. \nC.2.4.2  Storage of a non-reference picture into the DPB \nThe variable storePicFlag is derived as follows: \n    Rec. ITU-T H.264 (06/2019)  319 \n \n–  If any of the following conditions are true, storePicFlag is set equal to 1: \n–  the current picture n has OutputFlag equal to 1 and t (n) > t (n), \no,dpb r\n–  the decoding process specified in Annex H or Annex I is used and the current view component has a view order \nindex VOIdx less than VOIdxMax and inter_view_flag equal to 1. \n–  Otherwise, storePicFlag is set equal to 0. \nWhen storePicFlag is equal to 1, the current picture is stored in the DPB as follows: \n–  If the current decoded picture is a second field (in decoding order) of a complementary non-reference field pair, and \nthe first field of the pair is still in the DPB, the current decoded picture is stored in the same frame buffer as the first \nfield of the pair. \n–  Otherwise, the current decoded picture is stored in an empty frame buffer, and the DPB fullness is incremented by \none. \nC.3  Bitstream conformance \nA bitstream of coded data conforming to this Recommendation | International Standard fulfils the following requirements. \nThe  bitstream  is  constructed  according  to  the  syntax,  semantics,  and  constraints  specified  in  this \nRecommendation | International Standard outside of this annex. \nThe bitstream is tested by the HRD as specified below: \nFor Type I bitstreams, the number of tests carried out is equal to cpb_cnt_minus1 + 1 where cpb_cnt_minus1 is either the \nsyntax element of hrd_parameters( ) following the vcl_hrd_parameters_present_flag or is determined by the application \nby other means not specified in this Recommendation | International Standard. One test is carried out for each bit rate and \nCPB size combination specified by hrd_parameters( ) following the vcl_hrd_parameters_present_flag. Each of these tests \nis conducted at the Type I conformance point shown in Figure C-1. \nFor Type II bitstreams there are two sets of tests. The number of tests of the first set is equal to cpb_cnt_minus1 + 1 where \ncpb_cnt_minus1 is either the syntax element of hrd_parameters( ) following the vcl_hrd_parameters_present_flag or is \ndetermined by the application by other means not specified in this Recommendation | International Standard. One test is \ncarried out for each bit rate and CPB size combination. Each of these tests is conducted at the Type I conformance point \nshown in Figure C-1. For these tests, only VCL and filler data NAL units are counted for the input bit rate and CPB storage. \nThe number of tests of the second set, for Type II bitstreams, is equal to cpb_cnt_minus1 + 1 where cpb_cnt_minus1 is \neither the syntax element of hrd_parameters( ) following the nal_hrd_parameters_present_flag or is determined by the \napplication by other means not specified in this Recommendation | International Standard. One test is carried out for each \nbit rate and CPB size combination specified by hrd_parameters( ) following the nal_hrd_parameters_present_flag. Each of \nthese tests is conducted at the Type II conformance point shown in Figure C-1. For these tests, all NAL units (of a Type II \nNAL unit stream) or all bytes (of a byte stream) are counted for the input bit rate and CPB storage. \nNOTE 1 – NAL HRD parameters established by a value of SchedSelIdx for the Type II conformance point shown in Figure C-1 are \nsufficient to also establish VCL HRD conformance for the Type I conformance point shown in Figure C-1 for the same values of \ninitial_cpb_removal_delay[ SchedSelIdx ],  BitRate[ SchedSelIdx ],  and  CpbSize[ SchedSelIdx ]  for  the  VBR  case \n(cbr_flag[ SchedSelIdx ] equal to 0). This is because the data flow into the Type I conformance point is a subset of the data flow \ninto the Type II conformance point and because, for the VBR case, the CPB is allowed to become empty and stay empty until the \ntime a next picture is scheduled to begin to arrive. For example, when a coded video sequence conforming to one or more of the \nprofiles specified in Annex A is decoded by applying the decoding process specified in clauses 2 to 9, when NAL HRD parameters \nare provided for the Type II conformance point that not only fall within the bounds set for NAL HRD parameters for profile \nconformance in item j) of clause A.3.1 or item h) of clause A.3.3 (depending on the profile in use) but also fall within the bounds \nset for VCL HRD parameters for profile conformance in item i) of clause A.3.1 or item g) of clause A.3.3 (depending on the profile \nin use), conformance of the VCL HRD for the Type I conformance point is also assured to fall within the bounds of item i) of \nclause A.3.1. \nFor conforming bitstreams, all of the following conditions shall be fulfilled for each of the tests: \n1.  For each access unit n, with n>0, associated with a buffering period SEI message, with t ( n ) specified by \ng,90\nt ( n ) = 90000 * ( t ( n ) − t ( n − 1 ) )    (C-14) \ng,90 r,n af\nthe value of initial_cpb_removal_delay[ SchedSelIdx ] shall be constrained as follows: \n–  If cbr_flag[ SchedSelIdx ] is equal to 0, \ninitial_cpb_removal_delay[ SchedSelIdx ] <= Ceil( t ( n ) )  (C-15) \ng,90\n320  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (cbr_flag[ SchedSelIdx ] is equal to 1), \nFloor( t ( n ) ) <= initial_cpb_removal_delay[ SchedSelIdx ] <= Ceil( t ( n ) )  (C-16) \ng,90 g,90\nNOTE 2 – The exact number of bits in the CPB at the removal time of each picture may depend on which buffering \nperiod SEI message is selected to initialize the HRD. Encoders must take this into account to ensure that all specified \nconstraints must be obeyed regardless of which buffering period SEI message is selected to initialize the HRD, as the \nHRD may be initialized at any one of the buffering period SEI messages. \n2.  A CPB overflow is specified as the condition in which the total number of bits in the CPB is larger than the CPB \nsize. The CPB shall never overflow. \n3.  A CPB underflow is specified as the condition in which t ( n ) is less than t ( n ). When low_delay_hrd_flag is \nr,n af\nequal to 0, the CPB shall never underflow. \n4.  The nominal removal times of pictures from the CPB (starting from the second picture in decoding order), shall \nsatisfy the constraints on t ( n ) and t ( n ) expressed in clauses A.3.1 through A.3.3 for the profile and level \nr,n r\nspecified in the bitstream when a coded video sequence conforming to one or more of the profiles specified in",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "A",
          "A"
        ],
        [
          "N",
          3
        ],
        [
          "N",
          5
        ]
      ],
      "type": "AlphaNumeric"
    },
    {
      "section_title": "Annex A is decoded by applying the decoding process specified in clauses 2 to 9, and they shall satisfy the",
      "section_text": "constraints on t ( n ) and t ( n ) expressed in clauses G.10.2.1 and G.10.2.2 for profile and level specified in the \nr,n r\nbitstream when a coded video sequence conforming to one or more of the profiles specified in Annex G is decoded \nby applying the decoding process specified in Annex G, and they shall satisfy the constraints on t ( n ) and t ( n ) \nr,n r\nexpressed in clause H.10.2 for the profile and level specified in the bitstream when a coded video sequence \nconforming to one or more of the profiles specified in Annex H is decoded by applying the decoding process \nspecified in Annex H, and they shall satisfy the constraints on t ( n ) and t ( n ) expressed in clause I.10.2 for the \nr,n r\nprofile and level specified in the bitstream when a coded video sequence conforming to one or more of the profiles \nspecified in Annex I is decoded by applying the decoding process specified in Annex I. \n5.  Immediately after any decoded picture is added to the DPB, the fullness of the DPB shall be less than or equal to \nthe DPB size as constrained by Annexes A, D, and E and clauses G.10, G.13, G.14, H.10, H.13, H.14, and I.14 for \nthe profile and level specified in the bitstream. \n6.  All reference pictures shall be present in the DPB when needed for prediction. Each picture shall be present in the \nDPB at its DPB output time unless it is not stored in the DPB at all, or is removed from the DPB before its output \ntime by one of the processes specified in clause C.2. \n7.  The value of  ( n ) as given by Equation C-13, which is the difference between the output time of a picture and \nto,dpb\nthat of the first picture following it in output order and having OutputFlag equal to 1, shall satisfy the constraint \nexpressed  in  clause A.3.1  for  the  profile  and  level  specified  in  the  bitstream  when  a  coded  video  sequence \nconforming to one or more of the profiles specified in Annex A is decoded by applying the decoding process \nspecified in clauses 2 to 9, and it shall satisfy the constraint expressed in clause G.10.2.1 for profile and level \nspecified in the bitstream when a coded video sequence conforming to one or more of the profiles specified in \nAnnex G is decoded by applying the decoding process specified in Annex G, and it shall satisfy the constraints \nexpressed in clause H.10.2 for the profile and level specified in the bitstream when a coded video sequence \nconforming to one or more of the profiles specified in Annex H is decoded by applying the decoding process \nspecified in Annex H, and it shall satisfy the constraints expressed in clause I.10.2 for the profile and level specified \nin the bitstream when a coded video sequence conforming to one or more of the profiles specified in Annex I is \ndecoded by applying the decoding process specified in Annex I. \nC.4  Decoder conformance \nA decoder conforming to this Recommendation | International Standard fulfils the following requirements. \nA decoder claiming conformance to a specific profile and level shall be able to decode successfully all conforming \nbitstreams  specified  for  decoder  conformance  in  clause C.3,  provided  that  all  sequence  parameter  sets  and  picture \nparameter sets referred to in the VCL NAL units, and appropriate buffering period and picture timing SEI messages are \nconveyed to the decoder, in a timely manner, either in the bitstream (by non-VCL NAL units), or by external means not \nspecified by this Recommendation | International Standard. \nThere are two types of conformance that can be claimed by a decoder: output timing conformance and output order \nconformance. \nTo check conformance of a decoder, test bitstreams conforming to the claimed profile and level, as specified in clause C.3 \nare delivered by a hypothetical stream scheduler (HSS) both to the HRD and to the decoder under test (DUT). All pictures \noutput by the HRD shall also be output by the DUT and, for each picture output by the HRD, the values of all samples that \nare output by the DUT for the corresponding picture shall be equal to the values of the samples output by the HRD. \n    Rec. ITU-T H.264 (06/2019)  321 \n \nFor output timing decoder conformance, the HSS operates as described above, with delivery schedules selected only from \nthe subset of values of SchedSelIdx for which the bit rate and CPB size are restricted as specified in Annex A, Annex G, \nAnnex H, and Annex I for the specified profile and level, or with \"interpolated\" delivery schedules as specified below for \nwhich the bit rate and CPB size are restricted as specified in Annex A, Annex G, Annex H, and Annex I. The same delivery \nschedule is used for both the HRD and DUT. \nWhen the HRD parameters and the buffering period SEI messages are present with cpb_cnt_minus1 greater than 0, the \ndecoder shall be capable of decoding the bitstream as delivered from the HSS operating using an \"interpolated\" delivery \nschedule specified as having peak bit rate r, CPB size c( r ), and initial CPB removal delay ( f( r ) ÷ r ) as follows: \n = ( r − BitRate[ SchedSelIdx − 1 ] ) ÷ ( BitRate[ SchedSelIdx ] − BitRate[ SchedSelIdx − 1 ] ),  (C-17) \nc( r ) =  * CpbSize[ SchedSelIdx ] + (1 −  * CpbSize[ SchedSelIdx−1 ],  (C-18) \nf( r ) = initial_cpb_removal_delay[ SchedSelIdx ] * BitRate[ SchedSelIdx ] +  \n   ( 1 −  initial_cpb_removal_delay[ SchedSelIdx − 1 ] * BitRate[ SchedSelIdx − 1 ]  (C-19) \nfor any SchedSelIdx > 0 and r such that BitRate[ SchedSelIdx − 1 ] <= r <= BitRate[ SchedSelIdx ] such that r and c( r ) \nare within the limits as specified in Annex A, Annex G, Annex H, and Annex I for the maximum bit rate and buffer size \nfor the specified profile and level. \nNOTE  1  – initial_cpb_removal_delay[ SchedSelIdx ]  can  be  different  from  one  buffering  period  to  another  and have  to be \nre-calculated. \nFor output timing decoder conformance, an HRD as described above is used and the timing (relative to the delivery time \nof the first bit) of picture output is the same for both HRD and the DUT up to a fixed delay. \nFor output order decoder conformance, the HSS delivers the bitstream to the DUT \"by demand\" from the DUT, meaning \nthat the HSS delivers bits (in decoding order) only when the DUT requires more bits to proceed with its processing. \nNOTE 2 – This means that for this test, the coded picture buffer of the DUT could be as small as the size of the largest access unit. \nA modified HRD as described below is used, and the HSS delivers the bitstream to the HRD by one of the schedules \nspecified in the bitstream such that the bit rate and CPB size are restricted as specified in Annex A, Annex G, Annex H, \nand Annex I. The order of pictures output shall be the same for both HRD and the DUT. \nFor output order decoder conformance, the HRD CPB size is equal to CpbSize[ SchedSelIdx ] for the selected schedule \nand the DPB size is equal to MaxDpbFrames. Removal time from the CPB for the HRD is equal to final bit arrival time \nand decoding is immediate. The operation of the DPB of this HRD is specified in clause C.4.1. \nC.4.1  Operation of the output order DPB \nThe decoded picture buffer contains frame buffers. When a coded video sequence conforming to one or more of the profiles \nspecified in Annex A is decoded by applying the decoding process specified in clauses 2 to 9, each of the frame buffers \nmay contain a decoded frame, a decoded complementary field pair or a single (non-paired) decoded field that is marked as \n\"used for reference\" or is held for future output (reordered pictures). When a coded video sequence conforming to one or \nmore of the profiles specified in Annex G is decoded by applying the decoding process specified in Annex G, each frame \nbuffer may contain a decoded frame, a decoded complementary field pair, a single (non-paired) decoded field, a decoded \nreference base frame, a decoded reference base complementary field pair or a single (non-paired) decoded reference base \nfield that is marked as \"used for reference\" (reference pictures) or is held for future output (reordered or delayed pictures). \nWhen a coded video sequence conforming to one or more of the profiles specified in Annex H is decoded by applying the \ndecoding process specified in Annex H, each of the frame buffers may contain a decoded frame view component, a decoded \ncomplementary field view component pair, or a single (non-paired) decoded field view component that is marked as \"used \nfor reference\" (reference pictures) or is held for future output (reordered or delayed pictures) or is held for inter-view \nprediction (inter-view only reference components). When a coded video sequence conforming to one or more of the profiles \nspecified in Annex I is decoded by applying the decoding process specified in Annex I, each of the frame buffers of the \ntexture  DPB  may  contain  a  decoded  texture  frame  view  component,  a  decoded  complementary  texture  field  view \ncomponent pair, a single (non-paired) decoded texture field view component that is marked as \"used for reference\" \n(reference pictures) or is held for future output (reordered or delayed pictures) or is held for inter-view prediction (inter-\nview only reference components). When a coded video sequence conforming to one or more of the profiles specified in \nAnnex I is decoded by applying the decoding process specified in Annex I, each of the frame buffers of the depth DPB \nmay contain a decoded depth frame view component, a decoded complementary depth field view component pair, or a \nsingle (non-paired) decoded depth field view component that is marked as \"used for reference\" (reference pictures) or is \nheld for future output (reordered or delayed pictures) or is held as reference for inter-view prediction (inter-view only \nreference components). \nAt HRD initialization, the DPB fullness, measured in non-empty frame buffers, is set equal to 0. The following steps all \nhappen instantaneously when an access unit is removed from the CPB, and in the order listed. When the decoding process \n322  Rec. ITU-T H.264 (06/2019) \n \nspecified in Annex H or Annex I is applied, the view components of the current primary coded picture are processed by \napplying the ordered steps to each view component in increasing order of the associated view order index VOIdx. The \ninvocation of the process for a depth view component, if present, follows the invocation of the process for the texture view \ncomponent within the same view component. \n1.  The process of decoding gaps in frame_num and storing \"non-existing\" frames as specified in clause C.4.2 is \ninvoked. \n2.  The picture decoding and output process as specified in clause C.4.3 is invoked. \n3.  The process of removing pictures from the DPB before possible insertion of the current picture as specified in \nclause C.4.4 is invoked. \n4.  The process of marking and storing the current decoded picture as specified in clause C.4.5 is invoked. \nNOTE – When the decoding process specified in Annex G is applied, the DPB is only operated for decoded pictures and \nreference base pictures associated with decoded pictures. The DPB is not operated for layer pictures with dependency_id less \nthan DependencyIdMax (and associated reference base pictures). All decoded pictures and associated reference base pictures are \ndecoded pictures and associated reference base pictures for dependency_id equal to DependencyIdMax, which represent the \nresults of the decoding process specified in clause G.8. \nC.4.2  Decoding of gaps in frame_num and storage of \"non-existing\" pictures \nWhen the decoding process specified in Annex H is applied, the process specified in this clause is invoked for a particular \nview with view order index VOIdx, with \"picture\" being replaced by \"view component\", \"frame\" being replaced by \"frame \nview component\", and \"field\" being replaced by \"field view component\". During the invocation of the process for a \nparticular view, only view components of the particular view are considered and view components of other views are not \nmarked as \"unused for reference\" or removed from the DPB. \nWhen the decoding process specified in Annex I is applied, the process specified in this clause for Annex H is invoked for \nparticular texture view and depth view with view order index VOIdx, with each \"view component\" being replaced by \n\"texture view component\" or \"depth view component\", \"frame view component\" being replaced by \"texture frame view \ncomponent\"  or  \"depth  frame  view  component\",  and  \"field  view  component\"  being  replaced  by  \"texture  field  view \ncomponent\". During the invocation of the process for a particular texture view, only the texture view components of the \nparticular view are considered and during the invocation of the process for a particular depth view, only the depth view \ncomponents of the particular view are considered and view components of other views are not marked as \"unused for \nreference\" or removed from the DPB. \nThe DPB fullness represents the total number of non-empty frame buffers. When the decoding process specified in \nAnnex H is applied, this includes frame buffers that contain view components of other views. When the decoding process \nspecified in Annex I is applied, this includes frame buffers that contain texture or depth view components of other views. \nWhen applicable, gaps in frame_num are detected by the decoding process and the necessary number of \"non-existing\" \nframes are inferred in the order specified by the generation of values of UnusedShortTermFrameNum in Equation 7-24 \nand are marked as specified in clauses 8.2.5.2 and G.8.2.5. Frame buffers containing a frame or a complementary field pair \nor a non-paired field which are marked as \"not needed for output\" and \"unused for reference\" are emptied (without output), \nand the DPB fullness is decremented by the number of frame buffers emptied. Each \"non-existing\" frame is stored in the \nDPB as follows: \n–  When there is no empty frame buffer (i.e., DPB fullness is equal to DPB size), the \"bumping\" process specified in \nclause C.4.5.3 is invoked repeatedly until there is an empty frame buffer in which to store the \"non-existing\" frame. \n–  The \"non-existing\" frame is stored in an empty frame buffer and is marked as \"not needed for output\", and the DPB \nfullness is incremented by one. \nC.4.3  Picture decoding \nWhen the decoding process specified in Annex H is applied, the process specified in this clause is invoked for a particular \nview with view order index VOIdx. \nWhen the decoding process specified in Annex I is applied, the process specified for Annex H in this clause is invoked for \na particular texture view and depth view with view order index VOIdx. \nThe decoding of the current picture or view component (when applying the decoding process specified in Annex H or \nAnnex I) is specified as follows: \n–  If the decoding process specified in clause 8 or Annex G is applied, the current primary coded picture n is decoded \nand is temporarily stored (not in the DPB). \n–  Otherwise (the decoding process specified in Annex H or Annex I is applied), the view component with view order \nindex VOIdx of the current primary coded picture n is decoded and is temporarily stored (not in the DPB). \n    Rec. ITU-T H.264 (06/2019)  323 \n \nC.4.4  Removal of pictures from the DPB before possible insertion of the current picture \nWhen the decoding process specified in Annex H is applied, the process specified in this clause is invoked for a particular \nview with view order index VOIdx, with \"picture\" being replaced by \"view component\", \"frame\" being replaced by \"frame \nview component\", and \"field\" being replaced by \"field view component\". \nWhen the decoding process specified in Annex I is applied, the process specified in this clause for Annex H is invoked for \nparticular texture view and depth view with view order index VOIdx, with each \"view component\" being replaced by \n\"texture view component\" or \"depth view component\", \"frame view component\" being replaced by \"texture frame view \ncomponent\"  or  \"depth  frame  view  component\",  and  \"field  view  component\"  being  replaced  by  \"texture  field  view \ncomponent\". During the invocation of the process for a particular texture view, only the texture view components of the \nparticular view are considered and during the invocation of the process for a particular depth view, only the depth view \ncomponents of the particular view are considered. \nWhen the decoding process specified in Annex H or Annex I is applied, the following process is specified for emptying \nframe buffers containing inter-view only reference components of the current access unit. By this process, frame buffers \nthat contain view components of the current view with view order index VOIdx are not emptied, but frame buffers that \ncontain inter-view only reference components of other views may be emptied. The process is specified as follows: \n–  If the view order index VOIdx of the current view is equal to VOIdxMax, all frame buffers containing a frame or a \ncomplementary field pair or a non-paired field which are marked as \"not needed for output\" and \"unused for reference\" \nare emptied (without output), and the DPB fullness is decremented by the number of frame buffers emptied. \nNOTE 1 – At this stage of the process, all frame buffers that contain a frame or a complementary field pair or a \nnon-paired field marked as \"not needed for output\" and \"unused for reference\" are frame buffers that contain an inter-\nview only reference component (of the current access unit and a view with view order index less than VOIdx) with \nOutputFlag equal to 0. \n–  Otherwise (the view order index VOIdx of the current view is less than VOIdxMax), frame buffers containing a frame \nor a complementary field pair or a non-paired field for which both of the following conditions are true are emptied \n(without output), and the DPB fullness is decremented by the number of frame buffers emptied: \n–  the frame or complementary field pair or non-paired field is marked as \"not needed for output\" and \"unused for \nreference\", \nNOTE 2 – At this stage of the process, all frame buffers that contain a frame or a complementary field pair or a \nnon-paired field marked as \"not needed for output\" and \"unused for reference\" are frame buffers that contain an inter-\nview only reference component (of the current access unit and a view with view order index less than VOIdx) with \nOutputFlag equal to 0. \n–  one of the following conditions is true: \n–  the current view component is a view component of an anchor picture and the view_id of the frame or \ncomplementary field pair or non-paired field is not equal to any value of anchor_ref_lX[ k ][ j ], with X \nbeing equal to 0 or 1, k being any integer value greater than the view order index VOIdx of the current view, \nand j being any integer value in the range of 0 to Max( 0, num_anchor_refs_lX[ k ] − 1 ), inclusive, \n–  the current view component is not a view component of an anchor picture and the view_id of the frame or \ncomplementary field pair or non-paired field is not equal to any value of non_anchor_ref_lX[ k ][ j ], with \nX being equal to 0 or 1, k being any integer value greater than the view order index VOIdx of the current \nview,  and  j  being  any  integer  value  in  the  range  of 0  to  Max( 0, num_non_anchor_refs_lX[ k ] − 1 ), \ninclusive. \nWhen the decoding process specified in Annex H or Annex I is applied, for the following processes specified in this clause, \nonly view components of the particular view for which this clause is invoked are considered, and frame buffers containing \nview components of other views are not emptied. The DPB fullness represents the total number of non-empty frame buffers, \nincluding frame buffers that contain view components of other views. \nThe removal of pictures from the DPB before possible insertion of the current picture proceeds as follows: \n–  If the decoded picture is an IDR picture the following applies: \n1.  All reference pictures in the DPB are marked as \"unused for reference\" as specified in clause 8.2.5 when a \ncoded video sequence conforming to one or more of the profiles specified in Annex A is decoded by applying \nthe decoding process specified in clauses 2 to 9, or as specified in clause G.8.2.4 when a coded video sequence \nconforming to one or more of the profiles specified in Annex G is decoded by applying the decoding process \nspecified in Annex G, or as specified in clause H.8.3 when a coded video sequence conforming to one or more \nof the profiles specified in Annex H is decoded by applying the decoding process specified in Annex H, or as \nspecified in clause I.8.3 when a coded video sequence conforming to one or more of the profiles specified in \nAnnex I is decoded by applying the decoding process specified in Annex I. \n324  Rec. ITU-T H.264 (06/2019) \n \n2.  When  the  IDR  picture  is  not  the  first  IDR  picture  decoded  and  the  value  of  PicWidthInMbs  or \nFrameHeightInMbs or max_dec_frame_buffering derived from the active sequence parameter set is different \nfrom  the  value  of  PicWidthInMbs  or  FrameHeightInMbs  or  max_dec_frame_buffering  derived  from  the \nsequence parameter set that was active for the preceding picture, respectively, no_output_of_prior_pics_flag is \ninferred to be equal to 1 by the HRD, regardless of the actual value of no_output_of_prior_pics_flag. \nNOTE 3 – Decoder implementations should try to handle changes in the value of PicWidthInMbs or FrameHeightInMbs \nor max_dec_frame_buffering more gracefully than the HRD. \n3.  When no_output_of_prior_pics_flag is equal to 1 or is inferred to be equal to 1, all frame buffers in the DPB \nare emptied without output of the pictures they contain, and DPB fullness is set to 0. \n–  Otherwise (the decoded picture is not an IDR picture), the decoded reference picture marking process is invoked as \nspecified in clause 8.2.5 when a coded video sequence conforming to one or more of the profiles specified in Annex A \nis decoded by applying the decoding process specified in clauses 2 to 9, or as specified in clause G.8.2.4 when a coded \nvideo sequence conforming to one or more of the profiles specified in Annex G is decoded by applying the decoding \nprocess specified in Annex G, or as specified in clause H.8.3 when a coded video sequence conforming to one or \nmore of the profiles specified in Annex H is decoded by applying the decoding process specified in Annex H, or as \nspecified in clause I.8.3 when a coded video sequence conforming to one or more of the profiles specified in Annex I \nis  decoded  by  applying  the  decoding  process  specified  in  Annex I.  Frame  buffers  containing  a  frame  or  a \ncomplementary field pair or a non-paired field which are marked as \"not needed for output\" and \"unused for reference\" \nare emptied (without output), and the DPB fullness is decremented by the number of frame buffers emptied. \nWhen  the  current  picture  has  a  memory_management_control_operation  equal  to 5  or  is  an  IDR  picture  for  which \nno_output_of_prior_pics_flag is not equal to 1 and is not inferred to be equal to 1, the following two steps are performed. \n1.  Frame buffers containing a frame or a complementary field pair or a non-paired field which are marked as \"not \nneeded for output\" and \"unused for reference\" are emptied (without output), and the DPB fullness is decremented \nby the number of frame buffers emptied. \n2.  All non-empty frame buffers in the DPB are emptied by repeatedly invoking the \"bumping\" process specified in \nclause C.4.5.3, and the DPB fullness is set to 0. \nC.4.5  Current decoded picture marking and storage \nWhen the decoding process specified in Annex H is applied, the process specified in this clause is invoked for a particular \nview with view order index VOIdx, with \"picture\" being replaced by \"view component\", \"frame\" being replaced by \"frame \nview component\", and \"field\" being replaced by \"field view component\". During the invocation of the process for a \nparticular view, only view components of the particular view are considered and frame buffers containing view components \nof other views are not emptied. \nWhen the decoding process specified in Annex I is applied, the process specified in this clause for Annex H is invoked for \nparticular texture view and depth view with view order index VOIdx, with each \"view component\" being replaced by \n\"texture view component\" or \"depth view component\", \"frame view component\" being replaced by \"texture frame view \ncomponent\"  or  \"depth  frame  view  component\",  and  \"field  view  component\"  being  replaced  by  \"texture  field  view \ncomponent\". During the invocation of the process for a particular texture view, only the texture view components of the \nparticular view are considered and during the invocation of the process for a particular depth view, only the depth view \ncomponents of the particular view are considered and frame buffers containing view components of other views are not \nemptied. \nThe DPB fullness represents the total number of non-empty frame buffers. When the decoding process specified in \nAnnex H is applied, this includes frame buffers that contain view components of other views. When the decoding process \nspecified in Annex I is applied, this includes frame buffers that contain texture or depth view components of other views. \nThe marking and storage of the current decoded picture is specified as follows: \n–  If the current picture is a reference picture, the storage and marking process for decoded reference pictures as specified \nin clause C.4.5.1 is invoked. \n–  Otherwise (the current picture is a non-reference picture), the storage and marking process for decoded non-reference \npictures as specified in clause C.4.5.2 is invoked. \nC.4.5.1  Storage and marking of a reference decoded picture into the DPB \nThe current picture is stored in the DPB as follows: \n–  If the current decoded picture is the second field (in decoding order) of a complementary reference field pair, and the \nfirst field of the pair is still in the DPB, the current picture is stored in the same frame buffer as the first field of the \npair and the following applies: \n–  If the current decoded picture has OutputFlag equal to 1, it is marked as \"needed for output\". \n    Rec. ITU-T H.264 (06/2019)  325 \n \n–  Otherwise (the current decoded picture has OutputFlag equal to 0), it is marked as \"not needed for output\". \n–  Otherwise, the following operations are performed: \n1.  When there is no empty frame buffer (i.e., DPB fullness is equal to DPB size), the \"bumping\" process specified \nin clause C.4.5.3 is invoked repeatedly until there is an empty frame buffer in which to store the current decoded \npicture. \n2.  The current decoded picture is stored in an empty frame buffer, the DPB fullness is incremented by one, and \nthe following applies: \n–  If the current decoded picture has OutputFlag equal to 1, it is marked as \"needed for output\". \n–  Otherwise (the current decoded picture has OutputFlag equal to 0), it is marked as \"not needed for output\". \nWhen the coded video sequence conforms to one or more of the profiles specified in Annex G and the decoding process \nspecified in Annex G is applied and the current picture has store_ref_base_pic_flag equal to 1 (i.e., the current picture is \nassociated with a reference base picture), the associated reference base picture is stored in the DPB as follows: \n–  If the reference base picture is a second field (in decoding order) of a complementary reference base field pair, and \nthe first field of the pair is still in the DPB, the reference base picture is stored in the same frame buffer as the first \nfield of the pair and marked as \"not needed for output\". \n–  Otherwise, the following operations are performed: \n1.  When there is no empty frame buffer (i.e., DPB fullness is equal to DPB size), the \"bumping\" process \nspecified in clause C.4.5.3 is invoked repeatedly until there is an empty frame buffer in which to store the \nreference base picture. \n2.  The reference base picture is stored in an empty frame buffer and marked as \"not needed for output\" and the \nDPB fullness is incremented by one. \nC.4.5.2  Storage and marking of a non-reference decoded picture into the DPB \nThe current picture is associated with a variable StoreInterViewOnlyRefFlag, which is derived as follows: \n–  If the decoding process specified in Annex H or Annex I is applied, the current view component has a view order \nindex VOIdx less than VOIdxMax and inter_view_flag equal to 1, StoreInterViewOnlyRefFlag is set equal to 1. \n–  Otherwise, StoreInterViewOnlyRefFlag is set equal to 0. \nThe current picture is stored in the DPB or output as follows: \n–  If the current decoded picture is the second field (in decoding order) of a complementary non-reference field pair and \nthe first field of the pair is still in the DPB, the current picture is stored in the same frame buffer as the first field of \nthe pair and the following applies: \n–  If the current decoded picture has OutputFlag equal to 1, it is marked as \"needed for output\". \n–  Otherwise (the current decoded picture has OutputFlag equal to 0), it is marked as \"not needed for output\". \n–  Otherwise, if the current picture has OutputFlag equal to 0 and StoreInterViewOnlyRefFlag equal to 0, the DPB is \nnot modified and the current picture is not output. \n–  Otherwise, if the current picture has StoreInterViewOnlyRefFlag equal to 1, the following operations are performed: \n1.  When there is no empty frame buffer (i.e., DPB fullness is equal to DPB size), the \"bumping\" process specified \nin clause C.4.5.3 is invoked repeatedly until there is an empty frame buffer in which to store the current decoded \npicture. \n2.  The current decoded picture is stored in an empty frame buffer, the DPB fullness is incremented by one, and \nthe following applies: \n–  If the current decoded picture has OutputFlag equal to 1, it is marked as \"needed for output\". \n–  Otherwise (the current decoded picture has OutputFlag equal to 0), it is marked as \"not needed for output\". \n–  Otherwise, the following operations are performed repeatedly until the current decoded picture has been cropped and \noutput or has been stored in the DPB: \n–  If there is no empty frame buffer (i.e., DPB fullness is equal to DPB size), the following applies: \n–  If the current picture does not have a lower value of PicOrderCnt( ) than all pictures in the DPB that are \nmarked as \"needed for output\", the \"bumping\" process described in clause C.4.5.3 is performed. \n–  Otherwise (the current picture has a lower value of PicOrderCnt( ) than all pictures in the DPB that are \nmarked as \"needed for output\"), the current picture is cropped, using the cropping rectangle specified in \nthe active sequence parameter set for the picture and the cropped picture is output. \n326  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (there is an empty frame buffer, i.e., DPB fullness is less than DPB size), the current decoded picture \nis stored in an empty frame buffer and is marked as \"needed for output\", and the DPB fullness is incremented \nby one. \nC.4.5.3  \"Bumping\" process \nWhen the decoding process specified in Annex H is applied, the process specified in this clause is invoked for a particular \nview with view order index VOIdx, with \"picture\" being replaced by \"view component\", \"frame\" being replaced by \"frame \nview component\", and \"field\" being replaced by \"field view component\". During the invocation of the process for a \nparticular view, only view components of the particular view are considered and frame buffers containing view components \nof other views are not emptied. \nWhen the decoding process specified in Annex I is applied, the process specified in this clause for Annex H is invoked for \nparticular texture view and depth view with view order index VOIdx, with each \"view component\" being replaced by \n\"texture view component\" or \"depth view component\", \"frame view component\" being replaced by \"texture frame view \ncomponent\"  or  \"depth  frame  view  component\",  and  \"field  view  component\"  being  replaced  by  \"texture  field  view \ncomponent\". During the invocation of the process for a particular texture view, only the texture view components of the \nparticular view are considered while respective depth view components may be cropped and output too During the \ninvocation of the process for a particular depth view, only the depth view components of the particular view are considered \nand frame buffers containing view components of other views are not emptied. The DPB fullness represents the total \nnumber of non-empty frame buffers, including frame buffers that contain view components of other views, for the texture \nDPB or the depth DPB depending on whether the process is invoked for a texture view or a depth view, respectively. \nThe DPB fullness represents the total number of non-empty frame buffers. When the decoding process specified in \nAnnex H is applied, this includes frame buffers that contain view components of other views. When the decoding process \nspecified in Annex I is applied, this includes frame buffers that contain texture or depth view components of other views. \nThe \"bumping\" process is invoked in the following cases. \n–  There is no empty frame buffer (i.e., DPB fullness is equal to DPB size) and an empty frame buffer is needed for \nstorage of an inferred \"non-existing\" frame, as specified in clause C.4.2. \n–  The current picture is an IDR picture and no_output_of_prior_pics_flag is not equal to 1 and is not inferred to be \nequal to 1, as specified in clause C.4.4. \n–  The current picture has memory_management_control_operation equal to 5, as specified in clause C.4.4. \n–  There is no empty frame buffer (i.e., DPB fullness is equal to DPB size) and an empty frame buffer is needed for \nstorage of a decoded (non-IDR) reference picture or a reference base picture, as specified in clause C.4.5.1. \n–  There is no empty frame buffer (i.e., DPB fullness is equal to DPB size) and the current picture is a non-reference \npicture that is not the second field of a complementary non-reference field pair and the current picture has OutputFlag \nequal to 1 and there are pictures in the DPB that are marked as \"needed for output\" that precede the current non-\nreference picture in output order, as specified in clause C.4.5.2, so an empty buffer is needed for storage of the current \npicture. \n–  There is no empty frame buffer (i.e., DPB fullness is equal to DPB size) and the current picture is a non-reference \npicture  that  is  not  the  second  field  of  a  complementary  non-reference  field  pair  and  the  current  picture  has \nStoreInterViewOnlyRefFlag equal to 1, as specified in clause C.4.5.2, so an empty buffer is needed for storage of the \ncurrent picture. \nThe \"bumping\" process consists of the following ordered steps: \n1.  The picture or complementary reference field pair that is considered first for output is selected as follows: \na.  The frame buffer is selected that contains the picture having the smallest value of PicOrderCnt( ) of all \npictures in the DPB marked as \"needed for output\". \nb.  Depending on the frame buffer, the following applies: \n–  If this frame buffer contains a complementary non-reference field pair with both fields marked as \n\"needed for output\" and both fields have the same PicOrderCnt( ), the first of these two fields in \ndecoding order is considered first for output. \n–  Otherwise, if this frame buffer contains a complementary reference field pair with both fields marked \nas \"needed for output\" and both fields have the same PicOrderCnt( ), the entire complementary reference \nfield pair is considered first for output. \nNOTE – When the two fields of a complementary reference field pair have the same value of PicOrderCnt( ), this \n\"bumping\" process will output these pictures together, although the two fields have different output times from a \ndecoder that satisfies output timing conformance criteria (as specified in clause C.2.2). \n–  Otherwise, the picture in this frame buffer that has the smallest value of PicOrderCnt( ) is considered \nfirst for output. \n    Rec. ITU-T H.264 (06/2019)  327 \n \n2.  Depending on whether a single picture or a complementary reference field pair is considered for output, the \nfollowing applies: \n–  If a single picture is considered first for output, this picture is cropped, using the cropping rectangle specified \nin the active sequence parameter set for the picture, the cropped picture is output, and the picture is marked as \n\"not needed for output\". \n–  Otherwise  (a  complementary  reference  field  pair  is  considered  first  for  output),  the  two  fields  of  the \ncomplementary reference field pair are both cropped, using the cropping rectangle specified in the active \nsequence parameter set for the pictures, the two fields of the complementary reference field pair are output \ntogether, and both fields of the complementary reference field pair are marked as \"not needed for output\". \n3.  When there is a single depth view component or a complementary depth view component pair having the same \nvalues of view_id and PicOrderCnt( ) as the single picture or complementary reference field pair considered for \noutput, the single depth view component or complementary depth view component pair are output as in step 2. \n4.  The frame buffer that included the picture or complementary reference field pair that was cropped and output is \nchecked, and when any of the following conditions are true, the frame buffer is emptied and the DPB fullness is \ndecremented by 1: \n–  The frame buffer contains a non-reference non-paired field. \n–  The frame buffer contains a non-reference frame. \n–  The frame buffer contains a complementary non-reference field pair with both fields marked as \"not needed \nfor output\". \n–  The frame buffer contains a non-paired reference field marked as \"unused for reference\". \n–  The frame buffer contains a reference frame with both fields marked as \"unused for reference\". \n–  The frame buffer contains a complementary reference field pair with both fields marked as \"unused for \nreference\" and \"not needed for output\". \n328  Rec. ITU-T H.264 (06/2019) \n \nAnnex D \n \nSupplemental enhancement information \n \n(This annex forms an integral part of this Recommendation | International Standard.) \nThis annex specifies syntax and semantics for SEI message payloads. \nSEI messages assist in processes related to decoding, display or other purposes. However, SEI messages are not required \nfor constructing the luma or chroma samples by the decoding process. Conforming decoders are not required to process \nthis information for output order conformance to this Recommendation | International Standard (see Annex C for the \nspecification of conformance). Some SEI message information is required to check bitstream conformance and for output \ntiming decoder conformance. \nIn Annex D, specification for presence of SEI messages are also satisfied when those messages (or some subset of them) \nare conveyed to decoders (or to the HRD) by other means not specified by this Recommendation | International Standard. \nWhen present in the bitstream, SEI messages shall obey the syntax and semantics specified in clauses 7.3.2.3 and 7.4.2.3 \nand this annex. When the content of an SEI message is conveyed for the application by some means other than presence \nwithin the bitstream, the representation of the content of the SEI message is not required to use the same syntax specified \nin this annex. For the purpose of counting bits, only the appropriate bits that are actually present in the bitstream are \ncounted. \nD.1  SEI payload syntax \nD.1.1  General SEI message syntax \n \nsei_payload( payloadType, payloadSize ) {  C  Descriptor \nif( payloadType  = =  0 )     \nbuffering_period( payloadSize )  5   \nelse if( payloadType  = =  1 )     \npic_timing( payloadSize )  5   \nelse if( payloadType  = =  2 )     \npan_scan_rect( payloadSize )  5   \nelse if( payloadType  = =  3 )     \n  filler_payload( payloadSize )  5   \nelse if( payloadType  = =  4 )     \n  user_data_registered_itu_t_t35( payloadSize )  5   \nelse if( payloadType  = =  5 )     \n  user_data_unregistered( payloadSize )  5   \nelse if( payloadType  = =  6 )     \n  recovery_point( payloadSize )  5   \nelse if( payloadType  = =  7 )     \n  dec_ref_pic_marking_repetition( payloadSize )  5   \nelse if( payloadType  = =  8 )     \n  spare_pic( payloadSize )  5   \nelse if( payloadType  = =  9 )     \n  scene_info( payloadSize )  5   \nelse if( payloadType  = =  10 )     \n  sub_seq_info( payloadSize )  5   \nelse if( payloadType  = =  11 )     \n  sub_seq_layer_characteristics( payloadSize )  5   \nelse if( payloadType  = =  12 )     \n  sub_seq_characteristics( payloadSize )  5   \n    Rec. ITU-T H.264 (06/2019)  329 \n \nelse if( payloadType  = =  13 )     \n  full_frame_freeze( payloadSize )  5   \nelse if( payloadType  = =  14 )     \n  full_frame_freeze_release( payloadSize )  5   \nelse if( payloadType  = =  15 )     \n  full_frame_snapshot( payloadSize )  5   \nelse if( payloadType  = =  16 )     \n  progressive_refinement_segment_start( payloadSize )  5   \nelse if( payloadType  = =  17 )     \n  progressive_refinement_segment_end( payloadSize )  5   \nelse if( payloadType  = =  18 )     \n  motion_constrained_slice_group_set( payloadSize )  5   \nelse if( payloadType  = =  19 )     \n  film_grain_characteristics( payloadSize )  5   \nelse if( payloadType  = =  20 )     \n  deblocking_filter_display_preference( payloadSize )  5   \nelse if( payloadType  = =  21 )     \n  stereo_video_info( payloadSize )  5   \nelse if( payloadType  = =  22 )     \n  post_filter_hint( payloadSize )  5   \nelse if( payloadType  = =  23 )     \n  tone_mapping_info( payloadSize )  5   \nelse if( payloadType  = =  24 )     \n  scalability_info( payloadSize )  /* specified in Annex G */  5   \nelse if( payloadType  = =  25 )     \n  sub_pic_scalable_layer( payloadSize )  /* specified in Annex G */  5   \nelse if( payloadType  = =  26 )     \n  non_required_layer_rep( payloadSize )  /* specified in Annex G */  5   \nelse if( payloadType  = =  27 )     \n  priority_layer_info( payloadSize )  /* specified in Annex G */  5   \nelse if( payloadType  = =  28 )     \n  layers_not_present( payloadSize )  /* specified in Annex G */  5   \nelse if( payloadType  = =  29 )     \n  layer_dependency_change( payloadSize )  /* specified in Annex G */  5   \nelse if( payloadType  = =  30 )     \n  scalable_nesting( payloadSize )  /* specified in Annex G */  5   \nelse if( payloadType  = =  31 )     \n  base_layer_temporal_hrd( payloadSize )  /* specified in Annex G */  5   \nelse if( payloadType  = =  32 )     \n  quality_layer_integrity_check( payloadSize )  /* specified in Annex G */  5   \nelse if( payloadType  = =  33 )     \n  redundant_pic_property( payloadSize )  /* specified in Annex G */  5   \nelse if( payloadType  = =  34 )     \n  tl0_dep_rep_index( payloadSize )  /* specified in Annex G */  5   \nelse if( payloadType  = =  35 )     \n  tl_switching_point( payloadSize )  /* specified in Annex G */  5   \nelse if( payloadType  = =  36 )     \n  parallel_decoding_info( payloadSize )  /* specified in Annex H */  5   \n330  Rec. ITU-T H.264 (06/2019) \n \nelse if( payloadType  = =  37 )     \n  mvc_scalable_nesting( payloadSize )  /* specified in Annex H */  5   \nelse if( payloadType  = =  38 )     \n  view_scalability_info( payloadSize )  /* specified in Annex H */  5   \nelse if( payloadType  = =  39 )     \n  multiview_scene_info( payloadSize )  /* specified in Annex H */  5   \nelse if( payloadType  = =  40 )     \n  multiview_acquisition_info( payloadSize )  /* specified in Annex H */  5   \nelse if( payloadType  = =  41 )     \n  non_required_view_component( payloadSize )  /* specified in Annex H */  5   \nelse if( payloadType  = =  42 )     \n  view_dependency_change( payloadSize )  /* specified in Annex H */  5   \nelse if( payloadType  = =  43 )     \n  operation_points_not_present( payloadSize )  /* specified in Annex H */  5   \nelse if( payloadType  = =  44 )     \n  base_view_temporal_hrd( payloadSize )  /* specified in Annex H */  5   \nelse if( payloadType  = =  45 )     \n  frame_packing_arrangement( payloadSize )  5   \nelse if( payloadType  = =  46 )     \n  multiview_view_position( payloadSize )  /* specified in Annex H */  5   \nelse if( payloadType  = =  47 )     \n  display_orientation( payloadSize )  5   \nelse if( payloadType  = =  48 )     \n  mvcd_scalable_nesting( payloadSize )  /* specified in Annex I */  5   \nelse if( payloadType  = =  49 )     \n  mvcd_view_scalability_info( payloadSize )  /* specified in Annex I */  5   \nelse if( payloadType  = =  50 )     \n  depth_representation_info( payloadSize )  /* specified in Annex I */  5   \nelse if( payloadType  = =  51 )     \n  three_dimensional_reference_displays_info( payloadSize )  5   \n                          /* specified in Annex I */ \nelse if( payloadType  = =  52 )     \n  depth_timing( payloadSize )  /* specified in Annex I */  5   \nelse if( payloadType  = =  53 )     \n  depth_sampling_info( payloadSize )  /* specified in Annex I */  5   \nelse if( payloadType  = =  54 )     \n  constrained_depth_parameter_set_identifier( payloadSize )   5   \n                      /* specified in Annex J */ \nelse if( payloadType  = =  56 )     \n  green_metadata( payloadSize )  /* specified in ISO/IEC 23001-11 */  5   \nelse if( payloadType  = =  137 )     \n  mastering_display_colour_volume( payloadSize )  5   \nelse if( payloadType  = =  142 )     \n  colour_remapping_info( payloadSize )  5   \nelse if( payloadType  = =  144 )     \n  content_light_level_info( payloadSize )  5   \nelse if( payloadType  = =  147 )     \n  alternative_transfer_characteristics( payloadSize )  5   \nelse if( payloadType  = =  148 )     \n    Rec. ITU-T H.264 (06/2019)  331 \n \n  ambient_viewing_environment( payloadSize )  5   \nelse if( payloadType  = =  149 )     \n  content_colour_volume( payloadSize )  5   \nelse if( payloadType  = =  150 )     \n  equirectangular_projection( payloadSize )  5   \nelse if( payloadType  = =  151 )     \n  cubemap_projection( payloadSize )  5   \nelse if( payloadType  = =  154 )     \n  sphere_rotation( payloadSize )  5   \nelse if( payloadType  = =  155 )     \n  regionwise_packing( payloadSize )  5   \nelse if( payloadType  = =  156 )     \n  omni_viewport( payloadSize )  5   \nelse if( payloadType  = =  181 )     \n  alternative_depth_info( payloadSize )  /* specified in Annex I */  5   \nelse if( payloadType  = =  200 )     \n  sei_manifest( payloadSize )  5   \nelse if( payloadType  = =  201 )     \n  sei_prefix_indication( payloadSize )  5   \nelse     \n  reserved_sei_message( payloadSize )  5   \nif( !byte_aligned( ) ) {     \nbit_equal_to_one  /* equal to 1 */  5  f(1) \nwhile( !byte_aligned( ) )     \nbit_equal_to_zero  /* equal to 0 */  5  f(1) \n}     \n}     \n \nD.1.2  Buffering period SEI message syntax \n \nbuffering_period( payloadSize ) {  C  Descriptor \n  seq_parameter_set_id  5  ue(v) \n  if( NalHrdBpPresentFlag )     \n    for( SchedSelIdx = 0; SchedSelIdx <= cpb_cnt_minus1; SchedSelIdx++ ) {     \n      initial_cpb_removal_delay[ SchedSelIdx ]  5  u(v) \n      initial_cpb_removal_delay_offset[ SchedSelIdx ]  5  u(v) \n    }     \n  if( VclHrdBpPresentFlag )     \n    for( SchedSelIdx = 0; SchedSelIdx <= cpb_cnt_minus1; SchedSelIdx++ ) {     \n      initial_cpb_removal_delay[ SchedSelIdx ]  5  u(v) \n      initial_cpb_removal_delay_offset[ SchedSelIdx ]  5  u(v) \n    }     \n}     \n \n332  Rec. ITU-T H.264 (06/2019) \n \nD.1.3  Picture timing SEI message syntax \n \npic_timing( payloadSize ) {  C  Descriptor \n  if( CpbDpbDelaysPresentFlag ) {     \n    cpb_removal_delay  5  u(v) \n    dpb_output_delay  5  u(v) \n  }     \n  if( pic_struct_present_flag ) {     \n    pic_struct  5  u(4) \n    for( i = 0; i < NumClockTS; i++ ) {     \n      clock_timestamp_flag[ i ] 5  u(1) \n \n      if( clock_timestamp_flag[ i ] ) {     \n      ct_type  5  u(2) \n      nuit_field_based_flag  5  u(1) \n      counting_type  5  u(5) \n      full_timestamp_flag  5  u(1) \n      discontinuity_flag  5  u(1) \n      cnt_dropped_flag  5  u(1) \n      n_frames  5  u(8) \n      if( full_timestamp_flag ) {     \n      seconds_value /* 0..59 */  5  u(6) \n      minutes_value /* 0..59 */  5  u(6) \n      hours_value /* 0..23 */  5  u(5) \n      } else {     \n      seconds_flag  5  u(1) \n      if( seconds_flag ) {     \n            seconds_value /* range 0..59 */  5  u(6) \n            minutes_flag  5  u(1) \n            if( minutes_flag ) {     \n              minutes_value /* 0..59 */  5  u(6) \n              hours_flag  5  u(1) \n              if( hours_flag )     \n                hours_value /* 0..23 */  5  u(5) \n            }     \n          }     \n        }     \n        if( time_offset_length > 0 )     \n          time_offset  5  i(v) \n      }     \n    }     \n  }     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  333 \n \nD.1.4  Pan-scan rectangle SEI message syntax \n \npan_scan_rect( payloadSize ) {  C  Descriptor \npan_scan_rect_id  5  ue(v) \npan_scan_rect_cancel_flag  5  u(1) \nif( !pan_scan_rect_cancel_flag ) {     \n  pan_scan_cnt_minus1  5  ue(v) \n  for( i = 0; i <= pan_scan_cnt_minus1; i++ ) {     \n    pan_scan_rect_left_offset[ i ]  5  se(v) \n    pan_scan_rect_right_offset[ i ]  5  se(v) \n    pan_scan_rect_top_offset[ i ]  5  se(v) \n    pan_scan_rect_bottom_offset[ i ]  5  se(v) \n  }     \n  pan_scan_rect_repetition_period  5  ue(v) \n}     \n}     \n \nD.1.5  Filler payload SEI message syntax \n \nfiller_payload( payloadSize ) {  C  Descriptor \n  for( k = 0; k < payloadSize; k++ )     \n    ff_byte  /* equal to 0xFF */  5  f(8) \n}     \n \nD.1.6  User data registered by Rec. ITU-T T.35 SEI message syntax \n \nuser_data_registered_itu_t_t35( payloadSize ) {  C  Descriptor \n  itu_t_t35_country_code  5  b(8) \n  if( itu_t_t35_country_code  !=  0xFF )     \n    i = 1     \n  else {     \n    itu_t_t35_country_code_extension_byte  5  b(8) \n    i = 2     \n  }     \n  do {     \n    itu_t_t35_payload_byte  5  b(8) \n    i++     \n  } while( i < payloadSize )     \n}     \n \n334  Rec. ITU-T H.264 (06/2019) \n \nD.1.7  User data unregistered SEI message syntax \n \nuser_data_unregistered( payloadSize ) {  C  Descriptor \n  uuid_iso_iec_11578  5  u(128) \n  for( i = 16; i < payloadSize; i++ )     \n    user_data_payload_byte  5  b(8) \n}     \n \nD.1.8  Recovery point SEI message syntax \n \nrecovery_point( payloadSize ) {  C  Descriptor \n  recovery_frame_cnt  5  ue(v) \n  exact_match_flag  5  u(1) \n  broken_link_flag  5  u(1) \n  changing_slice_group_idc  5  u(2) \n}     \n \nD.1.9  Decoded reference picture marking repetition SEI message syntax \n \ndec_ref_pic_marking_repetition( payloadSize ) {  C  Descriptor \n  original_idr_flag  5  u(1) \n  original_frame_num  5  ue(v) \n  if( !frame_mbs_only_flag ) {     \n    original_field_pic_flag  5  u(1) \n    if( original_field_pic_flag )     \n      original_bottom_field_flag  5  u(1) \n  }     \n  dec_ref_pic_marking( )  5   \n}     \n \n    Rec. ITU-T H.264 (06/2019)  335 \n \nD.1.10  Spare picture SEI message syntax \n \nspare_pic( payloadSize ) {  C  Descriptor \n  target_frame_num  5  ue(v) \n  spare_field_flag  5  u(1) \n  if( spare_field_flag )     \n    target_bottom_field_flag  5  u(1) \n  num_spare_pics_minus1  5  ue(v) \n  for( i = 0; i < num_spare_pics_minus1 + 1; i++ ) {     \n    delta_spare_frame_num[ i ]  5  ue(v) \n    if( spare_field_flag )     \n      spare_bottom_field_flag[ i ]  5  u(1) \n    spare_area_idc[ i ]  5  ue(v) \n    if( spare_area_idc[ i ]  = =  1 )     \n      for( j = 0; j < PicSizeInMapUnits; j++ )      \n        spare_unit_flag[ i ][ j ]  5  u(1) \n    else if( spare_area_idc[ i ]  = =  2 ) {     \n      mapUnitCnt = 0     \n      for( j=0; mapUnitCnt < PicSizeInMapUnits; j++ ) {     \n        zero_run_length[ i ][ j ]  5  ue(v) \n        mapUnitCnt += zero_run_length[ i ][ j ] + 1     \n      }     \n    }     \n  }      \n}     \n \nD.1.11  Scene information SEI message syntax \n \nscene_info( payloadSize ) {  C  Descriptor \n  scene_info_present_flag  5  u(1) \n  if( scene_info_present_flag ) {     \n    scene_id  5  ue(v) \n    scene_transition_type  5  ue(v) \n    if( scene_transition_type > 3 )     \n      second_scene_id  5  ue(v) \n  }     \n}     \n \n336  Rec. ITU-T H.264 (06/2019) \n \nD.1.12  Sub-sequence information SEI message syntax \n \nsub_seq_info( payloadSize ) {  C  Descriptor \n  sub_seq_layer_num  5  ue(v) \n  sub_seq_id  5  ue(v) \n  first_ref_pic_flag  5  u(1) \n  leading_non_ref_pic_flag  5  u(1) \n  last_pic_flag  5  u(1) \n  sub_seq_frame_num_flag  5  u(1) \n  if( sub_seq_frame_num_flag )     \n    sub_seq_frame_num  5  ue(v) \n}     \n \nD.1.13  Sub-sequence layer characteristics SEI message syntax \n \nsub_seq_layer_characteristics( payloadSize ) {  C  Descriptor \n  num_sub_seq_layers_minus1  5  ue(v) \n  for( layer = 0; layer <= num_sub_seq_layers_minus1; layer++ ) {     \n    accurate_statistics_flag  5  u(1) \n    average_bit_rate  5  u(16) \n    average_frame_rate  5  u(16) \n  }     \n}     \n \nD.1.14  Sub-sequence characteristics SEI message syntax \n \nsub_seq_characteristics( payloadSize ) {  C  Descriptor \n  sub_seq_layer_num  5  ue(v) \n  sub_seq_id  5  ue(v) \n  duration_flag  5  u(1) \n  if( duration_flag)     \n    sub_seq_duration  5  u(32) \n  average_rate_flag  5  u(1) \n  if( average_rate_flag ) {     \n    accurate_statistics_flag  5  u(1) \n    average_bit_rate  5  u(16) \n    average_frame_rate  5  u(16) \n  }     \n  num_referenced_subseqs  5  ue(v) \n  for( n = 0; n < num_referenced_subseqs; n++ ) {     \n    ref_sub_seq_layer_num  5  ue(v) \n    ref_sub_seq_id  5  ue(v) \n    ref_sub_seq_direction  5  u(1) \n  }     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  337 \n \nD.1.15  Full-frame freeze SEI message syntax \n \nfull_frame_freeze( payloadSize ) {  C  Descriptor \n  full_frame_freeze_repetition_period  5  ue(v) \n}     \n \nD.1.16  Full-frame freeze release SEI message syntax \n \nfull_frame_freeze_release( payloadSize ) {  C  Descriptor \n}     \n \nD.1.17  Full-frame snapshot SEI message syntax \n \nfull_frame_snapshot( payloadSize ) {  C  Descriptor \n  snapshot_id  5  ue(v) \n}     \n \nD.1.18  Progressive refinement segment start SEI message syntax \n \nprogressive_refinement_segment_start( payloadSize ) {  C  Descriptor \n  progressive_refinement_id  5  ue(v) \n  num_refinement_steps_minus1  5  ue(v) \n}     \n \nD.1.19  Progressive refinement segment end SEI message syntax \n \nprogressive_refinement_segment_end( payloadSize ) {  C  Descriptor \n  progressive_refinement_id  5  ue(v) \n}     \n \nD.1.20  Motion-constrained slice group set SEI message syntax \n \nmotion_constrained_slice_group_set( payloadSize ) {  C  Descriptor \n  num_slice_groups_in_set_minus1  5  ue(v) \n  if( num_slice_groups_minus1 > 0 )     \n    for( i = 0; i <= num_slice_groups_in_set_minus1; i++ )     \n      slice_group_id[ i ]  5  u(v) \n  exact_sample_value_match_flag  5  u(1) \n  pan_scan_rect_flag  5  u(1) \n  if( pan_scan_rect_flag )     \n    pan_scan_rect_id  5  ue(v) \n}     \n \n338  Rec. ITU-T H.264 (06/2019) \n \nD.1.21  Film grain characteristics SEI message syntax \n \nfilm_grain_characteristics( payloadSize ) {  C  Descriptor \n  film_grain_characteristics_cancel_flag  5  u(1) \n  if( !film_grain_characteristics_cancel_flag ) {     \n    film_grain_model_id  5  u(2) \n    separate_colour_description_present_flag  5  u(1) \n    if( separate_colour_description_present_flag ) {     \n      film_grain_bit_depth_luma_minus8  5  u(3) \n      film_grain_bit_depth_chroma_minus8  5  u(3) \n      film_grain_full_range_flag  5  u(1) \n      film_grain_colour_primaries  5  u(8) \n      film_grain_transfer_characteristics  5  u(8) \n      film_grain_matrix_coefficients  5  u(8) \n    }     \n    blending_mode_id  5  u(2) \n    log2_scale_factor  5  u(4) \n    for( c = 0; c < 3; c++ )     \n      comp_model_present_flag[ c ]  5  u(1) \n    for( c = 0; c < 3; c++ )     \n      if( comp_model_present_flag[ c ] ) {     \n        num_intensity_intervals_minus1[ c ]  5  u(8) \n        num_model_values_minus1[ c ]  5  u(3) \n        for( i = 0; i <= num_intensity_intervals_minus1[ c ]; i++ ) {     \n          intensity_interval_lower_bound[ c ][ i ]   5  u(8) \n          intensity_interval_upper_bound[ c ][ i ]  5  u(8) \n          for( j = 0; j <= num_model_values_minus1[ c ]; j++ )     \n            comp_model_value[ c ][ i ][ j ]  5  se(v) \n        }     \n      }     \n  film_grain_characteristics_repetition_period  5  ue(v) \n  }     \n}     \n \nD.1.22  Deblocking filter display preference SEI message syntax \n \ndeblocking_filter_display_preference( payloadSize ) {  C  Descriptor \n  deblocking_display_preference_cancel_flag  5  u(1) \n  if( !deblocking_display_preference_cancel_flag ) {     \n    display_prior_to_deblocking_preferred_flag  5  u(1) \n    dec_frame_buffering_constraint_flag  5  u(1) \n    deblocking_display_preference_repetition_period  5  ue(v) \n  }     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  339 \n \nD.1.23  Stereo video information SEI message syntax \n \nstereo_video_info( payloadSize ) {  C  Descriptor \n  field_views_flag  5  u(1) \n  if( field_views_flag )     \n    top_field_is_left_view_flag  5  u(1) \n  else {     \n    current_frame_is_left_view_flag  5  u(1) \n    next_frame_is_second_view_flag  5  u(1) \n  }     \n  left_view_self_contained_flag  5  u(1) \n  right_view_self_contained_flag  5  u(1) \n}     \n \nD.1.24  Post-filter hint SEI message syntax \n \npost_filter_hint( payloadSize ) {  C  Descriptor \n  filter_hint_size_y  5  ue(v) \n  filter_hint_size_x  5  ue(v) \n  filter_hint_type  5  u(2) \n  for( colour_component = 0; colour_component < 3; colour_component ++ )     \n    for( cy = 0; cy < filter_hint_size_y; cy ++ )     \n      for( cx = 0; cx < filter_hint_size_x; cx ++ )     \n        filter_hint[ colour_component ][ cy ][ cx ]  5  se(v) \n  additional_extension_flag  5  u(1) \n}     \n \n340  Rec. ITU-T H.264 (06/2019) \n \nD.1.25  Tone mapping information SEI message syntax \n \ntone_mapping_info( payloadSize ) {  C  Descriptor \n  tone_map_id  5  ue(v) \n  tone_map_cancel_flag  5  u(1) \n  if( !tone_map_cancel_flag ) {     \n    tone_map_repetition_period  5  ue(v) \n    coded_data_bit_depth  5  u(8) \n    target_bit_depth  5  u(8) \n    tone_map_model_id  5  ue(v) \n    if( tone_map_model_id  = =  0 ) {     \n      min_value  5  u(32) \n      max_value  5  u(32) \n    }     \n    if( tone_map_model_id  = =  1 ) {     \n      sigmoid_midpoint  5  u(32) \n      sigmoid_width  5  u(32) \n    }     \n    if( tone_map_model_id  = =  2 )     \n      for( i = 0; i < ( 1 << target_bit_depth ); i++ )     \n        start_of_coded_interval[ i ]  5  u(v) \n    if( tone_map_model_id  = =  3 ) {     \n      num_pivots  5  u(16) \n      for( i=0; i < num_pivots; i++ ) {     \n        coded_pivot_value[ i ]  5  u(v) \n        target_pivot_value[ i ]  5  u(v) \n      }     \n    }     \n    if( tone_map_model_id  = =  4 ) {     \n      camera_iso_speed_idc  5  u(8) \n      if( camera_iso_speed_idc = =  Extended_ISO )     \n        camera_iso_speed_value  5  u(32) \n      exposure_index_idc  5  u(8) \n      if( exposure_index_idc  = =  Extended_ISO )     \n        exposure_index_value  5  u(32) \n      exposure_compensation_value_sign_flag  5  u(1) \n      exposure_compensation_value_numerator  5  u(16) \n      exposure_compensation_value_denom_idc  5  u(16) \n      ref_screen_luminance_white  5  u(32) \n      extended_range_white_level  5  u(32) \n      nominal_black_level_luma_code_value  5  u(16) \n      nominal_white_level_luma_code_value  5  u(16) \n      extended_white_level_luma_code_value  5  u(16) \n    }     \n  }     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  341 \n \nD.1.26  Frame packing arrangement SEI message syntax \n \nframe_packing_arrangement( payloadSize ) {  C  Descriptor \n  frame_packing_arrangement_id  5  ue(v) \n  frame_packing_arrangement_cancel_flag  5  u(1) \n  if( !frame_packing_arrangement_cancel_flag ) {     \n    frame_packing_arrangement_type  5  u(7) \n    quincunx_sampling_flag  5  u(1) \n    content_interpretation_type  5  u(6) \n    spatial_flipping_flag  5  u(1) \n    frame0_flipped_flag  5  u(1) \n    field_views_flag  5  u(1) \n    current_frame_is_frame0_flag  5  u(1) \n    frame0_self_contained_flag  5  u(1) \n    frame1_self_contained_flag  5  u(1) \n    if( !quincunx_sampling_flag  &&     \n      frame_packing_arrangement_type  !=  5 ) { \n      frame0_grid_position_x  5  u(4) \n      frame0_grid_position_y  5  u(4) \n      frame1_grid_position_x  5  u(4) \n      frame1_grid_position_y  5  u(4) \n    }     \n    frame_packing_arrangement_reserved_byte  5  u(8) \n    frame_packing_arrangement_repetition_period  5  ue(v) \n  }     \n  frame_packing_arrangement_extension_flag  5  u(1) \n}     \n \nD.1.27  Display orientation SEI message syntax \n \ndisplay_orientation( payloadSize ) {  C  Descriptor \n  display_orientation_cancel_flag  5  u(1) \n  if( !display_orientation_cancel_flag ) {     \n    hor_flip  5  u(1) \n    ver_flip  5  u(1) \n    anticlockwise_rotation  5  u(16) \n    display_orientation_repetition_period  5  ue(v) \n    display_orientation_extension_flag  5  u(1) \n  }     \n}     \n \nD.1.28  Green metadata SEI message syntax \nThe syntax for this SEI message is specified in ISO/IEC 23001-11 (Green metadata), which facilitates reduced power \nconsumption in decoders, encoders, displays, and in media selection. \n342  Rec. ITU-T H.264 (06/2019) \n \nD.1.29  Mastering display colour volume SEI message syntax \n \nmastering_display_colour_volume( payloadSize ) {  C  Descriptor \n  for( c = 0; c < 3; c++ ) {     \n    display_primaries_x[ c ]  5  u(16) \n    display_primaries_y[ c ]  5  u(16) \n  }     \n  white_point_x  5  u(16) \n  white_point_y  5  u(16) \n  max_display_mastering_luminance  5  u(32) \n  min_display_mastering_luminance  5  u(32) \n}     \n \n    Rec. ITU-T H.264 (06/2019)  343 \n \nD.1.30  Colour remapping information SEI message syntax \n \ncolour_remapping_info( payloadSize ) {  C  Descriptor \n  colour_remap_id  5  ue(v) \n  colour_remap_cancel_flag  5  u(1) \n  if( !colour_remap_cancel_flag ) {     \n    colour_remap_repetition_period  5  ue(v) \n    colour_remap_video_signal_info_present_flag  5  u(1) \n    if( colour_remap_video_signal_info_present_flag ) {     \n      colour_remap_full_range_flag  5  u(1) \n      colour_remap_primaries  5  u(8) \n      colour_remap_transfer_function  5  u(8) \n      colour_remap_matrix_coefficients  5  u(8) \n    }     \n    colour_remap_input_bit_depth  5  u(8) \n    colour_remap_output_bit_depth  5  u(8) \n    for( c = 0; c < 3; c++ ) {     \n      pre_lut_num_val_minus1[ c ]  5  u(8) \n      if( pre_lut_num_val_minus1[ c ] > 0 )     \n        for( i = 0; i  <=  pre_lut_num_val_minus1[ c ]; i++ ) {     \n          pre_lut_coded_value[ c ][ i ]  5  u(v) \n          pre_lut_target_value[ c ][ i ]  5  u(v) \n        }     \n    }     \n    colour_remap_matrix_present_flag  5  u(1) \n    if( colour_remap_matrix_present_flag ) {     \n      log2_matrix_denom  5  u(4) \n      for( c = 0; c < 3; c++ )     \n        for( i = 0; i < 3; i++ )     \n          colour_remap_coeffs[ c ][ i ]  5  se(v) \n    }     \n    for( c = 0; c < 3; c++ ) {     \n      post_lut_num_val_minus1[ c ]  5  u(8) \n      if( post_lut_num_val_minus1[ c ] > 0 )     \n        for( i = 0; i  <=  post_lut_num_val_minus1[ c ]; i++ ) {     \n          post_lut_coded_value[ c ][ i ]  5  u(v) \n          post_lut_target_value[ c ][ i ]  5  u(v) \n        }     \n    }     \n  }     \n}     \n \n344  Rec. ITU-T H.264 (06/2019) \n \nD.1.31  Content light level information SEI message syntax \n \ncontent_light_level_info( payloadSize ) {  C  Descriptor \n  max_content_light_level  5  u(16) \n  max_pic_average_light_level  5  u(16) \n}     \n \nD.1.32  Alternative transfer characteristics SEI message syntax \n \nalternative_transfer_characteristics( payloadSize ) {  C  Descriptor \n  preferred_transfer_characteristics  5  u(8) \n}     \n \nD.1.33  Content colour volume SEI message syntax \n \ncontent_colour_volume( payloadSize ) {  C  Descriptor \n  ccv_cancel_flag  5  u(1) \n  if( !ccv_cancel_flag ) {     \n    ccv_persistence_flag  5  u(1) \n    ccv_primaries_present_flag  5  u(1) \n    ccv_min_luminance_value_present_flag  5  u(1) \n    ccv_max_luminance_value_present_flag  5  u(1) \n    ccv_avg_luminance_value_present_flag  5  u(1) \n    ccv_reserved_zero_2bits  5  u(2) \n    if( ccv_primaries_present_flag )     \n      for( c = 0; c < 3; c++ ) {     \n        ccv_primaries_x[ c ]  5  i(32) \n        ccv_primaries_y[ c ]  5  i(32) \n      }     \n    if( ccv_min_luminance_value_present_flag )     \n      ccv_min_luminance_value  5  u(32) \n    if( ccv_max_luminance_value_present_flag )     \n      ccv_max_luminance_value  5  u(32) \n    if( ccv_avg_luminance_value_present_flag )     \n      ccv_avg_luminance_value  5  u(32) \n  }     \n}     \n \nD.1.34  Ambient viewing environment SEI message syntax \n \nambient_viewing_environment( payloadSize ) {  C  Descriptor \n  ambient_illuminance  5  u(32) \n  ambient_light_x  5  u(16) \n  ambient_light_y  5  u(16) \n}     \n \n    Rec. ITU-T H.264 (06/2019)  345 \n \nD.1.35  Syntax of omnidirectional video specific SEI messages \nD.1.35.1   Equirectangular projection SEI message syntax \n \nequirectangular_projection( payloadSize ) {  C  Descriptor \n  erp_cancel_flag  5  u(1) \n  if( !erp_cancel_flag )     \n    erp_persistence_flag  5  u(1) \n    erp_padding_flag  5  u(1) \n    erp_reserved_zero_2bits  5  u(2) \n    if( erp_padding_flag  = =  1 ) {     \n      gp_erp_type  5  u(3) \n      left_gb_erp_width  5  u(8) \n      right_gb_erp_width  5  u(8) \n    }     \n  }     \n}     \n \nD.1.35.2   Cubemap projection SEI message syntax \n \ncubemap_projection( payloadSize ) {  C  Descriptor \n  cmp_cancel_flag  5  u(1) \n  if( !cmp_cancel_flag )     \n    cmp_persistence_flag  5  u(1) \n}     \n \nD.1.35.3   Sphere rotation SEI message syntax \n \nsphere_rotation( payloadSize ) {  C  Descriptor \n  sphere_rotation_cancel_flag  5  u(1) \n  if( !sphere_rotation_cancel_flag ) {     \n    sphere_rotation_persistence_flag  5  u(1) \n    sphere_rotation_reserved_zero_6bits  5  u(6) \n    yaw_rotation  5  i(32) \n    pitch_rotation  5  i(32) \n    roll_rotation  5  i(32) \n  }     \n}     \n \n346  Rec. ITU-T H.264 (06/2019) \n \nD.1.35.4   Region-wise packing SEI message syntax \n \nregionwise_packing( payloadSize ) {  C  Descriptor \n  rwp_cancel_flag  5  u(1) \n  if( !rwp_cancel_flag ) {     \n    rwp_persistence_flag  5  u(1) \n    constituent_picture_matching_flag  5  u(1) \n    rwp_reserved_zero_5bits  5  u(5) \n    num_packed_regions  5  u(8) \n    proj_picture_width  5  u(32) \n    proj_picture_height  5  u(32) \n    packed_picture_width  5  u(16) \n    packed_picture_height  5  u(16) \n    for( i = 0; i < num_packed_regions; i++ ) {     \n      rwp_reserved_zero_4bits[ i ]  5  u(4) \n      transform_type[ i ]  5  u(3) \n      guard_band_flag[ i ]  5  u(1) \n      proj_region_width[ i ]  5  u(32) \n      proj_region_height[ i ]  5  u(32) \n      proj_region_top[ i ]  5  u(32) \n      proj_region_left[ i ]  5  u(32) \n      packed_region_width[ i ]  5  u(16) \n      packed_region_height[ i ]  5  u(16) \n      packed_region_top[ i ]  5  u(16) \n      packed_region_left[ i ]  5  u(16) \n      if( guard_band_flag[ i ] ) {     \n        left_gb_width[ i ]  5  u(8) \n        right_gb_width[ i ]  5  u(8) \n        top_gb_height[ i ]  5  u(8) \n        bottom_gb_height[ i ]  5  u(8) \n        gb_not_used_for_pred_flag[ i ]  5  u(1) \n        for( j = 0; j < 4; j++ )     \n          gb_type[ i ][ j ]  5  u(3) \n        rwp_gb_reserved_zero_3bits[ i ]  5  u(3) \n      }     \n    }     \n  }     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  347 \n \nD.1.35.5   Omnidirectional viewport SEI message syntax \n \nomni_viewport( payloadSize ) {  C  Descriptor \n  omni_viewport_id  5  u(10) \n  omni_viewport_cancel_flag  5  u(1) \n  if( !omni_viewport_cancel_flag ) {     \n    omni_viewport_persistence_flag  5  u(1) \n    omni_viewport_cnt_minus1  5  u(4) \n    for( i = 0; i  <=  omni_viewport_cnt_minus1; i++ ) {     \n      omni_viewport_azimuth_centre[ i ]  5  i(32) \n      omni_viewport_elevation_centre[ i ]  5  i(32) \n      omni_viewport_tilt_centre[ i ]  5  i(32) \n      omni_viewport_hor_range[ i ]  5  u(32) \n      omni_viewport_ver_range[ i ]  5  u(32) \n    }     \n  }     \n}     \n \nD.1.36  SEI manifest SEI message syntax \n \nsei_manifest( payloadSize ) {  C  Descriptor \n  manifest_num_sei_msg_types  5  u(16) \n  for( i = 0; i < manifest_num_sei_msg_types; i++ ) {     \n    manifest_sei_payload_type[ i ]  5  u(16) \n    manifest_sei_description[ i ]  5  u(8) \n  }     \n}     \n \nD.1.37  SEI prefix indication SEI message syntax \n \nsei_prefix_indication( payloadSize ) {  C  Descriptor \n  prefix_sei_payload_type  5  u(16) \n  num_sei_prefix_indications_minus1  5  u(8) \n  for( i = 0; i  <=  num_sei_prefix_indications_minus1; i++ ) {     \n    num_bits_in_prefix_indication_minus1[ i ]  5  u(16) \n    for( j = 0; j  <=  num_bits_in_prefix_indication_minus1[ i ]; j++ )     \n      sei_prefix_data_bit[ i ][ j ]  5  u(1) \n    while( !byte_aligned( ) )     \n      byte_alignment_bit_equal_to_one /* equal to 1 */  5  f(1) \n  }     \n}     \n \n348  Rec. ITU-T H.264 (06/2019) \n \nD.1.38  Reserved SEI message syntax \n \nreserved_sei_message( payloadSize ) {  C  Descriptor \n  for( i = 0; i < payloadSize; i++ )     \n    reserved_sei_message_payload_byte  5  b(8) \n}     \n \nD.2  SEI payload semantics \nD.2.1  General SEI payload semantics \nbit_equal_to_one shall be equal to 1. \nbit_equal_to_zero shall be equal to 0. \nThe semantics and persistence scope for each SEI message are specified in the semantics specification for each particular \nSEI message. \nThe values of some SEI message syntax elements, including pan_scan_rect_id, scene_id, second_scene_id, snapshot_id, \nprogressive_refinement_id, tone_map_id, frame_packing_arrangement_id, and colour_remap_id, are split into two sets of \nvalue ranges, where the first set is specified as \"may be used as determined by the application\", and the second set is \nspecified as \"reserved for future use by ITU-T | ISO/IEC\". Applications should be cautious of potential “collisions” of the \ninterpretation for values of these syntax elements belonging to the first set of value ranges. Since different applications \nmight use these IDs having values in the first set of value ranges for different purposes, particular care should be exercised \nin the design of encoders that generate SEI messages with these IDs having values in the first set of value ranges, and in \nthe design of decoders that interpret SEI messages with these IDs. This Specification does not define any management for \nthese values. These IDs having values in the first set of value ranges might only be suitable for use in contexts in which \n\"collisions\" of usage (i.e., different definitions of the syntax and semantics of an SEI message with one of these IDs having \nthe same value in the first set of value ranges) are unimportant, or not possible, or are managed – e.g., defined or managed \nin  the  controlling  application  or  transport  specification,  or  by  controlling  the  environment  in  which  bitstreams  are \ndistributed. \nD.2.2  Buffering period SEI message semantics \nThe presence of the buffering period SEI message in the bitstream is specified as follows: \n–  If NalHrdBpPresentFlag is equal to 1 or VclHrdBpPresentFlag is equal to 1, one buffering period SEI message can \nbe present in any access unit of the bitstream, and one buffering period SEI message shall be present in every IDR \naccess unit and every access unit associated with a recovery point SEI message. \n–  Otherwise (NalHrdBpPresentFlag is equal to 0 and VclHrdBpPresentFlag is equal to 0), no buffering period SEI \nmessages shall be present in any access unit of the bitstream. \nNOTE 1 – For some applications, the frequent presence of a buffering period SEI message may be desirable. \nA buffering period is specified as the set of access units between two instances of the buffering period SEI message in \ndecoding order. \nseq_parameter_set_id  specifies  the  sequence  parameter  set  for  the  current  coded  video  sequence.  The  value  of \nseq_parameter_set_id shall be equal to the value of seq_parameter_set_id in the picture parameter set referenced by the \nprimary coded picture associated with the buffering period SEI message. The value of seq_parameter_set_id shall be in \nthe range of 0 to 31, inclusive. \nNOTE 2 – When the sequence parameter set identified by seq_parameter_set_id is not already active, the buffering SEI message \nwill activate the identified sequence parameter set for the current coded video sequence as specified in clause 7.4.1.2.1. \ninitial_cpb_removal_delay[ SchedSelIdx ] specifies the delay for the SchedSelIdx-th CPB between the time of arrival in \nthe CPB of the first bit of the coded data associated with the access unit associated with the buffering period SEI message \nand the time of removal from the CPB of the coded data associated with the same access unit, for the first buffering period \nafter HRD initialization. The syntax element has a length in bits given by initial_cpb_removal_delay_length_minus1 + 1. \nIt is in units of a 90 kHz clock. initial_cpb_removal_delay[ SchedSelIdx ] shall not be equal to 0 and shall not exceed \n90000 * ( CpbSize[ SchedSelIdx ] ÷ BitRate[ SchedSelIdx ] ), the time-equivalent of the CPB size in 90 kHz clock units. \ninitial_cpb_removal_delay_offset[  SchedSelIdx  ]  is  used  for  the  SchedSelIdx-th  CPB  in  combination  with  the \ncpb_removal_delay  to  specify  the  initial  delivery  time  of  coded  access  units  to  the  CPB. \ninitial_cpb_removal_delay_offset[ SchedSelIdx ]  is  in  units  of  a  90  kHz  clock.  The \ninitial_cpb_removal_delay_offset[ SchedSelIdx ] syntax element is a fixed length code having a length in bits given by \n    Rec. ITU-T H.264 (06/2019)  349 \n \ninitial_cpb_removal_delay_length_minus1 + 1. This syntax element is not used by decoders and is needed only for the \ndelivery scheduler (HSS) specified in Annex C. \nOver  the  entire  coded  video  sequence,  the  sum  of  initial_cpb_removal_delay[ SchedSelIdx ]  and \ninitial_cpb_removal_delay_offset[ SchedSelIdx ] shall be constant for each value of SchedSelIdx. \nD.2.3  Picture timing SEI message semantics \nNOTE 1 – The syntax of the picture timing SEI message is dependent on the content of the sequence parameter set that is active for \nthe primary coded picture associated with the picture timing SEI message. However, unless the picture timing SEI message of an \nIDR access unit is preceded by a buffering period SEI message within the same access unit, the activation of the associated sequence \nparameter set (and, for IDR pictures that are not the first picture in the bitstream, the determination that the primary coded picture is \nan IDR picture) does not occur until the decoding of the first coded slice NAL unit of the primary coded picture. Since the coded \nslice NAL unit of the primary coded picture follows the picture timing SEI message in NAL unit order, there may be cases in which \nit is necessary for a decoder to store the RBSP containing the picture timing SEI message until determining the parameters of the \nsequence parameter that will be active for the primary coded picture, and then perform the parsing of the picture timing SEI message. \nThe presence of the picture timing SEI message in the bitstream is specified as follows: \n–  If CpbDpbDelaysPresentFlag is equal to 1 or pic_struct_present_flag is equal to 1, one picture timing SEI message \nshall be present in every access unit of the coded video sequence. \n–  Otherwise (CpbDpbDelaysPresentFlag is equal to 0 and pic_struct_present_flag is equal to 0), no picture timing SEI \nmessages shall be present in any access unit of the coded video sequence. \ncpb_removal_delay specifies how many clock ticks (see clause E.2.1) to wait after removal from the CPB of the access \nunit associated with the most recent buffering period SEI message in a preceding access unit before removing from the \nbuffer the access unit data associated with the picture timing SEI message. This value is also used to calculate an earliest \npossible time of arrival of access unit data into the CPB for the HSS, as specified in Annex C. The syntax element is a \nfixed length code having a length in bits given by cpb_removal_delay_length_minus1 + 1. The cpb_removal_delay is the \nremainder of a modulo 2(cpb_removal_delay_length_minus1 + 1) counter. \nNOTE 2  –  The  value  of  cpb_removal_delay_length_minus1  that  determines  the  length  (in  bits)  of  the  syntax  element \ncpb_removal_delay is the value of cpb_removal_delay_length_minus1 coded in the sequence parameter set that is active for the \nprimary coded picture associated with the picture timing SEI message, although cpb_removal_delay specifies a number of clock \nticks relative to the removal time of the preceding access unit containing a buffering period SEI message, which may be an access \nunit of a different coded video sequence. \ndpb_output_delay is used to compute the DPB output time of the picture. It specifies how many clock ticks to wait after \nremoval of an access unit from the CPB before the decoded picture can be output from the DPB (see clause C.2). \nNOTE 3 – A picture is not removed from the DPB at its output time when it is still marked as \"used for short-term reference\" or \n\"used for long-term reference\". \nNOTE 4 – Only one dpb_output_delay is specified for a decoded picture. \nThe length of the syntax element dpb_output_delay is given in bits by dpb_output_delay_length_minus1 + 1. When \nmax_dec_frame_buffering is equal to 0, dpb_output_delay shall be equal to 0. \nThe output time derived from the dpb_output_delay of any picture that is output from an output timing conforming decoder \nas specified in clause C.2 shall precede the output time derived from the dpb_output_delay of all pictures in any subsequent \ncoded video sequence in decoding order. \nThe  output  time  derived  from  the  dpb_output_delay  of  the  second  field,  in  decoding  order,  of  a  complementary \nnon-reference field pair shall exceed the output time derived from the dpb_output_delay of the first field of the same \ncomplementary non-reference field pair. \nThe picture output order established by the values of this syntax element shall be the same order as established by the \nvalues of PicOrderCnt( ) as specified in clauses C.4.1 to C.4.5, except that when the two fields of a complementary \nreference field pair have the same value of PicOrderCnt( ), the two fields have different output times. \nFor pictures that are not output by the \"bumping\" process of clause C.4.5 because they precede, in decoding order, an IDR \npicture  with  no_output_of_prior_pics_flag  equal  to  1  or  inferred  to  be  equal  to  1,  the  output  times  derived  from \ndpb_output_delay shall be increasing with increasing value of PicOrderCnt( ) relative to all pictures within the same coded \nvideo sequence subsequent to any picture having a memory_management_control_operation equal to 5. \npic_struct indicates whether a picture should be displayed as a frame or one or more fields, according to Table D-1. Frame \ndoubling (pic_struct equal to 7) indicates that the frame should be displayed two times consecutively, and frame tripling \n(pic_struct equal to 8) indicates that the frame should be displayed three times consecutively. \nNOTE 5 – Frame doubling can facilitate the display, for example, of 25p video on a 50p display and 29.97p video on a 59.94p \ndisplay. Using frame doubling and frame tripling in combination on every other frame can facilitate the display of 23.98p video on \na 59.94p display. \n350  Rec. ITU-T H.264 (06/2019) \n \nWhen pic_struct is present (pic_struct_present_flag is equal to 1), the constraints specified in the third column of Table D-1 \nshall be obeyed. \nNOTE 6 – When pic_struct_present_flag is equal to 0, then in many cases default values may be inferred. In the absence of other \nindications of the intended display type of a picture, the decoder should infer the value of pic_struct as follows: \n–  If field_pic_flag is equal to 1, pic_struct should be inferred to be equal to (1 + bottom_field_flag). \n–  Otherwise, if TopFieldOrderCnt is equal to BottomFieldOrderCnt, pic_struct should be inferred to be equal to 0. \n–  Otherwise, if TopFieldOrderCnt is less than BottomFieldOrderCnt, pic_struct should be inferred to be equal to 3. \n–  Otherwise (field_pic_flag is equal to 0 and TopFieldOrderCnt is greater than BottomFieldOrderCnt), pic_struct should be \ninferred to be equal to 4. \npic_struct is only a hint as to how the decoded video should be displayed on an assumed display type (e.g., interlaced or progressive) \nat an assumed display rate. When another display type or display rate is used by the decoder, then pic_struct does not indicate the \ndisplay method, but may aid in processing the decoded video for the alternative display. When it is desired for pic_struct to have an \neffective value in the range of 5 to 8, inclusive, pic_struct_present_flag should be equal to 1, as the above inference rule will not \nproduce these values. \nTable D-1 – Interpretation of pic_struct \n \nValue  Indicated display of picture  Restrictions  NumClockTS \n0  (progressive) frame  field_pic_flag shall be 0,  1 \nTopFieldOrderCnt shall be equal to \nBottomFieldOrderCnt \n1  top field  field_pic_flag shall be 1,  1 \nbottom_field_flag shall be 0 \n2  bottom field  field_pic_flag shall be 1,  1 \nbottom_field_flag shall be 1 \n3  top field, bottom field, in that order  field_pic_flag shall be 0,  2 \nTopFieldOrderCnt shall be less than or \nequal to BottomFieldOrderCnt \n4  bottom field, top field, in that order  field_pic_flag shall be 0,  2 \nBottomFieldOrderCnt shall be less than \nor equal to TopFieldOrderCnt \n5  top field, bottom field, top field repeated,  field_pic_flag shall be 0,  3 \nin that order  TopFieldOrderCnt shall be less than or \nequal to BottomFieldOrderCnt \n6  bottom  field,  top  field,  bottom  field  field_pic_flag shall be 0,  3 \nrepeated, in that order  BottomFieldOrderCnt shall be less than \nor equal to TopFieldOrderCnt \n7  frame doubling   field_pic_flag shall be 0,  2  \nfixed_frame_rate_flag shall be 1, \nTopFieldOrderCnt shall be equal to \nBottomFieldOrderCnt \n8  frame tripling   field_pic_flag shall be 0,  3  \nfixed_frame_rate_flag shall be 1, \nTopFieldOrderCnt shall be equal to \nBottomFieldOrderCnt \n9..15  reserved     \n \nWhen fixed_frame_rate_flag is equal to 1, it is a requirement of bitstream conformance that the constraints specified as \nfollows shall be obeyed throughout the operation of the following process, which is operated in output order. \n1.  Prior to output of the first picture of the bitstream (in output order) and prior to the output of the first picture (in \noutput order) of each subsequent coded video sequence for which the content of the active sequence parameter set \ndiffers from that of the previously-active sequence parameter set, the variable lastFieldBottom is set equal to \"not \ndetermined\". \n    Rec. ITU-T H.264 (06/2019)  351 \n \n2.  After the output of each picture, the value of lastFieldBottom is checked and set as follows, using the values of \nfield_pic_flag, bottom_field_flag, pic_struct, TopFieldOrderCnt and BottomFieldOrderCnt (when applicable) for \nthe picture that was output. \n–  If field_pic_flag is equal to 1, it is a requirement of bitstream conformance that the value of lastFieldBottom \nshall not be equal to bottom_field_flag. The value of lastFieldBottom is then set equal to bottom_field_flag. \n–  Otherwise (field_pic_flag is equal to 0), the following applies: \n–  If pic_struct is present and is equal to 3 or 5, it is a requirement of bitstream conformance that the value \nof  lastFieldBottom  shall  not  be  equal  to  0.  The  value  of  lastFieldBottom  is  then  set  equal  to \n1 − ( ( pic_struct − 1 ) >> 2 ). \n–  Otherwise, if pic_struct is present and is equal to 4 or 6, it is a requirement of bitstream conformance \nthat the value of lastFieldBottom shall not be equal to 1. The value of lastFieldBottom is then set equal \nto ( ( pic_struct − 1 ) >> 2 ). \n–  Otherwise, if TopFieldOrderCnt is less than BottomFieldOrderCnt, it is a requirement of bitstream \nconformance that the value of lastFieldBottom shall not be equal to 0.  The value of lastFieldBottom is \nthen set equal to 1. \n–  Otherwise, if TopFieldOrderCnt is greater than BottomFieldOrderCnt, it is a requirement of bitstream \nconformance that the value of lastFieldBottom shall not be equal to 1. The value of lastFieldBottom is \nthen set equal to 0. \n–  Otherwise (TopFieldOrderCnt is equal to BottomFieldOrderCnt and pic_struct is not present or is not \nin the range of 3 to 6, inclusive), lastFieldBottom may have any value, and its value is not changed. \nNumClockTS is determined by pic_struct as specified in Table D-1. There are up to NumClockTS sets of clock timestamp \ninformation for a picture, as specified by clock_timestamp_flag[ i ] for each set. The sets of clock timestamp information \napply to the field(s) or the frame(s) associated with the picture by pic_struct. \nThe contents of the clock timestamp syntax elements indicate a time of origin, capture, or alternative ideal display. This \nindicated time is computed as \nclockTimestamp = ( ( hH * 60 + mM ) * 60 + sS ) * time_scale +  \n                    nFrames * ( num_units_in_tick * ( 1 + nuit_field_based_flag ) ) + tOffset,  (D-1) \nin units of clock ticks of a clock with clock frequency equal to time_scale Hz, relative to some unspecified point in time \nfor  which  clockTimestamp  is  equal  to  0.  Output  order  and  DPB  output  timing  are  not  affected  by  the  value  of \nclockTimestamp. When two or more frames with pic_struct equal to 0 are consecutive in output order and have equal \nvalues of clockTimestamp, the indication is that the frames represent the same content and that the last such frame in output \norder is the preferred representation. \nNOTE 7 – clockTimestamp time indications may aid display on devices with refresh rates other than those well-matched to DPB \noutput times. \nclock_timestamp_flag[ i ] equal to 1 indicates that a number of clock timestamp syntax elements are present and follow \nimmediately. clock_timestamp_flag[ i ] equal to 0 indicates that the associated clock timestamp syntax elements are not \npresent. When NumClockTS is greater than 1 and clock_timestamp_flag[ i ] is equal to 1 for more than one value of i, the \nvalue of clockTimestamp shall be non-decreasing with increasing value of i. \nct_type indicates the scan type (interlaced or progressive) of the source material as specified in Table D-2. \nTwo fields of a coded frame may have different values of ct_type. \nWhen clockTimestamp is equal for two fields of opposite parity that are consecutive in output order, both with ct_type \nequal to 0 (progressive) or ct_type equal to 2 (unknown), the two fields are indicated to have come from the same original \nprogressive frame. Two consecutive fields in output order shall have different values of clockTimestamp when the value \nof ct_type for either field is 1 (interlaced). \n352  Rec. ITU-T H.264 (06/2019) \n \nTable D-2 – Mapping of ct_type to source picture scan \n \nOriginal  \nValue \npicture scan \n0  progressive \n1  interlaced \n2  unknown \n3  reserved \n \nnuit_field_based_flag is used in calculating clockTimestamp, as specified in Equation D-1. \ncounting_type specifies the method of dropping values of the n_frames as specified in Table D-3. \nTable D-3 – Definition of counting_type values \n \nValue  Interpretation \n0  no  dropping  of  n_frames  count  values  and  no  use  of \ntime_offset \n1  no dropping of n_frames count values \n2  dropping of individual zero values of n_frames count \n3  dropping of individual MaxFPS − 1 values of n_frames \ncount \n4  dropping  of  the  two  lowest  (value  0  and  1)  n_frames \ncounts  when  seconds_value  is  equal  to 0  and \nminutes_value is not an integer multiple of 10 \n5  dropping of unspecified individual n_frames count values \n6  dropping of unspecified numbers of unspecified n_frames \ncount values \n7..31  reserved \n \nfull_timestamp_flag equal to 1 specifies that the n_frames syntax element is followed by seconds_value, minutes_value, \nand hours_value. full_timestamp_flag equal to 0 specifies that the n_frames syntax element is followed by seconds_flag. \ndiscontinuity_flag equal to 0 indicates that the difference between the current value of clockTimestamp and the value of \nclockTimestamp computed from the previous clock timestamp in output order can be interpreted as the time difference \nbetween the times of origin or capture of the associated frames or fields. discontinuity_flag equal to 1 indicates that the \ndifference between the current value of clockTimestamp and the value of clockTimestamp computed from the previous \nclock timestamp in output order should not be interpreted as the time difference between the times of origin or capture of \nthe associated frames or fields. When discontinuity_flag is equal to 0, the value of clockTimestamp shall be greater than \nor equal to all values of clockTimestamp present for the preceding picture in DPB output order. \ncnt_dropped_flag specifies the skipping of one or more values of n_frames using the counting method specified by \ncounting_type. \nn_frames specifies the value of nFrames used to compute clockTimestamp. n_frames shall be less than \nMaxFPS = Ceil( time_scale ÷ ( 2 * num_units_in_tick ) )  (D-2) \nNOTE 8 – n_frames is a frame-based counter. For field-specific timing indications, time_offset should be used to indicate a distinct \nclockTimestamp for each field. \nWhen counting_type is equal to 2 and cnt_dropped_flag is equal to 1, n_frames shall be equal to 1 and the value of \nn_frames for the previous picture in output order shall not be equal to 0 unless discontinuity_flag is equal to 1. \nNOTE 9 – When counting_type is equal to 2, the need for increasingly large magnitudes of tOffset in Equation D-1 when using \nfixed non-integer frame rates (e.g., 12.5 frames per second with time_scale equal to 50 and num_units_in_tick equal to 2 and \n    Rec. ITU-T H.264 (06/2019)  353 \n \nnuit_field_based_flag equal to 0) can be avoided by occasionally skipping over the value n_frames equal to 0 when counting (e.g., \ncounting  n_frames  from  0  to 12,  then  incrementing  seconds_value  and  counting  n_frames  from  1  to 12,  then  incrementing \nseconds_value and counting n_frames from 0 to 12, etc.). \nWhen counting_type is equal to 3 and cnt_dropped_flag is equal to 1, n_frames shall be equal to 0 and the value of \nn_frames for the previous picture in output order shall not be equal to MaxFPS − 1 unless discontinuity_flag is equal to 1. \nNOTE 10 – When counting_type is equal to 3, the need for increasingly large magnitudes of tOffset in Equation D-1 when using \nfixed non-integer frame rates (e.g., 12.5 frames per second with time_scale equal to 50 and num_units_in_tick equal to 2 and \nnuit_field_based_flag equal to 0) can be avoided by occasionally skipping over the value n_frames equal to MaxFPS − 1 when \ncounting (e.g., counting n_frames from 0 to 12, then incrementing seconds_value and counting n_frames from 0 to 11, then \nincrementing seconds_value and counting n_frames from 0 to 12, etc.). \nWhen counting_type is equal to 4 and cnt_dropped_flag is equal to 1, n_frames shall be equal to 2 and the specified value \nof sS shall be zero and the specified value of mM shall not be an integer multiple of ten and n_frames for the previous \npicture in output order shall not be equal to 0 or 1 unless discontinuity_flag is equal to 1. \nNOTE 11 – When counting_type is equal to 4, the need for increasingly large magnitudes of tOffset in Equation D-1 when using \nfixed non-integer frame rates (e.g., 30000÷1001 frames per second with time_scale equal to 60000 and num_units_in_tick equal \nto 1 001 and nuit_field_based_flag equal to 1) can be reduced by occasionally skipping over the values of n_frames equal to 0 and 1 \nwhen counting (e.g., counting n_frames from 0 to 29, then incrementing seconds_value and counting n_frames from 0 to 29, etc., \nuntil the seconds_value is zero and minutes_value is not an integer multiple of ten, then counting n_frames from 2 to 29, then \nincrementing seconds_value and counting n_frames from 0 to 29, etc.). This counting method is well known in industry and is often \nreferred to as \"NTSC drop-frame\" counting. \nWhen counting_type is equal to 5 or 6 and cnt_dropped_flag is equal to 1, n_frames shall not be equal to 1 plus the value \nof n_frames for the previous picture in output order modulo MaxFPS unless discontinuity_flag is equal to 1. \nNOTE 12 – When counting_type is equal to 5 or 6, the need for increasingly large magnitudes of tOffset in Equation D-1 when \nusing fixed non-integer frame rates can be avoided by occasionally skipping over some values of n_frames when counting. The \nspecific values of n_frames that are skipped are not specified when counting_type is equal to 5 or 6. \nseconds_flag equal to 1 specifies that seconds_value and minutes_flag are present when full_timestamp_flag is equal to 0. \nseconds_flag equal to 0 specifies that seconds_value and minutes_flag are not present. \nseconds_value specifies the value of sS used to compute clockTimestamp. The value of seconds_value shall be in the \nrange of 0 to 59, inclusive. When seconds_value is not present, the previous seconds_value in decoding order shall be used \nas sS to compute clockTimestamp. \nminutes_flag equal to 1 specifies that minutes_value and hours_flag are present when full_timestamp_flag is equal to 0 \nand seconds_flag is equal to 1. minutes_flag equal to 0 specifies that minutes_value and hours_flag are not present. \nminutes_value specifies the value of mM used to compute clockTimestamp. The value of minutes_value shall be in the \nrange of 0 to 59, inclusive. When minutes_value is not present, the previous minutes_value in decoding order shall be used \nas mM to compute clockTimestamp. \nhours_flag equal to 1 specifies that hours_value is present when full_timestamp_flag is equal to 0 and seconds_flag is \nequal to 1 and minutes_flag is equal to 1. \nhours_value specifies the value of hH used to compute clockTimestamp. The value of hours_value shall be in the range \nof 0 to 23, inclusive. When hours_value is not present, the previous hours_value in decoding order shall be used as hH to \ncompute clockTimestamp. \ntime_offset  specifies  the  value  of  tOffset  used  to  compute  clockTimestamp.  The  number  of  bits  used  to  represent \ntime_offset shall be equal to time_offset_length. When time_offset is not present, the value 0 shall be used as tOffset to \ncompute clockTimestamp. \nD.2.4  Pan-scan rectangle SEI message semantics \nThe pan-scan rectangle SEI message syntax elements specify the coordinates of a rectangle relative to the cropping \nrectangle of the sequence parameter set. Each coordinate of this rectangle is specified in units of one-sixteenth sample \nspacing relative to the luma sampling grid. \npan_scan_rect_id contains an identifying number that may be used to identify the purpose of the pan-scan rectangle (for \nexample, to identify the rectangle as the area to be shown on a particular display device or as the area that contains a \nparticular actor in the scene). The value of pan_scan_rect_id shall be in the range of 0 to 232 − 2, inclusive. \nValues of pan_scan_rect_id from 0 to 255, inclusive, and from 512 to 231 − 1, inclusive, may be used as determined by the \napplication. Values of pan_scan_rect_id from 256 to 511, inclusive, and from 231 to 232 − 2, inclusive, are reserved for \nfuture use by ITU-T | ISO/IEC. Decoders encountering a value of pan_scan_rect_id in the range of 256 to 511, inclusive, \nor in the range of 231 to 232 − 2, inclusive, shall ignore it. \n354  Rec. ITU-T H.264 (06/2019) \n \npan_scan_rect_cancel_flag equal to 1 indicates that the SEI message cancels the persistence of any previous pan-scan \nrectangle SEI message in output order. pan_scan_rect_cancel_flag equal to 0 indicates that pan-scan rectangle information \nfollows. \npan_scan_cnt_minus1  specifies  the  number  of  pan-scan  rectangles  that  are  present  in  the  SEI  message. \npan_scan_cnt_minus1 shall be in the range of 0 to 2, inclusive. pan_scan_cnt_minus1 equal to 0 indicates that a single \npan-scan rectangle is present that applies to all fields of the decoded picture. pan_scan_cnt_minus1 shall be equal to 0 \nwhen the current picture is a field. pan_scan_cnt_minus1 equal to 1 indicates that two pan-scan rectangles are present, the \nfirst of which applies to the first field of the picture in output order and the second of which applies to the second field of \nthe picture in output order. pan_scan_cnt_minus1 equal to 2 indicates that three pan-scan rectangles are present, the first \nof which applies to the first field of the picture in output order, the second of which applies to the second field of the picture \nin output order, and the third of which applies to a repetition of the first field as a third field in output order. \npan_scan_rect_left_offset[ i ],  pan_scan_rect_right_offset[ i ],  pan_scan_rect_top_offset[ i ],  and \npan_scan_rect_bottom_offset[ i ], specify, as signed integer quantities in units of one-sixteenth sample spacing relative \nto the luma sampling grid, the location of the pan-scan rectangle. The values of each of these four syntax elements shall \nbe in the range of −231 + 1 to 231 − 1, inclusive. \nThe pan-scan rectangle is specified, in units of one-sixteenth sample spacing relative to a luma frame sampling grid, as the \nregion with frame horizontal coordinates from 16*CropUnitX * frame_crop_left_offset + pan_scan_rect_left_offset[ i ] to \n16 * ( 16 * PicWidthInMbs − CropUnitX * frame_crop_right_offset ) +  pan_scan_rect_right_offset[ i ] − 1  and  with \nvertical  coordinates  from  16 *CropUnitY * frame_crop_top_offset +  pan_scan_rect_top_offset[ i ]  to \n16 * ( 16 * PicHeightInMbs − CropUnitY * frame_crop_bottom_offset ) +  pan_scan_rect_bottom_offset[ i ] − 1, \ninclusive. The value of 16 * CropUnitX * frame_crop_left_offset + pan_scan_rect_left_offset[ i ] shall be less than or \nequal to 16 * ( 16 * PicWidthInMbs − CropUnitX * frame_crop_right_offset ) + pan_scan_rect_right_offset[ i ] − 1; and \nthe  value  of  16 * CropUnitY * frame_crop_top_offset + pan_scan_rect_top_offset[ i ]  shall  be  less  than  or  equal  to \n16 * ( 16 * PicHeightInMbs − CropUnitY * frame_crop_bottom_offset ) + pan_scan_rect_bottom_offset[ i ] − 1. \nWhen the pan-scan rectangular area includes samples outside of the cropping rectangle, the region outside of the cropping \nrectangle may be filled with synthesized content (such as black video content or neutral grey video content) for display. \npan_scan_rect_repetition_period specifies the persistence of the pan-scan rectangle SEI message and may specify a \npicture order count interval within which another pan-scan rectangle SEI message with the same value of pan_scan_rect_id \nor the end of the coded video sequence shall be present in the bitstream. The value of pan_scan_rect_repetition_period \nshall  be  in  the  range  of  0  to  16 384,  inclusive.  When  pan_scan_cnt_minus1  is  greater  than  0, \npan_scan_rect_repetition_period shall not be greater than 1. \npan_scan_rect_repetition_period equal to 0 specifies that the pan-scan rectangle information applies to the current decoded \npicture only. \npan_scan_rect_repetition_period equal to 1 specifies that the pan-scan rectangle information persists in output order until \nany of the following conditions are true: \n–  A new coded video sequence begins. \n–  A picture in an access unit containing a pan-scan rectangle SEI message with the same value of pan_scan_rect_id is \noutput having PicOrderCnt( ) greater than PicOrderCnt( CurrPic ). \npan_scan_rect_repetition_period equal to 0 or equal to 1 indicates that another pan-scan rectangle SEI message with the \nsame value of pan_scan_rect_id may or may not be present. \npan_scan_rect_repetition_period greater than 1 specifies that the pan-scan rectangle information persists until any of the \nfollowing conditions are true: \n–  A new coded video sequence begins. \n–  A picture in an access unit containing a pan-scan rectangle SEI message with the same value of pan_scan_rect_id is \noutput having PicOrderCnt( ) greater than PicOrderCnt( CurrPic ) and less than or equal to PicOrderCnt( CurrPic ) + \npan_scan_rect_repetition_period. \npan_scan_rect_repetition_period greater than 1 indicates that another pan-scan rectangle SEI message with the same value \nof pan_scan_rect_id shall be present for a picture in an access unit that is output having PicOrderCnt( ) greater than \nPicOrderCnt( CurrPic ) and less than or equal to PicOrderCnt( CurrPic ) + pan_scan_rect_repetition_period; unless the \nbitstream ends or a new coded video sequence begins without output of such a picture. \nD.2.5  Filler payload SEI message semantics \nThis message contains a series of payloadSize bytes of value 0xFF, which can be discarded. \nff_byte shall be a byte having the value 0xFF. \n    Rec. ITU-T H.264 (06/2019)  355 \n \nD.2.6  User data registered by Rec. ITU-T T.35 SEI message semantics \nThis message contains user data registered as specified by Rec. ITU-T T.35, the contents of which are not specified by this \nRecommendation | International Standard. \nitu_t_t35_country_code shall be a byte having a value specified as a country code by Rec. ITU-T T.35 Annex A. \nitu_t_t35_country_code_extension_byte shall be a byte having a value specified as a country code by Rec. ITU-T T.35 \nAnnex B. \nitu_t_t35_payload_byte shall be a byte containing data registered as specified by Rec. ITU-T T.35. \nThe ITU-T T.35 terminal provider code and terminal provider oriented code shall be contained in the first one or more \nbytes of the itu_t_t35_payload_byte, in the format specified by the Administration that issued the terminal provider code. \nAny remaining itu_t_t35_payload_byte data shall be data having syntax and semantics as specified by the entity identified \nby the ITU-T T.35 country code and terminal provider code. \nD.2.7  User data unregistered SEI message semantics \nThis message contains unregistered user data identified by a UUID, the contents of which are not specified by this \nRecommendation | International Standard. \nuuid_iso_iec_11578 shall have a value specified as a UUID according to the procedures of ISO/IEC 11578:1996 Annex A. \nuser_data_payload_byte shall be a byte containing data having syntax and semantics as specified by the UUID generator. \nD.2.8  Recovery point SEI message semantics \nThe recovery point SEI message assists a decoder in determining when the decoding process will produce acceptable \npictures for display after the decoder initiates random access or after the encoder indicates a broken link in the coded video \nsequence. When the decoding process is started with the access unit in decoding order associated with the recovery point \nSEI message, all decoded pictures at or subsequent to the recovery point in output order specified in this SEI message are \nindicated to be correct or approximately correct in content. Decoded pictures produced by random access at or before the \npicture associated with the recovery point SEI message need not be correct in content until the indicated recovery point, \nand the operation of the decoding process starting at the picture associated with the recovery point SEI message may \ncontain references to pictures not available in the decoded picture buffer. \nIn addition, by use of the broken_link_flag, the recovery point SEI message can indicate to the decoder the location of \nsome pictures in the bitstream that can result in serious visual artefacts when displayed, even when the decoding process \nwas begun at the location of a previous IDR access unit in decoding order. \nNOTE 1 – The broken_link_flag can be used by encoders to indicate the location of a point after which the decoding process for the \ndecoding of some pictures may cause references to pictures that, though available for use in the decoding process, are not the pictures \nthat were used for reference when the bitstream was originally encoded (e.g., due to a splicing operation performed during the \ngeneration of the bitstream). \nThe recovery point is specified as a count in units of frame_num increments subsequent to the frame_num of the current \naccess unit at the position of the SEI message. \nNOTE 2 – When HRD information is present in the bitstream, a buffering period SEI message should be associated with the access \nunit associated with the recovery point SEI message in order to establish initialization of the HRD buffer model after a random \naccess. \nAny picture parameter set RBSP that is referred to by a picture associated with a recovery point SEI message or by any \npicture following such a picture in decoding order shall be available to the decoding process prior to its activation, \nregardless of whether or not the decoding process is started at the beginning of the bitstream or with the access unit, in \ndecoding order, that is associated with the recovery point SEI message. \nAny sequence parameter set RBSP that is referred to by a picture associated with a recovery point SEI message or by any \npicture following such a picture in decoding order shall be available to the decoding process prior to its activation, \nregardless of whether or not the decoding process is started at the beginning of the bitstream or with the access unit, in \ndecoding order, that is associated with the recovery point SEI message. \nrecovery_frame_cnt specifies the recovery point of output pictures in output order. All decoded pictures in output order \nare indicated to be correct or approximately correct in content starting at the output order position of the reference picture \nhaving the frame_num equal to the frame_num of the VCL NAL units  for the current access unit incremented by \nrecovery_frame_cnt  in  modulo  MaxFrameNum  arithmetic.  recovery_frame_cnt  shall  be  in  the  range  of  0  to \nMaxFrameNum − 1, inclusive. \nexact_match_flag indicates whether decoded pictures at and subsequent to the specified recovery point in output order \nderived by starting the decoding process at the access unit associated with the recovery point SEI message shall be an exact \nmatch to the pictures that would be produced by starting the decoding process at the location of a previous IDR access unit \n356  Rec. ITU-T H.264 (06/2019) \n \nin the NAL unit stream. The value 0 indicates that the match need not be exact and the value 1 indicates that the match \nshall be exact. \nWhen decoding starts from the location of the recovery point SEI message, all references to not available reference pictures \nshall be inferred as references to pictures containing only macroblocks coded using Intra macroblock prediction modes \nand  having  sample  values  given  by  Y  samples  equal  to  ( 1 << ( BitDepth  − 1 ) ),  Cb  samples  equal  to \nY\n( 1 << ( BitDepth  − 1 ) ), and Cr samples equal to ( 1 << ( BitDepth  − 1 ) ) (mid-level grey) for purposes of determining \nC C\nthe conformance of the value of exact_match_flag. \nNOTE 3 – When performing random access, decoders should infer all references to not available reference pictures as references to \npictures containing only intra macroblocks and having sample values given by Y equal to ( 1 << ( BitDepth  − 1 ) ), Cb equal to \nY\n( 1 << ( BitDepth  − 1 ) ), and Cr equal to ( 1 << ( BitDepth  − 1 ) ) (mid-level grey), regardless of the value of exact_match_flag. \nC C\nWhen exact_match_flag is equal to 0, the quality of the approximation at the recovery point is chosen by the encoding \nprocess and is not specified by this Recommendation | International Standard. \nNOTE 4 – Under some circumstances, the decoding process of pictures depends on the difference DiffPicOrderCnt( picA, picB ) \nbetween the PicOrderCnt( ) values for two pictures picA and picB. However, no particular values of TopFieldOrderCnt and \nBottomFieldOrderCnt (as applicable) are specified to be assigned to the reference pictures that are not available due to the initiation \nof random access at the location of a picture associated with a recovery point SEI message. Also, no particular value has been \nspecified  for  initialization  (for  random  access  purposes)  of  the  related  variables  prevPicOrderCntMsb,  prevPicOrderCntLsb, \nprevFraneNumOffset, and prevFrameNum. Thus, any values for these variables may be assigned that could hypothetically have \nresulted from operation of the decoding process starting with a hypothetical preceding IDR picture in decoding order, although such \nvalues may not be the same as the values that would have been obtained if the decoding process had started with the actual preceding \nIDR picture in the bitstream. When performing random access at a picture associated with a recovery point SEI message, it is \nsuggested that decoders should derive the picture order count variables TopFieldOrderCnt and BottomFieldOrderCnt according to \nthe following method: \n–  A bit range greater than 32 bits should be allocated for the variables TopFieldOrderCnt and BottomFieldOrderCnt for each \ncurrent picture to be decoded, as well as for the intermediate variables used for deriving these variables as specified in \nclause 8.2.1. (Due to the lack of assurance of correspondence of the values used for initialization of the related variables when \nrandom access is performed to the values that would be obtained if the decoding process had begun with the preceding IDR \npicture in decoding order, the calculations involving these variables in the decoding process of subsequent pictures may result \nin violation of the 32 bit range.) \n–  Any value within in the range of −231 to 231 − 1, inclusive, may be assigned to the values of the variables TopFieldOrderCnt \nand BottomFieldOrderCnt of the reference pictures that are not available due to the random access operation. For example, the \nvalue 0 may be assigned to these variables. \n–  For  the  derivation  of  the  picture  order  count  variables  for  the  picture  at  which  random  access  is  performed, \nprevPicOrderCntMsb may be set equal to any integer multiple of MaxPicOrderCntLsb in the range of −231 to 231 − 1, inclusive, \nprevPicOrderCntLsb  may  be  set  equal  to  any  value  in  the  range  of  0  to  MaxPicOrderCntLsb − 1,  inclusive, \nprevFrameNumOffset may be set equal to any integer multiple of MaxFrameNum in the range of 0 to 231 − 1, inclusive, and \nprevFrameNum may be set equal to any value in the range of 0 to MaxFrameNum − 1, inclusive. For example, the value 0 may \nbe assigned to all of the variables prevPicOrderCntMsb, prevPicOrderCntLsb, prevFrameNumOffset, and prevFrameNum. \nWhen exact_match_flag is equal to 1, it is a requirement of bitstream conformance that the values of the samples in the \ndecoded pictures at or subsequent to the recovery point in output order shall be independent of the values that a decoder \nassigns to the variables prevPicOrderCntMsb, prevPicOrderCntLsb, prevFrameNumOffset, and prevFrameNum used in \nclause 8.2.1 for deriving the picture order count variables for the  initialization of the decoding process at the picture \nassociated  with  the  recovery  point  SEI  message,  and  of  the  values  that  are  assigned  to  the  TopFieldOrderCnt  and \nBottomFieldOrderCnt variables of the reference pictures that are not available due to the random access operation. \nbroken_link_flag indicates the presence or absence of a broken link in the NAL unit stream at the location of the recovery \npoint SEI message and is assigned further semantics as follows: \n–  If broken_link_flag is equal to 1, pictures produced by starting the decoding process at the location of a previous IDR \naccess unit may contain undesirable visual artefacts to the extent that decoded pictures at and subsequent to the access \nunit associated with the recovery point SEI message in decoding order should not be displayed until the specified \nrecovery point in output order. \n–  Otherwise (broken_link_flag is equal to 0), no indication is given regarding any potential presence of visual artefacts. \nRegardless of the value of the broken_link_flag, pictures subsequent to the specified recovery point in output order are \nspecified to be correct or approximately correct in content. \nNOTE 5 – When a sub-sequence information SEI message is present in conjunction with a recovery point SEI message in which \nbroken_link_flag is equal to 1 and when sub_seq_layer_num is equal to 0, sub_seq_id should be different from the latest sub_seq_id \nfor sub_seq_layer_num equal to 0 that was decoded prior to the location of the recovery point SEI message. When broken_link_flag \nis equal to 0, the sub_seq_id in sub-sequence layer 0 should remain unchanged. \nchanging_slice_group_idc equal to 0 indicates that decoded pictures are correct or approximately correct in content at \nand subsequent to the recovery point in output order when all macroblocks of the primary coded pictures are decoded \nwithin the changing slice group period, i.e., the period between the access unit associated with the recovery point SEI \nmessage (inclusive) and the specified recovery point (inclusive) in decoding order. changing_slice_group_idc shall be \n    Rec. ITU-T H.264 (06/2019)  357 \n \nequal to 0 when num_slice_groups_minus1 is equal to 0 in any primary coded picture within the changing slice group \nperiod. \nWhen  changing_slice_group_idc  is  equal  to 1  or  2,  num_slice_groups_minus1  shall  be  equal  to 1  and  the \nmacroblock-to-slice-group map type 3, 4, or 5 shall be applied in each primary coded picture in the changing slice group \nperiod. \nchanging_slice_group_idc equal to 1 indicates that within the changing slice group period no sample values outside the \ndecoded macroblocks covered by slice group 0 are used for inter prediction of any macroblock within slice group 0. In \naddition, changing_slice_group_idc equal to 1 indicates that when all macroblocks in slice group 0 within the changing \nslice group period are decoded, decoded pictures will be correct or approximately correct in content at and subsequent to \nthe specified recovery point in output order regardless of whether any macroblock in slice group 1 within the changing \nslice group period is decoded. \nchanging_slice_group_idc equal to 2 indicates that within the changing slice group period no sample values outside the \ndecoded macroblocks covered by slice group 1 are used for inter prediction of any macroblock within slice group 1. In \naddition, changing_slice_group_idc equal to 2 indicates that when all macroblocks in slice group 1 within the changing \nslice group period are decoded, decoded pictures will be correct or approximately correct in content at and subsequent to \nthe specified recovery point in output order regardless of whether any macroblock in slice group 0 within the changing \nslice group period is decoded. \nchanging_slice_group_idc shall be in the range of 0 to 2, inclusive. \nD.2.9  Decoded reference picture marking repetition SEI message semantics \nThe decoded reference picture marking repetition SEI message is used to repeat the decoded reference picture marking \nsyntax structure that was located in the slice headers of an earlier picture in the same coded video sequence in decoding \norder. \noriginal_idr_flag shall be equal to 1 when the decoded reference picture marking syntax structure occurred originally in \nan IDR picture. original_idr_flag shall be equal to 0 when the repeated decoded reference picture marking syntax structure \ndid not occur in an IDR picture originally. \noriginal_frame_num shall be equal to the frame_num of the picture where the repeated decoded reference picture marking \nsyntax structure originally occurred. The picture indicated by original_frame_num is the previous coded picture having the \nspecified  value  of  frame_num.  The  value  of  original_frame_num  used  to  refer  to  a  picture  having  a \nmemory_management_control_operation equal to 5 shall be 0. \noriginal_field_pic_flag shall be equal to the field_pic_flag of the picture where the repeated decoded reference picture \nmarking syntax structure originally occurred. \noriginal_bottom_field_flag shall be equal to the bottom_field_flag of the picture where the repeated decoded reference \npicture marking syntax structure originally occurred. \ndec_ref_pic_marking( ) shall contain a copy of the decoded reference picture marking syntax structure of the picture that \nhas  a  value  of  frame_num  equal  to  original_frame_num.  The  IdrPicFlag  used  in  the  specification  of  the  repeated \ndec_ref_pic_marking( ) syntax structure shall be the IdrPicFlag of the slice header(s) of the picture that has a value of \nframe_num  equal  to  original_frame_num  (i.e.,  IdrPicFlag  as  used  in  clause 7.3.3.3  shall  be  considered  equal  to \noriginal_idr_flag). \nD.2.10  Spare picture SEI message semantics \nThis SEI message indicates that certain slice group map units, called spare slice group map units, in one or more decoded \nreference pictures resemble the co-located slice group map units in a specified decoded picture called the target picture. A \nspare slice group map unit may be used to replace a co-located, incorrectly decoded slice group map unit, in the target \npicture. A decoded picture containing spare slice group map units is called a spare picture. \nA spare picture SEI message shall not be present in an IDR access unit. The value of the PicSizeInMapUnits variable for \nthe target picture (as specified later in this clause) shall be equal to the value of the PicSizeInMapUnits variable for the \nsequence parameter set that is active when processing the spare picture SEI message. \nFor all spare pictures identified in a spare picture SEI message, the value of frame_mbs_only_flag shall be equal to the \nvalue of frame_mbs_only_flag of the target picture in the same SEI message. The spare pictures in the SEI message are \nconstrained as follows: \n–  If the target picture is a decoded field, all spare pictures identified in the same SEI message shall be decoded fields. \n–  Otherwise (the target picture is a decoded frame), all spare pictures identified in the same SEI message shall be \ndecoded frames. \n358  Rec. ITU-T H.264 (06/2019) \n \nFor  all  spare  pictures  identified  in  a  spare  picture  SEI  message,  the  values  of  pic_width_in_mbs_minus1  and \npic_height_in_map_units_minus1  shall  be  equal  to  the  values  of  pic_width_in_mbs_minus1  and \npic_height_in_map_units_minus1, respectively, of the target picture in the same SEI message. The picture associated (as \nspecified in clause 7.4.1.2.3) with this SEI message shall appear after the target picture, in decoding order. \ntarget_frame_num indicates the frame_num of the target picture. \nspare_field_flag equal to 0 indicates that the target picture and the spare pictures are decoded frames. spare_field_flag \nequal to 1 indicates that the target picture and the spare pictures are decoded fields. \ntarget_bottom_field_flag equal to 0 indicates that the target picture is a top field. target_bottom_field_flag equal to 1 \nindicates that the target picture is a bottom field. \nA target picture is a decoded reference picture for which the corresponding primary coded picture precedes the current \npicture, in decoding order, and in which the values of frame_num, field_pic_flag (when present) and bottom_field_flag \n(when present) are equal to target_frame_num, spare_field_flag and target_bottom_field_flag, respectively. \nnum_spare_pics_minus1 indicates the number of spare pictures for the specified target picture. The number of spare \npictures is equal to num_spare_pics_minus1 + 1. The value of num_spare_pics_minus1 shall be in the range of 0 to 15, \ninclusive. \ndelta_spare_frame_num[ i ] is used to identify the spare picture that contains the i-th set of spare slice group map units, \nhereafter called the i-th spare picture, as specified below. The value of delta_spare_frame_num[ i ] shall be in the range of \n0 to MaxFrameNum − 2 + spare_field_flag, inclusive. \nThe  frame_num  of  the  i-th  spare  picture,  spareFrameNum[ i ],  is  derived  as  follows  for  all  values  of  i  from  0  to \nnum_spare_pics_minus1, inclusive: \ncandidateSpareFrameNum = target_frame_num − 1 + spare_field_flag \nfor ( i = 0; i  <=  num_spare_pics_minus1; i++ ) { \n  if( candidateSpareFrameNum < 0 )   \n    candidateSpareFrameNum = MaxFrameNum − 1 \n  spareFrameNum[ i ] = candidateSpareFrameNum − delta_spare_frame_num[ i ]   (D-3) \n  if( spareFrameNum[ i ] < 0 ) \n    spareFrameNum[ i ] = MaxFrameNum + spareFrameNum[ i ] \n  candidateSpareFrameNum = spareFrameNum[ i ] − 1 + spare_field_flag \n} \nspare_bottom_field_flag[ i ] equal to 0 indicates that the i-th spare picture is a top field. spare_bottom_field_flag[ i ] \nequal to 1 indicates that the i-th spare picture is a bottom field. \nThe 0-th spare picture is a decoded reference picture for which the corresponding primary coded picture precedes the target \npicture, in decoding order, and in which the values of frame_num, field_pic_flag (when present) and bottom_field_flag \n(when present) are equal to spareFrameNum[ 0 ], spare_field_flag and spare_bottom_field_flag[ 0 ], respectively. The i-th \nspare picture is a decoded reference picture for which the corresponding primary coded picture precedes the ( i − 1 )-th \nspare  picture,  in  decoding  order,  and  in  which  the  values  of  frame_num,  field_pic_flag  (when  present)  and \nbottom_field_flag (when present) are equal to spareFrameNum[ i ], spare_field_flag and spare_bottom_field_flag[ i ], \nrespectively. \nspare_area_idc[ i ] indicates the method used to identify the spare slice group map units in the i-th spare picture. \nspare_area_idc[ i ] shall be in the range of 0 to 2, inclusive. spare_area_idc[ i ] equal to 0 indicates that all slice group map \nunits in the i-th spare picture are spare units. spare_area_idc[ i ] equal to 1 indicates that the value of the syntax element \nspare_unit_flag[ i ][ j ] is used to identify the spare slice group map units. spare_area_idc[ i ] equal to 2 indicates that the \nzero_run_length[ i ][ j ] syntax element is used to derive the values of spareUnitFlagInBoxOutOrder[ i ][ j ], as described \nbelow. \nspare_unit_flag[ i ][ j ] equal to 0 indicates that the j-th slice group map unit in raster scan order in the i-th spare picture \nis a spare unit. spare_unit_flag[ i ][ j ] equal to 1 indicates that the j-th slice group map unit in raster scan order in the i-th \nspare picture is not a spare unit. \nzero_run_length[ i ][ j ] is used to derive the values of spareUnitFlagInBoxOutOrder[ i ][ j ] when spare_area_idc[ i ] is \nequal to 2. In this case, the spare slice group map units identified in spareUnitFlagInBoxOutOrder[ i ][ j ] appear in counter-\nclockwise box-out order, as specified in clause 8.2.2.4, for each spare picture. spareUnitFlagInBoxOutOrder[ i ][ j ] equal \nto 0 indicates that the j-th slice group map unit in counter-clockwise box-out order in the i-th spare picture is a spare unit. \nspareUnitFlagInBoxOutOrder[ i ][ j ] equal to 1 indicates that the j-th slice group map unit in counter-clockwise box-out \norder in the i-th spare picture is not a spare unit. \n    Rec. ITU-T H.264 (06/2019)  359 \n \nWhen spare_area_idc[ 0 ] is equal to 2, spareUnitFlagInBoxOutOrder[ 0 ][ j ] is derived as specified by the following \npseudo-code: \nfor( j = 0, loop = 0; j < PicSizeInMapUnits; loop++ ) { \n    for( k = 0; k < zero_run_length[ 0 ][ loop ]; k++ ) \n        spareUnitFlagInBoxOutOrder[ 0 ][ j++ ] = 0    (D-4) \n    spareUnitFlagInBoxOutOrder[ 0 ][ j++ ] = 1 \n} \nWhen spare_area_idc[ i ] is equal to 2 and the value of i is greater than 0, spareUnitFlagInBoxOutOrder[ i ][ j ] is derived \nas specified by the following pseudo-code: \nfor( j = 0, loop = 0; j < PicSizeInMapUnits; loop++ ) { \n    for( k = 0; k < zero_run_length[ i ][ loop ]; k++ ) \n        spareUnitFlagInBoxOutOrder[ i ][ j ] = spareUnitFlagInBoxOutOrder[ i − 1 ][ j++ ]   (D-5) \n    spareUnitFlagInBoxOutOrder[ i ][ j ] = !spareUnitFlagInBoxOutOrder[ i − 1 ][ j++ ] \n} \nD.2.11  Scene information SEI message semantics \nA scene and a scene transition are herein defined as a set of consecutive pictures in output order. \nNOTE 1 – Decoded pictures within one scene generally have similar content. The scene information SEI message is used to label \npictures with scene identifiers and to indicate scene changes. The message specifies how the source pictures for the labelled pictures \nwere created. The decoder may use the information to select an appropriate algorithm to conceal transmission errors. For example, \na specific algorithm may be used to conceal transmission errors that occurred in pictures belonging to a gradual scene transition. \nFurthermore, the scene information SEI message may be used in a manner determined by the application, such as for indexing the \nscenes of a coded sequence. \nA scene information SEI message labels all pictures, in decoding order, from the primary coded picture to which the SEI \nmessage is associated (inclusive), as specified in clause 7.4.1.2.3, to the primary coded picture to which the next scene \ninformation SEI message (if present) in decoding order is associated (exclusive) or (otherwise) to the last access unit in \nthe bitstream (inclusive). These pictures are herein referred to as the target pictures. \nscene_info_present_flag equal to 0 indicates that the scene or scene transition to which the target pictures belong is \nunspecified. scene_info_present_flag equal to 1 indicates that the target pictures belong to the same scene or scene \ntransition. \nscene_id identifies the scene to which the target pictures belong. When the value of scene_transition_type of the target \npictures is less than 4, and the previous picture in output order is marked with a value of scene_transition_type less than 4, \nand the value of scene_id is the same as the value of scene_id of the previous picture in output order, this indicates that the \nsource scene for the target pictures and the source scene for the previous picture (in output order) are considered by the \nencoder to have been the same scene. When the value of scene_transition_type of the target pictures is greater than 3, and \nthe previous picture in output order is marked with a value of scene_transition_type less than 4, and the value of scene_id \nis the same as the value of scene_id of the previous picture in output order, this indicates that one of the source scenes for \nthe target pictures and the source scene for the previous picture (in output order) are considered by the encoder to have \nbeen the same scene. When the value of scene_id is not equal to the value of scene_id of the previous picture in output \norder, this indicates that the target pictures and the previous picture (in output order) are considered by the encoder to have \nbeen from different source scenes. \nThe value of scene_id shall be in the range of 0 to 232 − 2, inclusive. \nValues of scene_id in the range of 0 to 255, inclusive, and in the range of 512 to 231 − 1, inclusive, may be used as \ndetermined by the application. Values of scene_id in the range of 256 to 511, inclusive, and in the range of 231 to 232 − 2, \ninclusive, are reserved for future use by ITU-T | ISO/IEC. Decoders encountering a value of scene_id in the range of 256 \nto 511, inclusive, or in the range of 231 to 232 − 2, inclusive, shall ignore (remove from the bitstream and discard) it. \nscene_transition_type specifies in which type of a scene transition (if any) the target pictures are involved. The valid \nvalues of scene_transition_type are specified in Table D-4. \n360  Rec. ITU-T H.264 (06/2019) \n \nTable D-4 – scene_transition_type values \n \nValue  Description \n0  No transition \n1  Fade to black \n2  Fade from black \n3  Unspecified transition from or to constant colour \n4  Dissolve \n5  Wipe \n6  Unspecified mixture of two scenes \n \nWhen scene_transition_type is greater than 3, the target pictures include contents both from the scene labelled by its \nscene_id and the next scene, in output order, which is labelled by second_scene_id (see below). The term \"the current \nscene\" is used to indicate the scene labelled by scene_id. The term \"the next scene\" is used to indicate the scene labelled \nby second_scene_id. It is not required for any following picture, in output order, to be labelled with scene_id equal to \nsecond_scene_id of the current SEI message. \nScene transition types are specified as follows. \n\"No transition\" specifies that the target pictures are not involved in a gradual scene transition. \nNOTE 2 – When two consecutive pictures in output order have scene_transition_type equal to 0 and different values of scene_id, a \nscene cut occurred between the two pictures. \n\"Fade to black\" indicates that the target pictures are part of a sequence of pictures, in output order, involved in a fade to \nblack scene transition, i.e., the luma samples of the scene gradually approach zero and the chroma samples of the scene \ngradually approach 128. \nNOTE 3 – When two pictures are labelled to belong to the same scene transition and their scene_transition_type is \"Fade to black\", \nthe later one, in output order, is darker than the previous one. \n\"Fade from black\" indicates that the target pictures are part of a sequence of pictures, in output order, involved in a fade \nfrom black scene transition, i.e., the luma samples of the scene gradually diverge from zero and the chroma samples of the \nscene may gradually diverge from 128. \nNOTE 4 – When two pictures are labelled to belong to the same scene transition and their scene_transition_type is \"Fade from \nblack\", the later one in output order is lighter than the previous one. \n\"Dissolve\" indicates that the sample values of each target picture (before encoding) were generated by calculating a sum \nof co-located weighted sample values of a picture from the current scene and a picture from the next scene. The weight of \nthe current scene gradually decreases from full level to zero level, whereas the weight of the next scene gradually increases \nfrom  zero  level  to  full  level.  When  two  pictures  are  labelled  to  belong  to  the  same  scene  transition  and  their \nscene_transition_type is \"Dissolve\", the weight of the current scene for the later one, in output order, is less than the weight \nof the current scene for the previous one, and the weight of the next scene for the later one, in output order, is greater than \nthe weight of the next scene for the previous one. \n\"Wipe\" indicates that some of the sample values of each target picture (before encoding) were generated by copying \nco-located sample values of a picture in the current scene and the remaining sample values of each target picture (before \nencoding) were generated by copying co-located sample values of a picture in the next scene. When two pictures are \nlabelled to belong to the same scene transition and their scene_transition_type is \"Wipe\", the number of samples copied \nfrom the next scene to the later picture in output order is greater than the number of samples copied from the next scene to \nthe previous picture. \nsecond_scene_id identifies the next scene in the gradual scene transition in which the target pictures are involved. The \nvalue of second_scene_id shall not be equal to the value of scene_id. The value of second_scene_id shall not be equal to \nthe value of scene_id in the previous picture in output order. When the next picture in output order is marked with a value \nof scene_transition_type less than 4, and the value of second_scene_id is the same as the value of scene_id of the next \npicture in output order, this indicates that the encoder considers one of the source scenes for the target pictures and the \nsource scene for the next picture (in output order) to have been the same scene. When the value of second_scene_id is not \nequal to the value of scene_id or second_scene_id (if present) of the next picture in output order, this indicates that the \nencoder considers the target pictures and the next picture (in output order) to have been from different source scenes. \nWhen the value of scene_id of a picture is equal to the value of scene_id of the following picture in output order and the \nvalue of scene_transition_type in both of these pictures is less than 4, this indicates that the encoder considers the two \npictures  to  have  been  from  the  same  source  scene.  When  the  values  of  scene_id,  scene_transition_type  and \nsecond_scene_id (if present) of a picture are equal to the values of scene_id, scene_transition_type and second_scene_id \n    Rec. ITU-T H.264 (06/2019)  361 \n \n(respectively) of the following picture in output order and the value of scene_transition_type is greater than 0, this indicates \nthat the encoder considers the two pictures to have been from the same source gradual scene transition. \nThe value of second_scene_id shall be in the range of 0 to 232 − 2, inclusive. \nValues of second_scene_id in the range of 0 to 255, inclusive, and in the range of 512 to 231 − 1, inclusive, may be used as \ndetermined by the application. Values of second_scene_id in the range of 256 to 511, inclusive, and in the range of 231 \nto 232 − 2, inclusive, are reserved for future use by ITU-T | ISO/IEC. Decoders encountering a value of second_scene_id \nin the range of 256 to 511, inclusive, or in the range of 231 to 232 − 2, inclusive, shall ignore (remove from the bitstream \nand discard) it. \nD.2.12  Sub-sequence information SEI message semantics \nThe sub-sequence information SEI message is used to indicate the position of a picture in data dependency hierarchy that \nconsists of sub-sequence layers and sub-sequences. \nA sub-sequence layer contains a subset of the coded pictures in a sequence. Sub-sequence layers are numbered with \nnon-negative integers. A layer having a larger layer number is a higher layer than a layer having a smaller layer number. \nThe layers are ordered hierarchically based on their dependency on each other so that any picture in a layer shall not be \npredicted from any picture on any higher layer. \nNOTE 1 – In other words, any picture in layer 0 must not be predicted from any picture in layer 1 or above, pictures in layer 1 may \nbe predicted from layer 0, pictures in layer 2 may be predicted from layers 0 and 1, etc. \nNOTE 2 – The subjective quality is expected to increase along with the number of decoded layers. \nA sub-sequence is a set of coded pictures within a sub-sequence layer. A picture shall reside in one sub-sequence layer and \nin one sub-sequence only. Any picture in a sub-sequence shall not be predicted from any picture in another sub-sequence \nin the same or in a higher sub-sequence layer. A sub-sequence in layer 0 can be decoded independently of any picture that \ndoes not belong to the sub-sequence. \nThe sub-sequence information SEI message concerns the current access unit. The primary coded picture in the access unit \nis herein referred to as the current picture. \nThe sub-sequence information SEI message shall not be present unless gaps_in_frame_num_value_allowed_flag in the \nsequence parameter set referenced by the picture associated with the sub-sequence SEI message is equal to 1. \nsub_seq_layer_num specifies the sub-sequence layer number of the current picture. When sub_seq_layer_num is greater \nthan 0, memory management control operations shall not be used in any slice header of the current picture. When the \ncurrent picture resides in a sub-sequence for which the first picture in decoding order is an IDR picture, the value of \nsub_seq_layer_num shall be equal to 0. For a non-paired reference field, the value of sub_seq_layer_num shall be equal \nto 0. sub_seq_layer_num shall be in the range of 0 to 255, inclusive. \nsub_seq_id identifies the sub-sequence within a layer. When the current picture resides in a sub-sequence for which the \nfirst picture in decoding order is an IDR picture, the value of sub_seq_id shall be the same as the value of idr_pic_id of the \nIDR picture. sub_seq_id shall be in the range of 0 to 65535, inclusive. \nfirst_ref_pic_flag equal to 1 specifies that the current picture is the first reference picture of the sub-sequence in decoding \norder. When the current picture is not the first picture of the sub-sequence in decoding order, the first_ref_pic_flag shall \nbe equal to 0. \nleading_non_ref_pic_flag equal to 1 specifies that the current picture is a non-reference picture preceding any reference \npicture in decoding order within the sub-sequence or that the sub-sequence contains no reference pictures. When the current \npicture is a reference picture or the current picture is a non-reference picture succeeding at least one reference picture in \ndecoding order within the sub-sequence, the leading_non_ref_pic_flag shall be equal to 0. \nlast_pic_flag equal to 1 indicates that the current picture is the last picture of the sub-sequence (in decoding order), \nincluding all reference and non-reference pictures of the sub-sequence. When the current picture is not the last picture of \nthe sub-sequence (in decoding order), last_pic_flag shall be equal to 0. \nThe current picture is assigned to a sub-sequence as follows: \n–  If one or more of the following conditions are true, the current picture is the first picture of a sub-sequence in decoding \norder: \n–  no earlier picture in decoding order is labelled with the same values of sub_seq_id and sub_seq_layer_num as \nthe current picture, \n–  the value of leading_non_ref_pic_flag is equal to 1 and the value of leading_non_ref_pic_flag is equal to 0 in \nthe previous picture in decoding order having the same values of sub_seq_id and sub_seq_layer_num as the \ncurrent picture, \n362  Rec. ITU-T H.264 (06/2019) \n \n–  the value of first_ref_pic_flag is equal to 1 and the value of leading_non_ref_pic_flag is equal to 0 in the previous \npicture in decoding order having the same values of sub_seq_id and sub_seq_layer_num as the current picture, \n–  the value of last_pic_flag is equal to 1 in the previous picture in decoding order having the same values of \nsub_seq_id and sub_seq_layer_num as the current picture. \n–  Otherwise, the current picture belongs to the same sub-sequence as the previous picture in decoding order having the \nsame values of sub_seq_id and sub_seq_layer_num as the current picture. \nsub_seq_frame_num_flag equal to 0 specifies that sub_seq_frame_num is not present. sub_seq_frame_num_flag equal \nto 1 specifies that sub_seq_frame_num is present. \nsub_seq_frame_num shall be equal to 0 for the first reference picture of the sub-sequence and for any non-reference \npicture  preceding  the  first  reference  picture  of  the  sub-sequence  in  decoding  order.  sub_seq_frame_num  is  further \nconstrained as follows: \n–  If the current picture is not the second field of a complementary field pair, sub_seq_frame_num shall be incremented \nby 1, in modulo MaxFrameNum operation, relative to the previous reference picture, in decoding order, that belongs \nto the sub-sequence. \n–  Otherwise (the current picture is the second field of a complementary field pair), the value of sub_seq_frame_num \nshall be the same as the value of sub_seq_frame_num for the first field of the complementary field pair. \nsub_seq_frame_num shall be in the range of 0 to MaxFrameNum − 1, inclusive. \nWhen  the  current  picture  is  an  IDR  picture,  it  shall  start  a  new  sub-sequence  in  sub-sequence  layer  0.  Thus,  the \nsub_seq_layer_num shall be 0, the sub_seq_id shall be different from the previous sub-sequence in sub-sequence layer 0, \nfirst_ref_pic_flag shall be 1, and leading_non_ref_pic_flag shall be equal to 0. \nWhen the sub-sequence information SEI message is present for both coded fields of a complementary field pair, the values \nof sub_seq_layer_num, sub_seq_id, leading_non_ref_pic_flag and sub_seq_frame_num, when present, shall be the same \nfor both of these pictures. \nWhen the sub-sequence information SEI message is present only for one coded field of a complementary field pair, the \nvalues of sub_seq_layer_num, sub_seq_id, leading_non_ref_pic_flag and sub_seq_frame_num, when present, are also \napplicable to the other coded field of the complementary field pair. \nD.2.13  Sub-sequence layer characteristics SEI message semantics \nThe sub-sequence layer characteristics SEI message specifies the characteristics of sub-sequence layers. \nnum_sub_seq_layers_minus1  plus  1  specifies  the  number  of  sub-sequence  layers  in  the  sequence. \nnum_sub_seq_layers_minus1 shall be in the range of 0 to 255, inclusive. \nA  pair  of  average_bit_rate  and  average_frame_rate  characterizes  each  sub-sequence  layer.  The  first  pair  of \naverage_bit_rate and average_frame_rate specifies the characteristics of sub-sequence layer 0. When present, the second \npair  specifies  the  characteristics  of  sub-sequence  layers  0  and  1  jointly.  Each  pair  in  decoding  order  specifies  the \ncharacteristics for a range of sub-sequence layers from layer number 0 to the layer number specified by the layer loop \ncounter. The values are in effect from the point they are decoded until an update of the values is decoded. \naccurate_statistics_flag equal to 1 indicates that the values of average_bit_rate and average_frame_rate are rounded from \nstatistically  correct  values.  accurate_statistics_flag  equal  to 0  indicates  that  the  average_bit_rate  and  the \naverage_frame_rate are estimates and may deviate somewhat from the correct values. \nWhen accurate_statistics_flag is equal to 0, the quality of the approximation used in the computation of the values of \naverage_bit_rate  and  the  average_frame_rate  is  chosen  by  the  encoding  process  and  is  not  specified  by  this \nRecommendation | International Standard. \naverage_bit_rate indicates the average bit rate in units of 1000 bits per second. All NAL units in the range of sub-sequence \nlayers specified above are taken into account in the calculation. The average bit rate is derived according to the access unit \nremoval time specified in Annex C of the Recommendation | International Standard. In the following, bTotal is the number \nof bits in all NAL units succeeding a sub-sequence layer characteristics SEI message (including the bits of the NAL units \nof  the  current  access  unit)  and  preceding  the  next  access  unit  (in  decoding  order)  including  a  sub-sequence  layer \ncharacteristics SEI message (if present) or the end of the stream (otherwise). t  is the removal time (in seconds) of the \n1\ncurrent access unit, and t  is the removal time (in seconds) of the latest access unit (in decoding order) before the next sub-\n2\nsequence layer characteristics SEI message (if present) or the end of the stream (otherwise). \nWhen accurate_statistics_flag is equal to 1, the following conditions shall be fulfilled as follows: \n–  If t  is not equal to t , the following condition shall be true: \n1 2\naverage_bit_rate  = =  Round( bTotal ÷ ( ( t  − t  ) * 1000 ) ) )  (D-6) \n2 1\n    Rec. ITU-T H.264 (06/2019)  363 \n \n–  Otherwise (t  is equal to t ), the following condition shall be true: \n1 2\naverage_bit_rate  = =  0    (D-7) \naverage_frame_rate indicates the average frame rate in units of frames/(256 seconds). All NAL units in the range of sub-\nsequence layers specified above are taken into account in the calculation. In the following, fTotal is the number of frames, \ncomplementary field pairs and non-paired fields between the current picture (inclusive) and the next sub-sequence layer \ncharacteristics SEI message (if present) or the end of the stream (otherwise). t  is the removal time (in seconds) of the \n1\ncurrent access unit, and t  is the removal time (in seconds) of the latest access unit (in decoding order) before the next sub-\n2\nsequence layer characteristics SEI message (if present) or the end of the stream (otherwise). \nWhen accurate_statistics_flag is equal to 1, the following conditions shall be fulfilled as follows: \n–  If t  is not equal to t , the following condition shall be true: \n1 2\naverage_frame_rate  = =  Round( fTotal * 256 ÷ ( t  − t  ) )  (D-8) \n2 1\n–  Otherwise (t  is equal to t ), the following condition shall be true: \n1 2\naverage_frame_rate  = =  0    (D-9) \nD.2.14  Sub-sequence characteristics SEI message semantics \nThe sub-sequence characteristics SEI message indicates the characteristics of a sub-sequence. It also indicates inter \nprediction dependencies between sub-sequences. This message shall be contained in the first access unit in decoding order \nof the sub-sequence to which the sub-sequence characteristics SEI message applies. This sub-sequence is herein called the \ntarget sub-sequence. \nsub_seq_layer_num identifies the sub-sequence layer number of the target sub-sequence. sub_seq_layer_num shall be in \nthe range of 0 to 255, inclusive. \nsub_seq_id identifies the target sub-sequence. sub_seq_id shall be in the range of 0 to 65535, inclusive. \nduration_flag equal to 0 indicates that the duration of the target sub-sequence is not specified. \nsub_seq_duration specifies the duration of the target sub-sequence in clock ticks of a 90-kHz clock. \naverage_rate_flag equal to 0 indicates that the average bit rate and the average frame rate of the target sub-sequence are \nunspecified. \naccurate_statistics_flag  indicates  how  reliable  the  values  of  average_bit_rate  and  average_frame_rate  are. \naccurate_statistics_flag  equal  to 1,  indicates  that  the  average_bit_rate  and  the  average_frame_rate  are  rounded  from \nstatistically  correct  values.  accurate_statistics_flag  equal  to 0  indicates  that  the  average_bit_rate  and  the \naverage_frame_rate are estimates and may deviate from the statistically correct values. \naverage_bit_rate indicates the average bit rate in (1000 bits)/second of the target sub-sequence. All NAL units of the \ntarget sub-sequence are taken into account in the calculation. The average bit rate is derived according to the access unit \nremoval time specified in clause C.1.2. In the following, nB is the number of bits in all NAL units in the sub-sequence. t  \n1\nis the removal time (in seconds) of the first access unit of the sub-sequence (in decoding order), and t  is the removal time \n2\n(in seconds) of the last access unit of the sub-sequence (in decoding order). \nWhen accurate_statistics_flag is equal to 1, the following conditions shall be fulfilled as follows: \n–  If t  is not equal to t , the following condition shall be true: \n1 2\naverage_bit_rate  = =  Round( nB ÷ ( ( t  − t  ) * 1000 ) )  (D-10) \n2 1\n–  Otherwise (t  is equal to t ), the following condition shall be true: \n1 2\naverage_bit_rate  = =  0    (D-11) \naverage_frame_rate indicates the average frame rate in units of frames/(256 seconds) of the target sub-sequence. All \nNAL units of the target sub-sequence are taken into account in the calculation. The average frame rate is derived according \nto the access unit removal time specified in clause C.1.2. In the following, fC is the number of frames, complementary \nfield pairs and non-paired fields in the sub-sequence. t  is the removal time (in seconds) of the first access unit of the sub-\n1\nsequence (in decoding order), and t  is the removal time (in seconds) of the last access unit of the sub-sequence (in decoding \n2\norder). \nWhen accurate_statistics_flag is equal to 1, the following conditions shall be fulfilled as follows: \n364  Rec. ITU-T H.264 (06/2019) \n \n–  If t  is not equal to t , the following condition shall be true: \n1 2\naverage_frame_rate  = =  Round( fC * 256 ÷ ( t  − t  ) )  (D-12) \n2 1\n–  Otherwise (t  is equal to t ), the following condition shall be true: \n1 2\naverage_frame_rate  = =  0    (D-13) \nnum_referenced_subseqs specifies the number of sub-sequences that contain pictures that are used as reference pictures \nfor inter prediction in the pictures of the target sub-sequence. num_referenced_subseqs shall be in the range of 0 to 255, \ninclusive. \nref_sub_seq_layer_num, ref_sub_seq_id, and ref_sub_seq_direction identify the sub-sequence that contains pictures \nthat  are  used  as  reference  pictures  for  inter  prediction  in  the  pictures  of  the  target  sub-sequence.  Depending  on \nref_sub_seq_direction, the following applies: \n–  If ref_sub_seq_direction is equal to 0, a set of candidate sub-sequences consists of the sub-sequences which have a \nvalue of sub_seq_id equal to ref_sub_seq_id, which reside in the sub-sequence layer having sub_seq_layer_num equal \nto ref_sub_seq_layer_num, and for which the first picture in decoding order precedes the first picture of the target \nsub-sequence in decoding order. \n–  Otherwise (ref_sub_seq_direction is equal to 1), a set of candidate sub-sequences consists of the sub-sequences which \nhave  a  value  of  sub_seq_id  equal  to  ref_sub_seq_id,  which  reside  in  the  sub-sequence  layer  having \nsub_seq_layer_num equal to ref_sub_seq_layer_num, and for which the first picture in decoding order succeeds the \nfirst picture of the target sub-sequence in decoding order. \nThe  sub-sequence  used  as  a  reference  for  the  target  sub-sequence  is  the  sub-sequence  among  the  set  of  candidate \nsub-sequences for which the first picture is the closest to the first picture of the target sub-sequence in decoding order. \nD.2.15  Full-frame freeze SEI message semantics \nThe full-frame freeze SEI message indicates that the current picture and any subsequent pictures in output order that meet \nspecified conditions should not affect the content of the display. No more than one full-frame freeze SEI message shall be \npresent in any access unit. \nfull_frame_freeze_repetition_period specifies the persistence of the full-frame freeze SEI message and may specify a \npicture order count interval within which another full-frame freeze SEI message or a full-frame freeze release SEI message \nor the end of the coded video sequence shall be present in the bitstream. The value of full_frame_freeze_repetition_period \nshall be in the range of 0 to 16 384, inclusive. \nfull_frame_freeze_repetition_period equal to 0 specifies that the full-frame freeze SEI message applies to the current \ndecoded picture only. \nfull_frame_freeze_repetition_period equal to 1 specifies that the full-frame freeze SEI message persists in output order \nuntil any of the following conditions are true: \n–  A new coded video sequence begins. \n–  A picture in an access unit containing a full-frame freeze SEI message or a full-frame freeze release SEI message is \noutput having PicOrderCnt( ) greater than PicOrderCnt( CurrPic ). \nfull_frame_freeze_repetition_period greater than 1 specifies that the full-frame freeze SEI message persists until any of \nthe following conditions are true:. \n–  A new coded video sequence begins. \n–  A picture in an access unit containing a full-frame freeze SEI message or a full-frame freeze release SEI message is \noutput having PicOrderCnt( ) greater than PicOrderCnt( CurrPic ) and less than or equal to PicOrderCnt( CurrPic ) + \nfull_frame_freeze_repetition_period. \nfull_frame_freeze_repetition_period greater than 1 indicates that another full-frame freeze SEI message or a full-frame \nfreeze release SEI message shall be present for a picture in an access unit that is output having PicOrderCnt( ) greater than \nPicOrderCnt( CurrPic ) and less than or equal to PicOrderCnt( CurrPic ) + full_frame_freeze_repetition_period; unless the \nbitstream ends or a new coded video sequence begins without output of such a picture. \nD.2.16  Full-frame freeze release SEI message semantics \nThe full-frame freeze release SEI message cancels the effect of any full-frame freeze SEI message sent with pictures that \nprecede the current picture in output order. The full-frame freeze release SEI message indicates that the current picture and \nsubsequent pictures in output order should affect the contents of the display. \n    Rec. ITU-T H.264 (06/2019)  365 \n \nNo more than one full-frame freeze release SEI message shall be present in any access unit. A full-frame freeze release \nSEI message shall not be present in an access unit containing a full-frame freeze SEI message. When a full-frame freeze \nSEI  message  is  present  in  an  access  unit  containing  a  field  of  a  complementary  field  pair  in  which  the  values  of \nPicOrderCnt( CurrPic ) for the two fields of the complementary field pair are equal to each other, a full-frame freeze release \nSEI message shall not be present in either of the two access units. \nD.2.17  Full-frame snapshot SEI message semantics \nThe full-frame snapshot SEI message indicates that the current frame is labelled for use as determined by the application \nas a still-image snapshot of the video content. \nsnapshot_id specifies a snapshot identification number. snapshot_id shall be in the range of 0 to 232 − 2, inclusive. \nValues of snapshot_id in the range of 0 to 255, inclusive, and in the range of 512 to 231 − 1, inclusive, may be used as \ndetermined by the application. Values of snapshot_id in the range of 256 to 511, inclusive, and in the range of 231 to 232 − 2, \ninclusive, are reserved for future use by ITU-T | ISO/IEC. Decoders encountering a value of snapshot_id in the range of \n256 to 511, inclusive, or in the range of 231 to 232 − 2, inclusive, shall ignore (remove from the bitstream and discard) it. \nD.2.18  Progressive refinement segment start SEI message semantics \nThe progressive refinement segment start SEI message specifies the beginning of a set of consecutive coded pictures that \nis labelled as the current picture followed by a sequence of one or more pictures of refinement of the quality of the current \npicture, rather than as a representation of a continually moving scene. \nThe tagged set of consecutive coded pictures shall continue until one of the following conditions is true. When a condition \nbelow becomes true, the next slice to be decoded does not belong to the tagged set of consecutive coded pictures: \n–  The next slice to be decoded belongs to an IDR picture. \n–  num_refinement_steps_minus1 is greater than 0 and the frame_num of the next slice to be decoded is (currFrameNum \n+ num_refinement_steps_minus1 + 1) % MaxFrameNum, where currFrameNum is the value of frame_num of the \npicture in the access unit containing the SEI message. \n–  num_refinement_steps_minus1  is  0  and  a  progressive  refinement  segment  end  SEI  message  with  the  same \nprogressive_refinement_id as the one in this SEI message is decoded. \nThe decoding order of pictures within the tagged set of consecutive pictures should be the same as their output order. \nprogressive_refinement_id  specifies  an  identification  number  for  the  progressive  refinement  operation. \nprogressive_refinement_id shall be in the range of 0 to 232 − 2, inclusive. \nValues of progressive_refinement_id in the range of 0 to 255, inclusive, and in the range of 512 to 231 − 1, inclusive, may \nbe used as determined by the application. Values of progressive_refinement_id in the range of 256 to 511, inclusive, and \nin the range of 231 to 232 − 2, inclusive, are reserved for future use by ITU-T | ISO/IEC. Decoders encountering a value of \nprogressive_refinement_id in the range of 256 to 511, inclusive, or in the range of 231 to 232 − 2, inclusive, shall ignore \n(remove from the bitstream and discard) it. \nnum_refinement_steps_minus1 specifies the number of reference frames in the tagged set of consecutive coded pictures \nas follows: \n–  If num_refinement_steps_minus1 is equal to 0, the number of reference frames in the tagged set of consecutive coded \npictures is unknown. \n–  Otherwise,  the  number  of  reference  frames  in  the  tagged  set  of  consecutive  coded  pictures  is  equal  to \nnum_refinement_steps_minus1 + 1. \nnum_refinement_steps_minus1 shall be in the range of 0 to MaxFrameNum − 1, inclusive. \nD.2.19  Progressive refinement segment end SEI message semantics \nThe progressive refinement segment end SEI message specifies the end of a set of consecutive coded pictures that has been \nlabelled by use of a progressive refinement segment start SEI message as an initial picture followed by a sequence of one \nor more pictures of the refinement of the quality of the initial picture, and ending with the current picture. \nprogressive_refinement_id  specifies  an  identification  number  for  the  progressive  refinement  operation. \nprogressive_refinement_id shall be in the range of 0 to 232 − 2, inclusive. \nThe progressive refinement segment end SEI message specifies the end of any progressive refinement segment previously \nstarted using a progressive refinement segment start SEI message with the same value of progressive_refinement_id. \nValues of progressive_refinement_id in the range of 0 to 255, inclusive, and in the range of 512 to 231 − 1, inclusive, may \nbe used as determined by the application. Values of progressive_refinement_id in the range of 256 to 511, inclusive, and \nin the range of 231 to 232 − 2, inclusive, are reserved for future use by ITU-T | ISO/IEC. Decoders encountering a value of \n366  Rec. ITU-T H.264 (06/2019) \n \nprogressive_refinement_id in the range of 256 to 511, inclusive, or in the range of 231 to 232 − 2, inclusive, shall ignore \n(remove from the bitstream and discard) it. \nD.2.20  Motion-constrained slice group set SEI message semantics \nNOTE 1 – The syntax of the motion-constrained slice group set SEI message is dependent on the content of the picture parameter \nset that is active for the primary coded picture associated with the motion-constrained slice group set SEI message. However, the \nactivation of the associated picture parameter set does not occur until the decoding of the first coded slice NAL unit of the primary \ncoded picture. Since the coded slice NAL units of the primary coded picture follow the motion-constrained slice group set SEI \nmessage in NAL unit order, it may be necessary for a decoder to store the RBSP containing the motion-constrained slice group set \nSEI message until determining the parameters of the picture parameter set that will be active for the primary coded picture, and then \nperform the parsing of the motion-constrained slice group set SEI message. \nThis SEI message indicates that inter prediction over slice group boundaries is constrained as specified below. When \npresent, the message shall only appear where it is associated, as specified in clause 7.4.1.2.3, with an IDR access unit. \nThe target picture set for this SEI message contains all consecutive primary coded pictures in decoding order starting with \nthe associated primary coded IDR picture (inclusive) and ending with the following primary coded IDR picture (exclusive) \nor with the very last primary coded picture in the bitstream (inclusive) in decoding order when there is no following primary \ncoded IDR picture. The slice group set is a collection of one or more slice groups, identified by the slice_group_id[ i ] \nsyntax element. When separate_colour_plane_flag is equal to 1, the term \"primary coded pictures\" represents the parts of \nthe corresponding primary coded pictures that correspond to the NAL units having the same colour_plane_id. \nThis SEI message indicates that, for each picture in the target picture set, the inter prediction process is constrained as \nfollows: No sample value outside the slice group set, and no sample value at a fractional sample position that is derived \nusing one or more sample values outside the slice group set is used for inter prediction of any sample within the slice group \nset. \nnum_slice_groups_in_set_minus1 + 1 specifies the number of slice groups in the slice group set. The allowed range of \nnum_slice_groups_in_set_minus1  is  0  to  num_slice_groups_minus1,  inclusive.  The  allowed  range  of \nnum_slice_groups_minus1 is specified in Annex A and clauses G.10 and H.10. \nslice_group_id[ i ] with i = 0.. num_slice_groups_in_set_minus1 identifies the slice group(s) contained within the slice \ngroup set. The allowed range for slice_group_id[ i ] is from 0 to num_slice_groups_minus1, inclusive. The length of the \nslice_group_id[ i ] syntax element is Ceil( Log2( num_slice_groups_minus1 + 1 ) ) bits. \nWhen num_slice_groups_minus1 is equal to 0 (i.e., num_slice_groups_in_set_minus1 is equal to 0 and slice_group_id[ 0 ] \nis not present), the value of slice_group_id[ 0 ] shall be inferred to be equal to 0. \nexact_sample_value_match_flag equal to 0 indicates that, within the target picture set, when the macroblocks that do not \nbelong to the slice group set are not decoded, the value of each sample in the slice group set need not be exactly the same \nas the value of the same sample when all the macroblocks are  decoded. exact_sample_value_match_flag equal to 1 \nindicates that, within the target picture set, when the macroblocks that do not belong to the slice group set are not decoded, \nthe value of each sample in the slice group set shall be exactly the same as the value of the same sample when all the \nmacroblocks in the target picture set are decoded. \nNOTE 2  –  When  disable_deblocking_filter_idc  is  equal  to  1  or  2  in  all  slices  in  the  target  picture  set, \nexact_sample_value_match_flag should be 1. \npan_scan_rect_flag equal to 0 specifies that pan_scan_rect_id is not present. pan_scan_rect_flag equal to 1 specifies that \npan_scan_rect_id is present. \npan_scan_rect_id  indicates  that  the  specified  slice  group  set  covers  at  least  the  pan-scan  rectangle  identified  by \npan_scan_rect_id within the target picture set. \nNOTE 3 – Multiple motion_constrained_slice_group_set SEI messages may be associated with the same IDR picture. Consequently, \nmore than one slice group set may be active within a target picture set. \nNOTE 4 – The size, shape, and location of the slice groups in the slice group set may change within the target picture set. \nD.2.21  Film grain characteristics SEI message semantics \nThis SEI message provides the decoder with a parameterised model for film grain synthesis. For example, an encoder may \nuse the film grain characteristics SEI message to characterize film grain that was present in the original source video \nmaterial and was removed by pre-processing filtering techniques. Synthesis of simulated film grain on the decoded images \nfor the display process is optional and does not affect the decoding process specified in this Recommendation | International \nStandard. If synthesis of simulated film grain on the decoded images for the display process is performed, there is no \nrequirement that the method by which the synthesis is performed be the same as the parameterised model for the film grain \nas provided in the film grain characteristics SEI message. \nNOTE 1 – The display process is not specified in this Recommendation | International Standard. \n    Rec. ITU-T H.264 (06/2019)  367 \n \nNOTE 2 – The Society of Motion Picture and Television Engineers document RDD 5-2006 \"Film Grain Technology – Specifications \nfor  H.264/MPEG-4  AVC  Bitstreams\"  specifies  a  film  grain  simulator  based  on  the  information  provided  in  the  film  grain \ncharacteristics SEI message. \nfilm_grain_characteristics_cancel_flag equal to 1 indicates that the SEI message cancels the persistence of any previous \nfilm grain characteristics SEI message in output order. film_grain_characteristics_cancel_flag equal to 0 indicates that film \ngrain modelling information follows. \nfilm_grain_model_id  identifies  the  film  grain  simulation  model  as  specified  in  Table D-5.  The  value  of \nfilm_grain_model_id shall be in the range of 0 to 1, inclusive. The values of 2 and 3 for film_grain_model_id are reserved \nfor future use by ITU-T | ISO/IEC. Decoders shall ignore film grain characteristic SEI messages with film_grain_model_id \nequal to 2 or 3. \nTable D-5 – film_grain_model_id values \n \nValue  Description \n0  frequency filtering  \n1  auto-regression \n2  reserved \n3  reserved \n \nseparate_colour_description_present_flag equal to 1 indicates that a distinct colour space description for the film grain \ncharacteristics  specified  in  the  SEI  message  is  present  in  the  film  grain  characteristics  SEI  message  syntax. \nseparate_colour_description_present_flag equal to 0 indicates that the colour description for the film grain characteristics \nspecified in the SEI message is the same as for the coded video sequence as specified in clause E.2.1. \nNOTE 3 – When separate_colour_description_present_flag is equal to 1, the colour space specified for the film grain characteristics \nspecified in the SEI message may differ from the colour space specified for the coded video as specified in clause E.2.1. \nfilm_grain_bit_depth_luma_minus8 plus 8 specifies the  bit depth used for the luma  component of the  film  grain \ncharacteristics specified in the SEI message. When film_grain_bit_depth_luma_minus8 is not present in the film grain \ncharacteristics  SEI  message,  the  value  of  film_grain_bit_depth_luma_minus8  shall  be  inferred  to  be  equal \nto bit_depth_luma_minus8. \nThe value of filmGrainBitDepth[ 0 ] is derived as \nfilmGrainBitDepth[ 0 ] = film_grain_bit_depth_luma_minus8 + 8  (D-14) \nfilm_grain_bit_depth_chroma_minus8 plus 8 specifies the bit depth used for the Cb and Cr components of the film grain \ncharacteristics specified in the SEI message. When film_grain_bit_depth_chroma_minus8 is not present in the film grain \ncharacteristics  SEI  message,  the  value  of  film_grain_bit_depth_chroma_minus8  shall  be  inferred  to  be  equal \nto bit_depth_chroma_minus8. \nThe value of filmGrainBitDepth[ c ] for c = 1 and 2 is derived as \nfilmGrainBitDepth[ c ] = film_grain_bit_depth_chroma_minus8 + 8    with c = 1, 2  (D-15) \nfilm_grain_full_range_flag has the same semantics as specified in clause E.2.1 for the video_full_range_flag syntax \nelement, except as follows: \n–  film_grain_full_range_flag specifies the colour space of the film grain characteristics specified in the SEI message, \nrather than the colour space used for the coded video sequence. \n–  When  film_grain_full_range_flag  is  not  present  in  the  film  grain  characteristics  SEI  message,  the  value  of \nfilm_grain_full_range_flag shall be inferred to be equal to video_full_range_flag. \nfilm_grain_colour_primaries  has  the  same  semantics  as  specified  in  clause E.2.1  for  the  colour_primaries  syntax \nelement, except as follows: \n–  film_grain_colour_primaries specifies the colour space of the film grain characteristics specified in the SEI message, \nrather than the colour space used for the coded video sequence. \n–  When  film_grain_colour_primaries  is  not  present  in  the  film  grain  characteristics  SEI  message,  the  value  of \nfilm_grain_colour_primaries shall be inferred to be equal to colour_primaries. \nfilm_grain_transfer_characteristics has the same semantics as specified in clause E.2.1 for the transfer_characteristics \nsyntax element, except as follows: \n368  Rec. ITU-T H.264 (06/2019) \n \n–  film_grain_transfer_characteristics specifies the colour space of the film grain characteristics specified in the SEI \nmessage, rather than the colour space used for the coded video sequence. \n–  When film_grain_transfer_characteristics is not present in the film grain characteristics SEI message, the value of \nfilm_grain_transfer_characteristics shall be inferred to be equal to transfer_characteristics. \nfilm_grain_matrix_coefficients has the same semantics as specified in clause E.2.1 for the matrix_coefficients syntax \nelement, except as follows: \n–  film_grain_matrix_coefficients  specifies  the  colour  space  of  the  film  grain  characteristics  specified  in  the  SEI \nmessage, rather than the colour space used for the coded video sequence. \n–  When film_grain_matrix_coefficients is not present in the film  grain characteristics SEI message, the value of \nfilm_grain_matrix_coefficients shall be inferred to be equal to matrix_coefficients. \n–  The values allowed for film_grain_matrix_coefficients are not constrained by the value of chroma_format_idc. \nThe chroma_format_idc of the film grain characteristics specified in the film grain characteristics SEI message shall be \ninferred to be equal to 3 (4:4:4). \nNOTE 4 – Because the use of a specific method is not required for performing film grain generation function used by the display \nprocess, a decoder may, if desired, down-convert the model information for chroma in order to simulate film grain for other chroma \nformats (4:2:0 or 4:2:2) rather than up-converting the decoded video (using a method not specified by this Recommendation | \nInternational Standard) before performing film grain generation. \nblending_mode_id identifies the blending mode used to blend the simulated film grain with the decoded  images as \nspecified in Table D-6. blending_mode_id shall be in the range of 0 to 1, inclusive. \nTable D-6 – blending_mode_id values \n \nValue  Description \n0  additive  \n1  multiplicative \n2  reserved \n3  reserved \n \nDepending on blending_mode_id, the blending mode is specified as follows: \n–  If blending_mode_id is equal to 0 the blending mode is additive as specified by \nI [ x, y, c ] = Clip3( 0, ( 1 << filmGrainBitDepth[ c ] ) − 1, I [ x, y, c ] + G[ x, y, c ] )  (D-16) \ngrain decoded\n–  Otherwise (blending_mode_id is equal to 1), the blending mode is multiplicative as specified by \nI [ x, y, c ] = Clip3( 0, ( 1 << filmGrainBitDepth[ c ] ) − 1, I [ x, y, c ]  (D-17) \ngrain decoded\n                                         + Round( ( I [ x, y, c ] * G[ x, y, c ] ) ÷ ( ( 1 << bitDepth[ c ] ) − 1 ) ) ) \ndecoded\nwhere I [ x, y, c ] represents the sample value at coordinates x, y of the colour component c of the decoded image \ndecoded\nI , G[ x, y, c ] is the simulated film grain value at the same position and colour component, filmGrainBitDepth[ c ] is \ndecoded\nthe number of bits used for each sample in a fixed-length unsigned binary representation of the array I [ x, y, c ], and \ngrain\nbitDepth[ c ] is specified by \nBitDepth ; c  0\nbitDepth[ c ] =  Y     (D-18) \n\nBitDepth ; c 1, 2\n\nC\nlog2_scale_factor specifies a scale factor used in the film grain characterization equations. \ncomp_model_present_flag[ c ] equal to 0 indicates that film grain is not modelled on the c-th colour component, where c \nequal to 0 refers to the luma component, c equal to 1 refers to the Cb component, and c equal to 2 refers to the Cr component. \ncomp_model_present_flag[ c ] equal to 1 indicates that syntax elements specifying modelling of film grain on colour \ncomponent c are present in the SEI message. \nnum_intensity_intervals_minus1[ c ] plus 1 specifies the number of intensity intervals for which a specific set of model \nvalues has been estimated. \nNOTE 5 – The intensity intervals may overlap in order to simulate multi-generational film grain. \n    Rec. ITU-T H.264 (06/2019)  369 \n \nnum_model_values_minus1[ c ] plus 1 specifies the number of model values present for each intensity interval in which \nthe film grain has been modelled. The value of num_model_values_minus1[ c ] shall be in the range of 0 to 5, inclusive. \nintensity_interval_lower_bound[ c ][ i ] specifies the lower bound of the interval i of intensity levels for which the set of \nmodel values applies. \nintensity_interval_upper_bound[ c ][ i ] specifies the upper bound of the interval i of intensity levels for which the set \nof model values applies. \nDepending on film_grain_model_id, the selection of the sets of model values is specified as follows: \n–  If film_grain_model_id is equal to 0, the average value of each block b of 8x8 samples in I , referred as b , is \ndecoded avg\nused to select the sets of model values with index s[ j ] that apply to all the samples in the block: \nfor( i = 0, j = 0; i  <=  num_intensity_intervals_minus1[ c ]; i++ ) \n  if( b   >=  intensity_interval_lower_bound[ c ][ i ] && \navg\n       b   <=  intensity_interval_upper_bound[ c ][ i ] ) { \navg\n    s[ j ] = i     (D-19) \n    j++ \n  } \n–  Otherwise (film_grain_model_id is equal to 1), the sets of model values used to generate the film grain are selected \nfor each sample value in I  as follows: \ndecoded\nfor( i = 0, j = 0; i  <=  num_intensity_intervals_minus1[ c ]; i++ ) \n  if( I [ x, y, c ]  >=  intensity_interval_lower_bound[ c ][ i ] && \ndecoded\n       I [ x, y, c ]  <=  intensity_interval_upper_bound[ c ][ i ] ) {  (D-20) \ndecoded\n    s[ j ] = i \n    j++ \n  } \nSamples that do not fall into any of the defined intervals are not modified by the grain generation function. Samples that \nfall into more than one interval will originate multi-generation grain. Multi-generation grain results from adding the grain \ncomputed independently for each intensity interval. \ncomp_model_value[ c ][ i ][ j ] represents each one of the model values present for the colour component c and the \nintensity interval i. The set of model values has different meaning depending on the value of film_grain_model_id. The \nvalue of comp_model_value[ c ][ i ][ j ] shall be constrained as follows, and may be additionally constrained as specified \nelsewhere in this clause. \n–  If film_grain_model_id is equal to 0, comp_model_value[ c ][ i ][ j ] shall be in the range of 0 to 2filmGrainBitDepth[ c ] − 1, \ninclusive. \n–  Otherwise  (film_grain_model_id  is  equal  to  1),  comp_model_value[ c ][ i ][ j ]  shall  be  in  the  range  of \n−2( filmGrainBitDepth[ c ] − 1 ) to 2( filmGrainBitDepth[ c ] − 1 ) − 1, inclusive. \nDepending on film_grain_model_id, the synthesis of the film grain is modelled as follows: \n–  If film_grain_model_id is equal to 0, a frequency filtering model enables simulating the original film grain for c = 0..2, \nx = 0..PicWidthInSamples , and y = 0..PicHeightInSamples  as specified by: \nL L\nG[ x, y, c ] = ( comp_model_value[ c ][ s ][ 0 ] * Q[ c ][ x, y ] + comp_model_value[ c ][ s ][ 5 ] * \n      G[ x, y, c − 1 ] ) >> log2_scale_factor  (D-21) \n  where Q[ c ] is a two-dimensional random process generated by filtering 16x16 blocks gaussRv with random-value \nelements  gaussRv   generated  with  a  normalized  Gaussian  distribution  (independent  and  identically  distributed \nij\nGaussian  random  variable  samples  with  zero  mean  and  unity  variance)  and  where  the  value  of  an  element \nG[ x, y, c −1 ] used in the right-hand side of the equation is inferred to be equal to 0 when c − 1 is less than 0. \nNOTE 6 – A normalized Gaussian random value can be generated from two independent, uniformly distributed random \nvalues over the interval from 0 to 1 (and not equal to 0), denoted as uRv  and uRv , using the Box-Muller transformation \n0 1\nspecified by \ngaussRv  2*Ln( uRv ) *Cos( 2 * π*uRv  )\n  (D-22) \nij 0 1\nwhere  is Archimedes' constant 3.141 592 653.... \n370  Rec. ITU-T H.264 (06/2019) \n \n  The band-pass filtering of blocks gaussRv may be performed in the discrete cosine transform (DCT) domain as \nfollows: \nfor( y = 0; y < 16; y++ ) \n  for( x = 0; x < 16; x++ ) \n    if( ( x < comp_model_value[ c ][ s ][ 3 ]  &&  y < comp_model_value[ c ][ s ][ 4 ] )  | |  (D-23) \n       x > comp_model_value[ c ][ s ][ 1 ]  | |  y > comp_model_value[ c ][ s ][ 2 ] ) \n      gaussRv[ x, y ] = 0 \nfilteredRv = IDCT16x16( gaussRv ) \n  where IDCT16x16( z ) refers to a unitary inverse discrete cosine transformation (IDCT) operating on a 16x16 matrix \nargument z as specified by \nIDCT16x16( z ) = r * z * rT    (D-24) \n  where the superscript T indicates a matrix transposition and r is the 16x16 matrix with elements r  specified by \nij\n( ( i     0 ) ?  1  :  2 )  i *( 2* j  1 )* \nr  Cos        (D-25) \nij\n4  32 \n  where  is Archimedes' constant 3.141 592 653. \n  Q[ c ] is formed by the frequency-filtered blocks filteredRv. \nNOTE 7 – Coded model values are based on blocks of 16x16, but a decoder implementation may use other block sizes. \nFor example, decoders implementing the IDCT on 8x8 blocks, should down-convert by a factor of two the set of coded \nmodel values comp_model_value[ c ][ s ][ i ] for i equal to 1..4. \nNOTE 8 – To reduce the degree of visible blocks that can result from mosaicking the frequency-filtered blocks filteredRv, \ndecoders may apply a low-pass filter to the boundaries between frequency-filtered blocks. \n–  Otherwise (film_grain_model_id is equal to 1), an auto-regression model enables simulating the original film grain \nfor c = 0..2, x = 0..PicWidthInSamples , and y = 0..PicHeightInSamples  as specified by \nL L\nG[ x, y, c ] = ( comp_model_value[ c ][ s ][ 0 ] * n[ x, y, c ] + \ncomp_model_value[ c ][ s ][ 1 ] * ( G[ x − 1, y, c ] + ( ( comp_model_value[ c ][ s ][ 4 ] * G[ x, y − 1, c ] )  >> \n   log2_scale_factor ) ) + \ncomp_model_value[ c ][ s ][ 3 ] * ( ( ( comp_model_value[ c ][ s ][ 4 ] * G[ x − 1, y − 1, c ] ) >> \n   log2_scale_factor ) + G[ x+1, y − 1, c ] ) + \ncomp_model_value[ c ][ s ][ 5 ] * ( G[ x − 2, y, c ] + \n   ( ( comp_model_value[ c ][ s ][ 4 ] * comp_model_value[ c ][ s ][ 4 ] * G[ x, y − 2, c ] ) >> \n     ( 2 * log2_scale_factor ) ) ) + \n comp_model_value[ c ][ s ][ 2 ] * G[ x, y, c − 1 ] ) >> log2_scale_factor  (D-26) \n  where n[ x, y, c ] is a random value with normalized Gaussian distribution (independent and identically distributed \nGaussian random variable samples with zero mean and unity variance for each value of x, y, and c) and where the \nvalue of an element G[ x, y, c ] used in the right-hand side of the equation is inferred to be equal to 0 when any of the \nfollowing conditions are true: \n–  x is less than 0, \n–  y is less than 0, \n–  x is greater than or equal to PicWidthInSamples , \nL\n–  c is less than 0. \ncomp_model_value[ c ][ i ][ 0 ]  provides  the  first  model  value  for  the  model  as  specified  by  film_grain_model_id. \ncomp_model_value[ c ][ i ][ 0 ]  corresponds  to  the  standard  deviation  of  the  Gaussian  noise  term  in  the  generation \nfunctions specified in Equations D-21 through D-26. \ncomp_model_value[ c ][ i ][ 1 ] provides the second model value for the model as specified by film_grain_model_id. When \nfilm_grain_model_id is equal to 0, comp_model_value[ c ][ i ][ 1 ] shall be greater than or equal to 0 and less than 16. \nWhen not present in the film grain characteristics SEI message, comp_model_value[ c ][ i ][ 1 ] shall be inferred as \nfollows: \n–  If film_grain_model_id is equal to 0, comp_model_value[ c ][ i ][ 1 ] shall be inferred to be equal to 8. \n–  Otherwise (film_grain_model_id is equal to 1), comp_model_value[ c ][ i ][ 1 ] shall be inferred to be equal to 0. \ncomp_model_value[ c ][ i ][ 1 ] is interpreted as follows: \n    Rec. ITU-T H.264 (06/2019)  371 \n \n–  If film_grain_model_id is equal to 0, comp_model_value[ c ][ i ][ 1 ] indicates the horizontal high cut frequency to \nbe used to filter the DCT of a block of 16x16 random values. \n–  Otherwise  (film_grain_model_id  is  equal  to 1),  comp_model_value[ c ][ i ][ 1 ]  indicates  the  first  order  spatial \ncorrelation for neighbouring samples (x − 1, y) and (x, y − 1). \ncomp_model_value[ c ][ i ][ 2 ] provides the third model value for the model as specified by film_grain_model_id. When \nfilm_grain_model_id is equal to 0, comp_model_value[ c ][ i ][ 2 ] shall be greater than or equal to 0 and less than 16. \nWhen not present in the film grain characteristics SEI message, comp_model_value[ c ][ i ][ 2 ] shall be inferred as \nfollows: \n–  If  film_grain_model_id  is  equal  to  0,  comp_model_value[ c ][ i ][ 2 ]  shall  be  inferred  to  be  equal \nto comp_model_value[ c ][ i ][ 1 ] \n–  Otherwise (film_grain_model_id is equal to 1), comp_model_value[ c ][ i ][ 2 ] shall be inferred to be equal to 0. \ncomp_model_value[ c ][ i ][ 2 ] is interpreted as follows: \n–  If film_grain_model_id is equal to 0, comp_model_value[ c ][ i ][ 2 ] indicates the vertical high cut frequency to be \nused to filter the DCT of a block of 16x16 random values. \n–  Otherwise  (film_grain_model_id  is  equal  to 1),  comp_model_value[ c ][ i ][ 2 ]  indicates  the  colour  correlation \nbetween consecutive colour components. \ncomp_model_value[ c ][ i ][ 3 ] provides the fourth model value for the model as specified by film_grain_model_id. When \nfilm_grain_model_id is equal to 0, comp_model_value[ c ][ i ][ 3 ] shall be greater than or equal to 0 and less than or equal \nto comp_model_value[ c ][ i ][ 1 ]. \nWhen not present in the film grain characteristics SEI message, comp_model_value[ c ][ i ][ 3 ] shall be inferred to be \nequal to 0. \ncomp_model_value[ c ][ i ][ 3 ] is interpreted as follows: \n–  If film_grain_model_id is equal to 0, comp_model_value[ c ][ i ][ 3 ] indicates the horizontal low cut frequency to be \nused to filter the DCT of a block of 16x16 random values. \n–  Otherwise  (film_grain_model_id  is  equal  to 1),  comp_model_value[ c ][ i ][ 3 ]  indicates  the  first  order  spatial \ncorrelation for neighbouring samples (x − 1, y − 1) and (x + 1, y − 1). \ncomp_model_value[ c ][ i ][ 4 ] provides the fifth model value for the model as specified by film_grain_model_id. When \nfilm_grain_model_id is equal to 0, comp_model_value[ c ][ i ][ 4] shall be greater than or equal to 0 and less than or equal \nto comp_model_value[ c ][ i ][ 2 ]. \nWhen not present in the film grain characteristics SEI message, comp_model_value[ c ][ i ][ 4 ] shall be inferred to be \nequal to film_grain_model_id. \ncomp_model_value[ c ][ i ][ 4 ] is interpreted as follows: \n–  If film_grain_model_id is equal to 0, comp_model_value[ c ][ i ][ 4 ] indicates the vertical low cut frequency to be \nused to filter the DCT of a block of 16x16 random values. \n–  Otherwise  (film_grain_model_id  is  equal  to 1),  comp_model_value[ c ][ i ][ 4 ]  indicates  the  aspect  ratio  of  the \nmodelled grain. \ncomp_model_value[ c ][ i ][ 5 ] provides the sixth model value for the model as specified by film_grain_model_id. \nWhen not present in the film grain characteristics SEI message, comp_model_value[ c ][ i ][ 5 ] shall be inferred to be \nequal to 0. \ncomp_model_value[ c ][ i ][ 5 ] is interpreted as follows: \n–  If  film_grain_model_id  is  equal  to 0,  comp_model_value[ c ][ i ][ 5 ]  indicates  the  colour  correlation  between \nconsecutive colour components. \n–  Otherwise (film_grain_model_id is equal to 1), comp_model_value[ c ][ i ][ 5 ] indicates the second order spatial \ncorrelation for neighbouring samples (x, y − 2) and (x − 2, y). \nfilm_grain_characteristics_repetition_period specifies the persistence of the film grain characteristics SEI message and \nmay specify a picture order count interval within which another film grain characteristics SEI message or the end of the \ncoded video sequence shall be present in the bitstream. The value of film_grain_characteristics_repetition_period shall be \nin the range 0 to 16 384, inclusive. \nfilm_grain_characteristics_repetition_period equal to 0 specifies that the film grain characteristics SEI message applies to \nthe current decoded picture only. \n372  Rec. ITU-T H.264 (06/2019) \n \nfilm_grain_characteristics_repetition_period equal to 1 specifies that the film grain characteristics SEI message persists in \noutput order until any of the following conditions are true: \n–  A new coded video sequence begins. \n–  A picture in an access unit containing a film grain characteristics SEI message is output having PicOrderCnt( ) greater \nthan PicOrderCnt( CurrPic ). \nfilm_grain_characteristics_repetition_period greater than 1 specifies that the film grain characteristics SEI message persists \nuntil any of the following conditions are true: \n–  A new coded video sequence begins. \n–  A picture in an access unit containing a film grain characteristics SEI message is output having PicOrderCnt( ) greater \nthan  PicOrderCnt( CurrPic )  and  less  than  or  equal  to  PicOrderCnt( CurrPic )  + \nfilm_grain_characteristics_repetition_period. \nfilm_grain_characteristics_repetition_period greater than 1 indicates that another film grain characteristics SEI message \nshall be present for a picture in an access unit that is output having PicOrderCnt( ) greater than PicOrderCnt( CurrPic ) and \nless than or equal to PicOrderCnt( CurrPic ) + film_grain_characteristics_repetition_period; unless the bitstream ends or a \nnew coded video sequence begins without output of such a picture. \nD.2.22  Deblocking filter display preference SEI message semantics \nThis SEI message provides the decoder with an indication of whether the display of the cropped result of the deblocking \nfilter process specified in clause 8.7 or of the cropped result of the picture construction process prior to the deblocking \nfilter process specified in clause 8.5.14 is preferred by the encoder for the display of each decoded picture that is output. \nNOTE 1 – The display process is not specified in this Recommendation | International Standard. The means by which an encoder \ndetermines what to indicate as its preference expressed in a deblocking filter display preference SEI message is also not specified in \nthis Recommendation | International Standard, and the expression of an expressed preference in a deblocking filter display preference \nSEI message does not impose any requirement on the display process. \ndeblocking_display_preference_cancel_flag equal to 1 indicates that the SEI message cancels the persistence of any \nprevious deblocking filter display preference SEI message in output order. deblocking_display_preference_cancel_flag \nequal  to  0  indicates  that  a  display_prior_to_deblocking_preferred_flag  and \ndeblocking_display_preference_repetition_period follow. \nNOTE 2 – In the absence of the deblocking filter display preference SEI message, or after the receipt of a deblocking filter display \npreference SEI message in which deblocking_display_preference_cancel_flag is equal to 1, the decoder should infer that the display \nof the cropped result of the deblocking filter process specified in clause 8.7 is preferred over the display of the cropped result of the \npicture construction process prior to the deblocking filter process specified in clause 8.5.14 for the display of each decoded picture \nthat is output. \ndisplay_prior_to_deblocking_preferred_flag equal to 1 indicates that the encoder preference is for the display process \n(which is not specified in this Recommendation | International Standard) to display the cropped result of the picture \nconstruction process prior to the deblocking filter process specified in clause 8.5.14 rather than the cropped result of the \ndeblocking filter process specified in clause 8.7 for each picture that is cropped and output as specified in Annex C. \ndisplay_prior_to_deblocking_preferred_flag equal to 0 indicates that the encoder preference is for the display process \n(which is not specified in this Recommendation | International Standard) to display the cropped result of the deblocking \nfilter process specified in clause 8.7 rather than the cropped result of the picture construction process prior to the \ndeblocking filter process specified in clause 8.5.14 for each picture that is cropped and output as specified in Annex C. \nNOTE  3  –  The  presence  or  absence  of  the  deblocking  filter  display  preference  SEI  message  and  the  value  of \ndisplay_prior_to_deblocking_preferred_flag  does  not  affect  the  requirements  of  the  decoding  process  specified  in  this \nRecommendation | International Standard. Rather, it only provides an indication of when, in addition to fulfilling the requirements \nof this Recommendation | International Standard for the decoding process, enhanced visual quality might be obtained by performing \nthe display process (which is not specified in this Recommendation | International Standard) in an alternative fashion. Encoders that \nuse the deblocking filter display preference SEI message should be designed with an awareness that unless the encoder restricts its \nuse of the DPB capacity specified in Annex A and clauses G.10 and H.10 for the profile and level in use, some decoders may not \nhave sufficient memory capacity for the storage of the result of the picture construction process prior to the deblocking filter process \nspecified in clause 8.5.14 in addition to the storage of the result of the deblocking filter process specified in clause 8.7 when \nreordering and delaying pictures for display, and such decoders would therefore not be able to benefit from the preference indication. \nBy restricting its use of the DPB capacity, an encoder can be able to use at least half of the DPB capacity specified in Annex A and \nclauses G.10 and H.10 while allowing the decoder to use the remaining capacity for storage of unfiltered pictures that have been \nindicated as preferable for display until the output time arrives for those pictures. \n    Rec. ITU-T H.264 (06/2019)  373 \n \ndec_frame_buffering_constraint_flag equal to 1 indicates that the use of the frame buffering capacity of the HRD \ndecoded picture buffer (DPB) as specified by max_dec_frame_buffering has been constrained such that the coded video \nsequence will not require a decoded picture buffer with more than Max( 1, max_dec_frame_buffering ) frame buffers to \nenable the output of the decoded filtered or unfiltered pictures, as indicated by the deblocking filter display preference SEI \nmessages,  at  the  output  times  specified  by  the  dpb_output_delay  of  the  picture  timing  SEI  messages. \ndec_frame_buffering_constraint_flag equal to 0 indicates that the use of the frame buffering capacity in the HRD may or \nmay not be constrained in the manner that would be indicated by dec_frame_buffering_constraint_flag equal to 1. \nFor purposes of determining the constraint imposed when dec_frame_buffering_constraint_flag is equal to 1, the quantity \nof frame buffering capacity used at any given point in time by each frame buffer of the DPB that contains a picture shall \nbe derived as follows: \n–  If both of the following criteria are satisfied for the frame buffer, the frame buffer is considered to use two frame \nbuffers of capacity for its storage. \n–  The frame buffer contains a frame or one or more fields that is marked as \"used for reference\", and \n–  The frame buffer contains a picture for which both of the following criteria are fulfilled: \n–  The HRD output time of the picture is greater than the given point in time. \n–  It has been indicated in a deblocking filter display preference SEI message that the encoder preference for \nthe picture is for the display process to display the cropped result of the picture construction process prior \nto the deblocking filter process specified in clause 8.5.14 rather than the cropped result of the deblocking \nfilter process specified in clause 8.7. \n–  Otherwise, the frame buffer is considered to use one frame buffer of DPB capacity for its storage. \nWhen dec_frame_buffering_constraint_flag is equal to 1, the frame buffering capacity used by all of the frame buffers in \nthe DPB that contain pictures, as derived in this manner, shall not be greater than Max( 1, max_dec_frame_buffering ) \nduring the operation of the HRD for the coded video sequence. \nThe  value  of  dec_frame_buffering_constraint_flag  shall  be  the  same  in  all  deblocking  filter  display  preference  SEI \nmessages of the coded video sequence. \ndeblocking_display_preference_repetition_period specifies the persistence of the deblocking filter display preference \nSEI message and may specify a picture order count interval within which another deblocking filter display preference \nmessage  or  the  end  of  the  coded  video  sequence  shall  be  present  in  the  bitstream.  The  value  of \ndeblocking_display_preference_repetition_period shall be in the range 0 to 16 384, inclusive. \ndeblocking_display_preference_repetition_period equal to 0 specifies that the deblocking filter display preference SEI \nmessage applies to the current decoded picture only. \ndeblocking_display_preference_repetition_period equal to 1 specifies that the deblocking filter display preference SEI \nmessage persists in output order until any of the following conditions are true: \n–  A new coded video sequence begins. \n–  A  picture  in  an  access  unit  containing  a  deblocking  filter  display  preference  SEI  message  is  output  having \nPicOrderCnt( ) greater than PicOrderCnt( CurrPic ). \ndeblocking_display_preference_repetition_period greater than 1 specifies that the deblocking filter display preference SEI \nmessage persists until any of the following conditions are true: \n–  A new coded video sequence begins. \n–  A  picture  in  an  access  unit  containing  a  deblocking  filter  display  preference  SEI  message  is  output  having \nPicOrderCnt( )  greater  than  PicOrderCnt( CurrPic )  and  less  than  or  equal  to  PicOrderCnt( CurrPic )  + \ndeblocking_display_preference_repetition_period. \ndeblocking_display_preference_repetition_period  greater  than  1  indicates  that  another deblocking  filter  display \npreference SEI message shall be present for a picture in an access unit that is output having PicOrderCnt( ) greater than \nPicOrderCnt( CurrPic )  and  less  than  or  equal  to  PicOrderCnt( CurrPic )  + \ndeblocking_display_preference_repetition_period; unless the bitstream ends or a new coded video sequence begins without \noutput of such a picture. \nD.2.23  Stereo video information SEI message semantics \nNOTE 1 – The stereo video information SEI message is included in this Specification primarily for historical reasons. It is now \nsuggested to use the frame packing arrangement SEI message rather than the stereo video information SEI message to signal stereo \nvideo information. \nThis SEI message provides the decoder with an indication that the entire coded video sequence consists of pairs of pictures \nforming stereo-view content. \n374  Rec. ITU-T H.264 (06/2019) \n \nThe stereo video information SEI message shall not be present in any access unit of a coded video sequence unless a stereo \nvideo information SEI message is present in the first access unit of the coded video sequence. \nfield_views_flag equal to 1 indicates that all pictures in the current coded video sequence are fields and all fields of a \nparticular parity are considered a left view and all fields of the opposite parity are considered a right view for stereo-view \ncontent.  field_views_flag equal to 0 indicates  that all pictures in the current coded video sequence are  frames and \nalternating frames in output order represent a view of a stereo view. The value of field_views_flag shall be the same in all \nstereo video information SEI messages within a coded video sequence. \nWhen the stereo video information SEI message is present and field_views_flag is equal to 1, the left view and right view \nof a stereo video pair shall be coded as a complementary field pair, the display time of the first field of the field pair in \noutput order should be delayed to coincide with the display time of the second field of the field pair in output order, and \nthe spatial locations of the samples in each individual field should be interpreted for display purposes as representing \ncomplete pictures as shown in Figure 6-1 rather than as spatially-distinct fields within a frame as shown in Figure 6-2. \nNOTE 2 – The display process is not specified in this Recommendation | International Standard. \ntop_field_is_left_view_flag equal to 1 indicates that the top fields in the coded video sequence represent a left view and \nthe bottom fields in the coded video sequence represent a right view. top_field_is_left_view_flag equal to 0 indicates that \nthe bottom fields in the coded video sequence represent a left view and the top fields in the coded video sequence represent \na right view. When present, the value of top_field_is_left_view_flag shall be the same in all stereo video information SEI \nmessages within a coded video sequence. \ncurrent_frame_is_left_view_flag equal to 1 indicates that the current picture is the left view of a stereo-view pair. \ncurrent_frame_is_left_view_flag equal to 0 indicates that the current picture is the right view of a stereo-view pair. \nnext_frame_is_second_view_flag equal to 1 indicates that the current picture and the next picture in output order form a \nstereo-view pair, and the display time of the current picture should be delayed to coincide with the display time of the next \npicture in output order. next_frame_is_second_view_flag equal to 0 indicates that the current picture and the previous \npicture in output order form a stereo-view pair, and the display time of the current picture should not be delayed for \npurposes of stereo-view pairing. \nleft_view_self_contained_flag equal to 1 indicates that no inter prediction operations within the decoding process for the \nleft-view  pictures  of  the  coded  video  sequence  refer  to  reference  pictures  that  are  right-view  pictures. \nleft_view_self_contained_flag equal to 0 indicates that some inter prediction operations within the decoding process for \nthe left-view pictures of the coded video sequence may or may not refer to reference pictures that are right-view pictures. \nWithin a coded video sequence, the value of left_view_self_contained_flag in all stereo video information SEI messages \nshall be the same. \nright_view_self_contained_flag equal to 1 indicates that no inter prediction operations within the decoding process for \nthe  right-view  pictures  of  the  coded  video  sequence  refer  to  reference  pictures  that  are  left-view  pictures. \nright_view_self_contained_flag equal to 0 indicates that some inter prediction operations within the decoding process for \nthe right-view pictures of the coded video sequence may or may not refer to reference pictures that are left-view pictures. \nWithin a coded video sequence, the value of right_view_self_contained_flag in all stereo video information SEI messages \nshall be the same. \nD.2.24  Post-filter hint SEI message semantics \nThis SEI message provides the coefficients of a post-filter or correlation information for the design of a post-filter for \npotential use in post-processing of the output decoded pictures to obtain improved displayed quality. \nfilter_hint_size_y specifies the vertical size of the filter coefficient or correlation array. The value of filter_hint_size_y \nshall be in the range of 1 to 15, inclusive. \nfilter_hint_size_x specifies the horizontal size of the filter coefficient or correlation array. The value of filter_hint_size_x \nshall be in the range of 1 to 15, inclusive. \nfilter_hint_type identifies the type of the transmitted filter hints as specified in Table D-7. The value of filter_hint_type \nshall be in the range of 0 to 2, inclusive. Decoders shall ignore post-filter hint SEI messages having filter_hint_type equal \nto the reserved value 3. \n    Rec. ITU-T H.264 (06/2019)  375 \n \nTable D-7 – filter_hint_type values \n \nValue  Description \n0  coefficients of a 2D FIRfilter  \n1  coefficients of two 1D FIR filters \n2  cross-correlation matrix \n3  Reserved \n \nfilter_hint[ colour_component ][ cy ][ cx ] specifies a filter coefficient or an element of a cross-correlation matrix between \noriginal and decoded signal with 16-bit precision. The value of filter_hint[ colour_component ][ cy ][ cx ] shall be in the \nrange of −231 + 1 to 231 − 1, inclusive. colour_component specifies the related colour component. cy represents a counter \nin vertical direction, cx represents a counter in horizontal direction. Depending on filter_hint_type, the following applies: \n–  If filter_hint_type is equal to 0, the coefficients of a 2-dimensional FIR filter with the size of filter_hint_size_y * \nfilter_hint_size_x are transmitted. \n–  Otherwise, if filter_hint_type is equal to 1, the filter coefficients of two 1-dimensional FIR filters are transmitted. In \nthis case, filter_hint_size_y shall be equal to 2. The index cy = 0 specifies the filter coefficients of the horizontal filter \nand cy = 1 specifies the filter coefficients of the vertical filter. In the filtering process, the horizontal filter shall be \napplied first and the result shall be filtered by the vertical filter. \n–  Otherwise (filter_hint_type is equal to 2), the transmitted hints specify a cross-correlation matrix between the original \nsignal s and the decoded signal s′. \nNOTE 1 – The normalized cross-correlation matrix for a related colour component with the size of filter_hint_size_y * \nfilter_hint_size_x is defined as follows: \n1 h1 w1\nfilter_hint (cy,cx)   s(m,n)s(mcyoffset _ y,ncxoffset _ x)   (D-27) \n(28bitDepth1)2 hw\nm0n0\nwhere s denotes the original frame, s′ denotes the decoded frame, h denotes the vertical height of the related colour \ncomponent, w denotes the horizontal width of the related colour component, bitDepth denotes the bit depth of the colour \ncomponent,  offset_y  is  equal  to  (filter_hint_size_y >> 1),  offset_x  is  equal  to  (filter_hint_size_x  >>  1),  0  <=  cy  < \nfilter_hint_size_y and 0 <= cx < filter_hint_size_x. \nNOTE 2 – A decoder can derive a Wiener post-filter from the cross-correlation matrix of original and decoded signal and the \nauto-correlation matrix of the decoded signal. \nadditional_extension_flag equal to 0 indicates that no additional data follows within the post-filter hint SEI message. The \nvalue of additional_extension_flag shall be equal to 0. The value of 1 for additional_extension_flag is reserved for future \nuse by ITU-T | ISO/IEC. Decoders shall ignore all data that follows the value of 1 for additional_extension_flag in a post-\nfilter hint SEI message. \nD.2.25  Tone mapping information SEI message semantics \nThis SEI message provides information to enable remapping of the colour samples of the output decoded pictures for \ncustomization to particular display environments. The remapping process maps coded sample values in the RGB colour \nspace (specified in Annex E) to target sample values. The mappings are expressed in the luma or RGB colour space domain, \nand should be applied to the luma component or to each RGB component produced by colour space conversion of the \ndecoded image accordingly. \ntone_map_id contains an identifying number that may be used to identify the purpose of the tone mapping model. The \nvalue of tone_map_id shall be in the range of 0 to 232 − 2, inclusive. \nValues of tone_map_id from 0 to 255, inclusive, and from 512 to 231 − 1, inclusive, may be used as determined by the \napplication. Values of tone_map_id from 256 to 511, inclusive, and from 231 to 232 − 2, inclusive, are reserved for future \nuse by ITU-T | ISO/IEC. Decoders encountering a value of tone_map_id in the range of 256 to 511, inclusive, or in the \nrange of 231 to 232 − 2, inclusive, shall ignore it. \nNOTE 1 – The tone_map_id can be used to support tone mapping operations that are suitable for different display scenarios. For \nexample, different values of tone_map_id may correspond to different display bit depths. \ntone_map_cancel_flag equal to 1 indicates that the tone mapping information SEI message cancels the persistence of any \nprevious tone mapping information SEI message in output order. tone_map_cancel_flag equal to 0 indicates that tone \nmapping information follows. \n376  Rec. ITU-T H.264 (06/2019) \n \ntone_map_repetition_period specifies the persistence of the tone mapping information SEI message and may specify a \npicture  order  count  interval  within  which  another  tone  mapping  information  SEI  message  with  the  same  value  of \ntone_map_id  or  the  end  of  the  coded  video  sequence  shall  be  present  in  the  bitstream.  The  value  of \ntone_map_repetition_period shall be in the range of 0 to 16 384, inclusive. \ntone_map_repetition_period equal to 0 specifies that the tone map information applies to the current decoded picture only. \ntone_map_repetition_period equal to 1 specifies that the tone map information persists in output order until any of the \nfollowing conditions are true: \n–  A new coded video sequence begins. \n–  A picture in an access unit containing a tone mapping information SEI message with the same value of tone_map_id \nis output having PicOrderCnt( ) greater than PicOrderCnt( CurrPic ). \ntone_map_repetition_period equal to 0 or equal to 1 indicates that another tone mapping information SEI message with \nthe same value of tone_map_id may or may not be present. \ntone_map_repetition_period greater than 1 specifies that the tone map information persists until any of the following \nconditions are true: \n–  A new coded video sequence begins. \n–  A picture in an access unit containing a tone mapping information SEI message with the same value of tone_map_id \nis output having PicOrderCnt( ) greater than PicOrderCnt( CurrPic ) and less than or equal to PicOrderCnt( CurrPic ) \n+ tone_map_repetition_period. \ntone_map_repetition_period greater than 1 indicates that another tone mapping information SEI message with the same \nvalue of tone_map_id shall be present for a picture in an access unit that is output having PicOrderCnt( ) greater than \nPicOrderCnt( CurrPic )  and  less  than  or  equal  to  PicOrderCnt( CurrPic )  +  tone_map_repetition_period;  unless  the \nbitstream ends or a new coded video sequence begins without output of such a picture. \ncoded_data_bit_depth specifies the BitDepth  for interpretation of the luma component of the associated pictures for \nY\npurposes of interpretation of the tone mapping information SEI message. If tone mapping information SEI messages are \npresent that have coded_data_bit_depth that is not equal to BitDepth , these refer to the hypothetical result of a transcoding \nY\noperation performed to convert the coded video to the BitDepth  corresponding to the value of coded_data_bit_depth. \nY\nThe value of coded_data_bit_depth shall be in the range of 8 to 14, inclusive. Values of coded_data_bit_depth from 0 to 7 \nand from 15 to 255 are reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore (remove from the bitstream and \ndiscard) all tone mapping SEI messages that contain a coded_data_bit_depth in the range of 0 to 7 or in the range of 15 to \n255, and bitstreams shall not contain such values. \ntarget_bit_depth specifies the bit depth of the output of the dynamic range mapping function (or tone mapping function) \ndescribed  by  the  tone  mapping  information  SEI  message.  The  tone  mapping  function  specified  with  a  particular \ntarget_bit_depth is suggested to be reasonable for all display bit depths that are less than or equal to the target_bit_depth. \nThe value of target_bit_depth shall be in the range of 1 to 16, inclusive. Values of target_bit_depth equal to 0 and in the \nrange of 17 to 255 are reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore (remove from the bitstream and \ndiscard) all tone mapping SEI messages that contain a value of target_bit_depth equal to 0 or in the range of 17 to 255, and \nbitstreams shall not contain such values. \ntone_map_model_id specifies the model utilized for mapping the coded data into the target_bit_depth range. Values \ngreater than 3 are reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore (remove from the bitstream and \ndiscard) all tone mapping SEI messages that contain a value of tone_map_model_id greater than 4, and bitstreams shall \nnot contain such values. Decoders shall allow reserved values of tone_map_model_id in the range of 5 to 16 384, inclusive, \nto be present in the bitstream. \nNOTE 2 – A tone_map_model_id value of 0 corresponds to a linear mapping with clipping; a tone_map_model_id value of 1 \ncorresponds  to  a  sigmoidal  mapping;  a  tone_map_model_id  value  of  2  corresponds  to  a  user-defined  table  mapping,  a \ntone_map_model_id value of 3 corresponds to a piece-wise linear mapping, and a tone_map_model_id value of 4 corresponds to \nluminance dynamic range information. \nmin_value specifies the RGB sample value that maps to the minimum value in the bit depth indicated by target_bit_depth. \nIt is used in combination with the max_value parameter. All sample values of the decoded picture that are less than or \nequal to min_value after conversion to the RGB domain (when decoded in a different domain) are mapped to this minimum \nvalue in the target_bit_depth representation. \nmax_value specifies the RGB sample value that maps to the maximum value in the bit depth indicated by target_bit_depth. \nIt is used in combination with the min_value parameter. All sample values of the decoded picture that are greater than or \nequal to max_value after conversion to the RGB domain (when decoded in a different domain) are mapped to this \nmaximum value in the target_bit_depth representation. \n    Rec. ITU-T H.264 (06/2019)  377 \n \nmax_value shall be greater than or equal to min_value. \nsigmoid_midpoint  specifies  the  RGB  sample  value  of  the  coded  data  that  is  mapped  to  the  centre  point  of  the \ntarget_bit_depth representation. It is used in combination with the sigmoid_width parameter. \nsigmoid_width specifies the distance between two coded data values that approximately correspond to the 5% and 95% \nvalues of the target_bit_depth representation, respectively. It is used in combination with the sigmoid_midpoint parameter \nand is interpreted according to the following function: \n \n \n 2 target_bit_depth 1 \ncoded_bit_depth\nf (i)  Round   for i  0,, (2 1)     (D-28) \n \n 6* i  sigmoid_midpoint \n \n1exp \n  \nsigmoid_width\n  \nwhere f( i ) denotes the function that maps an RGB sample value i from the coded data to a resulting RGB sample value in \nthe target_bit_depth representation. \nstart_of_coded_interval[ i ] specifies the beginning point of an interval in the coded data such that all RGB sample values \nthat are greater than or equal to start_of_coded_interval[ i ] and less than start_of_coded_interval[ i + 1 ] are mapped to i \nin the target bit depth representation. The value of start_of_coded_interval[ 2target_bit_depth ] is equal to 2coded_bit_depth. The \nnumber of bits used for the representation of the start_of_coded_interval is ( ( coded_data_bit_depth + 7 ) >> 3 ) << 3. \nnum_pivots specifies the number of pivot points in the piece-wise linear mapping function without counting the two \ndefault end points, (0, 0) and (2coded_data_bit_depth − 1, 2target_bit_depth − 1) . \ncoded_pivot_value[ i ] specifies the value in the coded_data_bit_depth corresponding to the i-th pivot point. The number \nof bits used for the representation of the coded_pivot_value is ( ( coded_data_bit_depth + 7 ) >> 3 ) << 3. \ntarget_pivot_value[ i ] specifies the value in the reference target_bit_depth corresponding to the i-th pivot point. The \nnumber of bits used for the representation of the target_pivot_value is ( ( target_bit_depth + 7 ) >> 3 ) << 3. \ncamera_iso_speed_idc indicates the camera ISO speed for daylight illumination as specified by ISO 12232, interpreted \nas  specified  by  Table D-8.  When  camera_iso_speed_idc  indicates  Extended_ISO,  the  ISO  speed  is  represented  by \ncamera_iso_speed_value. \ncamera_iso_speed_value indicates the camera ISO speed for daylight illumination as specified by ISO 12232 when \ncamera_iso_speed_idc is set to Extended_ISO. The value of camera_iso_speed_value shall not be equal to 0. \nexposure_index_idc indicates the exposure index setting of the camera as specified by ISO 12232, interpreted as specified \nby  Table D-8.  When  exposure_index_idc  indicates  Extended_ISO,  the  exposure  index  is  indicated  by \nexposure_index_value. \nThe values of camera_iso_speed_idc and exposure_index_idc in the range of 31 to 254, inclusive, are reserved for future \nuse by ITU-T | ISO/IEC, and shall not be present in bitstreams conforming to this version of this Specification. Decoders \nconforming to this version of this Specification shall ignore tone mapping SEI messages that contain these values. \nexposure_index_value  indicates  the  exposure  index  setting  of  the  camera  as  specified  by  ISO  12232  when \nexposure_index_idc indicates Extended_ISO. The value of exposure_index_value shall not be equal to 0. \n378  Rec. ITU-T H.264 (06/2019) \n \nTable D-8 – Interpretation of camera_iso_speed_idc and exposure_index_idc \n \ncamera_iso_speed_idc or  Indicated value \nexposure_index_idc \n0  Unspecified \n1  10 \n2  12 \n3  16 \n4  20 \n5  25 \n6  32 \n7  40 \n8  50 \n9  64 \n10  80 \n11  100 \n12  125 \n13  160 \n14  200 \n15  250 \n16  320 \n17  400 \n18  500 \n19  640 \n20  800 \n21  1000 \n22  1250 \n23  1600 \n24  2000 \n25  2500 \n26  3200 \n27  4000 \n28  5000 \n29  6400 \n30  8000 \n31..254  Reserved \n255  Extended_ISO \n    Rec. ITU-T H.264 (06/2019)  379 \n \n \nexposure_compensation_value_sign_flag,  when  applicable  as  specified  below,  specifies  the  sign  of  the  variable \nExposureCompensationValue  that  indicates  the  exposure  compensation  value  setting  used  for  the  process  of  image \nproduction. \nexposure_compensation_value_numerator, when applicable as specified below, specifies the numerator of the variable \nExposureCompensationValue  that  indicates  the  exposure  compensation  value  setting  used  for  the  process  of  image \nproduction. \nexposure_compensation_value_denom_idc,  when  not  equal  to  0,  specifies  the  denominator  of  the  variable \nExposureCompensationValue  that  indicates  the  exposure  compensation  value  setting  used  for  the  process  of  image \nproduction. \nWhen exposure_compensation_value_denom_idc is present and not equal to 0, the variable ExposureCompensationValue \nis  derived  from  exposure_compensation_value_sign_flag,  exposure_compensation_value_numerator  and \nexposure_compensation_value_denom_idc.  exposure_compensation_value_sign_flag  equal  to  0  indicates  that  the \nExposureCompensationValue  is  positive.  exposure_compensation_value_sign_flag  equal  to  1  indicates  that  the \nExposureCompensationValue is negative. When ExposureCompensationValue is positive, the image is indicated to have \nbeen further sensitized through the process of production, relative to the recommended exposure index of the camera as \nspecified by ISO 12232. When ExposureCompensationValue is negative, the image is indicated to have been further \ndesensitized through the process of production, relative to the recommended exposure index of the camera as specified by \nISO 12232. \nWhen exposure_compensation_value_denom_idc is present and not equal to 0, the variable ExposureCompensationValue \nis derived as follows: \nExposureCompensationValue = ( 1 − 2 * exposure_compensation_value_sign_flag ) * \n    exposure_compensation_value_numerator ÷\n    exposure_compensation_value_denom_idc (D-29) \n \nThe  value  of  ExposureCompensationValue  is  interpreted  in  units  of  exposure  steps  such  that  an  increase  of  1  in \nExposureCompensationValue corresponds to a doubling of exposure in units of lux-seconds. For example, the exposure \ncompensation  value  equal  to  +1÷2  at  the  production  stage  may  be  indicated  by  setting \nexposure_compensation_value_sign_flag  to  0,  exposure_compensation_value_numerator  to  1,  and \nexposure_compensation_value_denom_idc to 2. \nWhen exposure_compensation_value_denom_idc is present and equal to 0, the exposure compensation value is indicated \nas unknown or unspecified. \nref_screen_luminance_white indicates the reference screen brightness setting for the extended range white level used for \nimage production process in units of candela per square metre. \nextended_range_white_level  indicates  the  luminance  dynamic  range  for  extended  dynamic-range  display  of  the \nassociated pictures, after conversion to the linear light domain for display, expressed as an integer percentage relative to \nthe nominal white level. When present, the value of extended_range_white_level should be greater than or equal to 100. \nnominal_black_level_luma_code_value specifies the luma sample value of the associated decoded pictures to which the \nnominal black level is assigned. For example, when coded_data_bit_depth is equal to 8, video_full_range_flag is equal to \n0, and matrix_coefficients is equal to 1, nominal_black_level_luma_code_value should be equal to 16. \nnominal_white_level_luma_code_value specifies the luma sample value of the associated decoded pictures to which the \nnominal white level is assigned. For example, when coded_data_bit_depth is equal to 8, video_full_range_flag is equal to \n0, and matrix_coefficients is equal to 1, nominal_white_level_luma_code_value should be equal to 235. When present, the \nvalue of nominal_white_level_luma_code_value shall be greater than nominal_black_level_luma_code_value. \nextended_white_level_luma_code_value specifies the luma sample value of the associated decoded pictures to which the \nwhite  level  associated  with  an  extended  dynamic  range  is  assigned.  When  present,  the  value  of \nextended_white_level_luma_code_value shall be greater than or equal to nominal_white_level_luma_code_value. \nD.2.26  Frame packing arrangement SEI message semantics \nThis SEI message informs the decoder that the output cropped decoded picture contains samples of multiple distinct \nspatially packed constituent frames that are packed into one frame, or that the output cropped decoded pictures in output \norder form a temporal interleaving of alternating first and second constituent frames, using an indicated frame packing \narrangement scheme. This information can be used by the decoder to appropriately rearrange and process the samples of \nthe constituent frames appropriately for display or other purposes (which are outside the scope of this Specification). \n380  Rec. ITU-T H.264 (06/2019) \n \nThis SEI message may be associated with pictures that are either frames or fields. The frame packing arrangement of the \nsamples is specified in terms of the sampling structure of a frame in order to define a frame packing arrangement structure \nthat is invariant with respect to whether a picture is a single field of such a packed frame or is a complete packed frame. \nframe_packing_arrangement_id contains an identifying number that may be used to identify the usage of the frame \npacking arrangement SEI message. The value of frame_packing_arrangement_id shall be in the range of 0 to 232 − 2, \ninclusive. \nValues of frame_packing_arrangement_id from 0 to 255, inclusive, and from 512 to 231 − 1, inclusive, may be used as \ndetermined by the application. Values of frame_packing_arrangement_id from 256 to 511, inclusive, and from 231 to \n232 − 2,  inclusive,  are  reserved  for  future  use  by  ITU-T | ISO/IEC.  Decoders  encountering  a  value  of \nframe_packing_arrangement_id in the range of 256 to 511, inclusive, or in the range of 231 to 232 − 2, inclusive, shall ignore \nit. \nframe_packing_arrangement_cancel_flag equal to 1 indicates that the frame packing arrangement SEI message cancels \nthe  persistence  of  any  previous  frame  packing  arrangement  SEI  message  in  output  order. \nframe_packing_arrangement_cancel_flag equal to 0 indicates that frame packing arrangement information follows. \nframe_packing_arrangement_type identifies the indicated interpretation of the sample arrays of the output cropped \ndecoded picture as specified in Table D-9. \n \nTable D-9 – Definition of frame_packing_arrangement_type \n \nValue  Interpretation \n0  The frame packing arrangement structure contains a \"checkerboard\" based interleaving of corresponding \nplanes of two constituent frames as illustrated in Figure D-1. \n1  The frame packing arrangement structure contains a column based interleaving of corresponding planes of \ntwo constituent frames as illustrated in Figure D-2 and Figure D-3. \n2  The frame packing arrangement structure contains a row based interleaving of corresponding planes of two \nconstituent frames as illustrated in Figure D-4 and Figure D-5. \n3  The frame packing arrangement structure contains a side-by-side packing arrangement of corresponding \nplanes of two constituent frames as illustrated in Figure D-6, Figure D-7, and Figure D-10. \n4  The frame packing arrangement structure contains a top-bottom packing arrangement of corresponding \nplanes of two constituent frames as illustrated in Figure D-8 and Figure D-9. \n5  The component planes of the output cropped decoded pictures in output order form a temporal interleaving \nof alternating first and second constituent frames as illustrated in Figure D-11. \n6  The output cropped decoded picture constitutes a complete 2D frame (when field_pic_flag is equal to 0) or \nfield (when field_pic_flag is equal to 1) without any frame packing. \n7  The frame packing arrangement structure contains a tile format packing arrangement of corresponding \nplanes of two constituent frames as illustrated in Figure D-12. \n \nNOTE 1 – Figure D-1 to Figure D-10 provide typical examples of rearrangement and upconversion processing for various packing \narrangement schemes. Actual characteristics of the constituent frames are signalled in detail by the subsequent syntax elements of \nthe frame packing arrangement SEI message. In Figure D-1 to Figure D-10, an upconversion processing is performed on each \nconstituent frame to produce frames having the same resolution as that of the decoded frame. An example of the upsampling method \nto be applied to a quincunx sampled frame as shown in Figure D-1 or Figure D-10 is to fill in missing positions with an average of \nthe available spatially neighbouring samples (the average of the values of the available samples above, below, to the left and to the \nright of each sample to be generated). The actual upconversion process to be performed, if any, is outside the scope of this \nSpecification. \nNOTE 2 – The sample aspect ratio (SAR) indicated in the VUI parameters should indicate the output picture shape for the packed \ndecoded frame output by a decoder that does not interpret the frame packing arrangement SEI message. In the examples shown in \nFigure D-1 to Figure D-10, the SAR produced in each upconverted colour plane would be the same as the SAR indicated in the VUI \nparameters, since the illustrated upconversion process produces the same total number of samples from each constituent frame as \nexisted in the packed decoded frame. \nNOTE 3 – When the output time of the samples of constituent frame 0 differs from the output time of the samples of constituent \nframe 1 (i.e., when field_views_flag is equal to 1 or frame_packing_arrangement_type is equal to 5) and the display system in use \npresents two views simultaneously, the display time for constituent frame 0 should be delayed to coincide with the display time for \nconstituent frame 1. (The display process is not specified in this Recommendation | International Standard.) \n    Rec. ITU-T H.264 (06/2019)  381 \n \nNOTE 4 – When  field_views_flag  is  equal  to  1  or  frame_packing_arrangement_type  is  equal  to  5,  the  value  0  for \nfixed_frame_rate_flag is not expected to be prevalent in industry use of this SEI message. \nNOTE 5 – frame_packing_arrangement_type equal to 5 describes a temporal interleaving process of different views. \nNOTE 6 – Figure D-12 provides an illustration of the rearrangement process for the frame packing arrangement scheme for the \nframe_packing_arrangement_type value of 7. \nAll other values of frame_packing_arrangement_type are reserved for future use by ITU-T | ISO/IEC. It is a requirement \nof bitstream conformance that the bitstreams shall not contain such other values of frame_packing_arrangement_type. \nquincunx_sampling_flag equal to 1 indicates that each colour component plane of each constituent frame is quincunx \nsampled as illustrated in Figure D-1 or Figure D-10, and quincunx_sampling_flag equal to 0 indicates that the colour \ncomponent planes of each constituent frame are not quincunx sampled. \nWhen  frame_packing_arrangement_type is equal to 0, it is a requirement of bitstream conformance that quincunx_\nsampling_flag shall be equal to 1. When frame_packing_arrangement_type is equal to 5, 6, or 7, it is a requirement of \nbitstream conformance that quincunx_sampling_flag shall be equal to 0. \nNOTE 7 – For any chroma format (4:2:0, 4:2:2, or 4:4:4), the luma plane and each chroma plane is quincunx sampled as illustrated \nin Figure D-1 when quincunx_sampling_flag is equal to 1. \nLet croppedWidth and croppedHeight be the width and height, respectively, of the cropped frame area output from the \ndecoder in units of luma samples, derived as follows: \ncroppedWidth = PicWidthInSamples  − CropUnitX * ( frame_crop_left_offset + frame_crop_right_offset ) \nL\n        (D-30) \ncroppedHeight = 16 * FrameHeightInMbs − CropUnitY * ( frame_crop_top_offset + frame_crop_bottom_offset ) \n        (D-31) \nWhen frame_packing_arrangement_type is equal to 7, it is a requirement of bitstream conformance that croppedWidth and \ncroppedHeight shall be integer multiples of 3. \nLet oneThirdWidth and oneThirdHeight be derived as follows: \noneThirdWidth = croppedWidth / 3    (D-32) \noneThirdHeight = croppedHeight / 3    (D-33) \nWhen frame_packing_arrangement_type is equal to 7, the frame packing arrangement is composed of five rectangular \nregions identified as R0, R1, R2, R3, and R4 as illustrated in Figure D-12. \nThe width and height of region R0 are specified in units of frame luma samples as follows: \nr0  = 2 * oneThirdWidth    (D-34) \nW\nr0  = 2* oneThirdHeight    (D-35) \nH\nThe width and height of region R1 are specified in units of frame luma samples as follows: \nr1  = oneThirdWidth    (D-36) \nW\nr1  = 2* oneThirdHeight    (D-37) \nH\nThe width and height of region R2 are specified in units of frame luma samples as follows: \nr2  = oneThirdWidth    (D-38) \nW\nr2  = oneThirdHeight    (D-39) \nH\nThe width and height of region R3 are specified in units of frame luma samples as follows: \nr3  = oneThirdWidth    (D-40) \nW\nr3  = oneThirdHeight    (D-41) \nH\nThe width and height of region R4 are specified in units of frame luma samples as follows: \n382  Rec. ITU-T H.264 (06/2019) \n \nr4  = oneThirdWidth    (D-42) \nW\nr4  = oneThirdHeight    (D-43) \nH\nWhen frame_packing_arrangement_type is equal to 7, constituent frame 0 is obtained by cropping from the decoded frames \nregion R0, and constituent frame 1 is obtained by stacking vertically regions R2 and R3 and placing the resulting rectangle \nto the right of the region R1. Region R4 is not part of either constituent frame and is discarded. \ncontent_interpretation_type indicates the intended interpretation of the constituent frames as specified in Table D-10. \nValues of content_interpretation_type that do not appear in Table D-10 are reserved for future specification by ITU-T | \nISO/IEC. When frame_packing_arrangement_type is equal to 6, content_interpretation_type shall be equal to 0. \nWhen frame_packing_arrangement_type is not equal to 6, for each specified frame packing arrangement scheme, there are \ntwo constituent frames that are referred to as frame 0 and frame 1. \nTable D-10 – Definition of content_interpretation_type \nValue  Interpretation \n0  Unspecified relationship between the frame packed constituent frames \n1  Indicates that the two constituent frames form the left and right views of a stereo view scene, with frame 0 \nbeing associated with the left view and frame 1 being associated with the right view \n2  Indicates that the two constituent frames form the right and left views of a stereo view scene, with frame 0 \nbeing associated with the right view and frame 1 being associated with the left view \n \nNOTE 8 – The value 2 for content_interpretation_type is not expected to be prevalent in industry use of this SEI message. However, \nthe value was specified herein for purposes of completeness. \nWhen  frame_packing_arrangement_type  is  equal  to  6,  content_interpretation_type,  frame0_self_contained_flag, \nframe1_self_contained_flag,  frame0_grid_position_x,  frame0_grid_position_y,  frame1_grid_position_x,  and \nframe1_grid_position_y have no meaning and shall be equal to 0, and decoders shall ignore the values of these syntax \nelements. In this case, semantics for other values of these syntax elements are reserved for future specification by ITU-T | \nISO/IEC. \nspatial_flipping_flag equal to 1, when frame_packing_arrangement_type is equal to 3 or 4, indicates that one of the two \nconstituent frames is spatially flipped relative to its intended orientation for display or other such purposes. \nWhen frame_packing_arrangement_type is equal to 3 or 4 and spatial_flipping_flag is equal to 1, the type of spatial flipping \nthat is indicated is as follows: \n–  If frame_packing_arrangement_type is equal to 3, the indicated spatial flipping is horizontal flipping. \n–  Otherwise (frame_packing_arrangement_type is equal to 4), the indicated spatial flipping is vertical flipping. \nWhen  frame_packing_arrangement_type  is  not  equal  to  3  or  4,  it  is  a  requirement  of  bitstream  conformance  that \nspatial_flipping_flag shall be equal to 0. When frame_packing_arrangement_type is not equal to 3 or 4, the value 1 for \nspatial_flipping_flag is reserved for future use by ITU-T | ISO/IEC. When frame_packing_arrangement_type is not equal \nto 3 or 4, decoders shall ignore the value 1 for spatial_flipping_flag. \nframe0_flipped_flag, when spatial_flipping_flag is equal to 1, indicates which one of the two constituent frames is flipped. \nWhen spatial_flipping_flag is equal to 1, frame0_flipped_flag equal to 0 indicates that frame 0 is not spatially flipped and \nframe 1 is spatially flipped, and frame0_flipped_flag equal to 1 indicates that frame 0 is spatially flipped and frame 1 is \nnot spatially flipped. \nWhen spatial_flipping_flag is equal to 0, it is a requirement of bitstream conformance that frame0_flipped_flag shall be \nequal to 0. When spatial_flipping_flag is equal to 0, the value 1 for spatial_flipping_flag is reserved for future use by ITU-\nT | ISO/IEC. When spatial_flipping_flag is equal to 0, decoders shall ignore the value of frame0_flipped_flag. \nfield_views_flag equal to 1 indicates that all pictures in the current coded video sequence are coded as complementary \nfield pairs.  All fields of a particular parity are considered a first constituent frame and all fields of the opposite parity are \nconsidered a second constituent frame.  When frame_packing_arrangement_type is not equal to 2, it is a requirement of \nbitstream conformance that the field_views_flag shall be equal to 0. When frame_packing_arrangement_type is not equal \nto  2,  the  value  1  for  field_views_flag  is  reserved  for  future  use  by  ITU-T |  ISO/IEC.  When  frame_\npacking_arrangement_type is not equal to 2, decoders shall ignore the value of field_views_flag. \n    Rec. ITU-T H.264 (06/2019)  383 \n \ncurrent_frame_is_frame0_flag equal to 1, when frame_packing_arrangement is equal to 5, indicates that the current \ndecoded frame is constituent frame 0 and the next decoded frame in output order is constituent frame 1, and the display \ntime  of  the  constituent  frame  0  should  be  delayed  to  coincide  with  the  display  time  of  constituent  frame  1. \ncurrent_frame_is_frame0_flag equal to 0, when frame_packing_arrangement is equal to 5, indicates that the current \ndecoded frame is constituent frame 1 and the previous decoded frame in output order is constituent frame 0, and the display \ntime of the constituent frame 1 should not be delayed for purposes of stereo-view pairing. \nWhen frame_packing_arrangement_type is not equal to 5, the constituent frame associated with the upper-left sample of \nthe decoded frame is considered to be constituent frame 0 and the other constituent frame is considered to be constituent \nframe 1. When frame_packing_arrangement_type is not equal to 5, it is a requirement of bitstream conformance that \ncurrent_frame_is_frame0_flag shall be equal to 0. When frame_packing_arrangement_type is not equal to 5, the value 1 \nfor current_frame_is_frame0_flag is reserved for future use by ITU-T | ISO/IEC. When frame_packing_arrangement_type \nis not equal to 5, decoders shall ignore the value of current_frame_is_frame0_flag. \nframe0_self_contained_flag equal to 1 indicates that no inter prediction operations within the decoding process for the \nsamples  of  constituent  frame  0  of  the  coded  video  sequence  refer  to  samples  of  any  constituent  frame  1. \nframe0_self_contained_flag equal to 0 indicates that some inter prediction operations within the decoding process for the \nsamples of constituent frame 0 of the coded video sequence may or may not refer to samples of some constituent frame 1. \nWhen  frame_packing_arrangement_type  is  equal  to  0  or  1,  it  is  a  requirement  of  bitstream  conformance  that \nframe0_self_contained_flag shall be equal to 0. When frame_packing_arrangement_type is equal to 0 or 1, the value 1 for \nframe0_self_contained_flag is reserved for future use by ITU-T | ISO/IEC. When frame_packing_arrangement_type is \nequal to 0 or 1, decoders shall ignore the value of frame0_self_contained_flag. Within a coded video sequence, the value \nof frame0_self_contained_flag in all frame packing arrangement SEI messages shall be the same. \nframe1_self_contained_flag equal to 1 indicates that no inter prediction operations within the decoding process for the \nsamples  of  constituent  frame  1  of  the  coded  video  sequence  refer  to  samples  of  any  constituent  frame  0. \nframe1_self_contained_flag equal to 0 indicates that some inter prediction operations within the decoding process for the \nsamples of constituent frame 1 of the coded video sequence may or may not refer to samples of some constituent frame 0. \nWhen  frame_packing_arrangement_type  is  equal  to  0  or  1,  it  is  a  requirement  of  bitstream  conformance  that \nframe1_self_contained_flag shall be equal to 0. When frame_packing_arrangement_type is equal to 0 or 1, the value 1 for \nframe1_self_contained_flag is reserved for future use by ITU-T | ISO/IEC. When frame_packing_arrangement_type is \nequal to 0 or 1, decoders shall ignore the value of frame1_self_contained_flag. Within a coded video sequence, the value \nof frame1_self_contained_flag in all frame packing arrangement SEI messages shall be the same. \nNOTE 9 – When  frame0_self_contained_flag  is  equal  to  1  or  frame1_self_contained_flag  is  equal  to  1,  and \nframe_packing_arrangement_type is equal to 2, it is expected that the decoded frame should not be an MBAFF frame. \nWhen quincunx_sampling_flag is equal to 0 and frame_packing_arrangement_type is not equal to 5, two (x, y) coordinate \npairs are specified to determine the indicated luma sampling grid alignment for constituent frame 0 and constituent frame \n1, relative to the upper left corner of the rectangular area represented by the samples of the corresponding constituent \nframe. \nNOTE 10 – The location of chroma samples relative to luma samples can be indicated by the chroma_sample_loc_type_top_field \nand chroma_sample_loc_type_bottom_field syntax elements in the VUI parameters. \nframe0_grid_position_x (when present) specifies the x component of the (x, y) coordinate pair for constituent frame 0. \nframe0_grid_position_y (when present) specifies the y component of the (x, y) coordinate pair for constituent frame 0. \nframe1_grid_position_x (when present) specifies the x component of the (x, y) coordinate pair for constituent frame 1. \nframe1_grid_position_y (when present) specifies the y component of the (x, y) coordinate pair for constituent frame 1. \nWhen quincunx_sampling_flag is equal to 0 and frame_packing_arrangement_type is not equal to 5 the (x, y) coordinate \npair for each constituent frame is interpreted as follows: \n–  If the (x, y) coordinate pair for a constituent frame is equal to (0, 0), this indicates a default sampling grid alignment \nspecified as follows: \n–  If frame_packing_arrangement_type is equal to 1 or 3, the indicated position is the same as for the (x, y) \ncoordinate pair value (4, 8), as illustrated in Figure D-2 and Figure D-6. \n–  Otherwise (frame_packing_arrangement_type is equal to 2 or 4), the indicated position is the same as for the \n(x, y) coordinate pair value (8, 4), as illustrated in Figure D-4 and Figure D-8. \n–  Otherwise, if the (x, y) coordinate pair for a constituent frame is equal to (15, 15), this indicates that the sampling \ngrid alignment is unknown or unspecified or specified by other means not specified in this Recommendation | \nInternational Standard. \n–  Otherwise, the x and y elements of the (x, y) coordinate pair specify the indicated horizontal and vertical sampling \ngrid alignment positioning to the right of and below the upper left corner of the rectangular area represented by the \n384  Rec. ITU-T H.264 (06/2019) \n \ncorresponding constituent frame, respectively, in units of one sixteenth of the luma sample grid spacing between the \nsamples of the columns and rows of the constituent frame that are present in the decoded frame (prior to any \nupsampling for display or other purposes). \nNOTE 11 – The spatial location reference information frame0_grid_position_x, frame0_grid_position_y, frame1_grid_position_x, \nand frame1_grid_position_y is not provided when quincunx_sampling_flag is equal to 1 because the spatial alignment in this case \nis assumed to be such that constituent frame 0 and constituent frame 1 cover corresponding spatial areas with interleaved quincunx \nsampling patterns as illustrated in Figure D-1 and Figure D-10. \nNOTE 12 – When  frame_packing_arrangement_type  is  equal  to  2  and  field_views_flag  is  equal  to  1,  it  is  suggested  that \nframe0_grid_position_y should be equal to frame1_grid_position_y. \nframe_packing_arrangement_reserved_byte is reserved for future use by ITU-T | ISO/IEC. It is a requirement of \nbitstream conformance that the value of frame_packing_arrangement_reserved_byte shall be equal to 0. All other values \nof frame_packing_arrangement_reserved_byte are reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore \n(remove from the bitstream and discard) the value of frame_packing_arrangement_reserved_byte. \nframe_packing_arrangement_repetition_period  specifies  the  persistence  of  the  frame  packing  arrangement  SEI \nmessage and may specify a frame order count interval within which another frame packing arrangement SEI message with \nthe same value of frame_packing_arrangement_id or the end of the coded video sequence shall be present in the bitstream. \nThe value of frame_packing_arrangement_repetition_period shall be in the range of 0 to 16 384, inclusive. \nframe_packing_arrangement_repetition_period equal to 0 specifies that the frame packing arrangement SEI message \napplies to the current decoded frame only. \nframe_packing_arrangement_repetition_period equal to 1 specifies that the frame packing arrangement SEI message \npersists in output order until any of the following conditions are true: \n–  A new coded video sequence begins. \n–  A  frame  in  an  access  unit  containing  a  frame  packing  arrangement  SEI  message  with  the  same  value  of \nframe_packing_arrangement_id is output having PicOrderCnt( ) greater than PicOrderCnt( CurrPic ). \nframe_packing_arrangement_repetition_period equal to 0 or equal to 1 indicates that another frame packing arrangement \nSEI message with the same value of frame_packing_arrangement_id may or may not be present. \nframe_packing_arrangement_repetition_period greater than 1 specifies that the frame packing arrangement SEI message \npersists until any of the following conditions are true: \n–  A new coded video sequence begins. \n–  A  frame  in  an  access  unit  containing  a  frame  packing  arrangement  SEI  message  with  the  same  value  of \nframe_packing_arrangement_id is output having PicOrderCnt( ) greater than PicOrderCnt( CurrPic ) and less than or \nequal to PicOrderCnt( CurrPic ) + frame_packing_arrangement_repetition_period. \nframe_packing_arrangement_repetition_period  greater  than  1  indicates  that  another  frame  packing  arrangement  SEI \nmessage with the same value of frame_packing_arrangement_frames_id shall be present for a frame in an access unit that \nis output having PicOrderCnt( ) greater than PicOrderCnt( CurrPic ) and less than or equal to PicOrderCnt( CurrPic ) + \nframe_packing_arrangement_repetition_period; unless the bitstream ends or a new coded video sequence begins without \noutput of such a frame. \nframe_packing_arrangement_extension_flag equal to 0 indicates that no additional data follows  within the  frame \npacking  arrangement  SEI  message.  It  is  a  requirement  of  bitstream  conformance  that  the  value  of  frame_packing_\narrangement_extension_flag shall be equal to 0. The value 1 for frame_packing_arrangement_extension_flag is reserved \nfor future use by ITU-T | ISO/IEC. Decoders shall ignore the value 1 for frame_packing_arrangement_extension_flag in a \nframe packing arrangement SEI message and shall ignore all data that follows within a frame packing arrangement SEI \nmessage after the value 1 for frame_packing_arrangement_extension_flag. \n \n    Rec. ITU-T H.264 (06/2019)  385 \n \n \nFigure D-1 – Rearrangement and upconversion of checkerboard interleaving  \n(frame_packing_arrangement_type equal to 0) \n \nFigure D-2 – Rearrangement and upconversion of column interleaving  \nwith frame_packing_arrangement_type equal to 1, quincunx_sampling_flag equal to 0, \nand (x, y) equal to (0, 0) or (4, 8) for both constituent frames \n386  Rec. ITU-T H.264 (06/2019) \n \n   \nFigure D-3 – Rearrangement and upconversion of column interleaving with \nframe_packing_arrangement_type equal to 1, quincunx_sampling_flag equal to 0,  \n(x, y) equal to (0, 0) or (4, 8) for constituent frame 0 and (x, y) equal to (12, 8) for constituent frame 1 \n \nFigure D-4 – Rearrangement and upconversion of row interleaving with \nframe_packing_arrangement_type equal to 2, quincunx_sampling_flag equal to 0, \nand (x, y) equal to (0, 0) or (8, 4) for both constituent frames \n    Rec. ITU-T H.264 (06/2019)  387 \n \n \nFigure D-5 – Rearrangement and upconversion of row interleaving with \nframe_packing_arrangement_type equal to 2, quincunx_sampling_flag equal to 0,  \n(x, y) equal to (0, 0) or (8, 4) for constituent frame 0, and (x, y) equal to (8, 12) for constituent frame 1 \n \nFigure D-6 – Rearrangement and upconversion of side-by-side packing arrangement with \nframe_packing_arrangement_type equal to 3, quincunx_sampling_flag equal to 0, \nand (x, y) equal to (0, 0) or (4, 8) for both constituent frames \n388  Rec. ITU-T H.264 (06/2019) \n \n \nFigure D-7 – Rearrangement and upconversion of side-by-side packing arrangement with \nframe_packing_arrangement_type equal to 3, quincunx_sampling_flag equal to 0, \n(x, y) equal to (12, 8) for constituent frame 0, and (x, y) equal to (0, 0) or (4, 8) for constituent frame 1 \n \nFigure D-8 – Rearrangement and upconversion of top-bottom packing arrangement with \nframe_packing_arrangement_type equal to 4, quincunx_sampling_flag equal to 0, \nand (x, y) equal to (0, 0) or (8, 4) for both constituent frames \n    Rec. ITU-T H.264 (06/2019)  389 \n \n \nFigure D-9 – Rearrangement and upconversion of top-bottom packing arrangement with \nframe_packing_arrangement_type equal to 4, quincunx_sampling_flag equal to 0, \n(x, y) equal to (8, 12) for constituent frame 0, and (x, y) equal to (0, 0) or (8, 4) for constituent frame 1 \n \nFigure D-10 – Rearrangement and upconversion of side-by-side packing arrangement with quincunx sampling \n(frame_packing_arrangement_type equal to 3 with quincunx_sampling_flag equal to 1) \n390  Rec. ITU-T H.264 (06/2019) \n \n \nFigure D-11 – Rearrangement of a temporal interleaving frame arrangement  \n(frame_packing_arrangement_type equal to 5) \n \nFigure D-12 – Rearrangement and upconversion of tile format packing arrangement \n(frame_packing_arrangement_type equal to 7) \nD.2.27  Display orientation SEI message semantics \nThis SEI message informs the decoder of a transformation that is recommended to be applied to the output decoded and \ncropped picture prior to display. \ndisplay_orientation_cancel_flag equal to 1 indicates that the SEI message cancels the persistence of any previous display \norientation SEI message in output order. display_orientation_cancel_flag equal to 0 indicates that display orientation \ninformation follows. \n    Rec. ITU-T H.264 (06/2019)  391 \n \nhor_flip equal to 1 indicates that the cropped decoded picture should be flipped horizontally for display. hor_flip equal to \n0 indicates that the decoded picture should not be flipped horizontally. \nWhen hor_flip is equal to 1, the cropped decoded picture should be flipped as follows for each colour component Z = L, \nCb, and Cr, letting dZ be the final cropped array of output samples for the component Z: \n  for( x = 0; x < croppedWidthInSamplesZ; x++ ) \n    for( y = 0; y < croppedHeightInSamplesZ; y++ ) \n      dZ[ x][ y ] = Z[ croppedWidthInSamplesZ − x − 1 ][ y ] \nver_flip equal to 1 indicates that the cropped decoded picture should be flipped vertically (in addition to any horizontal \nflipping when hor_flip is equal to 1) for display. ver_flip equal to 0 indicates that the decoded picture should not be flipped \nvertically. \nWhen ver_flip is equal to 1, the cropped decoded picture should be flipped as follows for each colour component Z = L, \nCb, and Cr, letting dZ be the final cropped array of output samples for the component Z: \n  for( x = 0; x < croppedWidthInSamplesZ; x++ ) \n    for( y = 0; y < croppedHeightInSamplesZ; y++ ) \n      dZ[ x ][ y ] = Z[ x ][ croppedWidthInSamplesZ − y − 1 ] \nanticlockwise_rotation  specifies  the  recommended  anticlockwise  rotation  of  the  decoded  picture  (after  applying \nhorizontal and/or vertical flipping when hor_flip or ver_flip is set) prior to display. The decoded picture should be rotated \nby  360 * anticlockwise_rotation ÷ 216  degrees  (2 * π * anticlockwise_rotation ÷ 216  radians,  where  π  is  Archimedes' \nConstant (3.141 592 653 589 793 …) in the anticlockwise direction prior to display. For example, anticlockwise_rotation \nequal to 0 indicates no rotation and anticlockwise_rotation equal to 16 384 indicates 90 degrees (π ÷ 2 radians) rotation in \nthe anticlockwise direction. \nNOTE – It is possible for equivalent transformations to be expressed in multiple ways using these syntax elements. For example, \nthe combination of having both hor_flip and ver_flip equal to 1 with anticlockwise_rotation equal to 0 can alternatively be expressed \nby having both hor_flip and ver_flip equal to 1 with anticlockwise_rotation equal to 0x8000000, and the combination of hor_flip \nequal to 1 with ver_flip equal to 0 and anticlockwise_rotation equal to 0 can alternatively be expressed by having hor_flip equal to \n0 with ver_flip equal to 1 and anticlockwise_rotation equal to 0x8000000. \ndisplay_orientation_repetition_period specifies the persistence of the display orientation SEI message and may specify \na picture order count interval within which another display orientation SEI message or the end of the coded video sequence \nshall be present in the bitstream. The value of display_orientation_repetition_period shall be in the range 0 to 16 384, \ninclusive. \ndisplay_orientation_repetition_period equal to 0 specifies that the display orientation SEI message applies to the current \ndecoded picture only. \ndisplay_orientation_repetition_period equal to 1 specifies that the display orientation SEI message persists in output order \nuntil any of the following conditions are true: \n–  A new coded video sequence begins. \n–  A picture in an access unit containing a display orientation SEI message is output having PicOrderCnt( ) greater than \nPicOrderCnt( CurrPic ). \ndisplay_orientation_repetition_period greater than 1 specifies that the display orientation SEI message persists until any \nof the following conditions are true: \n–  A new coded video sequence begins. \n–  A picture in an access unit containing a display orientation SEI message is output having PicOrderCnt( ) greater than \nPicOrderCnt( CurrPic ) and less than or equal to PicOrderCnt( CurrPic ) + display_orientation_repetition_period. \ndisplay_orientation_repetition_period greater than 1 indicates that another display orientation SEI message shall be present \nfor a picture in an access unit that is output having PicOrderCnt( ) greater than PicOrderCnt( CurrPic ) and less than or \nequal to PicOrderCnt( CurrPic ) + display_orientation_repetition_period; unless the bitstream ends or a new coded video \nsequence begins without output of such a picture. \ndisplay_orientation_extension_flag equal to 0 indicates that no additional data follows within the display orientation SEI \nmessage.  The  value  of  display_orientation_extension_flag  shall  be  equal  to  0.  The  value  of  1  for \ndisplay_orientation_extension_flag is reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore all data that \nfollows the value of 1 for display_orientation_extension_flag in a display orientation SEI message. \nD.2.28  Green metadata SEI message semantics \nThe semantics for this SEI message are specified in ISO/IEC 23001-11 (Green metadata), which facilitates reduced power \nconsumption in decoders, encoders, displays, and in media selection. \n392  Rec. ITU-T H.264 (06/2019) \n \nD.2.29  Mastering display colour volume SEI message semantics \nThis SEI message identifies the colour volume (the colour primaries, white point, and luminance range) of a display \nconsidered to be the mastering display for the associated video content – e.g., the colour volume of a display that was used \nfor viewing while authoring the video content. The described mastering display is a three-colour additive display system \nthat has been configured to use the indicated mastering colour volume. \nThis SEI message does not specify the measurement methodologies and procedures used for determining the indicated \nvalues or any description of the mastering environment. It also does not provide information on colour transformations \nthat would be appropriate to preserve creative intent on displays with colour volumes different from that of the described \nmastering display. \nThe information conveyed in this SEI message is intended to be adequate for purposes corresponding to the use of Society \nof Motion Picture and Television Engineers ST 2086. \nWhen a mastering display colour volume SEI message is present in any access unit of a coded video sequence, a mastering \ndisplay colour volume SEI message shall be present in the IDR access unit that is the first access unit of the coded video \nsequence. All mastering display colour volume SEI messages that apply to the same coded video sequence shall have the \nsame content. \nThe mastering display colour volume SEI message persists in decoding order from the current access unit until the end of \nthe coded video sequence. \ndisplay_primaries_x[ c ], when in the range of 5 to 37 000, inclusive, specifies the normalized x chromaticity coordinate \nof the colour primary component c of the mastering display, according to the CIE 1931 definition of x as specified in ISO \n11664-1 (see also ISO 11664-3 and CIE 15), in increments of 0.00002. When display_primaries_x[ c ] is not in the range \nof 5 to 37 000, inclusive, the normalized x chromaticity coordinate of the colour primary component c of the mastering \ndisplay is unknown or unspecified or specified by other means not specified in this Specification. \ndisplay_primaries_y[ c ], when in the range of 5 to 42 000, inclusive, specifies the normalized y chromaticity coordinate \nof the colour primary component c of the mastering display, according to the CIE 1931 definition of y as specified in ISO \n11664-1 (see also ISO 11664-3 and CIE 15), in increments of 0.00002. When display_primaries_y[ c ] is not in the range \nof 5 to 42 000, inclusive, the normalized y chromaticity coordinate of the colour primary component c of the mastering \ndisplay is unknown or unspecified or specified by other means not specified in this Specification. \nFor describing mastering displays that use red, green, and blue colour primaries, it is suggested that index value c equal to \n0 should correspond to the green primary, c equal to 1 should correspond to the blue primary and c equal to 2 should \ncorrespond to the red colour primary (see also Annex E and Table E-3). \nwhite_point_x, when in the range of 5 to 37 000, inclusive, specifies the normalized x chromaticity coordinate of the white \npoint of the mastering display, according to the CIE 1931 definition of x as specified in ISO 11664-1 (see also ISO 11664-\n3 and CIE 15), in normalized increments of 0.00002. When white_point_x is not in the range of 5 to 37 000, inclusive, the \nnormalized x chromaticity coordinate of the white point of the mastering display is indicated to be unknown or unspecified \nor specified by other means not specified in this Specification. \nwhite_point_y, when in the range of 5 to 42 000, inclusive, specifies the normalized y chromaticity coordinate of the white \npoint of the mastering display, according to the CIE 1931 definition of y as specified in ISO 11664-1 (see also ISO 11664-\n3 and CIE 15), in normalized increments of 0.00002. When white_point_y is not in the range of 5 to 42 000, inclusive, the \nnormalized y chromaticity coordinate of the white point of the mastering display is indicated to be unknown or unspecified \nor specified by other means not specified in this Specification. \nNOTE 1 – Society of Motion Picture and Television Engineers ST 2086 (2018) specifies that the normalized x and y chromaticity \ncoordinate values for the mastering display colour primaries and white point are to be represented with four decimal places. This \nwould correspond with using values of the syntax elements display_primaries_x[ c ], display_primaries_y[ c ], white_point_x, and \nwhite_point_y, as defined in this Specification, that are multiples of 5. \nNOTE 2 – An example of the use of values outside the range for which semantics are specified in this Specification is that \nANSI/CTA 861-G (2016) uses normalized (x, y) chromaticity coordinate values of (0,0) for the white point to indicate that the white \npoint chromaticity is unknown. \nmax_display_mastering_luminance,  when in the range of 50 000 to 100 000 000, specifies the nominal  maximum \ndisplay  luminance  of  the  mastering  display  in  units  of  0.0001  candelas  per  square  metre.  When \nmax_display_mastering_luminance is not in the range of 50 000 to 100 000 000, the nominal maximum display luminance \nof the mastering display is indicated to be unknown or unspecified or specified by other means not specified in this \nSpecification. \nNOTE 3 – Society of Motion Picture and Television Engineers ST 2086 (2018) specifies that the nominal maximum display \nluminance of the mastering display is to be specified as a multiple of 1 candela per square meter. This would correspond with using \nvalues of the syntax element max_display_mastering_luminance, as defined in this Specification, that are a multiple of 10 000. \n    Rec. ITU-T H.264 (06/2019)  393 \n \nNOTE 4 – An example of the use of values outside the range for which semantics are specified in this Specification is that \nANSI/CTA 861-G (2016) uses the value 0 for the nominal maximum display luminance of the mastering display to indicate that the \nnominal maximum display luminance of the mastering display is unknown. \nmin_display_mastering_luminance, when in the range of 1 to 50 000, specifies the nominal minimum display luminance \nof the mastering display in units of 0.0001 candelas per square metre. When min_display_mastering_luminance is not in \nthe range of 1 to 50 000, the nominal maximum display luminance of the mastering display is unknown or unspecified or \nspecified by other means not specified in this Specification. When max_display_mastering_luminance is equal to 50 000, \nmin_display_mastering_luminance shall not be equal to 50 000. \nNOTE 5 – Society of Motion Picture and Television Engineers ST 2086 (2018) specifies that the nominal minimum display \nluminance of the mastering display is to be specified as a multiple of 0.0001 candelas per square metre, which corresponds to the \nsemantics specified in this Specification. \nNOTE 6 – An example of the use of values outside the range for which semantics are specified in this Specification is that \nANSI/CTA 861-G (2016) uses the value 0 for the nominal minimum display luminance of the mastering display to indicate that the \nnominal minimum display luminance of the mastering display is unknown. \nNOTE 7 – Another example of the potential use of values outside the range for which semantics are specified in this Specification \nis that Society of Motion Picture and Television Engineers ST 2086 (2018) indicates that values outside the specified range could \nbe used to indicate that the black level and contrast of the mastering display have been adjusted using picture line-up generation \nequipment (PLUGE). \nAt the minimum luminance, the mastering display is considered to have the same nominal chromaticity as the white point. \nD.2.30  Colour remapping information SEI message semantics \nThe colour remapping information SEI message provides information to enable remapping of the reconstructed colour \nsamples of the output pictures for purposes such as converting the output pictures to a representation that is more suitable \nfor an alternative display. The colour remapping model used in the colour remapping information SEI message is composed \nof a first piece-wise linear function applied to each colour component (specified by the \"pre\" set of syntax elements herein), \nfollowed by a three-by-three matrix applied to the three resulting colour components, followed by a second piece-wise \nlinear function applied to each resulting colour component (specified by the \"post\" set of syntax elements herein). \nNOTE 1 – Colour remapping of the output pictures for the display process (which is outside the scope of this Specification) is \noptional and does not affect the decoding process specified in this Specification. \nUnless indicated otherwise by some means not specified in this Specification, the input to the indicated remapping process \nis the set of decoded sample values after applying an (unspecified) upsampling conversion process to the 4:4:4 colour \nsampling format as necessary when the colour remapping three-by-three matrix coefficients are present in the SEI message \nand chroma_format_idc is equal to 1 (4:2:0 chroma format) or 2 (4:2:2 chroma format). When chroma_format_idc is equal \nto 0 (monochrome), the colour remapping information SEI message shall not be present, although decoders shall allow \nsuch messages to be present and shall ignore any such colour remapping information SEI messages that may be present. \ncolour_remap_id contains an identifying number that may be used to identify the purpose of the colour remapping \ninformation. The value of colour_remap_id may be used (in a manner not specified in this Specification) to indicate that \nthe input to the remapping process is the output of some conversion process that is not specified in this Specification, such \nas  a  conversion  of  the  picture  to  some  alternative  colour  representation  (e.g.,  conversion  from  a  YCbCr  colour \nrepresentation to a GBR colour representation). When more than one colour remapping information SEI message is present \nwith the same value of colour_remap_id, the content of these colour remapping information SEI messages shall be the \nsame. When colour remapping information SEI messages are present that have more than one value of colour_remap_id, \nthis may indicate that the remapping processes indicated by the different values of colour_remap_id are alternatives that \nare provided for different purposes or that a cascading of remapping processes is to be applied in a sequential order (an \norder that is not specified in this Specification). The value of colour_remap_id shall be in the range of 0 to 232 − 2, inclusive. \nValues of colour_remap_id from 0 to 255, inclusive, and from 512 to 231 − 1, inclusive, may be used as determined by the \napplication. Values of colour_remap_id from 256 to 511, inclusive, and from 231 to 232 − 2, inclusive, are reserved for \nfuture use by ITU-T | ISO/IEC. Decoders encountering a value of colour_remap_id in the range of 256 to 511, inclusive, \nor in the range of 231 to 232 − 2, inclusive, shall ignore it. \nNOTE 2 – The colour_remap_id can be used to support different colour remapping processes that are suitable for different display \nscenarios. For example, different values of colour_remap_id may correspond to different remapped colour spaces supported by \ndisplays. \ncolour_remap_cancel_flag  equal  to  1  indicates  that  the  colour  remapping  information  SEI  message  cancels  the \npersistence of any previous colour remapping information SEI message in output order that applies to the current layer. \ncolour_remap_cancel_flag equal to 0 indicates that colour remapping information follows. \ncolour_remap_repetition_period specifies the persistence of the colour remapping information SEI message and may \nspecify a picture order count interval within which another colour remapping information SEI message with the same value \nof  colour_remap_id  or  the  end  of  the  coded  video  sequence  shall  be  present  in  the  bitstream.  The  value  of \ncolour_remap_repetition_period shall be in the range of 0 to 16 384, inclusive. \n394  Rec. ITU-T H.264 (06/2019) \n \ncolour_remap_repetition_period equal to 0 specifies that the colour remapping information applies to the current decoded \npicture only. \ncolour_remap_repetition_period equal to 1 specifies that the colour remapping information persists in output order until \nany of the following conditions are true: \n–  A new coded video sequence begins. \n–  A  picture  in  an  access  unit  containing  a  colour  remapping  information  SEI  message  with  the  same  value  of \ncolour_remap_id is output having PicOrderCnt( ) greater than PicOrderCnt( CurrPic ). \ncolour_remap_repetition_period equal to 0 or equal to 1 indicates that another colour remapping information SEI message \nwith the same value of colour_remap_id may or may not be present. \ncolour_remap_repetition_period greater than 1 specifies that the colour remapping information persists until any of the \nfollowing conditions are true: \n–  A new coded video sequence begins. \n–  A  picture  in  an  access  unit  containing  a  colour  remapping  information  SEI  message  with  the  same  value  of \ncolour_remap_id is output having PicOrderCnt( ) greater than PicOrderCnt( CurrPic ) and less than or equal to \nPicOrderCnt( CurrPic ) + colour_remap_repetition_period. \ncolour_remap_repetition_period greater than 1 indicates that another colour remapping information SEI message with the \nsame value of colour_remap_id shall be present for a picture in an access unit that is output having PicOrderCnt( ) greater \nthan PicOrderCnt( CurrPic ) and less than or equal to PicOrderCnt( CurrPic ) + colour_remap_repetition_period; unless \nthe bitstream ends or a new coded video sequence begins without output of such a picture. \ncolour_remap_video_signal_info_present_flag equal to 1 specifies that syntax elements colour_remap_full_range_flag, \ncolour_remap_primaries,  colour_remap_transfer_function  and  colour_remap_matrix_coefficients  are  present, \ncolour_remap_video_signal_info_present_flag equal to 0 specifies that syntax elements colour_remap_full_range_flag, \ncolour_remap_primaries, colour_remap_transfer_function and colour_remap_matrix_coefficients are not present. \ncolour_remap_full_range_flag has the same semantics as specified in clause E.2.1 for the video_full_range_flag syntax \nelement, except that colour_remap_full_range_flag identifies the colour space of the remapped reconstructed picture, rather \nthan the colour space used for the coded video sequence. When not present, the value of colour_remap_full_range_flag is \ninferred to be equal to the value of video_full_range_flag. \ncolour_remap_primaries has the same semantics as specified in clause E.2.1 for the colour_primaries syntax element, \nexcept that colour_remap_primaries identifies the colour space of the remapped reconstructed picture, rather than the \ncolour space used for the coded video sequence. When not present, the value of colour_remap_primaries is inferred to be \nequal to the value of colour_primaries. \ncolour_remap_transfer_function has the same semantics as specified in clause E.2.1 for the transfer_characteristics \nsyntax element, except that colour_remap_transfer_function identifies the colour space of the remapped reconstructed \npicture,  rather  than  the  colour  space  used  for  the  coded  video  sequence.  When  not  present,  the  value  of \ncolour_remap_transfer_function is inferred to be equal to the value of transfer_characteristics. \ncolour_remap_matrix_coefficients has the same semantics as specified in clause E.2.1 for the matrix_coefficients syntax \nelement, except that colour_remap_matrix_coefficients identifies the colour space of the remapped reconstructed picture, \nrather  than  the  colour  space  used  for  the  coded  video  sequence.  When  not  present,  the  value  of \ncolour_remap_matrix_coefficients is inferred to be equal to the value of matrix_coefficients. \ncolour_remap_input_bit_depth specifies the bit depth of the colour components of the associated pictures for purposes \nof interpretation of the colour remapping information SEI message. When any colour remapping information SEI messages \nis present with the value of colour_remap_input_bit_depth not equal to the bit depth of the decoded colour components, \nthe SEI message refers to the hypothetical result of a conversion operation performed to convert the decoded colour \ncomponent samples to the bit depth equal to colour_remap_input_bit_depth. \nThe  value  of  colour_remap_input_bit_depth  shall  be  in  the  range  of  8  to  16,  inclusive.  Values  of \ncolour_remap_input_bit_depth from 0 to 7, inclusive, and from 17 to 255, inclusive, are reserved for future use by ITU-T \n| ISO/IEC. Decoders shall ignore all colour remapping SEI messages that contain a colour_remap_input_bit_depth in the \nrange of 0 to 7, inclusive, or in the range of 17 to 255, inclusive, and bitstreams shall not contain such values. \ncolour_remap_output_bit_depth specifies the bit depth of the output of the colour remapping function described by the \ncolour remapping information SEI message. \nThe  value  of  colour_remap_output_bit_depth  shall  be  in  the  range  of  8  to  16,  inclusive.  Values  of \ncolour_remap_output_bit_depth from 0 to 7, inclusive, and in the range of 17 to 255, inclusive, are reserved for future use \nby  ITU-T  |  ISO/IEC.  Decoders  shall  ignore  all  colour  remapping  SEI  messages  that  contain  a  value  of \n    Rec. ITU-T H.264 (06/2019)  395 \n \ncolour_remap_output_bit_depth from 0 to 7, inclusive, or in the range of 17 to 255, inclusive, and bitstreams shall not \ncontain such values. \npre_lut_num_val_minus1[ c ] plus 1 specifies the number of pivot points in the piece-wise linear remapping function for \nthe c-th component, where c equal to 0 refers to the luma or G component, c equal to 1 refers to the Cb or B component, \nand c equal to 2 refers to the Cr or R component. When pre_lut_num_val_minus1[ c ] is equal to 0, the default end points \nof the input values are 0 and 2colour_remap_input_bit_depth − 1, and the corresponding default end points of the output values are 0 \nand 2colour_remap_output_bit_depth − 1, for the c-th component. In bitstreams conforming to this version of this Specification, the \nvalue of pre_lut_num_val_minus1[ c ] shall be in the range of 0 to 32, inclusive. \npre_lut_coded_value[ c ][ i ] specifies the value of the i-th pivot point for the c-th component. The number of bits used \nto represent pre_lut_coded_value[ c ][ i ] is ( ( colour_remap_input_bit_depth + 7 )  >>  3 )  <<  3. \npre_lut_target_value[ c ][ i ] specifies the value of the i-th pivot point for the c-th component. The number of bits used \nto represent pre_lut_target_value[ c ][ i ] is ( ( colour_remap_output_bit_depth + 7 )  >>  3 )  <<  3. \nWhen pre_lut_coded_value[ c ][ 0 ] is greater than 0, an initial linear segment should be inferred that maps input values \nranging from 0 to pre_lut_coded_value[ c ][ 0 ], inclusive, to target values ranging from 0 to pre_lut_target_value[ c ][ 0 ], \ninclusive. \nWhen pre_lut_coded_value[ c ][ pre_lut_num_val_minus1[ c ] ] is not equal to 2colour_remap_input_bit_depth − 1, a final linear \nsegment should be inferred that maps input values ranging from pre_lut_coded_value[ c ][ pre_lut_num_val_minus1[ c ] ] \nto  2colour_remap_input_bit_depth − 1,  inclusive,  to  target  values  ranging  from \npre_lut_target_value[ c ][ pre_lut_num_val_minus1[ c ] ] to 2colour_remap_output_bit_depth − 1, inclusive. \ncolour_remap_matrix_present_flag  equal  to  1  indicates  that  the  syntax  elements  log2_matrix_denom  and \ncolour_remap_coeffs[ c ][ i ], for c and i in the range of 0 to 2, inclusive, are present. colour_remap_matrix_present_flag \nequal to 0 indicates that the syntax elements log2_matrix_denom and colour_remap_coeffs[ c ][ i ], for c and i in the range \nof 0 to 2, inclusive, are not present. \nlog2_matrix_denom  specifies  the  base  2  logarithm  of  the  denominator  for  all  matrix  coefficients.  The  value  of \nlog2_matrix_denom shall be in the range of 0 to 15, inclusive. When not present, the value of log2_matrix_denom is \ninferred to be equal to 0. \ncolour_remap_coeffs[ c ][ i ] specifies the value of the three-by-three colour remapping matrix coefficients. The value of \ncolour_remap_coeffs[ c ][ i ] shall be in the range of −215 to 215 − 1, inclusive. When colour_remap_coeffs[ c ][ i ] is not \npresent, it is inferred to be equal to 1 if c is equal to i, and inferred to be equal to 0 otherwise. \nNOTE 3 – When colour_remap_matrix_present_flag is equal to 0, the colour remapping matrix is inferred to be equal to the identity \nmatrix of size 3x3. \nThe variable matrixOutput[ c ] for c = 0, 1 and 2 is derived as follows: \nroundingOffset = log2_matrix_denom  = =  0 ? 0: 1  <<  ( log2_matrix_denom − 1 ) \nmatrixOutput[ c ] = Clip3( 0, ( 1  <<  colour_remap_output_bit_depth ) − 1,   (D-44) \n  ( colour_remap_coeffs[ c ][ 0 ] * matrixInput[ 0 ] + colour_remap_coeffs[ c ][ 1 ] * matrixInput[ 1 ] \n  + colour_remap_coeffs[ c ][ 2 ] * matrixInput[ 2 ] + roundingOffset )  >>  log2_matrix_denom )   \nwhere matrixInput[ c ] is the input sample value of the c-th colour component,and matrixOutput[ c ] is the output sample \nvalue of the c-th colour component. \npost_lut_num_val_minus1[ c ] has the same semantics as pre_lut_num_val_minus1[ c ], with pre replaced by post, except \nthat the default end points of the input values are 0 and 2colour_remap_output_bit_depth − 1 for the c-th colour component. The value \nof post_lut_num_val_minus1[ c ] shall be in the range of 0 to 32, inclusive. \npost_lut_coded_value[ c ][ i ] has the same semantics as pre_lut_coded_value[ c ][ i ], with \"pre\" replaced by \"post\", \nexcept  that  the  number  of  bits  used  to  represent  post_lut_coded_value[ c ][ i ]  is \n( ( colour_remap_output_bit_depth + 7 )  >>  3 )  <<  3. \npost_lut_target_value[ c ][ i ] has the same semantics as pre_lut_target_value[ c ][ i ], with \"pre\" replaced by \"post\" \nexcept that colour_remap_input_bit_depth is replaced by colour_remap_output_bit_depth in the semantics. \nD.2.31  Content light level information SEI message semantics \nThis SEI message identifies upper bounds for the nominal target brightness light level of the pictures of the coded video \nsequence. \nThe information conveyed in this SEI message is intended to be adequate for purposes corresponding to the use of the \nConsumer Technology Association 861.3 specification. \n396  Rec. ITU-T H.264 (06/2019) \n \nThe semantics of the content light level information SEI message are defined in relation to the values of samples in a 4:4:4 \nrepresentation of red, green, and blue colour primary intensities in the linear light domain for the pictures of the coded \nvideo sequence, in units of candelas per square metre. However, this SEI message does not, by itself, identify a conversion \nprocess for converting the sample values of a decoded picture to the samples in a 4:4:4 representation of red, green, and \nblue colour primary intensities in the linear light domain for the picture. \nNOTE 1 – Other  syntax  elements,  such  as  colour_primaries,  transfer_characteristics,  matrix_coefficients,  and  the  chroma \nresampling filter hint SEI message, when present, may assist in the identification of such a conversion process. \nGiven the red, green, and blue colour primary intensities in the linear light domain for the location of a luma sample in a \ncorresponding 4:4:4 representation, denoted as E , E , and E , the maximum component intensity is defined as E  = \nR G B Max\nMax( E , Max( E , E  ) ). The light level corresponding to the stimulus is then defined as the CIE 1931 luminance \nR G B\ncorresponding to equal amplitudes of E  for all three colour primary intensities for red, green, and blue (with appropriate \nMax\nscaling to reflect the nominal luminance level associated with peak white – e.g., ordinarily scaling to associate peak white \nwith 10 000 candelas per square metre when transfer_characteristics is equal to 16). \nNOTE 2 – Since the maximum value E  is used in this definition at each sample location, rather than a direct conversion from E , \nMax R\nE , and E  to the corresponding CIE 1931 luminance, the CIE 1931 luminance at a location may in some cases be less than the \nG B\nindicated light level. This situation would occur, for example, when E  and E  are very small and EB is large, in which case the \nR G\nindicated light level would be much larger than the true CIE 1931 luminance associated with the ( E , E , E  ) triplet. \nR G B\nWhen a content light level information SEI message is present in any access unit of a coded video sequence, a content light \nlevel information SEI message shall be present in the IDR access unit that is the first access unit of the coded video \nsequence. All content light level information SEI messages that apply to the same coded video sequence shall have the \nsame content. \nThe content light level information SEI message persists in decoding order from the current access unit until the end of the \ncoded video sequence. \nmax_content_light_level, when not equal to 0, indicates an upper bound on the maximum light level among all individual \nsamples in a 4:4:4 representation of red, green, and blue colour primary intensities (in the linear light domain) for the \npictures of the coded video sequence, in units of candelas per square metre. When equal to 0, no such upper bound is \nindicated by max_content_light_level. \nmax_pic_average_light_level, when not equal to 0, indicates an upper bound on the maximum average light level among \nthe samples in a 4:4:4 representation of red, green, and blue colour primary intensities (in the linear light domain) for any \nindividual picture of the coded video sequence, in units of candelas per square metre. When equal to 0, no such upper \nbound is indicated by max_pic_average_light_level. \nNOTE 3 – When the visually relevant region does not correspond to the entire cropped decoded picture, such as for \"letterbox\" \nencoding of video content with a wide picture aspect ratio within a taller cropped decoded picture, the indicated average should be \nperformed only within the visually relevant region. \nD.2.32  Alternative transfer characteristics SEI message semantics \nThe alternative transfer characteristics SEI message provides a preferred alternative value for the transfer_characteristics \nsyntax element that is indicated by the colour description syntax of VUI parameters of the sequence parameter set. This \nSEI message is intended to be used in cases when some value of transfer_characteristics is preferred for interpretation of \nthe pictures of the coded video sequence although some other value of transfer_characteristics may also be acceptable for \ninterpretation of the pictures of the coded video sequence and that other value is provided in the colour description syntax \nof VUI parameters of the sequence parameter set for interpretation by decoders that do not support interpretation of the \npreferred value (e.g., because the preferred value had not yet been defined in a previous version of this Specification). \nWhen an alternative transfer characteristics SEI message is present for any picture of a coded video sequence, an alternative \ntransfer characteristics SEI message shall be present for the IDR picture of the coded video sequence. The alternative \ntransfer characteristics SEI message persists in decoding order from the current picture until the end of the coded video \nsequence. All alternative transfer characteristics SEI messages that apply to the same coded video sequence shall have the \nsame content. \npreferred_transfer_characteristics specifies a preferred alternative value for the transfer_characteristics syntax element \nof  the  colour  description  syntax  of  VUI  parameters  of  the  sequence  parameter  set.  The  semantics  for \npreferred_transfer_characteristics are otherwise the same as for the transfer_characteristics syntax element specified in the \nVUI parameters of the sequence parameter set (see clause E.2.1 and Table E-4). When preferred_transfer_characteristics \nis not equal to the value of transfer_characteristics indicated in the VUI parameters of the sequence parameter set, decoders \nshould ignore the value of transfer_characteristics indicated in the VUI parameters of the sequence parameter set and \ninstead use the value indicated by preferred_transfer_characteristics. \nD.2.33  Content colour volume SEI message semantics \nThe content colour volume SEI message describes the colour volume characteristics of the associated pictures. These \ncolour volume characteristics are expressed in terms of a nominal range, although deviations from this range may occur. \n    Rec. ITU-T H.264 (06/2019)  397 \n \nThe variable transferCharacteristics is specified as follows: \n–  If an alternative transfer characteristics SEI message is present for the coded video sequence, transferCharacteristics \nis set equal to preferred_transfer_characteristics; \n–  Otherwise,  (an  alternative  transfer  characteristics  SEI  message  is  not  present  for  the  coded  video  sequence), \ntransferCharacteristics is set equal to transfer_characteristics. \nThe content colour volume SEI message shall not be present, and decoders shall ignore it, when any of the following \nconditions is true: \n–  Any  of  the  values  of  transferCharacteristics,  colour_primaries,  and  matrix_coefficients  has  a  value  defined  as \nunspecified. \n–  The value of transfer_characteristics is equal to 2, 4, or 5. \n–  The value of colour_primaries is equal to 2. \nThe following applies when converting the signal from a non-linear to a linear representation: \n–  If the value of transferCharacteristics is equal to 1, 6, 7, 14, or 15, the Rec. ITU-R BT.1886-0 reference electro-optical \ntransfer function should be used to convert the signal to its linear representation, where the value of screen luminance \nfor white is set equal to 100 cd/m2, the value of screen luminance for black is set equal to 0 cd/m2, and the value of \nthe exponent of the power function is set equal to 2.4. \n–  Otherwise, if the value of transferCharacteristics is equal to 18, the hybrid log-gamma reference electro-optical \ntransfer function specified in Rec. ITU-R BT.2100-2 should be used to convert the signal to its linear representation, \nwhere the value of nominal peak luminance of the display is set equal to 1000 cd/m2, the value of the display \nluminance for black is set equal to 0 cd/m2, and the value of system gamma is set equal to 1.2. \n–  Otherwise (the value of transferCharacteristics is not equal to 1, 6, 7, 14, 15, or 18) when the content colour volume \nSEI message is present, the exact inverse of the transfer function specified in Table E-4 should be used to convert the \nnon-linear signal to a linear representation. \nccv_cancel_flag equal to 1 indicates that the content colour volume SEI message cancels the persistence of any previous \ncontent colour volume SEI message in output order. ccv_cancel_flag equal to 0 indicates that content colour volume \ninformation follows. \nccv_persistence_flag specifies the persistence of the content colour volume SEI message. \nccv_persistence_flag equal to 0 specifies that the content colour volume SEI message applies to the current decoded picture \nonly. \nLet picA be the current picture. ccv_persistence_flag equal to 1 specifies that the content colour volume SEI message \npersists in output order until one or more of the following conditions are true: \n–  A new CVS begins. \n–  The bitstream ends. \n–  A picture picB in an access unit containing a content colour volume SEI message is output having PicOrderCnt( picB ) \ngreater than PicOrderCnt( picA ). \nccv_primaries_present_flag equal to 1 specifies that the syntax elements ccv_primaries_x[ c ] and ccv_primaries_y[ c ] \nare  present.  ccv_primaries_present_flag  equal  to  0  specifies  that  the  syntax  elements  ccv_primaries_x[ c ]  and \nccv_primaries_y[ c ] are not present. \nccv_min_luminance_value_present_flag  equal  to  1  specifies  that  the  syntax  element  ccv_min_luminance_value  is \npresent. ccv_min_luminance_value_present_flag equal to 0 specifies that the syntax element ccv_min_luminance_value \nis not present. \nccv_max_luminance_value_present_flag equal to 1 specifies that the syntax element  ccv_max_luminance_value is \npresent. ccv_max_luminance_value_present_flag equal to 0 specifies that the syntax element ccv_max_luminance_value \nis not present. \nccv_avg_luminance_value_present_flag  equal  to  1  specifies  that  the  syntax  element  ccv_avg_luminance_value  is \npresent. ccv_avg_luminance_value_present_flag equal to 0 specifies that the syntax element ccv_avg_luminance_value is \nnot present. \nIt  is  a  requirement  of  bitstream  conformance  that  the  values  of  ccv_primaries_present_flag, \nccv_min_luminance_value_present_flag,  ccv_max_luminance_value_present_flag,  and \nccv_avg_luminance_value_present_flag shall not all be equal to 0. \n398  Rec. ITU-T H.264 (06/2019) \n \nccv_reserved_zero_2bits shall be equal to 0 in bitstreams conforming to this version of this Specification. Other values \nfor  ccv_reserved_zero_2bits  are  reserved  for  future  use  by  ITU-T  |  ISO/IEC.  Decoders  shall  ignore  the  value  of \nccv_reserved_zero_2bits. \nccv_primaries_x[ c ] and ccv_primaries_y[ c ] specify the normalized x and y chromaticity coordinates, respectively, of \nthe colour primary component c of the nominal content colour volume in normalized increments of 0.00002, according to \nthe CIE 1931 definition of x and y as specified in ISO 11664-1 (see also ISO 11664-3 and CIE 15), in normalized \nincrements of 0.00002. For describing colour volumes that use red, green, and blue colour primaries, it is suggested that \nindex value c equal to 0 should correspond to the green primary, c equal to 1 should correspond to the blue primary, and c \nequal to 2 should correspond to the red colour primary (see also Annex E and Table E-3). \nThe values of ccv_primaries_x[ c ] and ccv_primaries_y[ c ] shall be in the range of −5 000 000 to 5 000 000, inclusive. \nWhen ccv_primaries_x[ c ] and ccv_primaries_y[ c ] are not present, they are inferred to be equal to the normalized x and \ny chromaticity coordinates, respectively, specified by colour_primaries. \nccv_min_luminance_value specifies the normalized minimum luminance value, according to CIE 1931, that is expected \nto be present in the content, where values are normalized to L  or L  as specified in Table E-4 according to the indicated \no c\ntransfer characteristics of the signal. The values of ccv_min_luminance_value are in normalized increments of 0.0000001. \nccv_max_luminance_value specifies the maximum luminance value, according to CIE 1931, that is expected to be present \nin the content, where values are normalized to L  or L  as specified in Table E-4 according to the transfer characteristics \no c\nof the signal. The values of ccv_max_luminance_value are in normalized increments of 0.0000001. \nccv_avg_luminance_value specifies the average luminance value, according to CIE 1931, that is expected to be present \nin the content, where values are normalized to L  or L  as specified in Table E-4 according to the transfer characteristics \no c\nof the signal. The values of ccv_avg_luminance_value are in normalized increments of 0.0000001. \nNOTE – The resulting domain from this conversion process may or may not represent light in a source or display domain – it is \nmerely a gamut representation domain rather than necessarily being a representation of actual light in either the scene or display \ndomain.  Therefore,  the  values  corresponding  to  ccv_min_luminance_value,  ccv_max_luminance_value,  and \nccv_avg_luminance_value might not necessarily correspond to a true luminance value. \nThe value of ccv_min_luminance_value, when present, shall be less than or equal to ccv_avg_luminance_value, when \npresent. The value of ccv_avg_luminance_value, when present, shall be less than or equal to ccv_max_luminance_value, \nwhen  present.  The  value  of  ccv_min_luminance_value,  when  present,  shall  be  less  than  or  equal  to \nccv_max_luminance_value, when present. \nWhen the visually relevant region does not correspond to the entire cropped decoded picture, such as for \"letterbox\" \nencoding  of  video  content  with  a  wide  picture  aspect  ratio  within  a  taller  cropped  decoded  picture,  the  indicated \nccv_min_luminance_value, ccv_max_luminance_value, and ccv_avg_luminance_value should correspond only to values \nwithin the visually relevant region. \nD.2.34  Ambient viewing environment SEI message semantics \nThe ambient viewing environment SEI message identifies the characteristics of the nominal ambient viewing environment \nfor the display of the associated video content. The syntax elements of the ambient viewing environment SEI message may \nassist the receiving system in adapting the received video content for local display in viewing environments that may be \nsimilar or may substantially differ from those assumed or intended when mastering the video content. \nThis SEI message does not provide information on colour transformations that would be appropriate to preserve creative \nintent on displays with colour volumes different from that of the described mastering display. \nWhen an ambient viewing environment SEI message is present for any picture of a coded video sequence, an ambient \nviewing environment SEI message shall be present in the IDR access unit that is the first access unit of the coded video \nsequence. All ambient viewing environment SEI messages that apply to the same coded video sequence shall have the \nsame content. \nambient_illuminance specifies the environmental illluminance of the ambient viewing environment in units of 0.0001 \nlux. ambient_illuminance shall not be equal to 0. \nambient_light_x and ambient_light_y specify the normalized x and y chromaticity coordinates, respectively, of the \nenvironmental ambient light in the nominal viewing environment, according to the CIE 1931 definition of x and y as \nspecified in ISO 11664-1 (see also ISO 11664-3 and CIE 15), in normalized increments of 0.00002. The values of \nambient_light_x and ambient_light_y shall be in the range of 0 to 50 000, inclusive. \nNOTE – For example, the conditions identified in Rec. ITU-R BT.2035 can be expressed using ambient_illuminance equal to \n100 000 with background chromaticity indicating D65 (ambient_light_x equal to 15 635, ambient_light_y equal to 16 450), or \noptionally in some regions, background chromaticity indicating D93 (ambient_light_x equal to 14 155, ambient_light_y equal to \n14 855). \n    Rec. ITU-T H.264 (06/2019)  399 \n \nD.2.35  Semantics of omnidirectional video specific SEI messages \nD.2.35.1   Equirectangular projection SEI message semantics \nThe  equirectangular  projection  SEI  message  provides  information  to  enable  remapping  (through  an  equirectangular \nprojection) of the colour samples of the projected pictures onto a sphere coordinate space in sphere coordinates (ϕ, θ) for \nuse in omnidirectional video applications for which the viewing perspective is from the origin looking outward toward the \ninside of the sphere. The sphere coordinates are defined so that ϕ is the azimuth (longitude, increasing eastward) and θ is \nthe elevation (latitude, increasing northward). \nWhen  an  equirectangular  projection  SEI  message  is  present  for  any  picture  of  a  coded  video  sequence  (CVS),  an \nequirectangular projection SEI message shall be present for the first picture of the CVS and no SEI message indicating a \ndifferent type of projection shall be present for any picture of the CVS. \nWhen aspect_ratio_idc is present and greater than 1 in the active sequence parameter set, there should be no equirectangular \nprojection SEI messages applicable for any picture of the CVS. \nA frame packing arrangement SEI message for which all the following conditions are true is referred to as an effectively \napplicable frame packing arrangement SEI message: \n–  The value of frame_packing_arrangement_cancel_flag is equal to 0. \n–  The value of frame_packing_arrangement_type is equal to 3, 4, or 5. \n–  The value of quincunx_sampling_flag is equal to 0. \n–  The value of spatial_flipping_flag is equal to 0. \n–  The value of field_views_flag is equal to 0. \n–  The value of frame0_grid_position_x is equal to 0. \n–  The value of frame0_grid_position_y is equal to 0. \n–  The value of frame1_grid_position_x is equal to 0. \n–  The value of frame1_grid_position_y is equal to 0. \nWhen an effectively applicable frame packing arrangement SEI message that applies to the picture is not present, an \nequirectangular projection SEI message with erp_cancel_flag equal to 0 that applies to the picture shall not be present. \nDecoders shall ignore equirectangular projection SEI messages when an effectively applicable frame packing arrangement \nSEI message that applies to the picture is not present. \nerp_cancel_flag  equal  to  1  indicates  that  the  SEI  message  cancels  the  persistence  of  any  previous  equirectangular \nprojection SEI message in output order. erp_cancel_flag equal to 0 indicates that equirectangular projection information \nfollows. \nerp_persistence_flag specifies the persistence of the equirectangular projection SEI message. \nerp_persistence_flag equal to 0 specifies that the equirectangular projection SEI message applies to the current decoded \npicture only. \nLet picA be the current picture. erp_persistence_flag equal to 1 specifies that the equirectangular projection SEI message \npersists in output order until one or more of the following conditions are true: \n–  A new CVS begins. \n–  The bitstream ends. \n–  A  picture  picB  in  an  access  unit  containing  an  equirectangular  projection  SEI  message  is  output  having \nPicOrderCnt( picB ) greater than PicOrderCnt( picA ). \nerp_padding_flag equal to 1 indicates that the constituent picture contains padded areas for which the sizes are specified \nby  the  syntax  elements  left_gb_erp_width  and  right_gb_erp_width.  erp_padding_flag  equal  to  0  indicates  that  the \nconstituent  picture  does  not  contains  padded  areas  for  which  the  sizes  are  specified  by  the  syntax  elements \nleft_gb_erp_width and right_gb_erp_width. \nerp_reserved_zero_2bits shall be equal to 0 in bitstreams conforming to this version of this Specification. Other values \nfor  erp_reserved_zero_2bits  are  reserved  for  future  use  by  ITU-T  |  ISO/IEC.  Decoders  shall  ignore  the  value  of \nerp_reserved_zero_2bits. \ngb_erp_type specifies the type of the guard bands as follows: \n–  gb_erp_type equal to 0 specifies that the content of the guard band in relation to the content of the constituent picture \nis unspecified. \n400  Rec. ITU-T H.264 (06/2019) \n \n–  gb_erp_type equal to 1 specifies that the content of the guard band suffices for interpolation of sample values at sub-\npel sample fractional locations within the constituent picture. \nNOTE – gb_erp_type equal to 1 could be used when the boundary samples of a constituent picture have been copied \nhorizontally to the guard band. \n–  gb_erp_type equal to 2 specifies that the content of the guard band represents actual picture content at quality that \ngradually changes from the picture quality of the constituent picture. \n–  gb_erp_type equal to 3 specifies that the content of the guard bands represents actual picture content at a similar level \nof quality as the constituent picture. \n–  gb_erp_type values greater than 3 are reserved. Decoders shall ignore the value of gb_erp_type when the value is \ngreater than 3. \nleft_gb_erp_width specifies the width of the guard band on the left side of the constituent picture in units of luma samples. \nWhen erp_padding_flag is equal to 0, the value of left_gb_erp_width is inferred to be equal to 0. When the decoded picture \nhas 4:2:0 or 4:2:2 chroma format, left_gb_erp_width shall be an even number. \nright_gb_erp_width specifies the width of the guard band on the right side of the constituent picture in units of luma \nsamples. When erp_padding_flag is equal to 0, the value of right_gb_erp_width is inferred to be equal to 0. When the \ndecoded picture has 4:2:0 or 4:2:2 chroma format, right_gb_erp_width shall be an even number. \nD.2.35.2 Cubemap projection SEI message semantics \nThe cubemap projection SEI message provides information to enable remapping (through a cubemap projection) of the \ncolour  samples  of  the  projected  pictures  onto  a  sphere  coordinate  space  in  sphere  coordinates  (ϕ, θ)  for  use  in \nomnidirectional video applications for which the viewing perspective is from the origin looking outward toward the inside \nof the sphere. The sphere coordinates are defined so that ϕ is the azimuth (longitude, increasing eastward) and θ is the \nelevation (latitude, increasing northward). \nWhen a cubemap projection SEI message is present for any picture of a coded video sequence (CVS), a cubemap projection \nSEI message shall be present for the first picture of the CVS and no SEI message indicating a different type of projection \nshall be present for any picture. \nWhen aspect_ratio_idc is present and greater than 1 in the active sequence parameter set, there should be no cubemap \nprojection SEI messages applicable for any picture of the CVS. \nA frame packing arrangement SEI message for which all the following conditions are true is referred to as an effectively \napplicable frame packing arrangement SEI message: \n–  The value of frame_packing_arrangement_cancel_flag is equal to 0. \n–  The value of frame_packing_arrangement_type is equal to 3, 4, or 5. \n–  The value of quincunx_sampling_flag is equal to 0. \n–  The value of spatial_flipping_flag is equal to 0. \n–  The value of field_views_flag is equal to 0. \n–  The value of frame0_grid_position_x is equal to 0. \n–  The value of frame0_grid_position_y is equal to 0. \n–  The value of frame1_grid_position_x is equal to 0. \n–  The value of frame1_grid_position_y is equal to 0. \nWhen an effectively applicable frame packing arrangement SEI message that applies to the picture is not present, a \ncubemap projection SEI message with cmp_cancel_flag equal to 0 that applies to the picture shall not be present. Decoders \nshall ignore cubemap projection SEI messages when an effectively applicable frame packing arrangement SEI message \nthat applies to the picture is not present. \ncmp_cancel_flag equal to 1 indicates that the SEI message cancels the persistence of any previous cubemap projection \nSEI message in output order. cmp_cancel_flag equal to 0 indicates that cubemap projection information follows. \ncmp_persistence_flag specifies the persistence of the cubemap projection SEI message. \ncmp_persistence_flag equal to 0 specifies that the cubemap projection SEI message applies to the current decoded picture \nonly. \nLet picA be the current picture. cmp_persistence_flag equal to 1 specifies that the cubemap projection SEI message persists \nin output order until one or more of the following conditions are true: \n–  A new CVS begins. \n    Rec. ITU-T H.264 (06/2019)  401 \n \n–  The bitstream ends. \n–  A picture picB in an access unit containing a cubemap projection SEI message is output having PicOrderCnt( picB ) \ngreater than PicOrderCnt( picA ). \nD.2.35.3 Sphere rotation SEI message semantics \nThe sphere rotation SEI message provides information on rotation angles yaw (α), pitch (β), and roll (γ) that are used for \nconversion between the global coordinate axes and the local coordinate axes. \nRelative to an (x, y, z) Cartesian coordinate system, yaw expresses a rotation around the z (vertical, up) axis, pitch rotates \naround the y (lateral, side-to-side) axis, and roll rotates around the x (back-to-front) axis. Rotations are extrinsic, i.e., \naround x, y, and z fixed reference axes. The angles increase clockwise when looking from the origin towards the positive \nend of an axis. \nsphere_rotation_cancel_flag equal to 1 indicates that the SEI message cancels the persistence of any previous sphere \nrotation SEI message in output order. sphere_rotation_cancel_flag equal to 0 indicates that sphere rotation information \nfollows. \nsphere_rotation_persistence_flag specifies the persistence of the sphere rotation SEI message. \nsphere_rotation_persistence_flag equal to 0 specifies that the sphere rotation SEI message applies to the current decoded \npicture only. \nLet picA be the current picture. sphere_rotation_persistence_flag equal to 1 specifies that the sphere rotation SEI message \npersists in output order until one or more of the following conditions are true: \n–  A new coded video sequence (CVS) begins. \n–  The bitstream ends. \n–  A picture picB in an access unit containing a sphere rotation SEI message is output having PicOrderCnt( picB ) greater \nthan PicOrderCnt( picA ). \nWhen an equirectangular projection SEI message with erp_cancel_flag equal to 0 or a cubemap projection SEI message \nwith cmp_cancel_flag equal to 0 is not present in the CVS that applies to the current picture and precedes the sphere \nrotation SEI message in decoding order, a sphere rotation SEI message with sphere_rotation_cancel_flag equal to 0 shall \nnot be present in the CVS that applies to the current picture. Decoders shall ignore sphere rotation SEI messages with \nsphere_rotation_cancel_flag equal to 0 that do not follow, in decoding order, an equirectangular projection SEI message \nwith erp_cancel_flag equal to 0 or a cubemap projection SEI message with cmp_cancel_flag equal to 0 in the CVS that \napplies to the current picture. \nsphere_rotation_reserved_zero_6bits shall be equal to 0 in bitstreams conforming to this version of this Specification. \nOther values for sphere_rotation_reserved_zero_6bits are reserved for future use by ITU-T | ISO/IEC. Decoders shall \nignore the value of sphere_rotation_reserved_zero_6bits. \nyaw_rotation specifies the value of the yaw rotation angle, in units of 2−16 degrees. The value of yaw_rotation shall be in \nthe range of −180 * 216 (i.e., −11 796 480) to 180 * 216 − 1 (i.e., 11 796 479), inclusive. When not present, the value of \nyaw_rotation is inferred to be equal to 0. \npitch_rotation specifies the value of the pitch rotation angle, in units of 2−16 degrees. The value of pitch_rotation shall be \nin  the  range  of  −90 * 216  (i.e., −5 898 240)  to  90 * 216  (i.e., 5 898 240),  inclusive.  When  not  present,  the  value  of \npitch_rotation is inferred to be equal to 0. \nroll_rotation specifies the value of the roll rotation angle, in units of 2−16 degrees. The value of roll_rotation shall be in \nthe range of −180 * 216 (i.e., −11 796 480) to 180 * 216 − 1 (i.e., 11 796 479), inclusive. When not present, the value of \nroll_rotation is inferred to be equal to 0. \nD.2.35.4 Region-wise packing SEI message semantics \nThe region-wise packing SEI message provides information to enable remapping of the colour samples of the cropped \ndecoded pictures onto projected pictures as well as information on the location and size of the guard bands, if any. \nrwp_cancel_flag equal to 1 indicates that the SEI message cancels the persistence of any previous region-wise packing \nSEI message in output order. rwp_cancel_flag equal to 0 indicates that region-wise packing information follows. \nrwp_persistence_flag specifies the persistence of the region-wise packing SEI message. \nrwp_persistence_flag equal to 0 specifies that the region-wise packing SEI message applies to the current decoded picture \nonly. \n402  Rec. ITU-T H.264 (06/2019) \n \nLet picA be the current picture. rwp_persistence_flag equal to 1 specifies that the region-wise packing SEI message persists \nin output order until one or more of the following conditions are true: \n–  A new coded video sequence (CVS) begins. \n–  The bitstream ends. \n–  A picture picB in an access unit containing a region-wise packing SEI message is output having PicOrderCnt( picB ) \ngreater than PicOrderCnt( picA ). \nWhen an equirectangular projection SEI message with erp_cancel_flag equal to 0 and erp_padding_flag equal to 0 or a \ncubemap projection SEI message with cmp_cancel_flag equal to 0 is not present in the CVS that applies to the current \npicture and precedes the region-wise packing SEI message in decoding order, a region-wise packing SEI message with \nrwp_cancel_flag equal to 0 shall not be present in the CVS that applies to the current picture. Decoders shall ignore region-\nwise packing SEI messages with rwp_cancel_flag equal to 0 that do not follow, in decoding order, an equirectangular \nprojection SEI message with erp_cancel_flag equal to 0 or a cubemap projection SEI message with cmp_cancel_flag equal \nto 0 in the CVS that applies to the current picture. \nFor the frame packing arrangement scheme indicated by a frame packing arrangement SEI message that applies to the \ncurrent picture, if a region-wise packing SEI message with rwp_cancel_flag equal to 0 is present that applies to the current \npicture, the frame packing arrangement scheme applies to the projected picture, otherwise, the frame packing arrangement \nscheme applies to the cropped decoded picture. \nIf  a  frame  packing  arrangement  SEI  message  with  frame_packing_arrangement_cancel_flag  equal  to  0, \nframe_packing_arrangement_type equal to 3, 4, or 5, and quincunx_sampling_flag equal to 0 is not present that applies to \nthe current picture, the variables StereoFlag, TopBottomFlag, SideBySideFlag, and TempInterleavingFlag are all set equal \nto 0, the variables HorDiv1 and VerDiv1 are both set equal to 1. Otherwise the following applies: \n–  StereoFlag is equal to 1. \n–  When the frame_packing_arrangement_type is equal to 3, SideBySideFlag is set equal to 1, TopBottomFlag and \nTempInterleavingFlag are both set equal to 0, HorDiv1 is set equal to 2 and VerDiv1 is set equal to 1. \n–  When the frame_packing_arrangement_type is equal to 4, TopBottomFlag is set equal to 1, SideBySideFlag and \nTempInterleavingFlag are both set equal to 0, HorDiv1 is set equal to 1 and VerDiv1 is set equal to 2. \n–  When the frame_packing_arrangement_type is equal to 5, TempInterleavingFlag is set equal to 1, TopBottomFlag \nand SideBySideFlag are both set equal to 0, HorDiv1 and VerDiv1 are both set equal to 1. \nconstituent_picture_matching_flag equal to 1 specifies that the projected region information, packed region information, \nand guard band region information in this SEI message apply individually to each constituent picture and that the packed \npicture and the projected picture have the same stereoscopic frame packing  format indicated by the  frame packing \narrangement SEI message. constituent_picture_matching_flag equal to 0 specifies that the projected region information, \npacked region information, and guard band region information in this SEI message apply to the projected picture. \nWhen either of the following two conditions is true, the value of constituent_picture_matching_flag shall be equal to 0: \n–  StereoFlag is equal to 0. \n–  StereoFlag is equal to 1 and frame_packing_arrangement_type is equal to 5. \nrwp_reserved_zero_5bits shall be equal to 0 in bitstreams conforming to this version of this Specification. Other values \nfor rwp_reserved_zero_56bits[ i ] are reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore the value of \nrwp_reserved_zero_5bits[ i ]. \nnum_packed_regions specifies the number of packed regions when constituent_picture_matching_flag is equal to 0. The \nvalue of num_packed_regions shall be greater than 0. When constituent_picture_matching_flag is equal to 1, the total \nnumber  of  packed  regions  is  equal  to  num_packed_regions * 2,  and  the  information  in  each  entry  of  the  loop  of \nnum_packed_regions entries applies to each constituent picture of the projected picture and the packed picture. \nproj_picture_width and proj_picture_height specify the width and height, respectively, of the projected picture, in \nrelative projected picture sample units. \nThe values of proj_picture_width and proj_picture_height shall both be greater than 0. \npacked_picture_width and packed_picture_height specify the width and height, respectively, of the packed picture, in \nrelative packed picture sample units. \nThe values of packed_picture_width and packed_picture_height shall both be greater than 0. \nIt is a requirement of bitstream conformance that packed_picture_width and packed_picture_height shall have such values \nthat packed_picture_width is an integer multiple of cropPicWidth and packed_picture_height is an integer multiple of \ncropPicHeight, where cropPicWidth and cropPicHeight are the width and height, respectively, of the cropped decoded \npicture. \n    Rec. ITU-T H.264 (06/2019)  403 \n \nrwp_reserved_zero_4bits[ i ] shall be equal to 0 in bitstreams conforming to this version of this Specification. Other \nvalues for rwp_reserved_zero_4bits[ i ] are reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore the value of \nrwp_reserved_zero_4bits[ i ]. \ntransform_type[ i ] specifies the rotation and mirroring to be applied to the i-th packed region to remap to the i-th projected \nregion. When transform_type[ i ] specifies both rotation and mirroring, rotation applies before mirroring. The values of \ntransform_type[ i ] are specified in Table D-11: \nTable D-11 – transform_type[ i ] values \nValue  Description \n0  no transform \n1  mirroring horizontally \n2  rotation by 180 degrees (anticlockwise) \n3  rotation by 180 degrees (anticlockwise) before mirroring horizontally \n4  rotation by 90 degrees (anticlockwise) before mirroring horizontally \n5  rotation by 90 degrees (anticlockwise) \n6  rotation by 270 degrees (anticlockwise) before mirroring horizontally \n7  rotation by 270 degrees (anticlockwise) \n \nguard_band_flag[ i ] equal to 0 specifies that the i-th packed region does not have a guard band. guard_band_flag[ i ] \nequal to 1 specifies that the i-th packed region has a guard band. \nproj_region_width[ i ],  proj_region_height[ i ],  proj_region_top[ i ]  and  proj_region_left[ i ]  specify  the  width, \nheight, top sample row, and the left-most sample column, respectively, of the i-th projected region, either within the \nprojected picture (when constituent_picture_matching_flag is equal to 0) or within the constituent picture of the projected \npicture (when constituent_picture_matching_flag is equal to 1). \nproj_region_width[ i ],  proj_region_height[ i ],  proj_region_top[ i ],  and  proj_region_left[ i ]  are  indicated  in  relative \nprojected picture sample units. \nNOTE 1 – Two projected regions may partially or entirely overlap with each other. \npacked_region_width[ i ], packed_region_height[ i ], packed_region_top[ i ], and packed_region_left[ i ] specify the \nwidth, height, the top luma sample row, and the left-most luma sample column, respectively, of the packed region, either \nwithin the region-wise packed picture (when constituent_picture_matching_flag is equal to 0) or within each constituent \npicture of the region-wise packed picture (when constituent_picture_matching_flag is equal to 1). \npacked_region_width[ i ], packed_region_height[ i ], packed_region_top[ i ], and packed_region_left[ i ] are indicated in \nrelative  region-wise  packed  picture  sample  units.  packed_region_width[ i ],  packed_region_height[ i ], \npacked_region_top[ i ], and packed_region_left[ i ] shall represent integer horizontal and vertical coordinates of luma \nsample units within the cropped decoded pictures. \nNOTE 2 – Two packed regions may partially or entirely overlap with each other. \nleft_gb_width[ i ] specifies the width of the guard band on the left side of the i-th packed region in relative region-wise \npacked  picture  sample  units.  When  the  decoded  picture  has  4:2:0  or  4:2:2  chroma  format,  left_gb_width[ i ]  shall \ncorrespond to an even number of luma samples within the cropped decoded picture. \nright_gb_width[ i ] specifies the width of the guard band on the right side of the i-th packed region in relative region-wise \npacked picture sample units. When the decoded picture has 4:2:0 or 4:2:2 chroma format, right_gb_width[ i ] shall \ncorrespond to an even number of luma samples within the cropped decoded picture. \ntop_gb_height[ i ] specifies the height of the guard band above the i-th packed region in relative region-wise packed \npicture sample units. When the decoded picture has 4:2:0 chroma format, top_gb_height[ i ] shall correspond to an even \nnumber of luma samples within the cropped decoded picture. \n404  Rec. ITU-T H.264 (06/2019) \n \nbottom_gb_height[ i ] specifies the height of the guard band below the i-th packed region in relative region-wise packed \npicture sample units. When the decoded picture has 4:2:0 chroma format, bottom_gb_height[ i ] shall correspond to an \neven number of luma samples within the cropped decoded picture. \nWhen  guard_band_flag[ i ]  is  equal  to  1,  left_gb_width[ i ],  right_gb_width[ i ],  top_gb_height[ i ],  or \nbottom_gb_height[ i ] shall be greater than 0. \nThe i-th packed region as specified by this SEI message shall not overlap with any other packed region specified by the \nsame SEI message or any guard band specified by the same SEI message. \nThe guard bands associated with the i-th packed region, if any, as specified by this SEI message shall not overlap with any \npacked region specified by the same SEI message or any other guard bands specified by the same SEI message. \ngb_not_used_for_pred_flag[ i ] equal to 0 specifies that the guard bands may or may not be used in the inter prediction \nprocess. gb_not_used_for_pred_flag[ i ] equal to 1 specifies that the sample values of the guard bands are not used in the \ninter prediction process. \nNOTE 3 – When gb_not_used_for_pred_flag[ i ] is equal to 1, the sample values within guard bands in cropped decoded pictures \ncan be rewritten even if the cropped decoded pictures were used as references for inter prediction of subsequent pictures to be \ndecoded. For example, the content of a packed region can be seamlessly expanded to its guard band with decoded and re-projected \nsamples of another packed region. \ngb_type[ i ][ j ] specifies the type of the guard bands for the i-th packed region as follows, with j equal to 0, 1, 2, or 3 \nindicating that the semantics below apply to the left, right, top, or bottom edge, respectively, of the packed region: \n–  gb_type[ i ][ j ] equal to 0 specifies that the content of the guard bands in relation to the content of the packed regions \nis unspecified. When gb_not_used_for_pred_flag[ i ] is equal to 0, gb_type[ i ][ j ] shall not be equal to 0. \n–  gb_type[ i ][ j ] equal to 1 specifies that the content of the guard bands suffices for interpolation of sample values at \nsub-pel sample fractional locations within the packed region and less than sample outside of the boundary of the \npacked region. \nNOTE 4 – gb_type[ i ][ j ] equal to 1 can be used when the boundary samples of a packed region have been copied horizontally \nor vertically to the guard band. \n–  gb_type[ i ][ j ] equal to 2 specifies that the content of the guard bands represents actual picture content that is \nspherically adjacent to the content in the packed region and is on the surface of the packed region at quality that \ngradually changes from the picture quality of the packed region to that of the spherically adjacent packed region. \n–  gb_type[ i ][ j ] equal to 3 specifies that the content of the guard bands represents actual picture content that is \nspherically adjacent to the content in the packed region and is on the surface of the packed region at the picture quality \nof the packed region. \n–  gb_type[ i ][ j ] values greater than 3 are reserved. Decoders shall ignore the value of gb_type[ i ][ j ] when the value \nis greater than 3. \nrwp_gb_reserved_zero_3bits[ i ] shall be equal to 0 in bitstreams conforming to this version of this Specification. Other \nvalues for rwp_gb_reserved_zero_3bits[ i ] are reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore the value \nof rwp_gb_reserved_zero_3bits[ i ]. \nThe  variables  NumPackedRegions,  PackedRegionLeft[ n ],  PackedRegionTop[ n ],  PackedRegionWidth[ n ], \nPackedRegionHeight[ n ],  ProjRegionLeft[ n ],  ProjRegionTop[ n ],  ProjRegionWidth[ n ],  ProjRegionHeight[ n ],  and \nTrasnformType[ n ] are derived as follows: \n-  For n in the range of 0 to num_packed_regions − 1, inclusive, the following applies: \no  PackedRegionLeft[ n ] is set equal to packed_region_left[ n ]. \no  PackedRegionTop[ n ] is set equal to packed_region_top[ n ]. \no  PackedRegionWidth[ n ] is set equal to packed_region_width[ n ]. \no  PackedRegionHeight[ n ] is set equal to packed_region_height[ n ]. \no  ProjRegionLeft[ n ] is set equal to proj_region_left[ n ]. \no  ProjRegionTop[ n ] is set equal to proj_region_top[ n ]. \no  ProjRegionWidth[ n ] is set equal to proj_region_width[ n ]. \no  ProjRegionHeight[ n ] is set equal to proj_region_height[ n ]. \no  TransformType[ n ] is set equal to transform_type[ n ]. \n-  If constituent_picture_matching_flag is equal to 0, the following applies: \n    Rec. ITU-T H.264 (06/2019)  405 \n \no  NumPackedRegions is set equal to num_packed_regions. \n-  Otherwise (constituent_picture_matching_flag is equal to 1), the following applies: \no  NumPackedRegions is set equal to 2 * num_packed_regions. \no  When TopBottomFlag is equal to 1, the following applies: \no  projLeftOffset and packedLeftOffset are both set equal to 0. \no  projTopOffset  is  set  equal  to  proj_picture_height / 2  and  packedTopOffset  is  set  equal  to \npacked_picture_height / 2. \no  When SideBySideFlag is equal to 1, the following applies: \no  projLeftOffset  is  set  equal  to  proj_picture_width / 2  and  packedLeftOffset  is  set  equal  to \npacked_picture_width / 2. \no  projTopOffset and packedTopOffset are both set equal to 0. \no  For  n  in  the  range  of  NumPackedRegions / 2  to  NumPackedRegions − 1,  inclusive,  the  following \napplies: \n  nIdx is set equal to n − NumPackedRegions / 2. \n  PackedRegionLeft[ n ] is set equal to packed_region_left[ nIdx ] + packedLeftOffset. \n  PackedRegionTop[ n ] is set equal to packed_region_top[ nIdx ] + packedTopOffset. \n  PackedRegionWidth[ n ] is set equal to packed_region_width[ nIdx ]. \n  PackedRegionHeight[ n ] is set equal to packed_region_height[ nIdx ]. \n  ProjRegionLeft[ n ] is set equal to proj_region_left[ nIdx ] + projLeftOffset. \n  ProjRegionTop[ n ] is set equal to proj_region_top[ nIdx ] + projTopOffset. \n  ProjRegionWidth[ n ] is set equal to proj_region_width[ nIdx ]. \n  ProjRegionHeight[ n ] is set equal to proj_region_height[ nIdx ]. \n  TransformType[ n ] is set equal to transform_type[ nIdx ]. \nFor  each  value  of  n  in  the  range  of  0  to  NumPackedRegions − 1,  inclusive,  the  values  of  ProjRegionWidth[ n ], \nProjRegionHeight[ n ], ProjRegionTop[ n ], and ProjRegionLeft[ n ] are constrained as follows: \n-  ProjRegionWidth[ n ] shall be in the range of 1 to proj_picture_width, inclusive. \n-  ProjRegionHeight[ n ] shall be in the range of 1 to proj_picture_height, inclusive. \n-  ProjRegionLeft[ n ] shall be in the range of 0 to proj_picture_width − 1, inclusive. \n-  ProjRegionTop[ n ] shall be in the range of 0 to proj_picture_height − 1, inclusive. \n-  If  ProjRegionTop[ n ]  is  less  than  proj_picture_height / VerDiv1,  the  sum  of  ProjRegionTop[ n ]  and \nProjRegionHeight[ n ] shall be less than or equal to proj_picture_height / VerDiv1. Otherwise, the sum of \nProjRegionTop[ n ] and ProjRegionHeight[ n ] shall be less than or equal to proj_picture_height / VerDiv1 * 2. \nFor each value of n in the range of 0 to NumPackedRegions − 1, inclusive, the values of PackedRegionWidth[ n ], \nPackedRegionHeight[ n ], PackedRegionTop[ n ], and PackedRegionLeft[ n ] are constrained as follows: \n-  PackedRegionWidth[ n ] shall be in the range of 1 to packed_picture_width, inclusive. \n-  ProjRegionHeight[ n ] shall be in the range of 1 to packed_picture_height, inclusive. \n-  PackedRegionLeft[ n ] shall be in the range of 0 to packed_picture_width − 1, inclusive. \n-  PackedRegionTop[ n ] shall be in the range of 0 to packed_picture_height − 1, inclusive. \n-  If PackedRegionLeft[ n ] is less than packed_picture_width / HorDiv1, the sum of PackedRegionLeft[ n ] and \nPackedRegionWidth[ n ] shall be less than or equal to packed_picture_width / HorDiv1. Otherwise, the sum of \nPackedRegionLeft[ n ]  and  PackedRegionWidth[ n ]  shall  be  less  than  or  equal  to \npacked_picture_width / HorDiv1 * 2. \n-  If PackedRegionTop[ n ] is less than packed_picture_height / VerDiv1, the sum of PackedRegionTop[ n ] and \nPackedRegionHeight[ n ] shall be less than or equal to packed_picture_height / VerDiv1. Otherwise, the sum of \n406  Rec. ITU-T H.264 (06/2019) \n \nPackedRegionTop[ n ]  and  PackedRegionHeight[ n ]  shall  be  less  than  or  equal  to \npacked_picture_height / VerDiv1 * 2. \n-  When chroma_format_idc is equal to 1 (4:2:0 chroma format) or 2 (4:2:2 chroma format), PackedRegionLeft[ n ] \nshall correspond to an even horizontal coordinate value of luma sample units, and PackedRegionWidth[ n ] shall \ncorrespond to an even number of luma samples, both within the decoded picture. \n-  When chroma_format_idc is equal to 1 (4:2:0 chroma format), PackedRegionTop[ n ] shall correspond to an \neven vertical coordinate value of luma sample units, and ProjRegionHeight[ n ] shall correspond to an even \nnumber of luma samples, both within the decoded picture. \nD.2.35.5 Omnidirectional viewport SEI message semantics \nThe omnidirectional viewport SEI message specifies the coordinates of one or more regions of spherical-coordinate \ngeometry, bounded by four great circles, corresponding to viewports recommended for display when the user does not \nhave control of the viewing orientation or has released control of the viewing orientation. \nWhen an effectively applicable frame packing arrangement SEI message, as specified in clause D.2.35.1 or D.2.35.2, that \napplies to the picture is present, the information indicated by the omnidirectional viewport SEI message applies to both \nviews. \nomni_viewport_id  contains  an  identifying  number  that  may  be  used  to  identify  the  purpose  of  the  one  or  more \nrecommended viewport regions. \nomni_viewport_id equal to 0 indicates that the recommended viewports are per \"director’s cut\", i.e., a viewport suggested \naccording to the creative intent of the content author or content provider. omni_viewport_id equal to 1 indicates that the \nrecommended viewports are selected based on measurements of viewing statistics. \nValues  of  omni_viewport_id  from  2  to  511,  inclusive,  may  be  used  as  determined  by  the  application.  Values  of \nomni_viewport_id from 512 to 1023 are reserved for future use by ITU-T | ISO/IEC. Decoders encountering a value of \nomni_viewport_id in the range of 512 to 1023, inclusive, shall ignore it. \nomni_viewport_cancel_flag  equal  to  1  indicates  that  the  SEI  message  cancels  the  persistence  of  any  previous \nomnidirectional  viewport  SEI  message  in  output  order.  omni_viewport_cancel_flag  equal  to  0  indicates  that \nomnidirectional viewport information follows. \nomni_viewport_persistence_flag specifies the persistence of the omnidirectional viewport SEI message. \nomni_viewport_persistence_flag equal to 0 specifies that the omnidirectional viewport SEI message applies to the current \ndecoded picture only. \nLet picA be the current picture. omni_viewport_persistence_flag equal to 1 specifies that the omnidirectional viewport SEI \nmessage persists in output order until one or more of the following conditions are true: \n–  A new coded video sequence (CVS) begins. \n–  The bitstream ends. \n–  A  picture  picB  in  an  access  unit  containing  an  omnidirectional  viewport  SEI  message  is  output  having \nPicOrderCnt( picB ) greater than PicOrderCnt( picA ). \nWhen an equirectangular projection SEI message with erp_cancel_flag equal to 0 or a cubemap projection SEI message \nwith  cmp_cancel_flag  equal  to  0  is  not  present  in  the  CVS  that  applies  to  the  current  picture  and  precedes  the \nomnidirectional  viewport  SEI  message  in  decoding  order,  an  omnidirectional  viewport  SEI  message  with \nomni_viewport_cancel_flag equal to 0 shall not be present in the CVS that applies to the current picture. Decoders shall \nignore omnidirectional viewport SEI messages with omni_viewport_cancel_flag equal to 0 that do not follow, in decoding \norder, an equirectangular projection SEI message with erp_cancel_flag equal to 0 or a cubemap projection SEI message \nwith cmp_cancel_flag equal to 0 in the CVS that applies to the current picture. \nomni_viewport_cnt_minus1 plus 1 specifies the number of recommended viewport regions that are indicated by the SEI \nmessage. \nWhen omni_viewport_cnt_minus1 is greater than 0 and there is no information provided by external means not specified \nin this Specification on which recommended viewport is suggested to be displayed, the following applies: \n  When omni_viewport_id is equal to 0 or 1, the 0-th recommended viewport is suggested to be displayed when \nthe user does not have control of the viewing orientation or has released control of the viewing orientation. \n  When omni_viewport_id is equal to 0, between any two recommended viewports per director's cut, the i-th \nrecommended viewport has higher priority than the j-th recommended viewport for any values of i and j when i \nis less than j. The 0-th recommended viewport per director's cut has the highest priority. \n    Rec. ITU-T H.264 (06/2019)  407 \n \n  When omni_viewport_id is equal to 1, between any two recommended viewports, the i-th recommended viewport \nhas higher popularity, among some selection of candidate viewports, than the j-th recommended viewport for any \nvalues of i and j when i is less than j. The 0-th most-viewed recommended viewport has the highest popularity. \nThe selection of the candidate viewports is outside the scope of this Specification. \nomni_viewport_azimuth_centre[ i ]  and  omni_viewport_elevation_centre[ i ]  indicate  the  centre  of  the  i-th \nrecommended  viewport  region,  in  units  of  2−16  degrees  relative  to  the  global  coordinate  axes.  The  value  of \nomni_viewport_azimuth_centre[ i ]  shall  be  in  the  range  of  −180 * 216  (i.e., −11 796 480)  to  180 * 216 − 1 \n(i.e., 11 796 479),  inclusive.  The  value  of  omni_viewport_elevation_centre[ i ]  shall  be  in  the  range  of  −90 * 216 \n(i.e., −5 898 240) to 90 * 216 (i.e., 5 898 240), inclusive. \nomni_viewport_tilt_centre[ i ] indicates the tilt angle of the i-th recommended viewport region, in units of 2−16 degrees. \nThe  value  of  omni_viewport_tilt_centre[ i ]  shall  be  in  the  range  of  −180 * 216  (i.e., −11 796 480)  to   216 − 1 \n(i.e., 11 796 479), inclusive. \nomni_viewport_hor_range[ i ] indicates the azimuth range of the i-th recommended viewport region, in units of 2−16 \ndegrees. The value of omni_viewport_hor_range[ i ] shall be in the range of 1 to 360 * 216 (i.e., 23 592 960), inclusive. \nomni_viewport_ver_range[ i ] indicates the elevation range of the i-th recommended viewport region, in units of 2−16 \ndegrees. The value of omni_viewport_ver_range[ i ] shall be in the range of 1 to 180 * 216 (i.e., 11 796 480), inclusive. \nD.2.35.6 Sample location remapping process \nD.2.35.6.1  General \nTo remap colour sample locations of a region-wise packed picture to a unit sphere, the following ordered steps are applied: \n–  A region-wise packed picture is obtained as the cropped decoded picture by decoding a coded picture. For purposes \nof interpretation of chroma samples, the input to the indicated remapping process is the set of decoded sample values \nafter applying an (unspecified) upsampling conversion process to the 4:4:4 colour sampling format as necessary when \nchroma_format_idc is equal to 1 (4:2:0 chroma format) or 2 (4:2:2 chroma format). This (unspecified) upsampling \nprocess should account for the relative positioning relationship between the luma and chroma samples as indicated \nby chroma_sample_loc_type_top_field and chroma_sample_loc_type_bottom_field, when present. \n–  If region-wise packing is indicated, the sample locations of the region-wise packed picture are converted to sample \nlocations of the respective projected picture as specified in clause D.2.35.6.4. Otherwise, the projected picture is \nidentical to the region-wise packed picture. \n–  If frame packing is indicated, the sample locations of the projected picture are converted to sample locations of the \nrespective constituent picture of the projected picture, as specified in clause D.2.35.6.6. Otherwise, the constituent \npicture of the projected picture is identical to the projected picture. \n–  The sample locations of a constituent picture of the projected picture are converted to sphere coordinates relative to \nthe local coordinate axes, as specified in clause D.2.35.6.2. \n–  If rotation is indicated, the sphere coordinates relative to the local coordinate axes are converted to sphere coordinates \nrelative to the global coordinate axes, as specified in clause D.2.35.6.3. Otherwise, the global coordinate axes are \nidentical to the local coordinate axes. \nThe overall process for mapping of luma sample locations within a region-wise packed picture to sphere coordinates \nrelative to the global coordinate axes is normatively specified in clause D.2.35.6.5. \nFor each region-wise packed picture corresponding to a decoded picture, the following applies: \n–  When an equirectangular projection SEI message with erp_cancel_flag equal to 0 that applies to the picture is present, \nErpFlag is set equal to 1, and CmpFlag is set equal to 0. \n–  When a cubemap projection SEI message with cmp_cancel_flag equal to 0 that applies to the picture is present, \nCmpFlag is set equal to 1, and ErpFlag is set equal to 0. \n–  If a sphere rotation SEI message with sphere_rotation_cancel_flag equal to 0 that applies to the picture is present, \nRotationFlag is set equal to 1, and RotationYaw, RotationPitch, and RotationRoll are set equal to yaw_rotation ÷ 216, \npitch_rotation ÷ 216, and roll_rotation ÷ 216, respectively. \n–  Otherwise, RotationFlag is set equal to 0. \n–  If a frame packing arrangement SEI message with frame_packing_arrangement_cancel_flag equal to 0 that applies to \nthe picture is not present, StereoFlag, TopBottomFlag, and SideBySideFlag are all set equal to 0, HorDiv1 is set equal \nto 1, and VerDiv1 is set equal to 1. \n–  Otherwise, the following applies: \n408  Rec. ITU-T H.264 (06/2019) \n \n–  StereoFlag is set equal to 1. \n–  If the value of frame_packing_arrangement_type of the frame packing arrangement SEI message is equal to 3, \nTopBottomFlag is set equal to 0, SideBySideFlag is set equal to 1, HorDiv1 is set equal to 2 and VerDiv1 is set \nequal to 1. \n–  Otherwise, if the value of frame_packing_arrangement_type of the frame packing arrangement SEI message is \nequal to 4, TopBottomFlag is set equal to 1, SideBySideFlag is set equal to 0, HorDiv1 is set equal to 1, and \nVerDiv1 is set equal to 2. \n–  Otherwise, TopBottomFlag is set equal to 0, SideBySideFlag is set equal to 0, HorDiv1 is set equal to 1, and \nVerDiv1 is set equal to 1. \n–  If a region-wise packing SEI message with rwp_cancel_flag equal to 0 that applies to the picture is not present, \nRegionWisePackingFlag is set equal to 0, and ConstituentPicWidth and ConstituentPicHeight are set to be equal to \ncropPicWidth / HorDiv1 and cropPicHeight / VerDiv1, respectively, where cropPicWidth and cropPicHeight are the \nwidth and height, respectively, of the cropped decoded picture. \n–  Otherwise, RegionWisePackingFlag is set equal to 1, and ConstituentPicWidth and ConstituentPicHeight are set equal \nto proj_picture_width / HorDiv1 and proj_picture_height / VerDiv1, respectively. \nD.2.35.6.2  Projection for a sample location \nInputs to this clause are: \n–  pictureWidth and pictureHeight, which are the width and height, respectively, of a monoscopic projected luma picture, \nin relative projected picture sample units, and \n–  the centre point of a sample location (hPos, vPos) along the horizontal and vertical axes, respectively, in relative \nprojected picture sample units, where hPos and vPos may have non-integer real values. \nOutputs of this clause are: \n–  sphere coordinates (ϕ, θ) for the sample location in degrees relative to the coordinate axes specified in clause \nD.2.35.6.1. \nThe projection for a sample location is derived as follows: \n–  If ErpFlag is equal to 1, the following applies: \n–  If RegionWisePackingFlag is equal to 0 and erp_padding_flag is equal to 1, the following applies: \nhPos′ = hPos − left_gb_erp_width    (D-45) \npictureWidth = pictureWidth − left_gb_erp_width − right_gb_erp_width \n–  Otherwise, the following applies: \nhPos′ = hPos    (D-46) \n–  The following applies: \nϕ = 180 − hPos′ * ( 360 ÷ pictureWidth )    (D-47) \nθ = 90 − vPos * ( 180 ÷ pictureHeight ) \n–  Otherwise (CmpFlag is equal to 1), it is a requirement of bitstream conformance that pictureWidth shall be a multiple \nof 3 and pictureHeight shall be a multiple of 2, and that pictureWidth / 3 shall be equal to pictureHeight / 2, and the \nfollowing applies: \nlw = pictureWidth / 3 \nlh = pictureHeight / 2 \nw = Floor( hPos ÷ lw ) \nh = Floor( vPos ÷ lh ) \ntmpHorVal = hPos − w * lw \ntmpVerVal = vPos − h * lh \nhPos′ = −( 2 * tmpHorVal ÷ lw ) + 1 \nvPos′ = −( 2 * tmpVerVal ÷ lh ) + 1 \nif( w  = =  1  &&  h  = =  0 ) { /* positive x front face */ \n  x = 1.0 \n  y = hPos′ \n  z = vPos′ \n} else if( w  = =  1  &&  h  = =  1 ) { /* negative x back face */ \n  x = −1.0 \n    Rec. ITU-T H.264 (06/2019)  409 \n \n  y = −vPos′ \n  z = −hPos′ \n} else if( w  = =  2  &&  h  = =  1 ) { /* positive z top face */  (D-48) \n  x = −hPos′ \n  y = −vPos′ \n  z = 1.0 \n} else if( w  = =  0  &&  h  = =  1 ) { /* negative z bottom face */ \n  x = hPos′ \n  y = −vPos′ \n  z = −1.0 \n} else if( w  = =  0  &&  h  = =  0 ) { /* positive y left face */ \n  x = −hPos′ \n  y = 1.0 \n  z = vPos′ \n} else { /* ( w  = =  2  &&  h  = =  0 ), negative y right face */ \n  x = hPos′ \n  y = −1.0 \n  z = vPos′ \n} \nϕ = Atan2( y, x ) * 180 ÷ π \nθ = Asin( z ÷ Sqrt( x2 + y2 + z2 ) ) * 180 ÷ π \nD.2.35.6.3  Conversion from the local coordinate axes to the global coordinate axes \nInputs to this clause are: \n–  rotation_yaw (α ), rotation_pitch (β ), rotation_roll (γ ), all in units of degrees, and \nd d d\n–  sphere coordinates (ϕ , θ ) relative to the local coordinate axes. \nd d\nOutputs of this clause are: \n–  sphere coordinates (ϕ′, θ′) relative to the global coordinate axes. \nThe outputs are derived as follows: \nϕ = ϕ  * π ÷ 180 \nd\nθ = θ  * π ÷ 180 \nd\nα = α  * π ÷ 180 \nd\nβ = β  * π ÷ 180 \nd\nγ = γ  * π ÷ 180 \nd\nx  = Cos( ϕ ) * Cos( θ ) \n1\ny  = Sin( ϕ ) * Cos( θ ) \n1\nz  = Sin( θ ) \n1\nx  = Cos( β ) * Cos ( γ ) * x  − Cos( β ) * Sin( γ ) * y  + Sin( β ) * z   (D-49) \n2 1 1 1\ny  = ( Cos( α ) * Sin( γ ) + Sin( α ) * Sin( β ) * Cos( γ ) ) * x  + \n2 1\n  ( Cos( α ) * Cos( γ ) − Sin( α ) * Sin( β ) * Sin( γ ) ) * y  − \n1\n  Sin( α ) * Cos( β ) * z  \n1\nz  = ( Sin( α ) * Sin( γ ) − Cos( α ) * Sin( β ) * Cos( γ ) ) * x  + \n2 1\n  ( Sin( α ) * Cos( γ ) + Cos( α ) * Sin( β ) * Sin( γ ) ) * y  + \n1\n  Cos( α ) * Cos( β ) * z  \n1\nϕ′ = Atan2( y , x  ) * 180 ÷ π \n2 2\nθ′ = Asin( z  ) * 180 ÷ π \n2\nD.2.35.6.4  Conversion of sample locations for rectangular region-wise packing \nInputs to this clause are: \n–  sample location (x, y) within the packed region, where x and y are in relative packed picture sample units, while the \nsample location is at an integer sample location within the packed picture, \n–  the width and the height (projRegWidth, projRegHeight) of the projected region, in relative projected picture sample \nunits, \n–  the width and the height (packedRegWidth, packedRegHeight) of the packed region, in relative packed picture sample \nunits, \n–  transform type (transformType), and \n410  Rec. ITU-T H.264 (06/2019) \n \n–  offset values for the sampling position (offsetX, offsetY) in the range of 0, inclusive, to 1, exclusive, in horizontal \nand vertical relative packed picture sample units, respectively. \nNOTE:   offsetX and offsetY both equal to 0.5 indicate a sampling position that is in the centre point of a sample in packed \npicture sample units. \nOutputs of this clause are: \n–  the centre point of the sample location (hPos, vPos) within the projected region in relative projected picture sample \nunits, where hPos and vPos may have non-integer real values. \nThe outputs are derived as follows: \nif( transformType  = =  0  | |  transformType  = =  1  | |  transformType  = =  2  | |  transformType  = =  3 ) { \n  horRatio = projRegWidth ÷ packedRegWidth \n  verRatio = projRegHeight ÷ packedRegHeight \n} else if( transformType  = =  4  | |  transformType  = =  5  | |  transformType  = =  6  | | \n  transformType  = =  7 ) { \n  horRatio = projRegWidth ÷ packedRegHeight \n  verRatio = projRegHeight ÷ packedRegWidth \n} \nif( transformType  = =  0 ) { \n  hPos = horRatio * ( x + offsetX ) \n  vPos = verRatio * ( y + offsetY ) \n} else if( transformType  = =  1 ) { \n  hPos = horRatio * ( packedRegWidth − x − offsetX ) \n  vPos = verRatio * ( y + offsetY ) \n} else if( transformType  = =  2 ) { \n  hPos = horRatio * ( packedRegWidth − x − offsetX ) \n  vPos = verRatio * ( packedRegHeight − y − offsetY )  (D-50) \n} else if( transformType  = =  3 ) { \n  hPos = horRatio * ( x + offsetX ) \n  vPos = verRatio * ( packedRegHeight − y − offsetY ) \n} else if( transformType  = =  4 ) { \n  hPos = horRatio * ( y + offsetY ) \n  vPos = verRatio * ( x + offsetX ) \n} else if( transformType  = =  5 ) { \n  hPos = horRatio * ( y + offsetY ) \n  vPos = verRatio * ( packedRegWidth − x − offsetX ) \n} else if( transformType  = = 6 ) { \n  hPos = horRatio * ( packedRegHeight − y − offsetY ) \n  vPos = verRatio * ( packedRegWidth − x − offsetX ) \n} else if( transformType  = =  7 ) { \n  hPos = horRatio * ( packedRegHeight − y − offsetY ) \n  vPos = verRatio * ( x+ offsetX ) \n} \nD.2.35.6.5  Mapping of luma sample locations within a cropped decoded picture to sphere coordinates relative to \nthe global coordinate axes \nThis clause specifies the semantics of luma sample locations within a cropped decoded picture to sphere coordinates \nrelative to the global coordinate axes. \noffsetX is set equal to 0.5 and offsetY is set equal to 0.5. \nIf  RegionWisePackingFlag  is  equal  to  1,  the  following  applies  for  each  packed  region  n  in  the  range  of  0  to \nNumPackedRegions − 1, inclusive: \n–  For each sample location (xPackedPicture, yPackedPicture) belonging to the n-th packed region, the following \napplies: \n–  The corresponding sample location (xProjPicture, yProjPicture) of the projected picture is derived as follows: \n–  x is set equal to xPackedPicture − PackedRegionLeft[ n ]. \n–  y is set equal to yPackedPicture − PackedRegionTop[ n ]. \n    Rec. ITU-T H.264 (06/2019)  411 \n \n–  Clause  D.2.35.6.4  is  invoked  with  x,  y,  PackedRegionWidth[ n ],  PackedRegionHeight[ n ], \nProjRegionWidth[ n ], ProjRegionHeight[ n ], TransformType[ n ], offsetX, and offsetY as inputs, and the \noutput is assigned to sample location (hPos, vPos). \n–  xProjPicture is set equal to ProjRegionLeft[ n ] + hPos. \n–  When StereoFlag is equal to 0 or TopBottomFlag is equal to 1, and when xProjPicture is greater than or \nequal to proj_picture_width, xProjPicture is set equal to xProjPicture − proj_picture_width. \n–  When SideBySideFlag is equal to 1, the following applies: \n–  When ProjRegionLeft[ n ] is less than proj_picture_width / 2 and xProjPicture is greater than or equal \nto proj_picture_width / 2, xProjPicture is set equal to xProjPicture − proj_picture_width / 2. \n–  When ProjRegionLeft[ n ] is greater than or equal to proj_picture_width / 2 and xProjPicture is greater \nthan or equal to proj_picture_width, xProjPicture is set equal to xProjPicture − proj_picture_width / 2. \n–  yProjPicture is set equal to ProjRegionTop[ n ] + vPos. \n–  Clause D.2.35.6.6 is invoked with xProjPicture, yProjPicture, ConstituentPicWidth, and ConstituentPicHeight \nas inputs, and the outputs indicating the sphere coordinates and the constituent picture index (for frame-packed \nstereoscopic video) for the luma sample location (xPackedPicture, yPackedPicture) belonging to the n-th packed \nregion in the decoded picture. \nOtherwise (RegionWisePackingFlag is equal 0), the following applies for each sample location (x, y) that is not an \nequirectangular projection padded sample within the cropped decoded picture, where a sample location (x, y) is an \nequirectangular  projection  padded  sample  when  and  only  when  ErpFlag  is  equal  to  1,  x  is  in  the  range  of  0  to \nleft_gb_erp_width − 1, inclusive, or ConstituentPicWidth − right_gb_erp_width to ConstituentPicWidth − 1, inclusive, \nand y is in the range of 0 to ConstituentPicHeight − 1, inclusive: \n–  xProjPicture is set equal to x + offsetX. \n–  yProjPicture is set equal to y + offsetY. \n–  If ErpFlag is equal to 0, projPicWidth is set equal to ConstituentPicWidth. Otherwise (ErpFlag is equal to 1), \nprojPicWidth is set equal to ConstituentPicWidth − ( left_gb_erp_width + right_gb_erp_width ). \n–  Clause D.2.35.6.6 is invoked with xProjPicture, yProjPicture, projPicWidth, and ConstituentPicHeight as inputs, and \nthe outputs indicating the sphere coordinates and the constituent picture index (for frame-packed stereoscopic video) \nfor the sample location (x, y) within the region-wise packed picture. \nD.2.35.6.6  Conversion from a sample location in a projected picture to sphere coordinates relative to the global \ncoordinate axes \nInputs to this clause are: \n–  the centre point of a sample location (xProjPicture, yProjPicture) within a projected picture, where xProjPicture and \nyProjPicture are in relative projected picture sample units and may have non-integer real values, and \n–  pictureWidth and pictureHeight, which are the width and height, respectively, of a monoscopic projected luma picture, \nin relative projected picture sample units. \nOutputs of this clause are: \n–  sphere coordinates (azimuthGlobal, elevationGlobal), in units of degrees relative to the global coordinate axes, and \n–  when StereoFlag is equal to 1, the index of the constituent picture (constituentPicture) equal to 0 or 1. \nThe outputs are derived with the following ordered steps: \n–  If xProjPicture is greater than or equal to pictureWidth or yProjPicture is greater than or equal to pictureHeight, the \nfollowing applies: \n–  constituentPicture is set equal to 1. \n–  If xProjPicture is greater than or equal to pictureWidth, xProjPicture is set to xProjPicture − pictureWidth. \n–  If yProjPicture is greater than or equal to pictureHeight, yProjPicture is set to yProjPicture − pictureHeight. \n–  Otherwise, constituentPicture is set equal to 0. \n–  Clause D.2.35.6.2 is invoked with pictureWidth, pictureHeight, xProjPicture, and yProjPicture as inputs, and the \noutput is assigned to azimuthLocal, elevationLocal. \n412  Rec. ITU-T H.264 (06/2019) \n \n–  If  RotationFlag  is  equal  to  1,  clause  D.2.35.6.3  is  invoked  with  azimuthLocal,  elevationLocal,  RotationYaw, \nRotationPitch, and RotationRoll as inputs, and the output is assigned to azimuthGlobal and elevationGlobal. \n–  Otherwise, azimuthGlobal is set equal to azimuthLocal and elevationGlobal is set equal to elevationLocal. \nD.2.36  SEI manifest SEI message semantics \nThe SEI manifest SEI message conveys information on SEI messages that are indicated as expected (i.e., likely) to be \npresent or not present. Such information may include: \n1)  The indication that certain types of SEI messages are expected (i.e., likely) to be present (although not guaranteed \nto be present) in the CVS. \n2)  For each type of SEI message that is indicated as expected (i.e., likely) to be present in the CVS, the degree of \nexpressed necessity of interpretation of the SEI messages of this type. \nThe degree of necessity of interpretation of an SEI message type may be indicated as \"necessary\", \"unnecessary\", \nor \"undetermined\". \nAn SEI message is indicated by the encoder (i.e., the content producer) as being \"necessary\" when the information \nconveyed by the SEI message is considered as necessary for interpretation by the decoder or receiving system in \norder to properly process the content and enable an adequate user experience; it does not mean that the bitstream \nis required to contain the SEI message in order to be a conforming bitstream. It is at the discretion of the encoder \nto determine which SEI messages are to be considered as necessary in a particular CVS. However, it is suggested \nthat  some  SEI  messages,  such  as  the  frame  packing  arrangement,  segmented  rectangular  frame  packing \narrangement,  and  omnidirectional  projection  indication  SEI  messages,  should  typically  be  considered  as \nnecessary. \n3)  The indication that certain types of SEI messages are expected (i.e., likely) not to be present (although not \nguaranteed not to be present) in the CVS. \nNOTE – An example of such a usage of an SEI manifest SEI message is to express the expectation that there are no frame \npacking arrangement SEI messages, segmented rectangular frame packing arrangement SEI messages, display orientation \nSEI messages, or omnidirectional projection indication SEI messages in the CVS, and therefore that the rendering of the \ndecoded video pictures for display purposes would not need any of the additional post-processing that is commonly \nassociated with the interpretation of these SEI messages. \nThe content of an SEI manifest SEI message may, for example, be used by transport-layer or systems-layer processing \nelements to determine whether the CVS is suitable for delivery to a receiving and decoding system, based on whether the \nreceiving system can properly process the CVS to enable an adequate user experience or whether the CVS satisfies the \napplication needs. \nWhen an SEI manifest SEI message is present in any access unit of a CVS, an SEI manifest SEI message shall be present \nin the first access unit of the CVS. The SEI manifest SEI message persists in decoding order from the current access unit \nuntil the end of the CVS. When there are multiple SEI manifest SEI messages present in a CVS, they shall have the same \ncontent. \nAn SEI NAL unit containing an SEI manifest SEI message shall not contain any other SEI messages other than SEI prefix \nindication SEI messages. When present in an SEI NAL unit, the SEI manifest SEI message shall be the first SEI message \nin the SEI NAL unit. \nmanifest_num_sei_msg_types specifies the number of types of SEI messages for which information is provided in the \nSEI manifest SEI message. \nmanifest_sei_payload_type[ i ] indicates the payloadType value of the i-th type of SEI message for which information is \nprovided  in  the  SEI  manifest  SEI  message.  The  values  of  manifest_sei_payload_type[ m ]  and \nmanifest_sei_payload_type[ n ] shall not be identical when m is not equal to n. \nmanifest_sei_description[ i ]  provides  information  on  SEI  messages  with  payloadType  equal  to \nmanifest_sei_payload_type[ i ] as specified in Table D-12. \n    Rec. ITU-T H.264 (06/2019)  413 \n \nTable D-12– manifest_sei_description[ i ] values \n \nValue  Description \nIndicates  that  there  is  no  SEI  message  with  payloadType  equal  to \n0 \nmanifest_sei_payload_type[ i ] expected to be present in the CVS. \nIndicates  that  there  are  SEI  messages  with  payloadType  equal  to \n1  manifest_sei_payload_type[ i ] expected to be present in the CVS, and  \nthese SEI messages are considered as necessary. \nIndicates  that  there  are  SEI  messages  with  payloadType  equal  to \n2  manifest_sei_payload_type[ i ] expected to be present in the CVS, and  \nthese SEI messages are considered as unnecessary. \nIndicates  that  there  are  SEI  messages  with  payloadType  equal  to \n3  manifest_sei_payload_type[ i ] expected to be present in the CVS, and  \nthe necessity of these SEI messages is undetermined. \n4-255  Reserved \n \nThe value of manifest_sei_description[ i ] shall be in the range of 0 to 3, inclusive, in bitstreams conforming to this version \nof this Specification. Other values for  manifest_sei_description[ i ] are reserved for future use by ITU-T | ISO/IEC. \nDecoders shall allow the value of manifest_sei_description[ i ] greater than or equal to 4 to appear in the syntax and shall \nignore all information for payloadType equal to manifest_sei_payload_type[ i ] signalled in the SEI manifest SEI message \nand  shall  ignore  all  SEI  prefix  indication  SEI  messages  with  prefix_sei_payload_type  equal  to \nmanifest_sei_payload_type[ i ] when manifest_sei_description[ i ] is greater than or equal to 4. \nD.2.37  SEI prefix indication SEI message semantics \nThe SEI prefix indication SEI message carries one or more SEI prefix indications for SEI messages of a particular value \nof payloadType. Each SEI prefix indication is a bit string that follows the SEI payload syntax of that value of payloadType \nand contains a number of complete syntax elements starting from the first syntax element in the SEI payload. \nEach SEI prefix indication for an SEI message of a particular value of payloadType indicates that one or more SEI messages \nof this value of payloadType are expected (i.e., likely) to be present in the CVS and to start with the provided bit string. A \nstarting bit string would typically contain only a true subset of an SEI payload of the type of SEI message indicated by the \npayloadType, may contain a complete SEI payload, and shall not contain more than a complete SEI payload. It is not \nprohibited for SEI messages of the indicated value of payloadType to be present that do not start with any of the indicated \nbit strings. \nThese SEI prefix indications should provide sufficient information for indicating what type of processing is needed or what \ntype of content is included. The former (type of processing) indicates decoder-side processing capability, e.g., whether \nsome type of frame unpacking is needed. The latter (type of content) indicates, for example, whether the bitstream contains \nsubtitle captions in a particular language. \nThe content of an SEI prefix indication SEI message may, for example, be used by transport-layer or systems-layer \nprocessing elements to determine whether the CVS is suitable for delivery to a receiving and decoding system, based on \nwhether the receiving system can properly process the CVS to enable an adequate user experience or whether the CVS \nsatisfies the application needs (as determined in some manner by external means outside the scope of this Specification). \nIn one example, when the payloadType indicates the frame packing arrangement SEI message, an SEI prefix indication \nshould include up to at least the syntax element frame_packing_arrangement_type; and when the payloadType indicates \nthe omnidirectional projection indication SEI message, an SEI prefix indication should include up to at least the syntax \nelement projection_type. \nIn another example, for user data registered SEI messages that are used to carry captioning information, an SEI prefix \nindication should include up to at least the language code; and for user data unregistered SEI messages extended for private \nuse, an SEI prefix indication should include up to at least the UUID. \nWhen an SEI prefix indication SEI message is present in any access unit of a CVS, an SEI prefix indication SEI message \nshall be present in the first access unit of the CVS. The SEI prefix indication SEI message persists in decoding order from \nthe current access unit until the end of the CVS. When there are multiple SEI prefix indication SEI messages present in a \nCVS for a particular value of payloadType, they shall have the same content. \n414  Rec. ITU-T H.264 (06/2019) \n \nAn SEI NAL unit containing an SEI prefix indication SEI message for a particular value of payloadType shall not contain \nany other SEI messages other than an SEI manifest SEI message and SEI prefix indication SEI messages for other values \nof payloadType. \nprefix_sei_payload_type  indicates  the  payloadType  value  of  the  SEI  messages  for  which  one  or  more  SEI  prefix \nindications are provided in the SEI prefix indication SEI message. When an SEI manifest SEI message is also present for \nthe CVS, the value of prefix_sei_payload_type shall be equal to one of the manifest_sei_payload_type[ m ] values for \nwhich manifest_sei_description[ m ] is equal to 1 to 3, inclusive, as indicated by an SEI manifest SEI message that applies \nto the CVS. \nnum_sei_prefix_indications_minus1 plus 1 specifies the number of SEI prefix indications. \nnum_bits_in_prefix_indication_minus1[ i ] plus 1 specifies the number of bits in the i-th SEI prefix indication. \nsei_prefix_data_bit[ i ][ j ] specifies the j-th bit of the i-th SEI prefix indication. \nThe bits sei_prefix_data_bit[ i ][ j ] for j ranging from 0 to num_bits_in_prefix_indication_minus1[ i ], inclusive, follow \nthe syntax of the SEI payload with payloadType equal to prefix_sei_payload_type, and contain a number of complete \nsyntax elements starting from the first syntax element in the SEI payload syntax, and may or may not contain all the syntax \nelements  in  the  SEI  payload  syntax.  The  last  bit  of  these  bits  (i.e.,  the  bit \nsei_prefix_data_bit[ i ][ num_bits_in_prefix_indication_minus1[ i ] ]) shall be the last bit of a syntax element in the SEI \npayload syntax, unless it is a bit within an itu_t_t35_payload_byte or user_data_payload_byte. \nNOTE – The exception for itu_t_t35_payload_byte and user_data_payload_byte is provided because these syntax elements may \ncontain externally-specified syntax elements, and the determination of the boundaries of such externally-specified syntax elements \nis a matter outside the scope of this Specification. \nD.2.38  Reserved SEI message semantics \nThis message consists of data reserved for future backward-compatible use by ITU-T | ISO/IEC. Encoders conforming to \nthis Recommendation | International Standard shall not send reserved SEI messages until and unless the use of such \nmessages has been specified by ITU-T | ISO/IEC. Decoders that encounter reserved SEI messages shall discard their \ncontent without effect on the decoding process, except as specified in future Recommendations | International Standards \nspecified by ITU-T | ISO/IEC. \nreserved_sei_message_payload_byte is a byte reserved for future use by ITU-T | ISO/IEC. \n    Rec. ITU-T H.264 (06/2019)  415 \n \nAnnex E \n \nVideo usability information \n \n(This annex forms an integral part of this Recommendation | International Standard.) \nThis annex specifies syntax and semantics of the VUI parameters of the sequence parameter sets. \nVUI parameters are not required for constructing the luma or chroma samples by the decoding process. Conforming \ndecoders  are  not  required  to  process  this  information  for  output  order  conformance  to  this \nRecommendation | International Standard (see Annex C for the specification of conformance). Some VUI parameters are \nrequired to check bitstream conformance and for output timing decoder conformance. \nIn Annex E, specification for presence of VUI parameters is also satisfied when those parameters (or some subset of them) \nare conveyed to decoders (or to the HRD) by other means not specified by this Recommendation | International Standard. \nWhen present in the bitstream, VUI parameters shall follow the syntax and semantics specified in clauses 7.3.2.1 and \n7.4.2.1 and this annex. When the content of VUI parameters is conveyed for the application by some means other than \npresence within the bitstream, the representation of the content of the VUI parameters is not required to use the same syntax \nspecified in this annex. For the purpose of counting bits, only the appropriate bits that are actually present in the bitstream \nare counted. \nE.1  VUI syntax \nE.1.1  VUI parameters syntax \n \nvui_parameters( ) {  C  Descriptor \n  aspect_ratio_info_present_flag  0  u(1) \n  if( aspect_ratio_info_present_flag ) {     \n    aspect_ratio_idc  0  u(8) \n    if( aspect_ratio_idc  = =  Extended_SAR ) {     \n      sar_width  0  u(16) \n      sar_height  0  u(16) \n    }     \n  }     \n  overscan_info_present_flag  0  u(1) \n  if( overscan_info_present_flag )     \n    overscan_appropriate_flag  0  u(1) \n  video_signal_type_present_flag  0  u(1) \n  if( video_signal_type_present_flag ) {     \n    video_format  0  u(3) \n    video_full_range_flag  0  u(1) \n    colour_description_present_flag  0  u(1) \n    if( colour_description_present_flag ) {     \n      colour_primaries  0  u(8) \n      transfer_characteristics  0  u(8) \n      matrix_coefficients  0  u(8) \n    }     \n  }     \n  chroma_loc_info_present_flag  0  u(1) \n  if( chroma_loc_info_present_flag ) {     \n    chroma_sample_loc_type_top_field  0  ue(v) \n    chroma_sample_loc_type_bottom_field  0  ue(v) \n  }     \n416  Rec. ITU-T H.264 (06/2019) \n \n  timing_info_present_flag  0  u(1) \n  if( timing_info_present_flag ) {     \n    num_units_in_tick  0  u(32) \n    time_scale  0  u(32) \n    fixed_frame_rate_flag  0  u(1) \n  }     \n  nal_hrd_parameters_present_flag  0  u(1) \n  if( nal_hrd_parameters_present_flag )     \n    hrd_parameters( )  0   \n  vcl_hrd_parameters_present_flag  0  u(1) \n  if( vcl_hrd_parameters_present_flag )     \n    hrd_parameters( )  0   \n  if( nal_hrd_parameters_present_flag  | |  vcl_hrd_parameters_present_flag )     \n    low_delay_hrd_flag  0  u(1) \n  pic_struct_present_flag   0  u(1) \n  bitstream_restriction_flag  0  u(1) \n  if( bitstream_restriction_flag ) {     \n    motion_vectors_over_pic_boundaries_flag  0  u(1) \n    max_bytes_per_pic_denom  0  ue(v) \n    max_bits_per_mb_denom  0  ue(v) \n    log2_max_mv_length_horizontal  0  ue(v) \n    log2_max_mv_length_vertical  0  ue(v) \n    max_num_reorder_frames  0  ue(v) \n    max_dec_frame_buffering  0  ue(v) \n  }     \n}     \n \nE.1.2  HRD parameters syntax \n \nhrd_parameters( ) {  C  Descriptor \n  cpb_cnt_minus1  0 | 5  ue(v) \n  bit_rate_scale  0 | 5  u(4) \n  cpb_size_scale  0 | 5  u(4) \n  for( SchedSelIdx = 0; SchedSelIdx <= cpb_cnt_minus1; SchedSelIdx++ ) {     \n    bit_rate_value_minus1[ SchedSelIdx ]  0 | 5  ue(v) \n    cpb_size_value_minus1[ SchedSelIdx ]  0 | 5  ue(v) \n    cbr_flag[ SchedSelIdx ]  0 | 5  u(1) \n  }     \n  initial_cpb_removal_delay_length_minus1  0 | 5  u(5) \n  cpb_removal_delay_length_minus1  0 | 5  u(5) \n  dpb_output_delay_length_minus1  0 | 5  u(5) \n  time_offset_length  0 | 5  u(5) \n}     \n \n    Rec. ITU-T H.264 (06/2019)  417 \n \nE.2  VUI semantics \nE.2.1  VUI parameters semantics \naspect_ratio_info_present_flag equal to 1 specifies that aspect_ratio_idc is present. aspect_ratio_info_present_flag equal \nto 0 specifies that aspect_ratio_idc is not present. \naspect_ratio_idc specifies the value of the sample aspect ratio of the luma samples. Table E-1 shows the meaning of the \ncode. When aspect_ratio_idc indicates Extended_SAR, the sample aspect ratio is represented by sar_width : sar_height. \nWhen the aspect_ratio_idc syntax element is not present, aspect_ratio_idc value shall be inferred to be equal to 0. \nTable E-1 – Meaning of sample aspect ratio indicator \naspect_ratio_idc  Sample aspect  (informative) \nratio  Examples of use \n0  Unspecified   \n \n1  1:1  7680x4320 16:9 frame without horizontal overscan \n(\"square\")  3840x2160 16:9 frame without horizontal overscan \n1280x720 16:9 frame without horizontal overscan \n1920x1080 16:9 frame without horizontal overscan (cropped from \n1920x1088) \n640x480 4:3 frame without horizontal overscan \n2  12:11  720x576 4:3 frame with horizontal overscan \n352x288 4:3 frame without horizontal overscan \n3  10:11  720x480 4:3 frame with horizontal overscan \n352x240 4:3 frame without horizontal overscan \n4  16:11  720x576 16:9 frame with horizontal overscan \n528x576 4:3 frame without horizontal overscan \n5  40:33  720x480 16:9 frame with horizontal overscan \n528x480 4:3 frame without horizontal overscan \n6  24:11  352x576 4:3 frame without horizontal overscan \n480x576 16:9 frame with horizontal overscan \n7  20:11  352x480 4:3 frame without horizontal overscan \n480x480 16:9 frame with horizontal overscan \n8  32:11  352x576 16:9 frame without horizontal overscan \n9  80:33  352x480 16:9 frame without horizontal overscan \n10  18:11  480x576 4:3 frame with horizontal overscan \n11  15:11  480x480 4:3 frame with horizontal overscan \n12  64:33  528x576 16:9 frame without horizontal overscan \n13  160:99  528x480 16:9 frame without horizontal overscan \n14  4:3  1440x1080 16:9 frame without horizontal overscan \n15  3:2  1280x1080 16:9 frame without horizontal overscan \n16  2:1  960x1080 16:9 frame without horizontal overscan \n17..254  Reserved   \n255  Extended_SAR   \nNOTE 1 – For the examples in Table E-1, the term \"without horizontal overscan\" refers to display processes in which the display \narea matches the area of the cropped decoded pictures and the term \"with horizontal overscan\" refers to display processes in which \nsome parts near the left and/or right border of the cropped decoded pictures are not visible in the display area. As an example, the \nentry \"720x576 4:3 frame with horizontal overscan\" for aspect_ratio_idc equal to 2 refers to having an area of 704x576 luma samples \n(which has an aspect ratio of 4:3) of the cropped decoded frame (720x576 luma samples) that is visible in the display area. \nsar_width indicates the horizontal size of the sample aspect ratio (in arbitrary units). \nsar_height indicates the vertical size of the sample aspect ratio (in the same arbitrary units as sar_width). \nsar_width and sar_height shall be relatively prime or equal to 0. When aspect_ratio_idc is equal to 0 or sar_width is equal \nto 0  or  sar_height  is  equal  to 0,  the  sample  aspect  ratio shall  be  considered  unspecified  by  this  Recommendation  | \nInternational Standard. \noverscan_info_present_flag  equal  to 1  specifies  that  the  overscan_appropriate_flag  is  present.  When \noverscan_info_present_flag is equal to 0 or is not present, the preferred display method for the video signal is unspecified. \n418  Rec. ITU-T H.264 (06/2019) \n \noverscan_appropriate_flag equal to 1 indicates that the cropped decoded pictures output are suitable for display using \noverscan.  overscan_appropriate_flag  equal  to 0  indicates  that  the  cropped  decoded  pictures  output  contain  visually \nimportant information in the entire region out to the edges of the cropping rectangle of the picture, such that the cropped \ndecoded pictures output should not be displayed using overscan. Instead, they should be displayed using either an exact \nmatch between the display area and the cropping rectangle, or using underscan. As used in this paragraph, the term \n\"overscan\" refers to display processes in which some parts near the borders of the cropped decoded pictures are not visible \nin the display area. The term \"underscan\" describes display processes in which the entire cropped decoded pictures are \nvisible in the display area, but they do not cover the entire display area. For display processes that neither use overscan nor \nunderscan, the display area exactly matches the area of the cropped decoded pictures. \nNOTE 2 – For example, overscan_appropriate_flag equal to 1 might be used for entertainment television programming, or for a live \nview of people in a videoconference, and overscan_appropriate_flag equal to 0 might be used for computer screen capture or security \ncamera content. \nvideo_signal_type_present_flag  equal  to 1  specifies  that  video_format,  video_full_range_flag  and \ncolour_description_present_flag  are  present.  video_signal_type_present_flag  equal  to 0,  specify  that  video_format, \nvideo_full_range_flag and colour_description_present_flag are not present. \nvideo_format indicates the representation of the pictures as specified in Table E-2, before being coded in accordance with \nthis Recommendation | International Standard. When the video_format syntax element is not present, video_format value \nshall be inferred to be equal to 5. \nTable E-2 – Meaning of video_format \nvideo_format  Meaning \n0  Component \n1  PAL \n2  NTSC \n3  SECAM \n4  MAC \n5  Unspecified video format \n6  Reserved \n7  Reserved \n \nvideo_full_range_flag indicates the black level and range of the luma and chroma signals as derived from E′ , E′ , and \nY PB\nE′  or E′ , E′ , and E′  real-valued component signals. \nPR R G B\nWhen the video_full_range_flag syntax element is not present, the value of video_full_range_flag shall be inferred to be \nequal to 0. \ncolour_description_present_flag  equal  to 1  specifies  that  colour_primaries,  transfer_characteristics  and \nmatrix_coefficients  are  present.  colour_description_present_flag  equal  to 0  specifies  that  colour_primaries, \ntransfer_characteristics and matrix_coefficients are not present. \ncolour_primaries indicates the chromaticity coordinates of the source primaries as specified in Table E-3 in terms of the \nCIE 1931 definition of x and y as specified by ISO 11664-1. \nWhen the colour_primaries syntax element is not present, the value of colour_primaries shall be inferred to be equal to 2 \n(the chromaticity is unspecified or is determined by the application). \n    Rec. ITU-T H.264 (06/2019)  419 \n \nTable E-3 – Colour primaries interpretation using colour_primaries syntax element \n \nValue  Primaries  Informative remark \n0  Reserved  For future use by ITU-T | ISO/IEC \n1  primary  x  y  Rec. ITU-R BT.709-6 \ngreen  0.300  0.600  Rec. ITU-R BT.1361-0 conventional colour gamut \nsystem and extended colour gamut system (historical) \nblue  0.150  0.060 \nIEC 61966-2-1 sRGB or sYCC \nred  0.640  0.330 \nIEC 61966-2-4 \nwhite D65  0.3127  0.3290 \nSociety of Motion Picture and Television Engineers RP \n177 (1993) Annex B \n2  Unspecified  Image characteristics are unknown or are determined by \nthe application. \n3  Reserved  For future use by ITU-T | ISO/IEC \n4  primary  x  y  Rec. ITU-R BT.470-6 System M (historical) \ngreen  0.21  0.71  United States National Television System Committee \n1953 Recommendation for transmission standards for \nblue  0.14  0.08 \ncolour television \nred  0.67  0.33 \nUnited States Federal Communications Commission \nwhite C  0.310  0.316 \nTitle 47 Code of Federal Regulations (2003) 73.682 (a) \n(20) \n5  primary  x  y  Rec. ITU-R BT.470-6 System B, G (historical) \ngreen  0.29  0.60  Rec. ITU-R BT.601-7 625 \nblue  0.15  0.06  Rec. ITU-R BT.1358-0 625 (historical) \nred  0.64  0.33  Rec. ITU-R BT.1700-0 625 PAL and 625 SECAM \nwhite D65  0.3127  0.3290 \n6  primary  x  y  Rec. ITU-R BT.601-7 525 \ngreen  0.310  0.595  Rec. ITU-R BT.1358-1 525 or 625 (historical) \nblue  0.155  0.070  Rec. ITU-R BT.1700-0 NTSC \nred  0.630  0.340  Society of Motion Picture and Television Engineers \n170M (2004) \nwhite D65  0.3127  0.3290 \n(functionally the same as the value 7) \n7  primary  x  y  Society of Motion Picture and Television Engineers \n240M (1999, historical) \ngreen  0.310  0.595 \n(functionally the same as the value 6) \nblue  0.155  0.070 \nred  0.630  0.340 \nwhite D65  0.3127  0.3290 \n8  primary  x  y  Generic film (colour filters using Illuminant C) \ngreen  0.243  0.692 (Wratten 58) \nblue  0.145  0.049 (Wratten 47) \nred  0.681  0.319 (Wratten 25) \nwhite C  0.310  0.316 \n9  primary  x  y  Rec. ITU-R BT.2020-2 \ngreen  0.170  0.797  Rec. ITU-R BT.2100-2 \nblue  0.131  0.046 \nred  0.708  0.292 \nwhite D65  0.3127  0.3290 \n10  primary  x  y  Society of Motion Picture and Television Engineers ST \n428-1 (2006) \nY  0.0  1.0 \n(CIE 1931 XYZ as in ISO 11664-1) \nZ  0.0  0.0 \nX  1.0  0.0 \ncentre white  1 ÷ 3  1 ÷ 3 \n11  primary  x  y  Society of Motion Picture and Television Engineers RP \ngreen  0.265  0.690  431-2 (2011) \nblue  0.150  0.060  Society of Motion Picture and Television Engineers RP \nST 2113 (2019) \"P3DCI\" \nred  0.680  0.320 \nwhite  0.314  0.351 \n420  Rec. ITU-T H.264 (06/2019) \n \n12  primary  x  y  Society of Motion Picture and Television Engineers EG \n432-1 (2010) \ngreen  0.265  0.690 \nblue  0.150  0.060  Society of Motion Picture and Television Engineers ST \n2113 (2019) \"P3D65\" \nred  0.680  0.320 \nwhite D65  0.3127  0.3290 \n13..21  Reserved  For future use by ITU-T | ISO/IEC \n22  primary  x  y  EBU Tech. 3213-E (1975) \ngreen  0.295  0.605 \nblue  0.155  0.077 \nred  0.630  0.340 \nwhite D65  0.3127  0.3290 \n23..255  Reserved  For future use by ITU-T | ISO/IEC \n \ntransfer_characteristics, as specified in Table E-4, either indicates the reference opto-electronic transfer characteristic \nfunction of the source picture as a function of a source input linear optical intensity input L  with a nominal real-valued \nc\nrange of 0 to 1 or indicates the inverse of the reference electro-optical transfer characteristic function as a function of an \noutput linear optical intensity L  with a nominal real-valued range of 0 to 1. For interpretation of entries in Table E-4 that \no\nare expressed in terms of multiple curve segments parameterized by the variable  over a region bounded by the variable \n or by the variables  and , the values of  and  are defined to be the positive constants necessary for the curve segments \nthat meet at the value  to have continuity of both value and slope at the value . The value of , when applicable, is defined \nto  be  the  positive  constant  necessary  for  the  associated  curve  segments  to  meet  at  the  value  .  For  example,  for \ntransfer_characteristics equal to 1, 6, 11, 14, or 15,  has the value 1 + 5.5 *  = 1.099 296 826 809 442... and  has the \nvalue 0.018 053 968 510 807.... \nWhen video_full_range_flag is equal to 1 and either or both of the following conditions apply, transfer_characteristics \nshall not be equal to 16 or 18: \n–  BitDepth  is less than 10. \nY\n–  chroma_format_idc is not equal to 0 (monochrome) and BitDepth  is less than 10. \nC\nWhen the transfer_characteristics syntax element is not present, the value of transfer_characteristics shall be inferred to be \nequal  to  2  (the  transfer  characteristics  are  unspecified  or  are  determined  by  the  application).  Values  of \ntransfer_characteristics that are identified as reserved in Table E-4 are reserved for future use by ITU-T | ISO/IEC and \nshall not be present in bitstreams conforming to this version of this Specification. Decoders shall interpret reserved values \nof transfer_characteristics as equivalent to the value 2. \nNOTE 3 – As indicated in Table E-4, some values of transfer_characteristics are defined in terms of a reference opto-electronic \ntransfer characteristic  function and others are defined in terms of a reference electro-optical transfer characteristic function, \naccording to the convention that has been applied in other Specifications. In the cases of Rec. ITU-R BT.709-6 and Rec. ITU-R \nBT.2020-2 (which may be indicated by transfer_characteristics equal to 1, 6, 14, or 15), although the value is defined in terms of a \nreference opto-electronic transfer characteristic function, a suggested corresponding reference electro-optical transfer characteristic \nfunction for flat panel displays used in HDTV studio production has been specified in Rec. ITU-R BT.1886-0. \nTable E-4 – Transfer characteristics interpretation using transfer_characteristics syntax element \n \nValue  Transfer characteristic  Informative remark \n0  Reserved  For future use by ITU-T | ISO/IEC \n0.45\n1  V =  * L  − (  − 1 )  for 1 >= L  >=   Rec. ITU-R BT.709-6 \nc c\nV = 4.500 * L   for  > L  >= 0  Rec. ITU-R BT.1361-0 conventional \nc c\ncolour gamut system (historical) \n(functionally the same as the value 6, \n14, and 15) \n2  Unspecified  Image characteristics are unknown or \nare determined by the application. \n3  Reserved  For future use by ITU-T | ISO/IEC \n    Rec. ITU-T H.264 (06/2019)  421 \n \n4  Assumed display gamma 2.2  Rec. ITU-R BT.470-6 System M \n(historical) \nUnited States National Television \nSystem Committee 1953 \nRecommendation for transmission \nstandards for colour television \nUnited States Federal \nCommunications Commission Title 47 \nCode of Federal Regulations (2003) \n73.682 (a) (20) \nRec. ITU-R BT.1700-0 625 PAL and \n625 SECAM \n5  Assumed display gamma 2.8  Rec. ITU-R BT.470-6 System B, G \n(historical) \n0.45\n6  V =  * L  − (  − 1 )  for 1 >= L  >=   Rec. ITU-R BT.601-7 525 or 625 \nc c\nV = 4.500 * L   for  > L  >= 0  Rec. ITU-R BT.1358-1 525 or 625 \nc c\n(historical) \nRec. ITU-R BT.1700-0 NTSC \nSociety of Motion Picture and \nTelevision Engineers 170M (2004) \n(functionally the same as the value 1) \n0.45\n7  V =  * L  − (  − 1 )  for 1 >= L  >=   Society of Motion Picture and \nc c\nTelevision Engineers 240M (1999, \nV = 4.0 * L   for  > L  >= 0 \nc c\nhistorical) \n8  V = L   for 1 > L  >= 0  Linear transfer characteristics \nc c\n9  V = 1.0 + Log10( L  ) ÷ 2   for 1 >= L  >= 0.01  Logarithmic transfer characteristic \nc c\n(100:1 range) \nV = 0.0  for 0.01 > L  >= 0 \nc\n10  V = 1.0 + Log10( L  ) ÷ 2.5   for 1 >= L  >= Sqrt( 10 ) ÷ 1000  Logarithmic transfer characteristic \nc c\n(100 * Sqrt( 10 ) : 1 range) \nV = 0.0  for Sqrt( 10 ) ÷ 1000 > L  >= 0 \nc\n0.45\n11  V =  * L  − (  − 1 )  for L  >=   IEC 61966-2-4 \nc c\nV = 4.500 * L   for   > L  > − \nc c\n0.45\nV = − * ( −L  )  + (  − 1 )  for − >= L  \nc c\n0.45\n12  V =  * L  − (  − 1 )  for 1.33  >  L   >=    Rec. ITU-R BT.1361-0 extended \nc c\ncolour gamut system (historical)  \nV = 4.500 * L   for   > L  >= − \nc c\n0.45\nV = −(  * ( −4 * L  )  − (  − 1 ) ) ÷ 4  for −  >=  L   >=  −0.25 \nc c\n( 1÷2.4 )\n13  V =  * L  − (  − 1 )  for 1  >  L   >=    IEC 61966-2-1 sRGB or sYCC \nc c\nV = 12.92 * L   for   >  L   >=  0   \nc c\n0.45 \n14  V =  * L − (  − 1 )  for 1 >= L  >=   Rec. ITU-R BT.2020-2 (10 bit system) \nc c\n(functionally the same as the values 1, \nV = 4.500 * L   for  > L  >= 0 \nc c\n6, and 15) \n0.45 \n15  V =  * L − (  − 1 )  for 1 >= L  >=   Rec. ITU-R BT.2020-2 (12 bit system) \nc c\n(functionally the same as the values 1, \nV = 4.500 * L   for  > L  >= 0 \nc c\n6, and 15) \nn n m\n16  V = ( ( c  + c  * L  ) ÷ ( 1 + c  * L  ) )   for all values of L   Society of Motion Picture and \n1 2 o 3 o o\nTelevision Engineers ST 2084 for 10, \nc  = c  − c  + 1 = 107 ÷ 128 = 0.8359375 \n1 3 2\n12, 14, and 16-bit systems (2014) \nc  = 2413 ÷ 128 = 18.8515625 \n2\nRec. ITU-R BT.2100-2 perceptual \nc 3  = 2392 ÷ 128 = 18.6875  quantization (PQ) system \nm = 2523 ÷ 32 = 78.84375 \nn = 653 ÷ 4096 = 0.1593017578125 \nfor which L  equal to 1 for peak white is ordinarily intended to correspond to a \no\nreference output luminance level of 10 000 candelas per square metre \n( 1 ÷ 2.6 )\n17  V = ( 48 * L  ÷ 52.37 )      for all values of L   Society of Motion Picture and \no o\nTelevision Engineers ST 428-1 (2006) \nfor which L  equal to 1 for peak white is ordinarily intended to correspond to a \no\nreference output luminance level of 48 candelas per square metre \n422  Rec. ITU-T H.264 (06/2019) \n \n18  V = a * Ln( 12 * L  − b ) + c  for 1  >=  L  > 1 ÷ 12  Association of Radio Industries and \nc c\n0.5 Businesses (ARIB) STD-B67 \nV = Sqrt( 3 ) * L   for 1 ÷ 12  >=  L   >=  0 \nc c\nRec. ITU-R BT.2100-2 hybrid log-\na = 0.17883277 \ngamma (HLG) system \nb = 0.28466892 \nc = 0.55991073 \n19..255  Reserved  For future use by ITU-T | ISO/IEC \n \n \nNOTE 4 – For transfer_characteristics equal to 18, the equations given in Table E-4 are normalized for a source input linear optical \nintensity L  with a nominal real-valued range of 0 to 1. An alternative scaling that is mathematically equivalent is used in ARIB \nc\nSTD-B67 with the source input linear optical intensity having a nominal real-valued range of 0 to 12. \nmatrix_coefficients describes the matrix coefficients used in deriving luma and chroma signals from the green, blue, and \nred, or Y, Z, and X primaries, as specified in Table E-5. \nmatrix_coefficients shall not be equal to 0 unless both of the following conditions are true: \n–  BitDepth  is equal to BitDepth , \nC Y\n–  chroma_format_idc is equal to 3 (4:4:4). \nThe specification of the use of matrix_coefficients equal to 0 under all other conditions is reserved for future use by \nITU-T | ISO/IEC. \nmatrix_coefficients shall not be equal to 8 unless one of the following conditions is true: \n–  BitDepth  is equal to BitDepth , \nC Y\n–  BitDepth  is equal to BitDepth  + 1 and chroma_format_idc is equal to 3 (4:4:4). \nC Y\nThe specification of the use of matrix_coefficients equal to 8 under all other conditions is reserved for future use by \nITU-T | ISO/IEC. \nWhen the matrix_coefficients syntax element is not present, the value of matrix_coefficients is inferred to be equal to 2 \n(unspecified). \nThe interpretation of matrix_coefficients, together with colour_primaries and transfer_characteristics, is specified by the \nequations below. \nNOTE 5 – For purposes of YZX representation when matrix_coefficients is equal to 0, the symbols R, G, and B would be substituted \nfor X, Y, and Z, respectively, in the following descriptions of Equations E-1 to E-3, E-13 to E-15, E-19 to E-21, E-28 to E-30, and \nE-31 to E-33. \nE , E , and E  are defined as \"linear-domain\" real-valued signals based on the indicated colour primaries before application \nR G B\nof the transfer characteristics function. \nNominal white is specified as having E  equal to 1, E  equal to 1, and E  equal to 1. \nR G B\nNominal black is specified as having E  equal to 0, E  equal to 0, and E  equal to 0. \nR G B\nThe application of the transfer characteristics function is denoted by ( x )′ for an argument x. \n–  If matrix_coefficients is not equal to 14, the signals E′ , E′ , and E′  are determined by application of the transfer \nR G B\ncharacteristics function as follows: \nE′  = ( E  )′    (E-1) \nR R\nE′  = ( E  )′    (E-2) \nG G\nE′  = ( E  )′    (E-3) \nB B\nIn this case, the range of E′ , E′ , and E′  is specified as follows: \nR G B\n–  If transfer_characteristics is not equal to 11 or 12, E′ , E′ , and E′  are real numbers with values in the range of \nR G B\n0 to 1. \n–  Otherwise (transfer_characteristics is equal to 11 (IEC 61966-2-4) or 12 (Rec. ITU-R BT.1361-0 extended colour \ngamut system)), E′ , E′  and E′  are real numbers with a larger range not specified in this Specification. \nR G B\n–  Otherwise (matrix_coefficients is equal to 14), the \"linear-domain\" real-valued signals E , E , and E  are determined \nL M S\nas follows: \n    Rec. ITU-T H.264 (06/2019)  423 \n \nE  = ( 1688 * E  + 2146 * E  + 262 * E  ) ÷ 4096        (E-4) \nL R G B\nE  = ( 683 * E  + 2951 * E  + 462 * E  ) ÷ 4096        (E-5) \nM R G B\nE  = ( 99 * E  + 309 * E  + 3688 * E  ) ÷ 4096        (E-6) \nS R G B\nIn this case, the signals E′ , E′ , and E′  are determined by application of the transfer characteristics function as \nL M S\nfollows: \nE′  = ( E  )′    (E-7) \nL L\nE′  = ( E  )′    (E-8) \nM M\nE′  = ( E  )′    (E-9) \nS S\nThe interpretation of matrix_coefficients is specified as follows: \n–  If video_full_range_flag is equal to 0, the following applies: \n–  If matrix_coefficients is equal to 1, 4, 5, 6, 7, 9, 10, 11, 12, 13, or 14, the following equations apply: \nY = Clip1 ( Round( ( 1 << ( BitDepth  − 8 ) ) * ( 219 * E′  + 16 ) ) )  (E-10) \nY Y Y\nCb = Clip1 ( Round( ( 1 << ( BitDepth  − 8 ) ) * ( 224 * E′  + 128 ) ) )  (E-11) \nC C PB\nCr = Clip1 ( Round( ( 1 << ( BitDepth  − 8 ) ) * ( 224 * E′  + 128 ) ) )  (E-12) \nC C PR\n–  Otherwise, if matrix_coefficients is equal to 0 or 8, the following equations apply: \nR = Clip1 ( ( 1 << ( BitDepth  − 8 ) ) * ( 219 * E′  + 16 ) )  (E-13) \nY Y R\nG = Clip1 ( ( 1 << ( BitDepth  − 8 ) ) * ( 219 * E′  + 16 ) )  (E-14) \nY Y G\nB = Clip1 ( ( 1 << ( BitDepth  − 8 ) ) * ( 219 * E′  + 16 ) )  (E-15) \nY Y B\n–  Otherwise, if matrix_coefficients is equal to 2, the interpretation of the matrix_coefficients syntax element is \nunknown or is determined by the application. \n–  Otherwise (matrix_coefficients is not equal to 0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, or 14), the interpretation of \nthe matrix_coefficients syntax element is reserved for future definition by ITU-T | ISO/IEC. \n–  Otherwise (video_full_range_flag is equal to 1), the following applies: \n–  If matrix_coefficients is equal to 1, 4, 5, 6, 7, 9, 10, 11, 12, 13, or 14, the following equations apply: \nY = Clip1 ( Round( ( ( 1 << BitDepth  ) − 1 ) * E′  ) )  (E-16) \nY Y Y\nCb = Clip1 ( Round( ( ( 1 << BitDepth  ) − 1 )  * E′  + ( 1 << ( BitDepth  − 1 ) ) ) )  (E-17) \nC C PB C\nCr = Clip1 ( Round( ( ( 1 << BitDepth  ) − 1 )  * E′  + ( 1 << ( BitDepth  − 1 ) ) ) )  (E-18) \nC C PR C\n–  Otherwise, if matrix_coefficients is equal to 0 or 8, the following equations apply: \nR = Clip1 ( ( ( 1 << BitDepth  ) − 1 ) * E′  )    (E-19) \nY Y R\nG = Clip1 ( ( ( 1 << BitDepth  ) − 1 ) * E′  )    (E-20) \nY Y G\nB = Clip1 ( ( ( 1 << BitDepth  ) − 1 ) * E′  )    (E-21) \nY Y B\n–  Otherwise, if matrix_coefficients is equal to 2, the interpretation of the matrix_coefficients syntax element is \nunknown or is determined by the application. \n–  Otherwise (matrix_coefficients is not equal to 0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, or 14), the interpretation of \nthe matrix_coefficients syntax element is reserved for future definition by ITU-T | ISO/IEC. \nReserved values for matrix_coefficients shall not be present in bitstreams conforming to this version of this Specification. \nDecoders shall interpret reserved values of matrix_coefficients as equivalent to the value 2. \n424  Rec. ITU-T H.264 (06/2019) \n \nIt is a requirement of bitstream conformance to this version of this Specification that when colour_primaries is not equal \nto 1, 4, 5, 6, 7, 8, 9, 10, 11, 12, or 22, matrix_coefficients shall not be equal to 12 or 13. \nWhen matrix_coefficients is equal to 1, 4, 5, 6, 7, 9, 10, 11, 12, or 13, the constants K  and K  are specified as follows: \nR B\n–  If matrix_coefficients is not equal to 12 or 13, the constants K  and K  are specified in Table E-5. \nR B\n–  Otherwise (matrix_coefficients is equal to 12 or 13), the constants K  and K  are computed as follows, using the \nR B\nchromaticity coordinates (x , y ), (x , y ), (x , y ), and (x , y ) specified by Table E-3 for the colour_primaries \nR R G G B B W W\nsyntax element for the red, green, blue, and white colour primaries, respectively: \ny *(x *(y *z y *z ) y *(x *z x *z )z *(x *y x *y ))\nK  =  R W G B B G W B G G B W G B B G   (E-22) \nR\ny *(x *(y *z y *z )x *(y *z y *z )x *(y *z y *z ))\nW R G B B G G B R R B B R G G R\ny *(x *(y *z y *z ) y *(x *z x *z )z *(x *y x *y ))\nK  =  B W R G G R W G R R G W R G G R   (E-23) \nB\ny *(x *(y *z y *z )x *(y *z y *z )x *(y *z y *z ))\nW R G B B G G B R R B B R G G R\n  where the values of z , z , z , and z , are given by. \nR G B W\nz  = 1 − ( x  + y  )    (E-24) \nR R R\nz  = 1 − ( x  + y  )    (E-25) \nG G G\nz  = 1 − ( x  + y  )    (E-26) \nB B B\nz  = 1 − ( x  + y  )    (E-27) \nW W W\nThe variables E′ , E′ , and E′  (for matrix_coefficients not equal to 0 or 8) or Y, Cb, and Cr (for matrix_coefficients \nY PB PR\nequal to 0 or 8) are specified as follows: \n–  If matrix_coefficients is not equal to 0, 8, 10, 11, 13, or 14, the following equations apply: \nE′  = K  * E′  + ( 1 − K  − K  ) * E′  + K  * E′  \nY R R R B G B B\n  (E-28) \nE′  = 0.5 * ( E′  − E′  ) ÷ ( 1 − K  )    (E-29) \nPB B Y B\nE′  = 0.5 * ( E′  − E′  ) ÷ ( 1 − K  )    (E-30) \nPR R Y R\nE′  is a real number with the value 0 associated with nominal black and the value 1 associated with nominal white. \nY\nE′  and E′  are real numbers with the value 0 associated with both nominal black and nominal white. When \nPB PR\ntransfer_characteristics is not equal to 11 or 12, E′  is a real number with values in the range of 0 to 1. When \nY\ntransfer_characteristics is not equal to 11 or 12, E′  and E′  are real numbers with values in the range of −0.5 to 0.5. \nPB PR\nWhen transfer_characteristics is equal to 11, or 12, E′ , E′  and E′  are real numbers with a larger range not specified \nY PB PR\nin this Specification. \n–  Otherwise, if matrix_coefficients is equal to 0, the following equations apply: \nY   = Round( G )    (E-31) \nCb = Round( B )    (E-32) \nCr = Round( R )    (E-33) \n–  Otherwise, if matrix_coefficients is equal to 8, the following applies: \n–  If BitDepth  is equal to BitDepth , the following equations apply: \nC Y\nY   = Round( 0.5 * G + 0.25 * ( R + B ) )    (E-34) \nCb = Round( 0.5 * G − 0.25 * ( R + B ) ) + ( 1 << ( BitDepth  − 1 ) )  (E-35) \nC\nCr = Round( 0.5 * ( R − B ) ) + ( 1 << ( BitDepth  − 1 ) )  (E-36) \nC\n    Rec. ITU-T H.264 (06/2019)  425 \n \nNOTE 6 – In this case, for purposes of the YCgCo nomenclature used in Table E-5, Cb and Cr of Equations E-35 and E-36 \nwould be referred to as Cg and Co, respectively. An appropriate inverse conversion for Equations E-34 to E-36 is as follows: \nt   = Y − ( Cb − ( 1 << ( BitDepth  − 1 ) ) )    (E-37) \nC\nG = Clip1 ( Y + ( Cb − ( 1 << ( BitDepth  − 1 ) ) ) )  (E-38) \nY C\nB = Clip1 ( t − ( Cr − ( 1 << ( BitDepth  − 1 ) ) ) )   (E-39) \nY C\nR = Clip1 ( t + ( Cr − ( 1 << ( BitDepth  − 1 ) ) ) )   (E-40) \nY C\n–  Otherwise (BitDepth  is not equal to BitDepth ), the following equations apply: \nC Y\nCr = Round( R ) − Round( B ) + ( 1 << ( BitDepth  − 1 ) )  (E-41) \nC\nt = Round( B ) + ( ( Cr − ( 1 << ( BitDepth  − 1 ) ) ) >> 1 )  (E-42) \nC\nCb = Round( G ) − t + ( 1 << ( BitDepth  − 1 ) )  (E-43) \nC\nY = t + ( ( Cb − ( 1 << ( BitDepth  − 1 ) ) ) >> 1 )  (E-44) \nC\nNOTE 7 – In this case, for purposes of the YCgCo nomenclature used in Table E-5, Cb and Cr of Equations E-43 and E-41 \nwould be referred to as Cg and Co, respectively. An appropriate inverse conversion for Equations E-41 to E-44 is as follows: \nt   = Y − ( ( Cb − ( 1 << ( BitDepth  − 1 ) ) ) >> 1 )  (E-45) \nC\nG = Clip1 ( t + ( Cb − ( 1 << ( BitDepth  − 1 ) ) ) )  (E-46) \nY C\nB = Clip1 ( t − ( ( Cr − ( 1 << ( BitDepth  − 1 ) ) ) >> 1 ) )  (E-47) \nY C\nR = Clip1 ( B + ( Cr − ( 1 << ( BitDepth  − 1 ) ) ) )  (E-48) \nY C\n–  Otherwise, if matrix_coefficients is equal to 10 or 13, the signal E′  is determined by application of the transfer \nY\ncharacteristics function as follows: \nE  = K  * E  + ( 1 − K  − K  ) * E  + K  * E     (E-49) \nY R R R B G B B\nE′  = ( E  )′     (E-50) \nY Y\n  In this case, E  is defined from the \"linear-domain\" signals for E , E , and E , prior to application of the transfer \nY R G B\ncharacteristics function, which is then applied to produce the signal E′ . E  and E′  are real values with the value 0 \nY Y Y\nassociated with nominal black and the value 1 associated with nominal white. \n  In this case, the signals E′  and E′  are determined as follows: \nPB PR\nE′  = ( E′  − E′  ) ÷ ( 2 * N  )      for −N   <=  E′  − E′   <=  0  (E-51) \nPB B Y B B B Y\nE′  = ( E′  − E′  ) ÷ ( 2 * P  )      for 0  <  E′  − E′   <= P   (E-52) \nPB B Y B B Y B\nE′  = ( E′  − E′  ) ÷ ( 2 * N  )      for −N   <=  E′  − E′   <=  0  (E-53) \nPR R Y R R R Y\nE′  = ( E′  − E′  ) ÷ ( 2 * P  )      for 0  <  E′  − E′   <=  P   (E-54) \nPR R Y R R Y R\n  where the constants N , P , N , and P  are determined by application of the transfer characteristics function to \nB B R R\nexpressions involving the constants K  and K  as follows: \nB R\nN  = ( 1 − K  )′    (E-55) \nB B\nP  = 1 − ( K  )′     (E-56) \nB B\nN  = ( 1 − K  )′    (E-57) \nR R\nP  = 1 − ( K  )′      (E-58) \nR R\n–  Otherwise, if matrix_coefficients is equal to 11, the following equations apply: \nE′  = E′     (E-59) \nY G\nE′  = ( 0.986566 * E′  − E′  ) ÷ 2     (E-60) \nPB B Y\nE′  = ( E′  − 0.991902 * E′  ) ÷ 2    (E-61) \nPR R Y\nNOTE 8 – In this case, for purposes of the Y′D′ D′  nomenclature used in Table E-5, E′  and E′  of Equations E-60 and E-61 \nZ X PB PR\nwould be referred to as D′  and D′ , respectively. \nZ X\n426  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (matrix_coefficients is equal to 14), the following applies: \n–  If transfer_characteristics is not equal to 18, the following equations apply: \nE′  = 0.5 * ( E′  + E′  )              (E-62) \nY L M\nE′  = ( 6610 * E′  − 13613 * E′  + 7003 * E′  ) ÷ 4096  (E-63) \nPB L M S\nE′  = ( 17933 * E′  − 17390 * E′  − 543 * E′  ) ÷ 4096  (E-64) \nPR L M S\n–  Otherwise, the following equations apply: \nE′  = 0.5 * ( E′  + E′  )              (E-65) \nY L M\nE′  = ( 3625 * E′  − 7465 * E′  + 3840 * E′  ) ÷ 4096  (E-66) \nPB L M S\nE′  = ( 9500 * E′  − 9212 * E′  − 288 * E′  ) ÷ 4096  (E-67) \nPR L M S\nNOTE 9 – In this case, for purposes of the IC C  nomenclature used in Table E-5, E′ , E′ , and E′  of Equations E-62, E-63 and \nT P Y PB PR\nE-64 may be referred to as I, C , and C , respectively. Equations E-62 through E-64 were designed specifically for use with \nT P\ntransfer_characteristics  equal  to  16  (PQ),  and  Equations  E-65  through  E-67  were  designed  specifically  for  use  with \ntransfer_characteristics equal to 18 (HLG). \n    Rec. ITU-T H.264 (06/2019)  427 \n \nTable E-5 – Matrix coefficients interpretation using matrix_coefficients syntax element \n \nValue  Matrix  Informative remark \n0  GBR  The identity matrix. \nTypically used for GBR (often referred to as RGB); however, may also be \nused for YZX (often referred to as XYZ) \nIEC 61966-2-1 (sRGB) \nSociety of Motion Picture and Television Engineers ST 428-1 XYZ (2006) \nSee Equations E-1 to E-3 \n1  K  = 0.2126; K  = 0.0722  Rec. ITU-R BT.709-6 \nR B\nRec. ITU-R BT.1361-0 conventional colour gamut system and extended \ncolour gamut system (historical) \nIEC 61966-2-1 (sYCC) \nIEC 61966-2-4 xvYCC  \n709\nSociety of Motion Picture and Television Engineers RP 177 (1993) \nAnnex B \nSee Equations E-28 to E-30 \n2  Unspecified  Image characteristics are unknown or are determined by the application. \n3  Reserved  For future use by ITU-T | ISO/IEC \n4  K  = 0.30;   K  = 0.11  United States Federal Communications Commission Title 47 Code of \nR B\nFederal Regulations (2003) 73.682 (a) (20) \nSee Equations E-28 to E-30 \n5  K  = 0.299; K  = 0.114  Rec. ITU-R BT.470-6 System B, G (historical) \nR B\nRec. ITU-R BT.601-7 625 \nRec. ITU-R BT.1358-0 625 (historical) \nRec. ITU-R BT.1700-0 625 PAL and 625 SECAM \nIEC 61966-2-4 xvYCC  \n601\n(functionally the same as the value 6) \nSee Equations E-28 to E-30 \n6  K  = 0.299; K  = 0.114  Rec. ITU-R BT.601-7 525 \nR B\nRec. ITU-R BT.1358-1 525 or 625 \nRec. ITU-R BT.1700-0 NTSC \nSociety of Motion Picture and Television Engineers 170M (2004) \n(functionally the same as the value 5) \nSee Equations E-28 to E-30 \n7  K  = 0.212; K  = 0.087  Society of Motion Picture and Television Engineers 240M (1999, historical) \nR B\nSee Equations E-28 to E-30 \n8  YCgCo  See Equations E-34 to E-48 \n9  K  = 0.2627; K  = 0.0593  Rec. ITU-R BT.2020-2 non-constant luminance system \nR B\nRec. ITU-R BT.2100-2 Y′CbCr \nSee Equations E-28 to E-30 \n10  K  = 0.2627; K  = 0.0593  Rec. ITU-R BT.2020-2 constant luminance system \nR B\nSee Equations E-49 to E-58 \n11  Y′D′ D′   Society of Motion Picture and Television Engineers ST 2085 (2015) \nZ X\nSee Equations E-59 to E-61 \n12  See Equations E-22 to E-27.  Chromaticity-derived non-constant luminance system \nSee Equations E-28 to E-30. \n13  See Equations E-22 to E-27.  Chromaticity-derived constant luminance system \nSee Equations E-49 to E-58. \n14  IC C   Rec. ITU-R BT.2100-2 IC C\nT P T P \nSee Equations E-62 to E-64. for transfer_characteristics value 16 (PQ) \nSee Equations E-65 to E-67 for transfer_characteristics value 18 (HLG) \n15..255  Reserved  For future use by ITU-T | ISO/IEC \n \n428  Rec. ITU-T H.264 (06/2019) \n \nchroma_loc_info_present_flag  equal  to  1  specifies  that  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field  are  present.  chroma_loc_info_present_flag  equal  to 0  specifies  that \nchroma_sample_loc_type_top_field and chroma_sample_loc_type_bottom_field are not present. \nWhen chroma_format_idc is not equal to 1, chroma_loc_info_present_flag should be equal to 0. \nchroma_sample_loc_type_top_field  and  chroma_sample_loc_type_bottom_field  specify  the  location  of  chroma \nsamples as follows: \n–  If  chroma_format_idc  is  equal  to  1  (4:2:0  chroma  format),  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field specify the location of chroma samples for the top field and the bottom field, \nrespectively, as shown in Figure E-1. \n–  Otherwise  (chroma_format_idc  is  not  equal  to  1),  the  values  of  the  syntax  elements \nchroma_sample_loc_type_top_field  and  chroma_sample_loc_type_bottom_field  shall  be  ignored.  When \nchroma_format_idc is equal to 2 (4:2:2 chroma format) or 3 (4:4:4 chroma format), the location of chroma samples \nis specified in clause 6.2. When chroma_format_idc is equal to 0, there is no chroma sample array. \nThe value of chroma_sample_loc_type_top_field and chroma_sample_loc_type_bottom_field shall be in the range of 0 \nto 5, inclusive. When the chroma_sample_loc_type_top_field and chroma_sample_loc_type_bottom_field are not present, \nthe values of chroma_sample_loc_type_top_field and chroma_sample_loc_type_bottom_field shall be inferred to be equal \nto 0. \nNOTE 10  –  When  coding  progressive-scan  source  material,  the  syntax  elements  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field should have the same value. \n    Rec. ITU-T H.264 (06/2019)  429 \n \nH.264(09)_FE-1\nInterpretation of symbols\nLuma sample position indications:\nLuma sample top field Luma sample bottom field\nChroma sample position indications, where grey fill indicates a bottom field\nsample type and no fill indicates a top field sample type:\nChroma sample type 2 Chroma sample type 3\nChroma sample type 0 Chroma sample type 1\nChroma sample type 4 Chroma sample type 5\n \nFigure E-1 – Location of chroma samples for top and bottom fields for chroma_format_idc equal to 1 (4:2:0 \nchroma format) as a function of chroma_sample_loc_type_top_field and chroma_sample_loc_type_bottom_field \ntiming_info_present_flag equal to 1 specifies that num_units_in_tick, time_scale and fixed_frame_rate_flag are present \nin  the  bitstream.  timing_info_present_flag  equal  to 0  specifies  that  num_units_in_tick,  time_scale  and \nfixed_frame_rate_flag are not present in the bitstream. \nnum_units_in_tick is the number of time units of a clock operating at the frequency time_scale Hz that corresponds to \none increment (called a clock tick) of a clock tick counter. num_units_in_tick shall be greater than 0. A clock tick is the \nminimum interval of time that can be represented in the coded data. For example, when the frame rate of a video signal is \n30 000 ÷ 1001 Hz, time_scale may be equal to 60 000 and num_units_in_tick may be equal to 1001. See Equation C-1. \ntime_scale is the number of time units that pass in one second. For example, a time coordinate system that measures time \nusing a 27 MHz clock has a time_scale of 27 000 000. time_scale shall be greater than 0. \nfixed_frame_rate_flag  equal  to 1  indicates  that  the  temporal  distance  between  the  HRD  output  times  of  any  two \nconsecutive pictures in output order is constrained as follows. fixed_frame_rate_flag equal to 0 indicates that no such \nconstraints apply to the temporal distance between the HRD output times of any two consecutive pictures in output order. \nWhen fixed_frame_rate_flag is not present, it shall be inferred to be equal to 0. \nFor each picture n where n indicates the n-th picture (in output order) that is output and picture n is not the last picture in \nthe bitstream (in output order) that is output, the value of t ( n ) is specified by \nfi,dpb\nt ( n )  =  t ( n ) ÷ DeltaTfiDivisor  (E-50) \nfi,dpb o,dpb\n430  Rec. ITU-T H.264 (06/2019) \n \nwhere t ( n ) is specified in Equation C-13 and DeltaTfiDivisor is specified by Table E-6 based on the value of \no,dpb\npic_struct_present_flag, field_pic_flag, and pic_struct for the coded video sequence containing picture n. Entries marked \n\"-\" in Table E-6 indicate a lack of dependence of DeltaTfiDivisor on the corresponding syntax element. \nWhen fixed_frame_rate_flag is equal to 1 for a coded video sequence containing picture n, the value computed for \nt ( n ) shall be equal to t  as specified in Equation C-1 (using the value of t  for the coded video sequence containing \nfi,dpb c c\npicture n) when either or both of the following conditions are true for the following picture n  that is specified for use in \nn\nEquation C-13: \n–  picture n  is in the same coded video sequence as picture n. \nn\n–  picture n  is in a different coded video sequence and fixed_frame_rate_flag is equal to 1 in the coded video sequence \nn\ncontaining picture n  and the value of num_units_in_tick ÷ time_scale is the same for both coded video sequences. \nn\nTable E-6 – Divisor for computation of t ( n ) \nfi,dpb\npic_struct_present_flag  field_pic_flag  pic_struct  DeltaTfiDivisor \n0  1  -  1 \n1  -  1  1 \n1  -  2  1 \n0  0  -  2 \n1  -  0  2 \n1  -  3  2 \n1  -  4  2 \n1  -  5  3 \n1  -  6  3 \n1  -  7  4 \n1  -  8  6 \nNOTE 11 – In order to produce a DeltaTfiDivisor other than 2 for a picture with field_pic_flag equal to 0, pic_struct_present_flag \nmust be equal to 1. \n \nnal_hrd_parameters_present_flag equal to 1 specifies that NAL HRD parameters (pertaining to Type II bitstream \nconformance) are present. nal_hrd_parameters_present_flag equal to 0 specifies that NAL HRD parameters are not present. \nNOTE 12 – When nal_hrd_parameters_present_flag is equal to 0, the conformance of the bitstream cannot be verified without \nprovision of the NAL HRD parameters and all buffering period and picture timing SEI messages, by some means not specified in \nthis Recommendation | International Standard. \nWhen nal_hrd_parameters_present_flag is equal to 1, NAL HRD parameters (clauses E.1.2 and E.2.2) immediately follow \nthe flag. \nThe variable NalHrdBpPresentFlag is derived as follows: \n–  If any of the following is true, the value of NalHrdBpPresentFlag shall be set equal to 1: \n–  nal_hrd_parameters_present_flag is present in the bitstream and is equal to 1, \n–  the need for presence of buffering periods for NAL HRD operation to be present in the bitstream in buffering \nperiod SEI messages is determined by the application, by some means not specified in this Recommendation | \nInternational Standard. \n–  Otherwise, the value of NalHrdBpPresentFlag shall be set equal to 0. \nvcl_hrd_parameters_present_flag  equal  to 1  specifies  that  VCL  HRD  parameters  (pertaining  to  all  bitstream \nconformance) are present. vcl_hrd_parameters_present_flag equal to 0 specifies that VCL HRD parameters are not present. \nNOTE 13 – When vcl_hrd_parameters_present_flag is equal to 0, the conformance of the bitstream cannot be verified without \nprovision of the VCL HRD parameters and all buffering period and picture timing SEI messages, by some means not specified in \nthis Recommendation | International Standard. \nWhen vcl_hrd_parameters_present_flag is equal to 1, VCL HRD parameters (clauses E.1.2 and E.2.2) immediately follow \nthe flag. \nThe variable VclHrdBpPresentFlag is derived as follows: \n–  If any of the following is true, the value of VclHrdBpPresentFlag shall be set equal to 1: \n–  vcl_hrd_parameters_present_flag is present in the bitstream and is equal to 1, \n    Rec. ITU-T H.264 (06/2019)  431 \n \n–  the need for presence of buffering period parameters for VCL HRD operation in the bitstream in buffering period \nSEI  messages  is  determined  by  the  application,  by  some  means  not  specified  in  this  Recommendation  | \nInternational Standard. \n–  Otherwise, the value of VclHrdBpPresentFlag shall be set equal to 0. \nThe variable CpbDpbDelaysPresentFlag is derived as follows: \n–  If any of the following is true, the value of CpbDpbDelaysPresentFlag shall be set equal to 1: \n–  nal_hrd_parameters_present_flag is present in the bitstream and is equal to 1, \n–  vcl_hrd_parameters_present_flag is present in the bitstream and is equal to 1, \n–  the need for presence of CPB and DPB output delays in the bitstream in picture timing SEI  messages is \ndetermined by the application, by some means not specified in this Recommendation | International Standard. \n–  Otherwise, the value of CpbDpbDelaysPresentFlag shall be set equal to 0. \nlow_delay_hrd_flag specifies the HRD operational mode as specified in Annex C. When fixed_frame_rate_flag is equal \nto 1, low_delay_hrd_flag shall be equal to 0. When low_delay_hrd_flag is not present, its value shall be inferred to be \nequal to 1 − fixed_frame_rate_flag. \nNOTE 14 – When low_delay_hrd_flag is equal to 1, \"big pictures\" that violate the nominal CPB removal times due to the number \nof bits used by an access unit are permitted. It is expected, but not required, that such \"big pictures\" occur only occasionally. \npic_struct_present_flag equal to 1 specifies that picture timing SEI messages (clause D.2.3) are present that include the \npic_struct syntax element. pic_struct_present_flag equal to 0 specifies that the pic_struct syntax element is not present in \npicture timing SEI messages. When pic_struct_present_flag is not present, its value shall be inferred to be equal to 0. \nbitstream_restriction_flag equal to 1, specifies that the following coded video sequence bitstream restriction parameters \nare present. bitstream_restriction_flag equal to 0, specifies that the following coded video sequence bitstream restriction \nparameters are not present. \nmotion_vectors_over_pic_boundaries_flag equal to 0 indicates that no sample outside the picture boundaries and no \nsample at a fractional sample position for which the sample value is derived using one or more samples outside the picture \nboundaries is used for inter prediction of any sample. motion_vectors_over_pic_boundaries_flag equal to 1 indicates that \none  or  more  samples  outside  picture  boundaries  may  be  used  in  inter  prediction.  When  the \nmotion_vectors_over_pic_boundaries_flag  syntax  element  is  not  present,  motion_vectors_over_pic_boundaries_flag \nvalue shall be inferred to be equal to 1. \nmax_bytes_per_pic_denom indicates a number of bytes not exceeded by the sum of the sizes of the VCL NAL units \nassociated with any coded picture in the coded video sequence. \nThe number of bytes that represent a picture in the NAL unit stream is specified for this purpose as the total number of \nbytes of VCL NAL unit data (i.e., the total of the NumBytesInNALunit variables for the VCL NAL units) for the picture. \nThe value of max_bytes_per_pic_denom shall be in the range of 0 to 16, inclusive. \nDepending on max_bytes_per_pic_denom the following applies: \n–  If max_bytes_per_pic_denom is equal to 0, no limits are indicated. \n–  Otherwise (max_bytes_per_pic_denom is not equal to 0), it is a requirement of bitstream conformance that no coded \npicture shall be represented in the coded video sequence by more than the following number of bytes. \n( PicSizeInMbs * RawMbBits ) ÷ ( 8 * max_bytes_per_pic_denom )  (E-51) \nWhen the max_bytes_per_pic_denom syntax element is not present, the value of max_bytes_per_pic_denom shall be \ninferred to be equal to 2. \nmax_bits_per_mb_denom indicates an upper bound for the number of coded bits of macroblock_layer( ) data for any \nmacroblock in any picture of the coded video sequence. The value of max_bits_per_mb_denom shall be in the range of 0 \nto 16, inclusive. \nDepending on max_bits_per_mb_denom the following applies: \n–  If max_bits_per_mb_denom is equal to 0, no limit is specified by this syntax element. \n–  Otherwise (max_bits_per_mb_denom is not equal to 0), it is a requirement of bitstream conformance that no coded \nmacroblock_layer( ) shall be represented in the bitstream by more than the following number of bits. \n( 128 + RawMbBits ) ÷ max_bits_per_mb_denom    (E-52) \n432  Rec. ITU-T H.264 (06/2019) \n \nDepending on entropy_coding_mode_flag, the bits of macroblock_layer( ) data are counted as follows: \n–  If entropy_coding_mode_flag is equal to 0, the number of bits of macroblock_layer( ) data is given by the number of \nbits in the macroblock_layer( ) syntax structure for a macroblock. \n–  Otherwise (entropy_coding_mode_flag is equal to 1), the number of bits of macroblock_layer( ) data for a macroblock \nis  given  by  the  number  of  times  read_bits( 1 )  is  called  in  clauses 9.3.3.2.2  and  9.3.3.2.3  when  parsing  the \nmacroblock_layer( ) associated with the macroblock. \nWhen the max_bits_per_mb_denom is not present, the value of max_bits_per_mb_denom shall be inferred to be equal \nto 1. \nlog2_max_mv_length_horizontal  and  log2_max_mv_length_vertical  indicate  the  maximum  absolute  value  of  a \ndecoded horizontal and vertical motion vector component, respectively, in ¼ luma sample units, for all pictures in the \ncoded video sequence. A value of n asserts that no value of a motion vector component shall exceed the range from −2n to \n2n − 1, inclusive, in units of ¼ luma sample displacement. The value of log2_max_mv_length_horizontal shall be in the \nrange of 0 to 15, inclusive. The value of log2_max_mv_length_vertical shall be in the range of 0 to 15, inclusive. When \nlog2_max_mv_length_horizontal  is  not  present,  the  values  of  log2_max_mv_length_horizontal  and \nlog2_max_mv_length_vertical shall be inferred to be equal to 15. \nNOTE 15 – The maximum absolute value of a decoded vertical or horizontal motion vector component is also constrained by profile \nand level limits as specified in Annex A and clauses G.10 and H.10. \nmax_num_reorder_frames indicates an upper bound for the number of frames buffers, in the decoded picture buffer \n(DPB), that are required for storing  frames, complementary  field pairs,  and non-paired fields  before output. It is a \nrequirement of bitstream conformance that the maximum number of frames, complementary field pairs, or non-paired \nfields that precede any frame, complementary field pair, or non-paired field in the coded video sequence in decoding order \nand  follow  it  in  output  order  shall  be  less  than  or  equal  to  max_num_reorder_frames.  The  value  of \nmax_num_reorder_frames  shall  be  in  the  range  of  0  to  max_dec_frame_buffering,  inclusive.  When  the \nmax_num_reorder_frames syntax element is not present, the value of max_num_reorder_frames value shall be inferred as \nfollows: \n–  If  profile_idc  is  equal  to 44,  86,  100,  110,  122,  or  244  and  constraint_set3_flag  is  equal  to  1,  the  value  of \nmax_num_reorder_frames shall be inferred to be equal to 0. \n–  Otherwise (profile_idc is not equal to 44, 86, 100, 110, 122, or 244 or constraint_set3_flag is equal to 0), the value of \nmax_num_reorder_frames shall be inferred to be equal to MaxDpbFrames. \nmax_dec_frame_buffering specifies the required size of the HRD decoded picture buffer (DPB) in units of frame buffers. \nIt is a requirement of bitstream conformance that the coded video sequence shall not require a decoded picture buffer with \nsize of more than Max( 1, max_dec_frame_buffering ) frame buffers to enable the output of decoded pictures at the output \ntimes specified by dpb_output_delay of the picture timing SEI messages. The value of max_dec_frame_buffering shall be \ngreater than or equal to max_num_ref_frames. An upper bound for the value of max_dec_frame_buffering is specified by \nthe level limits in clauses A.3.1, A.3.2, G.10.2.1, and H.10.2. \nWhen the max_dec_frame_buffering syntax element is not present, the value of max_dec_frame_buffering shall be inferred \nas follows: \n–  If  profile_idc  is  equal  to  44,  86,  100,  110,  122,  or  244  and  constraint_set3_flag  is  equal  to  1,  the  value  of \nmax_dec_frame_buffering shall be inferred to be equal to 0. \n–  Otherwise (profile_idc is not equal to 44, 86, 100, 110, 122, or 244 or constraint_set3_flag is equal to 0), the value of \nmax_dec_frame_buffering shall be inferred to be equal to MaxDpbFrames. \nE.2.2  HRD parameters semantics \nThe syntax category of the HRD parameters syntax structure shall be inferred as follows: \n–  If the HRD parameters syntax structure is not part of an SEI message, the syntax category of the HRD parameters \nsyntax structure is inferred to be equal to 0. \n–  Otherwise (the HRD parameters syntax structure is part of the base layer temporal HRD SEI message as specified in \nclause G.13 or the base view temporal HRD SEI message as specified in clause H.13), the syntax category of the \nHRD parameters syntax structure is inferred to be equal to 5. \ncpb_cnt_minus1  plus  1  specifies  the  number  of  alternative  CPB  specifications  in  the  bitstream.  The  value  of \ncpb_cnt_minus1 shall be in the range of 0 to 31, inclusive. When low_delay_hrd_flag is equal to 1, cpb_cnt_minus1 shall \nbe equal to 0. When cpb_cnt_minus1 is not present, it shall be inferred to be equal to 0. \nbit_rate_scale  (together  with  bit_rate_value_minus1[ SchedSelIdx ])  specifies  the  maximum  input  bit  rate  of  the \nSchedSelIdx-th CPB. \n    Rec. ITU-T H.264 (06/2019)  433 \n \ncpb_size_scale (together with cpb_size_value_minus1[ SchedSelIdx ]) specifies the CPB size of the SchedSelIdx-th CPB. \nbit_rate_value_minus1[ SchedSelIdx ]  (together  with  bit_rate_scale)  specifies  the  maximum  input  bit  rate  for  the \nSchedSelIdx-th  CPB.  bit_rate_value_minus1[ SchedSelIdx ]  shall  be  in  the  range  of  0  to 232 − 2,  inclusive.  For  any \nSchedSelIdx > 0, bit_rate_value_minus1[ SchedSelIdx ] shall be greater than bit_rate_value_minus1[ SchedSelIdx − 1 ]. \nThe bit rate in bits per second is given by \nBitRate[ SchedSelIdx ] = ( bit_rate_value_minus1[ SchedSelIdx ] + 1 ) * 2(6 + bit_rate_scale)  (E-53) \nWhen the bit_rate_value_minus1[ SchedSelIdx ] syntax element is not present, the value of BitRate[ SchedSelIdx ] shall \nbe inferred as follows: \n–  If profile_idc is equal to 66, 77, or 88, BitRate[ SchedSelIdx ] shall be inferred to be equal to 1000 * MaxBR for VCL \nHRD  parameters  and  to  be  equal  to  1200 * MaxBR  for  NAL  HRD  parameters,  where  MaxBR  is  specified  in \nclause A.3.1. \n–  Otherwise,  BitRate[ SchedSelIdx ]  shall  be  inferred  to  be  equal  to  cpbBrVclFactor * MaxBR  for  VCL  HRD \nparameters and to be equal to cpbBrNalFactor * MaxBR for NAL HRD parameters, where MaxBR is specified in \nclause A.3.1 and cpbBrVclFactor and cpbBrNalFactor are specified in clause A.3.3 (for profiles specified in Annex A) \nor clause G.10.2.2 (for profiles specified in Annex G) or clause H.10.2 (for profiles specified in Annex H). \ncpb_size_value_minus1[ SchedSelIdx ] is used together with cpb_size_scale to specify the SchedSelIdx-th CPB size. \ncpb_size_value_minus1[ SchedSelIdx ] shall be in the range of 0 to 232 − 2, inclusive. For any SchedSelIdx greater than 0, \ncpb_size_value_minus1[ SchedSelIdx ] shall be less than or equal to cpb_size_value_minus1[ SchedSelIdx −1 ]. \nThe CPB size in bits is given by \nCpbSize[ SchedSelIdx ] = ( cpb_size_value_minus1[ SchedSelIdx ] + 1 ) * 2(4 + cpb_size_scale)  (E-54) \nWhen the cpb_size_value_minus1[ SchedSelIdx ] syntax element is not present, the value of CpbSize[ SchedSelIdx ] shall \nbe inferred as follows: \n–  If profile_idc is equal to 66, 77, or 88, CpbSize[ SchedSelIdx ] shall be inferred to be equal to 1000 * MaxCPB for \nVCL HRD parameters and to be equal to 1200 * MaxCPB for NAL HRD parameters, where MaxCPB is specified in \nclause A.3.1. \n–  Otherwise,  CpbSize[ SchedSelIdx ]  shall  be  inferred  to  be  equal  to  cpbBrVclFactor * MaxCPB  for  VCL  HRD \nparameters and to be equal to cpbBrNalFactor * MaxCPB for NAL HRD parameters, where MaxCPB is specified in \nclause A.3.1 and cpbBrVclFactor and cpbBrNalFactor are specified in clause A.3.3 (for profiles specified in Annex A) \nor clause G.10.2.2 (for profiles specified in Annex G) or clause H.10.2 (for profiles specified in Annex H). \ncbr_flag[ SchedSelIdx ] equal to 0 specifies that to decode this bitstream by the HRD using the SchedSelIdx-th CPB \nspecification,  the  hypothetical  stream  delivery  scheduler  (HSS)  operates  in  an  intermittent  bit  rate  mode. \ncbr_flag[ SchedSelIdx ]  equal  to 1  specifies  that  the  HSS  operates  in  a  constant  bit  rate  (CBR)  mode.  When  the \ncbr_flag[ SchedSelIdx ] syntax element is not present, the value of cbr_flag shall be inferred to be equal to 0. \ninitial_cpb_removal_delay_length_minus1 specifies the length in bits of the initial_cpb_removal_delay[ SchedSelIdx ] \nand initial_cpb_removal_delay_offset[ SchedSelIdx ] syntax elements of the buffering period SEI message. The length of \ninitial_cpb_removal_delay[ SchedSelIdx ]  and  of  initial_cpb_removal_delay_offset[ SchedSelIdx ]  is \ninitial_cpb_removal_delay_length_minus1 + 1. When the initial_cpb_removal_delay_length_minus1 syntax element is \npresent in more than one hrd_parameters( ) syntax structure within the VUI parameters syntax structure, the value of the \ninitial_cpb_removal_delay_length_minus1 parameters shall be equal in both hrd_parameters( ) syntax structures. When \nthe initial_cpb_removal_delay_length_minus1 syntax element is not present, it shall be inferred to be equal to 23. \ncpb_removal_delay_length_minus1 specifies the length in bits of the cpb_removal_delay syntax element. The length of \nthe cpb_removal_delay syntax element of the picture timing SEI message is cpb_removal_delay_length_minus1 + 1. \nWhen  the  cpb_removal_delay_length_minus1  syntax  element  is  present  in  more  than  one  hrd_parameters( )  syntax \nstructure within the VUI parameters syntax structure, the value of the cpb_removal_delay_length_minus1 parameters shall \nbe equal in both hrd_parameters( ) syntax structures. When the cpb_removal_delay_length_minus1 syntax element is not \npresent, it shall be inferred to be equal to 23. \ndpb_output_delay_length_minus1 specifies the length in bits of the dpb_output_delay syntax element. The length of the \ndpb_output_delay syntax element of the picture timing SEI message is dpb_output_delay_length_minus1 + 1. When the \ndpb_output_delay_length_minus1 syntax element is present in more than one hrd_parameters( ) syntax structure within \nthe VUI parameters syntax structure, the value of the dpb_output_delay_length_minus1 parameters shall be equal in both \nhrd_parameters( ) syntax structures. When the dpb_output_delay_length_minus1 syntax element is not present, it shall be \ninferred to be equal to 23. \n434  Rec. ITU-T H.264 (06/2019) \n \ntime_offset_length greater than 0 specifies the length in bits of the time_offset syntax element. time_offset_length equal \nto 0 specifies that the time_offset syntax element is not present. When the time_offset_length syntax element is present in \nmore  than  one  hrd_parameters( )  syntax  structure  within  the  VUI  parameters  syntax  structure,  the  value  of  the \ntime_offset_length parameters shall be equal in both hrd_parameters( ) syntax structures. When the time_offset_length \nsyntax element is not present, it shall be inferred to be equal to 24. \n   \n    Rec. ITU-T H.264 (06/2019)  435 \n \nAnnex F \n \nIntellectual property rights information \n \n(This annex does not forms an integral part of this Recommendation | International Standard.) \nThis annex, which contains information on intellectual property rights (IPR) applicable to this specification, is only present \nin  the  ISO/IEC  version  of  this  Recommendation | International Standard.  For  ITU-T,  the  applicable  information  is \navailable from the ITU-T IPR database at http://itu.int/ipr. \n \n \n436  Rec. ITU-T H.264 (06/2019) \n \nAnnex G \n \nScalable video coding \n \n(This annex forms an integral part of this Recommendation | International Standard.) \nThis annex specifies scalable video coding, referred to as SVC. \nG.1  Scope \nBitstreams and decoders conforming to one or more of the profiles specified in this annex are completely specified in this \nannex with reference made to clauses 2 to 9 and Annexes A to E. \nG.2  Normative references \nThe specifications in clause 2 apply with the following additions. \n–  ISO/IEC 10646:2003, Information technology − Universal Multiple-Octet Coded Character Set (UCS). \n–  IETF RFC 3986 (2005), Uniform Resource Identifiers (URI): Generic Syntax. \nG.3  Definitions \nFor the purpose of this annex, the following definitions apply in addition to the definitions in clause 3. These definitions \nare either not present in clause 3 or replace definitions in clause 3. \nG.3.1  arbitrary slice order (ASO): A decoding order of slices in which the macroblock address of the first macroblock \nof some slice of a slice group within a layer representation may be less than the macroblock address of the first \nmacroblock of some other preceding slice of the same slice group within the same layer representation or in \nwhich the slices of a slice group within a layer representation may be interleaved with the slices of one or more \nother slices groups within the same layer representation. \nG.3.2  associated NAL unit: A NAL unit that directly succeeds a prefix NAL unit in decoding order. \nG.3.3  B slice: A slice that may be decoded using intra-layer intra prediction or inter prediction using at most two motion \nvectors and reference indices to predict the sample values of each block. \nG.3.4  base layer: A bitstream subset that contains all NAL units with the nal_unit_type syntax element equal to 1 and 5 \nof the bitstream and does not contain any NAL unit with the nal_unit_type syntax element equal to 14, 15, or 20 \nand conforms to one or more of the profiles specified in Annex A. \nG.3.5  base quality layer representation: The layer representation of the target dependency representation of an access \nunit that is associated with the quality_id syntax element equal to 0. \nG.3.6  bitstream subset: A bitstream that is derived as a subset from a bitstream by discarding zero or more NAL units. \nA bitstream subset is also referred to as sub-bitstream. \nG.3.7  bottom macroblock (of a macroblock pair): The macroblock within a macroblock pair that contains the samples \nin the bottom row of samples for the macroblock pair. For a field macroblock pair, the bottom macroblock \nrepresents the samples from the region of the bottom field or layer bottom field of the frame or layer frame, \nrespectively, that lie within the spatial region of the macroblock pair. For a frame macroblock pair, the bottom \nmacroblock represents the samples of the frame or layer frame that lie within the bottom half of the spatial region \nof the macroblock pair. \nG.3.8  coded slice in scalable extension NAL unit: A coded slice NAL unit that contains an EI slice, EP slice, or an EB \nslice. \nG.3.9  complementary reference field pair: A collective term for two reference fields that are in consecutive access \nunits in decoding order as two coded fields, where the target dependency representations of the fields share the \nsame value of the frame_num syntax element and where the second field in decoding order is not an IDR picture \nand  the  target  dependency  representation  of  the  second  field  does  not  include  a \nmemory_management_control_operation syntax element equal to 5, or a complementary reference base field pair. \nG.3.10  complementary reference base field pair: Two reference base fields that are associated with two coded fields \nthat are in consecutive access units in decoding order, where the target dependency representations of the coded \nfields share the same value of the frame_num syntax element and where the second coded field in decoding order \nis not an IDR picture and the target dependency representation of the second coded field does not include a \n    Rec. ITU-T H.264 (06/2019)  437 \n \nmemory_management_control_operation syntax element equal to 5. A complementary reference base field pair \nis a complementary reference field pair. \nG.3.11  dependency representation: A subset of VCL NAL units within an access unit that are associated with the same \nvalue of the dependency_id syntax element, which is provided as part of the NAL unit header or by an associated \nprefix NAL unit, and the same value of the redundant_pic_cnt syntax element. A dependency representation \nconsists of one or more layer representations. \nG.3.12  EB slice: A slice that may be decoded using intra prediction or inter prediction or inter-layer prediction from \nsyntax elements and derived variables of the reference layer representation. For inter-prediction of EB slices at \nmost two motion vectors and reference indices are used to predict the sample values of each block. \nG.3.13  EI slice: A slice that is not an I slice or SI slice that is decoded using intra prediction only. \nG.3.14  EP slice: A slice that may be decoded using intra prediction or inter prediction or inter-layer prediction from \nsyntax elements and derived variables of the reference layer representation. For inter-prediction of EP slices at \nmost one motion vector and reference index is used to predict the sample values of each block. \nG.3.15  field macroblock: A macroblock containing samples from a single field or layer field. \nG.3.16  frame macroblock: A macroblock containing samples from the two fields or layer fields of a frame or layer \nframe, respectively. \nG.3.17  I slice: A slice that is decoded using intra-layer intra prediction only. \nG.3.18  instantaneous decoding refresh (IDR) picture: A coded picture for which the variable IdrPicFlag is equal to 1 \nfor the target dependency representation. An IDR picture causes the decoding process to mark all reference \npictures as \"unused for reference\" immediately after the decoding of the IDR picture. All coded pictures that \nfollow an IDR picture in decoding order can be decoded without inter prediction from any picture that precedes \nthe IDR picture in decoding order. The first picture of each coded video sequence in decoding order is an IDR \npicture. \nG.3.19  inter-layer  intra  prediction:  An  inter-layer  prediction  derived  from  decoded  samples  of  intra-coded \nmacroblocks of the reference layer representation. \nG.3.20  inter-layer prediction: A prediction derived from syntax elements, derived variables, or decoded samples of the \nreference layer representation. \nG.3.21  intra-layer intra prediction: A prediction derived from decoded samples of the same decoded slice. \nG.3.22  intra prediction: A collective term for intra-layer intra prediction or inter-layer intra prediction or a combination \nof intra-layer intra prediction together with inter-layer prediction from syntax elements and derived variables of \nthe reference layer representation. \nG.3.23  intra slice: A collective term for I slice or EI slice. \nG.3.24  layer bottom field: One of two layer fields that comprise a layer frame. Each row of a layer bottom field is \nspatially located immediately below a corresponding row of a layer top field. \nG.3.25  layer field: An assembly of alternate rows of a layer frame. A layer frame is composed of two layer fields, a layer \ntop field and a layer bottom field. \nG.3.26  layer frame: A layer frame contains an array of luma samples that represents an intermediate decoding result for \na field or a frame in monochrome format or an array of luma samples and two corresponding arrays of chroma \nsamples that represent an intermediate decoding result for a field or a frame in 4:2:0, 4:2:2, and 4:4:4 colour \nformat. A layer frame consists of two layer fields, a layer top field and a layer bottom field. \nG.3.27  layer picture: A collective term for a layer field or a layer frame. \nG.3.28  layer top field: One of two layer fields that comprise a layer frame. Each row of a layer top field is spatially \nlocated immediately above a corresponding row of a layer bottom field. \nG.3.29  layer representation: A subset of VCL NAL units within an access unit that are associated with the same values \nof the dependency_id and quality_id syntax elements, which are provided as part of the VCL NAL unit header or \nby an associated prefix NAL unit, and the same value of the redundant_pic_cnt syntax element. One or more layer \nrepresentations represent a dependency representation. \nG.3.30  layer representation identifier: An integer value by which a particular layer representation inside a coded \npicture is uniquely identified. \n438  Rec. ITU-T H.264 (06/2019) \n \nG.3.31  macroblock: A 16x16 block of luma samples and two corresponding blocks of chroma samples of a picture or \nlayer picture that has three sample arrays, or a 16x16 block of samples of a monochrome picture or layer picture. \nThe division of a slice or a macroblock pair into macroblocks is a partitioning. \nG.3.32  macroblock-adaptive frame/field decoding: A decoding process for coded frames or layer representations in \nwhich some macroblocks may be decoded as frame macroblocks and others may be decoded as field macroblocks. \nG.3.33  macroblock address: When macroblock-adaptive frame/field decoding is not in use, a macroblock address is the \nindex of a macroblock in a macroblock raster scan of the picture or layer picture starting with zero for the top-\nleft macroblock in a picture or layer picture. When macroblock-adaptive frame/field decoding is in use, the \nmacroblock address of the top macroblock of a macroblock pair is two times the index of the macroblock pair in \na  macroblock  pair  raster  scan  of  the  picture  or  layer  picture,  and  the  macroblock  address  of  the  bottom \nmacroblock of a macroblock pair is the macroblock address of the corresponding top macroblock plus 1. The \nmacroblock address of the top macroblock of each macroblock pair is an even number and the macroblock address \nof the bottom macroblock of each macroblock pair is an odd number. \nG.3.34  macroblock location: The two-dimensional coordinates of a macroblock in a picture or layer picture denoted by \n( x, y ). For the top left macroblock of the picture or layer picture ( x, y ) is equal to ( 0, 0 ). x is incremented by \n1 for each macroblock column from left to right. When macroblock-adaptive frame/field decoding is not in use, \ny is incremented by 1 for each macroblock row from top to bottom. When macroblock-adaptive frame/field \ndecoding is in use, y is incremented by 2 for each macroblock pair row from top to bottom, and is incremented \nby an additional 1 when a macroblock is a bottom macroblock. \nG.3.35  macroblock pair: A pair of vertically contiguous macroblocks in a frame or layer frame that is coupled for use \nin macroblock-adaptive frame/field decoding.  The division of a slice into macroblock pairs is a partitioning. \nG.3.36  macroblock to slice group map: A means of mapping macroblocks of a picture or layer picture into slice groups. \nThe macroblock to slice group map consists of a list of numbers, one for each coded macroblock, specifying the \nslice group to which each coded macroblock belongs. \nG.3.37  map unit to slice group map: A means of mapping slice group map units of a picture or layer picture into slice \ngroups. The map unit to slice group map consists of a list of numbers, one for each slice group map unit, specifying \nthe slice group to which each coded slice group map unit belongs to. \nG.3.38  non-paired reference base field: A reference base field that is not part of a complementary reference base field \npair. A non-paired reference base field is a non-paired reference field. \nG.3.39  P slice: A slice that may be decoded using intra-layer intra prediction or inter prediction using at most one motion \nvector and reference index to predict the sample values of each block. \nG.3.40  parameter: A syntax element of an SVC sequence parameter set or a picture parameter set. Parameter is also \nused as part of the defined term quantization parameter. \nG.3.41  picture  parameter  set:  A  syntax  structure  containing  syntax  elements  that  apply  to  zero  or  more  layer \nrepresentations as determined by the pic_parameter_set_id syntax element found in each slice header. \nG.3.42  prefix NAL unit: A NAL unit with nal_unit_type equal to 14 that immediately precedes in decoding order a NAL \nunit with nal_unit_type equal to 1 or 5. The NAL unit that immediately succeeds the prefix NAL unit in decoding \norder is referred to as the associated NAL unit. The prefix NAL unit contains data associated with the associated \nNAL unit, which are considered to be part of the associated NAL unit. \nG.3.43  reference base field: A reference field that is obtained by decoding a base quality layer representation with the \nnal_ref_idc  syntax  element  not  equal  to 0,  the  store_ref_base_pic_flag  syntax  element  equal  to 1,  and  the \nfield_pic_flag syntax element equal to 1 of a coded picture and all layer representations of the coded picture that \nare referred to by inter-layer prediction in the base quality layer representation. A reference base field is not a \ndecoded picture and it is not an output of the decoding process, but may be used for inter prediction when P, B, \nEP, and EB slices of a coded field or a field macroblock of a coded frame are decoded. See also reference base \npicture. \nG.3.44  reference base frame: A reference frame that is obtained by decoding a base quality layer representation with \nthe nal_ref_idc syntax element not equal to 0, the store_ref_base_pic_flag syntax element equal to 1, and the \nfield_pic_flag syntax element equal to 0 of a coded picture and all layer representations of the coded picture that \nare referred to by inter-layer prediction of the base quality layer representation. A reference base frame is not a \ndecoded picture and it is not an output of the decoding process, but may be used for inter prediction when P, B, \nEP, and EB slices of a coded frame are decoded. See also reference base picture. \nG.3.45  reference base picture: A collective term for a reference base field or a reference base frame. \n    Rec. ITU-T H.264 (06/2019)  439 \n \nG.3.46  reference field: A reference field may be used for inter prediction when P, B, EP, or EB slices of a coded field \nor field macroblocks of a coded frame are decoded. See also reference picture. \nG.3.47  reference frame: A reference frame may be used for inter prediction when P, B, EP, or EB slices of a coded \nframe are decoded. See also reference picture. \nG.3.48  reference layer macroblock: A macroblock of a reference layer representation. \nG.3.49  reference layer representation: A reference layer representation for a particular layer representation of a coded \npicture is the layer representation that is used for inter-layer prediction of the particular layer representation. \nThe reference layer representation belongs to the same access unit as the layer representation that uses the \nreference layer representation for inter-layer prediction. \nG.3.50  reference picture: A collective term for a decoded picture that is obtained by decoding a coded picture for which \nthe nal_ref_idc syntax element that is associated with the target dependency representation is not equal to 0 or a \nreference base picture. A reference picture contains samples that may be used for inter prediction in the decoding \nprocess of subsequent pictures in decoding order. \nG.3.51  reference picture list: A list of reference pictures that is used for inter prediction of a P, B, EP, or EB slice. For \nthe decoding process of a P or EP slice, there is one reference picture list. For the decoding process of a B or EB \nslice, there are two reference picture lists. \nG.3.52  reference picture list 0: A reference picture list used for inter prediction of a P, B, EP, or EB slice. All inter \nprediction used for P and EP slices uses reference picture list 0. Reference picture list 0 is one of two reference \npicture lists used for inter prediction for a B or EB slice, with the other being reference picture list 1. \nG.3.53  reference picture list 1: A reference picture list used for inter prediction of a B or EB slice. Reference picture \nlist 1 is one of two reference picture lists used for inter prediction for a B or EB slice, with the other being \nreference picture list 0. \nG.3.54  scalable bitstream: A bitstream with the property that one or more bitstream subsets that are not identical to the \nscalable bitstream form another bitstream that conforms to this specification. \nG.3.55  sequence  parameter  set:  A  syntax  structure  containing  syntax  elements  that  apply  to  zero  or  more  layer \nrepresentations with the dependency_id syntax element equal to 0 and the quality_id syntax element equal to 0 as \ndetermined by the content of a seq_parameter_set_id syntax element found in the picture parameter set referred \nto by the pic_parameter_set_id syntax element found in each slice header of I, P, and B slices. \nG.3.56  slice: An integer number of macroblocks or macroblock pairs ordered consecutively in the raster scan within a \nparticular slice group. Each macroblock or macroblock pair of a picture or layer picture shall not be contained in \nmore than one slice of a particular layer representation. Although a slice contains macroblocks or macroblock \npairs that are consecutive in the raster scan within a slice group, these macroblocks or macroblock pairs are not \nnecessarily consecutive in the raster scan within the picture or layer picture. The macroblock addresses are \nderived from the first macroblock address in a slice (as represented in the slice header) and the macroblock to \nslice group map. \nG.3.57  slice group: A subset of the macroblocks or macroblock pairs of a picture or layer picture. The division of the \npicture or layer picture into slice groups is a partitioning of the picture or layer picture. The partitioning is \nspecified by the macroblock to slice group map. \nG.3.58  spatial intra prediction: See intra-layer intra prediction. \nG.3.59  sub-bitstream: A subset of a bitstream. A sub-bitstream is also referred to as bitstream subset. \nG.3.60  subset: A subset contains only elements that are also contained in the set from which the subset is derived. The \nsubset may be identical to the set from which it is derived. \nG.3.61  subset sequence parameter set: A syntax structure containing syntax elements that apply to zero or more layer \nrepresentations with the dependency_id syntax element not equal to 0 or the quality_id syntax element not equal \nto 0 as determined by the content of a seq_parameter_set_id syntax element found in the picture parameter set \nreferred to by the pic_parameter_set_id syntax element found in each slice header of EI, EP, and EB slices. \nG.3.62  SVC sequence parameter set: A collective term for sequence parameter set or subset sequence parameter set. \nG.3.63  SVC sequence parameter set RBSP: A collective term for sequence parameter set RBSP or subset sequence \nparameter set RBSP. \nG.3.64  target dependency representation: The dependency representation of a coded picture that is associated with the \nlargest value of the dependency_id syntax element for all dependency representations of the coded picture. \n440  Rec. ITU-T H.264 (06/2019) \n \nG.3.65  target layer representation: The layer representation of the target dependency representation of a coded picture \nthat is associated with the largest value of the quality_id syntax element for all layer representations of the target \ndependency representation of the coded picture. \nG.3.66  top macroblock (of a macroblock pair): The macroblock within a macroblock pair that contains the samples in \nthe top row of samples for the macroblock pair. For a field macroblock pair, the top macroblock represents the \nsamples from the region of the top field or layer top field of the frame or layer frame that lie within the spatial \nregion of the macroblock pair. For a frame macroblock pair, the top macroblock represents the samples of the \nframe or layer frame that lie within the top half of the spatial region of the macroblock pair. \nG.3.67  VCL NAL unit: A collective term for coded slice NAL units and prefix NAL units. \nG.4  Abbreviations \nThe specifications in clause 4 apply. \nG.5  Conventions \nThe specifications in clause 5 apply. \nG.6  Source,  coded,  decoded  and  output  data  formats,  scanning  processes,  neighbouring  and \nreference layer relationships \nThe specifications in clause 6 apply with substituting SVC sequence parameter set for sequence parameter set. The \nspecification in clause 6.3 also applies to layer pictures. Additionally, the following processes are specified. \nG.6.1  Derivation process for reference layer macroblocks \nThis process is only invoked when no_inter_layer_pred_flag is equal to 0. \nInputs to this process are: \n–  a luma location ( xP, yP ) relative to the upper-left luma sample of the current macroblock, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  a one-dimensional array refLayerMbType with RefLayerPicSizeInMbs elements specifying macroblock types for the \nmacroblocks of the reference layer representation. \nOutputs of this process are: \n–  the macroblock address mbAddrRefLayer specifying the reference layer macroblock, \n–  a luma location ( xB, yB ) relative to the upper-left luma sample of the reference layer macroblock. \nLet currDQId be the current value of DQId and let levelIdc be the value of level_idc in the SVC sequence parameter set \nthat is referred to in coded slice NAL units with DQId equal to (( currDQId >> 4 ) << 4). \nThe variables shiftX, shiftY, scaleX, scaleY, offsetX, and offsetY are derived as specified in the following ordered steps: \n1.  The variables refW, refH, scaledW, scaledH, offsetX, and offsetY are derived by \nrefW      = RefLayerPicWidthInSamples   (G-1) \nL\nrefH       = RefLayerPicHeightInSamples   (G-2) \nL\nscaledW = ScaledRefLayerPicWidthInSamples   (G-3) \nL\nscaledH  = ScaledRefLayerPicHeightInSamples   (G-4) \nL\noffsetX   = ScaledRefLayerLeftOffset  (G-5) \noffsetY   = ScaledRefLayerTopOffset / ( 1 + field_pic_flag )  (G-6) \n2.  The variables shiftX and shiftY are derived by \nshiftX = ( ( levelIdc <= 30 )  ?  16  :  ( 31 − Ceil( Log2( refW ) ) ) )  (G-7) \nshiftY = ( ( levelIdc <= 30 )  ?  16  :  ( 31 − Ceil( Log2( refH  ) ) ) )  (G-8) \n3.  The variables scaleX and scaleY are derived by \n    Rec. ITU-T H.264 (06/2019)  441 \n \nscaleX = ( ( refW << shiftX ) + ( scaledW >> 1 ) ) / scaledW  (G-9) \nscaleY = ( ( refH  << shiftY ) + ( scaledH  >> 1 ) ) / scaledH  (G-10) \nNOTE 1 – The variables shiftX, shiftY, scaleX, scaleY, offsetX, and offsetY do not depend on the luma location ( xP, yP ), the \nvariable fieldMbFlag, or the current macroblock. \nThe reference layer luma location ( xRef, yRef ) relative to the upper-left sample of the reference layer picture is derived \nas specified by the following ordered steps: \n1.  The inverse macroblock scanning process as specified in clause 6.4.1 is invoked with CurrMbAddr as the input \nand the output is assigned to ( xM, yM ). For this invocation of the process in clause 6.4.1, the current macroblock \nis treated as field macroblock when fieldMbFlag is equal to 1, and it is treated as frame macroblock when \nfieldMbFlag is equal to 0. \n2.  The luma location ( xC, yC ) is derived by \nxC = xM + xP  (G-11) \nyC = yM + yP * ( 1 + fieldMbFlag − field_pic_flag )  (G-12) \n3.  The reference layer luma location is derived by \nxRef = ( ( xC − offsetX ) * scaleX + ( 1 << ( shiftX − 1 ) ) ) >> shiftX  (G-13) \nyRef = ( ( yC − offsetY ) * scaleY + ( 1 << ( shiftY − 1 ) ) ) >> shiftY  (G-14) \n4.  The reference layer luma location is modified by \nxRef = Min( RefLayerPicWidthInSamples   − 1, xRef )  (G-15) \nL\nyRef = Min( RefLayerPicHeightInSamples  − 1, yRef )  (G-16) \nL\nThe reference layer macroblock address mbAddrRefLayer and a luma location ( xB, yB ) relative to the upper-left sample \nof the reference layer macroblock mbAddrRefLayer are derived as follows: \n–  If MbaffFrameFlag is equal to 0 and RefLayerMbaffFrameFlag is equal to 0, the following ordered steps are specified: \n1.  The reference layer macroblock address mbAddrRefLayer is derived by \nmbAddrRefLayer = ( yRef / 16 ) * RefLayerPicWidthInMbs + ( xRef / 16 )  (G-17) \n2.  The luma location ( xB, yB ) is derived as follows: \n–  If mbAddrRefLayer is not available, ( xB, yB ) is marked as not available. \n–  Otherwise (mbAddrRefLayer is available), ( xB, yB ) is set equal to ( xRef % 16, yRef % 16 ). \n–  Otherwise (MbaffFrameFlag is equal to 1 or RefLayerMbaffFrameFlag is equal to 1), the following ordered steps are \nspecified: \nNOTE 2  –  When  MbaffFrameFlag  is  equal  to  1  or  RefLayerMbaffFrameFlag  is  equal  to  1,  field_pic_flag  and \nRefLayerFieldPicFlag are both equal to 0 (see clause G.7.4.3.4). \n1.  A virtual reference layer macroblock address virtMbAddrRefLayer is derived as follows: \n–  If RefLayerMbaffFrameFlag is equal to 1, virtMbAddrRefLayer is derived by \nvirtMbAddrRefLayer = 2 * ( ( yRef / 32 ) * RefLayerPicWidthInMbs + ( xRef / 16 ) ) + \n                                       ( yRef % 32 ) / 16  (G-18) \n–  Otherwise (RefLayerMbaffFrameFlag is equal to 0), virtMbAddrRefLayer is derived by \nvirtMbAddrRefLayer = ( yRef / 16 ) * RefLayerPicWidthInMbs + ( xRef / 16 )  (G-19) \n2.  The reference layer  macroblock address  mbAddrRefLayer and the luma location ( xB, yB ) are derived as \nfollows: \n–  If fieldMbFlag is equal to 0 and refLayerFieldMbRef[ virtMbAddrRefLayer ] is equal to 1, the field-to-\nframe  reference  layer  macroblock  conversion  process  as  specified  in  clause G.6.1.1  is  invoked  with \nvirtMbAddrRefLayer, ( xRef, yRef ), and refLayerMbType as the inputs and the outputs are assigned to \nmbAddrRefLayer and ( xB, yB ). \n442  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise, if fieldMbFlag is equal to 1 and refLayerFieldMbRef[ virtMbAddrRefLayer ] is equal to 0, the \nframe-to-field reference layer macroblock conversion process as specified in clause G.6.1.2 is invoked with \nvirtMbAddrRefLayer and ( xRef, yRef ) as the inputs and the outputs are assigned to mbAddrRefLayer and \n( xB, yB ). \n–  Otherwise (fieldMbFlag is equal to refLayerFieldMbRef[ virtMbAddrRefLayer ]), mbAddrRefLayer and \n( xB, yB ) are derived by \nmbAddrRefLayer = ( ( virtMbAddrRefLayer >> fieldMbFlag ) << fieldMbFlag ) \n                                 + ( CurrMbAddr % 2 ) * fieldMbFlag  (G-20) \nxB = ( xRef % 16 )  (G-21) \nyB = ( yRef % ( 16 << fieldMbFlag ) ) >> fieldMbFlag  (G-22) \nG.6.1.1  Field-to-frame reference layer macroblock conversion process \nInputs to this process are: \n–  a virtual reference layer macroblock address virtMbAddrRefLayer, \n–  a reference layer luma location ( xRef, yRef ) relative to the upper-left luma sample of the reference layer picture, \n–  a one-dimensional array refLayerMbType with RefLayerPicSizeInMbs elements specifying macroblock types for the \nmacroblocks of the reference layer representation. \nOutputs of this process are: \n–  the macroblock address mbAddrRefLayer of the reference layer macroblock, \n–  a luma location ( xB, yB ) relative to the upper-left luma sample of the reference layer macroblock. \nThe macroblock addresses mbAddrRefLayerTop and mbAddrRefLayerBot are derived by \nmbAddrRefLayerTop = virtMbAddrRefLayer − ( virtMbAddrRefLayer % 2 )  (G-23) \nmbAddrRefLayerBot = mbAddrRefLayerTop + 1  (G-24) \nThe reference layer macroblock address mbAddrRefLayer is derived as follows: \n–  If refLayerMbType[ mbAddrRefLayerTop ] is equal to I_PCM, I_16x16, I_8x8, I_4x4, or I_BL, mbAddrRefLayer is \nset equal to mbAddrRefLayerBot. \n–  Otherwise  (refLayerMbType[ mbAddrRefLayerTop ]  is  not  equal  to  I_PCM,  I_16x16,  I_8x8,  I_4x4,  or  I_BL), \nmbAddrRefLayer is set equal to mbAddrRefLayerTop. \nThe luma location ( xB, yB ) is derived by \nxB = xRef % 16  (G-25) \nyB = 8 * ( ( yRef / 16 ) % 2 ) + 4 * ( ( yRef % 16 ) / 8 )  (G-26) \nG.6.1.2  Frame-to-field reference layer macroblock conversion process \nInputs to this process are: \n–  a virtual reference layer macroblock address virtMbAddrRefLayer, \n–  a virtual reference layer luma location ( xRef, yRef ) relative to the upper-left luma sample of the reference layer \npicture. \nOutputs of this process are: \n–  the macroblock address mbAddrRefLayer of the reference layer macroblock, \n–  a luma location ( xB, yB ) relative to the upper-left luma sample of the reference layer macroblock. \nThe reference layer macroblock address mbAddrRefLayer and the luma location ( xB, yB ) are derived by \nmbAddrRefLayer = virtMbAddrRefLayer  (G-27) \nxB                        = xRef % 16  (G-28) \nyB                        = yRef % 16  (G-29) \nG.6.2  Derivation process for reference layer partitions \nThis process is only invoked when no_inter_layer_pred_flag is equal to 0. \n    Rec. ITU-T H.264 (06/2019)  443 \n \nInputs to this process are: \n–  a luma location ( xP, yP ) relative to the upper-left luma sample of the current macroblock, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  a one-dimensional array refLayerMbType with RefLayerPicSizeInMbs elements specifying macroblock types for the \nmacroblocks of the reference layer representation, \n–  a (RefLayerPicSizeInMbs)x4 array refLayerSubMbType specifying the sub-macroblock types for the macroblocks of \nthe reference layer representation. \nOutputs of this process are: \n–  the macroblock address mbAddrRefLayer specifying the reference layer macroblock, \n–  the macroblock partition index mbPartIdxRefLayer specifying the reference layer macroblock partition inside the \nreference layer macroblock mbAddrRefLayer, \n–  the sub-macroblock partition index subMbPartIdxRefLayer specifying the reference layer sub-macroblock partition \ninside the macroblock partition mbPartIdxRefLayer of the reference layer macroblock mbAddrRefLayer. \nThe  derivation  process  for  reference  layer  macroblocks  as  specified  in  clause G.6.1  is  invoked  with  the  luma \nlocation ( xP, yP ), fieldMbFlag, refLayerFieldMbFlag, and refLayerMbType as the input and the outputs are assigned to \nmbAddrRefLayer and ( xB, yB ). \nThe SVC derivation process for macroblock and sub-macroblock partition indices as specified in clause G.6.4 is invoked \nwith  currDQId  set  equal  to  ref_layer_dq_id,  the  luma  location  ( xB, yB ),  the  macroblock  type \nrefLayerMbType[ mbAddrRefLayer ], and, when refLayerMbType[ mbAddrRefLayer ] is equal to P_8x8, P_8x8ref0, or \nB_8x8, the list of sub-macroblock types refLayerSubMbType[ mbAddrRefLayer ] as the inputs and the outputs are the \nreference layer macroblock partition index mbPartIdxRefLayer and the reference layer sub-macroblock partition index \nsubMbPartIdxRefLayer. \nG.6.3  Derivation process for reference layer sample locations in resampling \nInputs to this process are: \n–  a variable chromaFlag specifying whether the luma or a chroma component is subject to the resampling process, \n–  a sample location ( xP, yP ) relative to the upper-left sample of the current macroblock, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable botFieldFlag specifying whether a top or a bottom field is subject to the resampling process (when \nRefLayerFrameMbsOnlyFlag is equal to 0 or frame_mbs_only_flag is equal to 0). \nOutput of this process is a reference layer sample location ( xRef16, yRef16 ), which specifies the following: \n–  If RefLayerFrameMbsOnlyFlag is equal to 1 or RefLayerFieldPicFlag is equal to 1, ( xRef16, yRef16 ) specifies the \nreference layer sample location in units of 1/16-th sample relative to the upper-left sample of the reference layer \npicture. \n–  Otherwise (RefLayerFrameMbsOnlyFlag is equal to 0 and RefLayerFieldPicFlag is equal to 0), ( xRef16, yRef16 ) \nspecifies the reference layer sample location in units of 1/16-th field sample relative to the upper-left sample of the \nfield specified by botFieldFlag of the reference layer picture. \nLet currDQId be the current value of DQId and let levelIdc be the value of level_idc in the SVC sequence parameter set \nthat is referred to in coded slice NAL units with DQId equal to (( currDQId >> 4 ) << 4). \nThe variables subW, subH, shiftX, shiftY, scaleX, scaleY, offsetX, offsetY, addX, addY, deltaX, and deltaY are derived \nas specified in the following ordered steps: \n1.  With Z being replaced by L for chromaFlag equal to 0 and C for chromaFlag equal to 1, the variables refW, refH, \nscaledW, and scaledH are derived by \nrefW      = RefLayerPicWidthInSamples   (G-30) \nZ\nrefH       = RefLayerPicHeightInSamples  * ( 1 + RefLayerFieldPicFlag )  (G-31) \nZ\nscaledW = ScaledRefLayerPicWidthInSamples   (G-32) \nZ\nscaledH  = ScaledRefLayerPicHeightInSamples  * ( 1 + field_pic_flag )  (G-33) \nZ\n444  Rec. ITU-T H.264 (06/2019) \n \n2.  When frame_mbs_only_flag is equal to 0 and RefLayerFrameMbsOnlyFlag is equal to 1, the variable scaledH is \nmodified by \nscaledH = scaledH / 2  (G-34) \n3.  The variables refPhaseX, refPhaseY, phaseX, phaseY, subW, and subH are derived by \nrefPhaseX = ( ( chromaFlag  = =  0 )  ?  0  :  ( ref_layer_chroma_phase_x_plus1_flag − 1 ) )  (G-35) \nrefPhaseY = ( ( chromaFlag  = =  0 )  ?  0  :  ( ref_layer_chroma_phase_y_plus1 − 1 ) )  (G-36) \nphaseX      = ( ( chromaFlag  = =  0 )  ?  0  :  ( chroma_phase_x_plus1_flag − 1 ) )  (G-37) \nphaseY      = ( ( chromaFlag  = =  0 )  ?  0  :  ( chroma_phase_y_plus1 − 1 ) )  (G-38) \nsubW         = ( ( chromaFlag  = =  0 )  ?  1  :  SubWidthC )  (G-39) \nsubH          = ( ( chromaFlag  = =  0 )  ?  1  :  SubHeightC )  (G-40) \n4.  When RefLayerFrameMbsOnlyFlag is equal to 0 or frame_mbs_only_flag is equal to 0, the following applies: \n–  If RefLayerFrameMbsOnlyFlag is equal to 1, the variables phaseY and refPhaseY are modified by \nphaseY      = phaseY + 4 * botFieldFlag + 3 − subH  (G-41) \nrefPhaseY = 2 * refPhaseY + 2  (G-42) \n–  Otherwise (RefLayerFrameMbsOnlyFlag is equal to 0), the variables phaseY and refPhaseY are modified \nby \nphaseY      = phaseY + 4 * botFieldFlag  (G-43) \nrefPhaseY = refPhaseY + 4 * botFieldFlag  (G-44) \n5.  The variables shiftX and shiftY are derived by \nshiftX = ( ( levelIdc <= 30 )  ?  16  :  ( 31 − Ceil( Log2( refW ) ) ) )  (G-45) \nshiftY = ( ( levelIdc <= 30 )  ?  16  :  ( 31 − Ceil( Log2( refH  ) ) ) )  (G-46) \n6.  The variables scaleX and scaleY are derived by \nscaleX = ( ( refW << shiftX ) + ( scaledW >> 1 ) ) / scaledW  (G-47) \nscaleY = ( ( refH  << shiftY ) + ( scaledH  >> 1 ) ) / scaledH  (G-48) \n7.  The variables offsetX, addX, and deltaX are derived by \noffsetX = ScaledRefLayerLeftOffset / subW  (G-49) \naddX    = ( ( ( refW * ( 2 + phaseX ) ) << ( shiftX − 2 ) ) + ( scaledW >> 1 ) ) / scaledW \n                + ( 1 << ( shiftX − 5 ) )  (G-50) \ndeltaX  = 4 * ( 2 + refPhaseX )  (G-51) \n8.  The variables offsetY, addY, and deltaY are derived as follows: \n–  If RefLayerFrameMbsOnlyFlag is equal to 1 and frame_mbs_only_flag is equal to 1, the variables offsetY, \naddY, and deltaY are derived by \noffsetY = ScaledRefLayerTopOffset / subH  (G-52) \naddY    = ( ( ( refH * ( 2 + phaseY ) ) << ( shiftY − 2 ) ) + ( scaledH >> 1 ) ) / scaledH \n                + ( 1 << ( shiftY − 5 ) )  (G-53) \ndeltaY  = 4 * ( 2 + refPhaseY )  (G-54) \n–  Otherwise (RefLayerFrameMbsOnlyFlag is equal to 0 or frame_mbs_only_flag is equal to 0), the variables \noffsetY, addY, and deltaY are derived by \noffsetY = ScaledRefLayerTopOffset / ( 2 * subH )  (G-55) \naddY    = ( ( ( refH * ( 2 + phaseY ) ) << ( shiftY − 3 ) ) + ( scaledH >> 1 ) ) / scaledH \n                + ( 1 << ( shiftY − 5 ) )  (G-56) \ndeltaY  = 2 * ( 2 + refPhaseY )  (G-57) \nNOTE – The variables subW, subH, shiftX, shiftY, scaleX, scaleY, offsetX, offsetY, addX, addY, deltaX, and deltaY do not depend \non the input sample location ( xP, yP ), the input variable fieldMbFlag, or the current macroblock address CurrMbAddr. \nThe sample location ( xC, yC ) is derived as specified in the following ordered steps: \n    Rec. ITU-T H.264 (06/2019)  445 \n \n1.  The inverse macroblock scanning process as specified in clause 6.4.1 is invoked with CurrMbAddr as input and \nthe output is assigned to ( xM, yM ). For this invocation of the process in clause 6.4.1, the current macroblock is \ntreated  as  field  macroblock  when  fieldMbFlag  is  equal  to  1  and  it  is  treated  as  frame  macroblock  when \nfieldMbFlag is equal to 0. \n2.  The sample location ( xC, yC ) is derived by \nxC = xP + ( xM >> ( subW − 1 ) )  (G-58) \nyC = yP + ( yM >> ( subH  − 1 + fieldMbFlag − field_pic_flag ) )  (G-59) \n3.  When RefLayerFrameMbsOnlyFlag is equal to 0 or frame_mbs_only_flag is equal to 0, the vertical component \nof the sample location ( xC, yC ) is modified by \nyC = yC >> ( 1 − fieldMbFlag )  (G-60) \nThe reference layer sample location ( xRef16 yRef16 ) is derived by \nxRef16 = ( ( ( xC − offsetX ) * scaleX + addX ) >> ( shiftX − 4 ) ) − deltaX  (G-61) \nyRef16 = ( ( ( yC − offsetY ) * scaleY + addY ) >> ( shiftY − 4 ) ) − deltaY  (G-62) \nG.6.4  SVC derivation process for macroblock and sub-macroblock partition indices \nInputs to this process are: \n–  a variable currDQId specifying an identifier for a layer representation, \n–  a luma location ( xP, yP ) relative to the upper-left luma sample of a macroblock, \n–  a macroblock type mbType, \n–  when mbType is equal to P_8x8, P_8x8ref0, or B_8x8, a list of sub-macroblock types subMbType with 4 elements. \nOutputs of this process are: \n–  a macroblock partition index mbPartIdx, \n–  a sub-macroblock partition index subMbPartIdx. \nThe variable svcDirectModeFlag is derived as follows: \n–  If currDQId is greater than 0 and any of the following conditions are true, svcDirectModeFlag is set equal to 1. \n–  mbType is equal to B_Skip or B_Direct_16x16 \n–  mbType is equal to B_8x8 and subMbType[ 2 * ( yP / 8 ) + ( xP / 8 ) ] is equal to B_Direct_8x8 \n–  Otherwise, svcDirectModeFlag is set equal to 0. \nDepending on svcDirectModeFlag, the following applies: \n–  If svcDirectModeFlag is equal to 0, the derivation process for macroblock and sub-macroblock partition indices as \nspecified in clause 6.4.13.4 is invoked with the luma location ( xP, yP ), the macroblock type mbType, and, when \nmbType is equal to P_8x8, P_8x8ref0, or B_8x8, the list of sub-macroblock types subMbType as the inputs and the \noutputs are the macroblock partition index mbPartIdx and the sub-macroblock partition index subMbPartIdx. \n–  Otherwise, if mbType is equal to B_Skip or B_Direct_16x16, mbPartIdx is set equal to 0 and subMbPartIdx is set \nequal to 0. \n–  Otherwise (currDQId is greater than 0, mbType is equal to B_8x8, and subMbType[ 2 * ( yP / 8 ) + ( xP / 8 ) ] is \nequal to B_Direct_8x8), mbPartIdx is set equal to ( 2 * ( yP / 8 ) + ( xP / 8 ) ) and subMbPartIdx is set equal to 0. \nG.7  Syntax and semantics \nThis clause specifies syntax and semantics for coded video sequences that conform to one or more of the profiles specified \nin this annex. \nG.7.1  Method of specifying syntax in tabular form \nThe specifications in clause 7.1 apply. \n446  Rec. ITU-T H.264 (06/2019) \n \nG.7.2  Specification of syntax functions, categories, and descriptors \nThe specifications in clause 7.2 apply. \nG.7.3  Syntax in tabular form \nG.7.3.1  NAL unit syntax \nThe syntax table is specified in clause 7.3.1. \nG.7.3.1.1  NAL unit header SVC extension syntax \n \nnal_unit_header_svc_extension( ) {  C  Descriptor \n  idr_flag  All  u(1) \n  priority_id  All  u(6) \n  no_inter_layer_pred_flag  All  u(1) \n  dependency_id  All  u(3) \n  quality_id  All  u(4) \n  temporal_id  All  u(3) \n  use_ref_base_pic_flag  All  u(1) \n  discardable_flag  All  u(1) \n  output_flag  All  u(1) \n  reserved_three_2bits  All  u(2) \n}     \n \nG.7.3.2  Raw byte sequence payloads and RBSP trailing bits syntax \nG.7.3.2.1  Sequence parameter set RBSP syntax \nThe syntax table is specified in clause 7.3.2.1. \nG.7.3.2.1.1  Sequence parameter set data syntax \nThe syntax table is specified in clause 7.3.2.1.1. \nG.7.3.2.1.1.1 Scaling list syntax \nThe syntax table is specified in clause 7.3.2.1.1.1. \nG.7.3.2.1.2  Sequence parameter set extension RBSP syntax \nThe syntax table is specified in clause 7.3.2.1.2. \nG.7.3.2.1.3  Subset sequence parameter set RBSP syntax \nThe syntax table is specified in clause 7.3.2.1.3. \nG.7.3.2.1.4  Sequence parameter set SVC extension syntax \n \nseq_parameter_set_svc_extension( ) {  C  Descriptor \n  inter_layer_deblocking_filter_control_present_flag  0  u(1) \n  extended_spatial_scalability_idc  0  u(2) \n  if( ChromaArrayType  = =  1  | |  ChromaArrayType  = =  2 )     \n    chroma_phase_x_plus1_flag  0  u(1) \n  if( ChromaArrayType  = =  1 )     \n    chroma_phase_y_plus1  0  u(2) \n  if( extended_spatial_scalability_idc  = =  1 ) {     \n    if( ChromaArrayType > 0 ) {     \n      seq_ref_layer_chroma_phase_x_plus1_flag  0  u(1) \n      seq_ref_layer_chroma_phase_y_plus1  0  u(2) \n    Rec. ITU-T H.264 (06/2019)  447 \n \n    }     \n    seq_scaled_ref_layer_left_offset  0  se(v) \n    seq_scaled_ref_layer_top_offset  0  se(v) \n    seq_scaled_ref_layer_right_offset  0  se(v) \n    seq_scaled_ref_layer_bottom_offset  0  se(v) \n  }     \n  seq_tcoeff_level_prediction_flag  0  u(1) \n  if( seq_tcoeff_level_prediction_flag ) {     \n    adaptive_tcoeff_level_prediction_flag  0  u(1) \n  }     \n  slice_header_restriction_flag  0  u(1) \n}     \n \nG.7.3.2.2  Picture parameter set RBSP syntax \nThe syntax table is specified in clause 7.3.2.2. \nG.7.3.2.3  Supplemental enhancement information RBSP syntax \nThe syntax table is specified in clause 7.3.2.3. \nG.7.3.2.3.1  Supplemental enhancement information message syntax \nThe syntax table is specified in clause 7.3.2.3.1. \nG.7.3.2.4  Access unit delimiter RBSP syntax \nThe syntax table is specified in clause 7.3.2.4. \nG.7.3.2.5  End of sequence RBSP syntax \nThe syntax table is specified in clause 7.3.2.5. \nG.7.3.2.6  End of stream RBSP syntax \nThe syntax table is specified in clause 7.3.2.6. \nG.7.3.2.7  Filler data RBSP syntax \nThe syntax table is specified in clause 7.3.2.7. \nG.7.3.2.8  Slice layer without partitioning RBSP syntax \nThe syntax table is specified in clause 7.3.2.8. \nG.7.3.2.9  Slice data partition RBSP syntax \nSlice data partition syntax is not present in coded video sequences conforming to any of the profiles specified in this annex. \nG.7.3.2.10  RBSP slice trailing bits syntax \nThe syntax table is specified in clause 7.3.2.10. \nG.7.3.2.11  RBSP trailing bits syntax \nThe syntax table is specified in clause 7.3.2.11. \nG.7.3.2.12  Prefix NAL unit RBSP syntax \nThe syntax table is specified in clause 7.3.2.12. \n448  Rec. ITU-T H.264 (06/2019) \n \nG.7.3.2.12.1 Prefix NAL unit SVC syntax \n \nprefix_nal_unit_svc( ) {  C  Descriptor \n  if( nal_ref_idc  !=  0 ) {     \n    store_ref_base_pic_flag  2  u(1) \n    if( ( use_ref_base_pic_flag  | |  store_ref_base_pic_flag )  &&     \n         !idr_flag ) \n      dec_ref_base_pic_marking( )  2   \n    additional_prefix_nal_unit_extension_flag  2  u(1) \n    if( additional_prefix_nal_unit_extension_flag  = =  1 )     \n      while( more_rbsp_data( ) )     \n        additional_prefix_nal_unit_extension_data_flag  2  u(1) \n    rbsp_trailing_bits( )  2   \n  } else if( more_rbsp_data( ) ) {     \n    while( more_rbsp_data( ) )     \n      additional_prefix_nal_unit_extension_data_flag  2  u(1) \n    rbsp_trailing_bits( )  2   \n  }     \n}     \n \nG.7.3.2.13  Slice layer extension RBSP syntax \nThe syntax table is specified in clause 7.3.2.13. \nG.7.3.3  Slice header syntax \nThe syntax table is specified in clause 7.3.3. \nG.7.3.3.1  Reference picture list modification syntax \nThe syntax table is specified in clause 7.3.3.1. \nG.7.3.3.2  Prediction weight table syntax \nThe syntax table is specified in clause 7.3.3.2. \nG.7.3.3.3  Decoded reference picture marking syntax \nThe syntax table is specified in clause 7.3.3.3. \nG.7.3.3.4  Slice header in scalable extension syntax \n \nslice_header_in_scalable_extension( ) {  C  Descriptor \n  first_mb_in_slice  2  ue(v) \n  slice_type  2  ue(v) \n  pic_parameter_set_id  2  ue(v) \n  if( separate_colour_plane_flag  = =  1 )     \n    colour_plane_id  2  u(2) \n  frame_num  2  u(v) \n  if( !frame_mbs_only_flag ) {     \n    field_pic_flag  2  u(1) \n    if( field_pic_flag )     \n      bottom_field_flag  2  u(1) \n  }     \n  if( idr_flag  = =  1 )     \n    idr_pic_id  2  ue(v) \n    Rec. ITU-T H.264 (06/2019)  449 \n \n  if( pic_order_cnt_type  = =  0 ) {     \n    pic_order_cnt_lsb  2  u(v) \n    if( bottom_field_pic_order_in_frame_present_flag  &&  !field_pic_flag )     \n      delta_pic_order_cnt_bottom  2  se(v) \n  }     \n  if( pic_order_cnt_type  = =  1  &&  !delta_pic_order_always_zero_flag ) {     \n    delta_pic_order_cnt[ 0 ]  2  se(v) \n    if( bottom_field_pic_order_in_frame_present_flag  &&  !field_pic_flag )     \n      delta_pic_order_cnt[ 1 ]  2  se(v) \n  }     \n  if( redundant_pic_cnt_present_flag )     \n    redundant_pic_cnt  2  ue(v) \n  if( quality_id  = =  0 ) {     \n    if( slice_type  = =  EB )     \n      direct_spatial_mv_pred_flag  2  u(1) \n    if( slice_type  = =  EP  | |  slice_type  = =  EB ) {     \n      num_ref_idx_active_override_flag  2  u(1) \n      if( num_ref_idx_active_override_flag ) {     \n        num_ref_idx_l0_active_minus1  2  ue(v) \n        if( slice_type  = =  EB )     \n          num_ref_idx_l1_active_minus1  2  ue(v) \n      }     \n    }     \n    ref_pic_list_modification( )  2   \n    if( ( weighted_pred_flag  &&  slice_type = = EP  )  | |     \n      ( weighted_bipred_idc  = =  1  &&  slice_type  = =  EB ) ) { \n      if( !no_inter_layer_pred_flag )     \n        base_pred_weight_table_flag  2  u(1) \n      if( no_inter_layer_pred_flag  | |  !base_pred_weight_table_flag )     \n        pred_weight_table( )  2   \n    }     \n    if( nal_ref_idc  !=  0 ) {     \n      dec_ref_pic_marking( )  2   \n      if( !slice_header_restriction_flag ) {     \n        store_ref_base_pic_flag  2  u(1) \n        if( ( use_ref_base_pic_flag  | |  store_ref_base_pic_flag )  &&     \n              !idr_flag )  \n          dec_ref_base_pic_marking( )  2   \n      }     \n    }     \n  }     \n  if( entropy_coding_mode_flag  &&  slice_type  !=  EI )     \n    cabac_init_idc  2  ue(v) \n  slice_qp_delta  2  se(v) \n  if( deblocking_filter_control_present_flag ) {     \n    disable_deblocking_filter_idc  2  ue(v) \n    if( disable_deblocking_filter_idc  !=  1 ) {     \n      slice_alpha_c0_offset_div2  2  se(v) \n      slice_beta_offset_div2  2  se(v) \n450  Rec. ITU-T H.264 (06/2019) \n \n    }     \n  }     \n  if( num_slice_groups_minus1 > 0  &&     \n    slice_group_map_type  >=  3  &&  slice_group_map_type  <=  5 ) \n    slice_group_change_cycle  2  u(v) \n  if( !no_inter_layer_pred_flag  &&  quality_id  = =  0 ) {     \n    ref_layer_dq_id  2  ue(v) \n    if( inter_layer_deblocking_filter_control_present_flag ) {     \n      disable_inter_layer_deblocking_filter_idc  2  ue(v) \n      if( disable_inter_layer_deblocking_filter_idc  !=  1 ) {     \n        inter_layer_slice_alpha_c0_offset_div2  2  se(v) \n        inter_layer_slice_beta_offset_div2  2  se(v) \n      }     \n    }     \n    constrained_intra_resampling_flag  2  u(1) \n    if( extended_spatial_scalability_idc  = =  2 ) {     \n      if( ChromaArrayType > 0 ) {     \n        ref_layer_chroma_phase_x_plus1_flag  2  u(1) \n        ref_layer_chroma_phase_y_plus1  2  u(2) \n      }     \n      scaled_ref_layer_left_offset  2  se(v) \n      scaled_ref_layer_top_offset  2  se(v) \n      scaled_ref_layer_right_offset  2  se(v) \n      scaled_ref_layer_bottom_offset  2  se(v) \n    }     \n  }     \n  if( !no_inter_layer_pred_flag ) {     \n    slice_skip_flag  2  u(1) \n    if( slice_skip_flag )     \n      num_mbs_in_slice_minus1  2  ue(v) \n    else {     \n      adaptive_base_mode_flag  2  u(1) \n      if( !adaptive_base_mode_flag )     \n        default_base_mode_flag  2  u(1) \n      if( !default_base_mode_flag ) {     \n        adaptive_motion_prediction_flag  2  u(1) \n        if( !adaptive_motion_prediction_flag )     \n          default_motion_prediction_flag  2  u(1) \n      }     \n      adaptive_residual_prediction_flag  2  u(1) \n      if( !adaptive_residual_prediction_flag )     \n        default_residual_prediction_flag  2  u(1) \n    }     \n    if( adaptive_tcoeff_level_prediction_flag )     \n      tcoeff_level_prediction_flag  2  u(1) \n  }     \n  if( !slice_header_restriction_flag  &&  !slice_skip_flag ) {     \n    scan_idx_start  2  u(4) \n    scan_idx_end  2  u(4) \n    Rec. ITU-T H.264 (06/2019)  451 \n \n  }     \n}     \n \nG.7.3.3.5  Decoded reference base picture marking syntax \n \ndec_ref_base_pic_marking( ) {  C  Descriptor \n  adaptive_ref_base_pic_marking_mode_flag  2  u(1) \n  if( adaptive_ref_base_pic_marking_mode_flag )     \n    do {     \n      memory_management_base_control_operation  2  ue(v) \n      if( memory_management_base_control_operation  = =  1 )     \n        difference_of_base_pic_nums_minus1  2  ue(v) \n      if( memory_management_base_control_operation  = =  2  )     \n        long_term_base_pic_num  2  ue(v) \n    } while( memory_management_base_control_operation  !=  0 )     \n}     \n \nG.7.3.4  Slice data syntax \nThe syntax table is specified in clause 7.3.4. \n452  Rec. ITU-T H.264 (06/2019) \n \nG.7.3.4.1  Slice data in scalable extension syntax \n \nslice_data_in_scalable_extension( ) {  C  Descriptor \n  if( entropy_coding_mode_flag)     \n    while( !byte_aligned( ) )     \n      cabac_alignment_one_bit  2  f(1) \n  CurrMbAddr = first_mb_in_slice * ( 1 + MbaffFrameFlag )     \n  moreDataFlag = 1     \n  prevMbSkipped = 0     \n  do {     \n    if( slice_type  !=  EI )     \n      if( !entropy_coding_mode_flag ) {     \n        mb_skip_run  2  ue(v) \n        prevMbSkipped = ( mb_skip_run > 0 )     \n        for( i = 0; i < mb_skip_run; i++ )     \n          CurrMbAddr = NextMbAddress( CurrMbAddr )     \n        if( mb_skip_run > 0 )     \n          moreDataFlag = more_rbsp_data( )     \n      } else {     \n        mb_skip_flag  2  ae(v) \n        moreDataFlag = !mb_skip_flag     \n      }     \n    if( moreDataFlag )  {     \n      if( MbaffFrameFlag  &&  ( ( CurrMbAddr % 2 )  = =  0  | |     \n        ( ( CurrMbAddr % 2 )  = =  1  &&  prevMbSkipped ) ) ) \n        mb_field_decoding_flag  2  u(1) | ae(v) \n      macroblock_layer_in_scalable_extension( )  2 | 3 | 4   \n    }     \n    if( !entropy_coding_mode_flag )     \n      moreDataFlag = more_rbsp_data( )     \n    else {     \n      if( slice_type  !=  EI )     \n        prevMbSkipped = mb_skip_flag     \n      if( MbaffFrameFlag  &&  ( CurrMbAddr % 2 )  = =  0 )     \n        moreDataFlag = 1     \n      else {     \n        end_of_slice_flag  2  ae(v) \n        moreDataFlag = !end_of_slice_flag     \n      }     \n    }     \n    CurrMbAddr = NextMbAddress( CurrMbAddr )     \n  } while( moreDataFlag )     \n}     \n \nG.7.3.5  Macroblock layer syntax \nThe syntax table is specified in clause 7.3.5. \nG.7.3.5.1  Macroblock prediction syntax \nThe syntax table is specified in clause 7.3.5.1. \n    Rec. ITU-T H.264 (06/2019)  453 \n \nG.7.3.5.2  Sub-macroblock prediction syntax \nThe syntax table is specified in clause 7.3.5.2. \nG.7.3.5.3  Residual data syntax \nThe syntax table is specified in clause 7.3.5.3. \nG.7.3.5.3.1  Residual luma syntax \nThe syntax table is specified in clause 7.3.5.3.1. \nG.7.3.5.3.2  Residual block CAVLC syntax \nThe syntax table is specified in clause 7.3.5.3.2. \nG.7.3.5.3.3  Residual block CABAC syntax \nThe syntax table is specified in clause 7.3.5.3.3. \nG.7.3.6  Macroblock layer in scalable extension syntax \n \nmacroblock_layer_in_scalable_extension( ) {  C  Descriptor \n  if( InCropWindow( CurrMbAddr )  &&  adaptive_base_mode_flag )     \n    base_mode_flag  2  u(1) | ae(v) \n  if( !base_mode_flag)     \n    mb_type  2  ue(v) | ae(v) \n  if( mb_type  = =  I_PCM ) {     \n    while( !byte_aligned( ) )     \n      pcm_alignment_zero_bit  3  f(1) \n    for( i = 0; i < 256; i++ )     \n      pcm_sample_luma[ i ]  3  u(v) \n    for( i = 0; i < 2 * MbWidthC * MbHeightC; i++ )     \n      pcm_sample_chroma[ i ]  3  u(v) \n  } else {     \n    if( !base_mode_flag )  {     \n      noSubMbPartSizeLessThan8x8Flag = 1     \n      if( mb_type  !=  I_NxN  &&     \n        MbPartPredMode( mb_type, 0 )  !=  Intra_16x16  && \n        NumMbPart( mb_type )  = =  4 ) { \n        sub_mb_pred_in_scalable_extension( mb_type )  2   \n        for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n          if( sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8 ) {     \n            if( NumSubMbPart( sub_mb_type[ mbPartIdx ] ) > 1 )     \n              noSubMbPartSizeLessThan8x8Flag = 0     \n          } else if( !direct_8x8_inference_flag )     \n            noSubMbPartSizeLessThan8x8Flag = 0     \n      } else {     \n        if( transform_8x8_mode_flag  &&  mb_type  = =  I_NxN )     \n          transform_size_8x8_flag  2  u(1) | ae(v) \n        mb_pred_in_scalable_extension( mb_type )  2   \n      }     \n    }     \n454  Rec. ITU-T H.264 (06/2019) \n \n    if( adaptive_residual_prediction_flag  &&  slice_type  !=  EI  &&     \n      InCropWindow( CurrMbAddr )  && \n      ( base_mode_flag  | | \n        ( MbPartPredMode( mb_type, 0 )  !=  Intra_16x16  && \n        MbPartPredMode( mb_type, 0 )  !=  Intra_8x8  && \n        MbPartPredMode( mb_type, 0 )  !=  Intra_4x4 ) ) ) \n      residual_prediction_flag  2  u(1) | ae(v) \n    if( scan_idx_end >= scan_idx_start ) {     \n      if( base_mode_flag  | |     \n        MbPartPredMode( mb_type, 0 )  !=  Intra_16x16 ) { \n        coded_block_pattern  2  me(v) | ae(v) \n        if( CodedBlockPatternLuma > 0  &&     \n           transform_8x8_mode_flag  && \n          ( base_mode_flag  | | \n            ( mb_type  !=  I_NxN  && \n              noSubMbPartSizeLessThan8x8Flag  && \n              ( mb_type  !=  B_Direct_16x16  | | \n                direct_8x8_inference_flag ) ) ) ) \n          transform_size_8x8_flag  2  u(1) | ae(v) \n      }     \n      if( CodedBlockPatternLuma > 0  | |     \n         CodedBlockPatternChroma > 0  | | \n         MbPartPredMode( mb_type, 0 )  = =  Intra_16x16 )  { \n        mb_qp_delta  2  se(v) | ae(v) \n        residual( scan_idx_start, scan_idx_end )  3 | 4   \n      }     \n    }     \n  }     \n}     \n \nG.7.3.6.1  Macroblock prediction in scalable extension syntax \n \nmb_pred_in_scalable_extension( mb_type ) {  C  Descriptor \n  if( MbPartPredMode( mb_type, 0 )  = =  Intra_4x4  | |       \n    MbPartPredMode( mb_type, 0 )  = =  Intra_8x8  | |   \n    MbPartPredMode( mb_type, 0 )  = =  Intra_16x16 ) { \n    if( MbPartPredMode( mb_type, 0 )  = =  Intra_4x4 )     \n      for( luma4x4BlkIdx = 0; luma4x4BlkIdx < 16; luma4x4BlkIdx++ ) {     \n        prev_intra4x4_pred_mode_flag[ luma4x4BlkIdx ]  2  u(1) | ae(v) \n        if( !prev_intra4x4_pred_mode_flag[ luma4x4BlkIdx ] )     \n          rem_intra4x4_pred_mode[ luma4x4BlkIdx ]  2  u(3) | ae(v) \n      }     \n    if( MbPartPredMode( mb_type, 0 )  = =  Intra_8x8 )     \n      for( luma8x8BlkIdx = 0; luma8x8BlkIdx < 4; luma8x8BlkIdx++ ) {     \n        prev_intra8x8_pred_mode_flag[ luma8x8BlkIdx ]  2  u(1) | ae(v) \n        if( !prev_intra8x8_pred_mode_flag[ luma8x8BlkIdx ] )     \n          rem_intra8x8_pred_mode[ luma8x8BlkIdx ]  2  u(3) | ae(v) \n      }     \n    if( ChromaArrayType  !=  0 )     \n      intra_chroma_pred_mode  2  ue(v) | ae(v) \n  } else if( MbPartPredMode( mb_type, 0 )  !=  Direct ) {     \n    if( InCropWindow( CurrMbAddr )  &&     \n              adaptive_motion_prediction_flag ) { \n    Rec. ITU-T H.264 (06/2019)  455 \n \n      for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++ )     \n        if( MbPartPredMode( mb_type, mbPartIdx )  !=  Pred_L1 )     \n          motion_prediction_flag_l0[ mbPartIdx ]  2  u(1) | ae(v) \n      for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++ )     \n        if( MbPartPredMode( mb_type, mbPartIdx )  !=  Pred_L0 )     \n          motion_prediction_flag_l1[ mbPartIdx ]  2  u(1) | ae(v) \n    }     \n    for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++ )     \n      if( ( num_ref_idx_l0_active_minus1 > 0  | |     \n           mb_field_decoding_flag  !=  field_pic_flag )  && \n        MbPartPredMode( mb_type, mbPartIdx )  !=  Pred_L1  && \n        !motion_prediction_flag_l0[ mbPartIdx ]  ) \n        ref_idx_l0[ mbPartIdx ]  2  te(v) | ae(v) \n    for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++ )     \n      if( ( num_ref_idx_l1_active_minus1 > 0  | |     \n           mb_field_decoding_flag  !=  field_pic_flag )  && \n        MbPartPredMode( mb_type, mbPartIdx )  !=  Pred_L0  && \n        !motion_prediction_flag_l1[ mbPartIdx ] ) \n        ref_idx_l1[ mbPartIdx ]  2  te(v) | ae(v) \n    for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++ )     \n      if( MbPartPredMode ( mb_type, mbPartIdx )  !=  Pred_L1 )     \n        for( compIdx = 0; compIdx < 2; compIdx++ )     \n          mvd_l0[ mbPartIdx ][ 0 ][ compIdx ]  2  se(v) | ae(v) \n    for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++ )     \n      if( MbPartPredMode( mb_type, mbPartIdx )  !=  Pred_L0 )     \n        for( compIdx = 0; compIdx < 2; compIdx++ )     \n          mvd_l1[ mbPartIdx ][ 0 ][ compIdx ]  2  se(v) | ae(v) \n  }     \n}     \n456  Rec. ITU-T H.264 (06/2019) \n \nG.7.3.6.2  Sub-macroblock prediction in scalable extension syntax \n \nsub_mb_pred_in_scalable_extension( mb_type ) {  C  Descriptor \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )       \n    sub_mb_type[ mbPartIdx ]  2  ue(v) | ae(v) \n  if( InCropWindow( CurrMbAddr )  &&  adaptive_motion_prediction_flag ) {     \n    for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n      if( SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Direct  &&     \n        SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L1 ) \n        motion_prediction_flag_l0[ mbPartIdx ]  2  u(1) | ae(v) \n    for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n      if( SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Direct  &&     \n        SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L0 ) \n        motion_prediction_flag_l1[ mbPartIdx ]  2  u(1) | ae(v) \n  }     \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )       \n    if( ( num_ref_idx_l0_active_minus1 > 0  | |     \n         mb_field_decoding_flag  !=  field_pic_flag )  && \n      mb_type  !=  P_8x8ref0  && \n      sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8  && \n      SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L1  && \n      !motion_prediction_flag_l0[ mbPartIdx ] ) \n      ref_idx_l0[ mbPartIdx ]  2  te(v) | ae(v) \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )       \n    if( ( num_ref_idx_l1_active_minus1 > 0  | |     \n         mb_field_decoding_flag  !=  field_pic_flag )  && \n      sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8  && \n      SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L0  && \n      !motion_prediction_flag_l1[ mbPartIdx ] ) \n      ref_idx_l1[ mbPartIdx ]  2  te(v) | ae(v) \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )       \n    if( sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8  &&     \n      SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L1 ) \n      for( subMbPartIdx = 0;      \n           subMbPartIdx < NumSubMbPart( sub_mb_type[ mbPartIdx ] ); \n           subMbPartIdx++ ) \n        for( compIdx = 0; compIdx < 2; compIdx++ )     \n          mvd_l0[ mbPartIdx ][ subMbPartIdx ][ compIdx ]  2  se(v) | ae(v) \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )       \n    if( sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8  &&     \n      SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L0 ) \n      for( subMbPartIdx = 0;      \n           subMbPartIdx < NumSubMbPart( sub_mb_type[ mbPartIdx ] ); \n           subMbPartIdx++ ) \n        for( compIdx = 0; compIdx < 2; compIdx++ )     \n          mvd_l1[ mbPartIdx ][ subMbPartIdx ][ compIdx ]  2  se(v) | ae(v) \n}     \n \nG.7.4  Semantics \nSemantics associated with the syntax structures and syntax elements within these structures (in  clause G.7.3 and in \nclause 7.3 by reference in clause G.7.3) are specified in this clause and by reference to clause 7.4. When the semantics of \na syntax element are specified using a table or a set of tables, any values that are not specified in the table(s) shall not be \npresent in the bitstream unless otherwise specified in this Recommendation | International Standard. \nSub-bitstreams that are derived according to the process specified in clause G.8.8.1 shall conform to one or more of the \nprofiles specified in Annex A or one or more of the profiles specified in this annex. \n    Rec. ITU-T H.264 (06/2019)  457 \n \nOne or more sub-bitstreams shall conform to one or more of the profiles specified in Annex A. The decoding for these sub-\nbitstreams is specified in clauses 2 to 9 and Annexes B to E. \nThe decoding for bitstreams conforming to one or more of the profiles specified in this annex is completely specified in \nthis annex with reference made to clauses 2 to 9 and Annexes B to E. \nA specification or a process in clauses 2 to 9 and Annexes B to E may be used as is or by specifying assignments or \nalternative meanings of certain parts. \nThis clause describes the semantics of syntax elements. The syntax elements appear multiple times in the bitstream and in \neach access unit. The meaning of each syntax element and derived variables depends on the position of the syntax structure \nin the bitstream in which it is contained. A decoder conforming to this Recommendation | International Standard processes \nthe syntax structures in decoding order and determines the semantics according to the position derived from that. \nG.7.4.1  NAL unit semantics \nThe  semantics  for  the  syntax  elements  in  clause G.7.3.1  are  specified  in  clause 7.4.1.  The  following  specifications \nadditionally apply. \nFor NAL units with nal_unit_type equal to 14, nal_ref_idc shall be identical to nal_ref_idc of the associated NAL unit, \nwhich succeeds the NAL unit with nal_unit_type equal to 14 in decoding order. \nThe value of nal_ref_idc shall be the same for all VCL NAL units of a dependency representation. \nThe variable refNalRefIdc is derived as follows: \n–  If nal_unit_type is not equal to 20 or dependency_id is equal to the minimum value of dependency_id for all VCL \nNAL units of the coded picture, refNalRefIdc is set equal to 0. \n–  Otherwise (nal_unit_type is equal to 20 and dependency_id is not equal to the minimum value of dependency_id for \nall VCL NAL units of the coded picture), refNalRefIdc is set equal to the maximum value of nal_ref_idc for all VCL \nNAL units of the coded picture with a value of dependency_id less than the current value of dependency_id. \nWhen refNalRefIdc is greater than 0, the value of nal_ref_idc shall not be equal to 0. \nnal_ref_idc equal to 0 for a NAL unit containing a slice and having a value of dependency_id that is equal to the maximum \nvalue of dependency_id in the coded picture indicates that all coded slice NAL units of the coded picture are coded slice \nNAL units of a non-reference picture. \nnal_ref_idc greater than 0 for a NAL unit containing a slice and having a value of dependency_id that is equal to the \nmaximum value of dependency_id in the coded picture indicates that all coded slice NAL units of the coded picture are \ncoded slice NAL units of a reference picture. \nG.7.4.1.1  NAL unit header SVC extension semantics \nThe  syntax  elements  idr_flag,  priority_id,  no_inter_layer_pred_flag,  dependency_id,  quality_id,  temporal_id, \nuse_ref_base_pic_flag, discardable_flag, and output_flag, when present in a prefix NAL unit, are considered as if they \nwere present in the associated NAL unit. \nidr_flag equal to 1 specifies that the current coded picture is an IDR picture when the value of dependency_id for the NAL \nunit is equal to the maximum value of dependency_id in the coded picture. idr_flag equal to 0 specifies that the current \ncoded picture is not an IDR picture when the value of dependency_id for the NAL unit is equal to the maximum value of \ndependency_id  in  the  coded  picture.  The  value  of  idr_flag  shall  be  the  same  for  all  NAL  units  of  a  dependency \nrepresentation. \nNOTE 1 – The classification of a coded picture as IDR picture and the partitioning of a sequence of access units in coded video \nsequences depends on the maximum value of dependency_id that is present in the associated NAL units. When NAL units are \nremoved from a bitstream, e.g. in order to adjust the bitstream to the capabilities of a receiving device, the maximum value of \ndependency_id in the coded pictures may change and hence the classification of coded pictures as IDR pictures may change and \nwith that the partitioning of the sequence of access units into coded video sequences may change. \nWhen idr_flag is equal to 1 for a prefix NAL unit, the associated NAL unit shall have nal_unit_type equal to 5. When \nidr_flag is equal to 0 for a prefix NAL unit, the associated NAL unit shall have nal_unit_type equal to 1. \nWhen nal_ref_idc is equal to 0, the value of idr_flag shall be equal to 0. \nFor NAL units, in which idr_flag is present, the variable IdrPicFlag derived in clause 7.4.1 is modified by setting it equal \nto idr_flag. \npriority_id specifies a priority identifier for the NAL unit. The assignment of values to priority_id is constrained by the \nsub-bitstream extraction process as specified in clause G.8.8.1. \n458  Rec. ITU-T H.264 (06/2019) \n \nNOTE 2  –  The  syntax  element  priority_id  is  not  required  by  the  decoding  process  specified  in  this \nRecommendation | International Standard. The syntax element priority_id may be used as determined by the application within the \nspecified constraints. \nno_inter_layer_pred_flag specifies whether inter-layer prediction may be used for decoding the coded slice. When \nno_inter_layer_pred_flag  is  equal  to 1,  inter-layer  prediction  is  not  used  for  decoding  the  coded  slice.  When \nno_inter_layer_pred_flag is equal to 0, inter-layer prediction may be used for decoding the coded slice as signalled in the \nmacroblock layer. \nFor prefix NAL units, no_inter_layer_pred_flag shall be equal to 1. When nal_unit_type is equal to 20 and quality_id is \ngreater than 0, no_inter_layer_pred_flag shall be equal to 0. \nThe variable MinNoInterLayerPredFlag is set equal to the minimum value of no_inter_layer_pred_flag for the slices of the \nlayer representation. \ndependency_id specifies a dependency identifier for the NAL unit. dependency_id shall be equal to 0 in prefix NAL units. \nThe  assignment  of  values  to  dependency_id  is  constrained  by  the  sub-bitstream  extraction  process  as  specified  in \nclause G.8.8.1. \nquality_id specifies a quality identifier for the NAL unit. quality_id shall be equal to 0 in prefix NAL units. The assignment \nof values to quality_id is constrained by the sub-bitstream extraction process as specified in clause G.8.8.1. \nThe variable DQId is derived by \nDQId = ( dependency_id << 4 ) + quality_id  (G-63) \nWhen nal_unit_type is equal to 20, the bitstream shall not contain data that result in DQId equal to 0. \ntemporal_id specifies a temporal identifier for the NAL unit. The assignment of values to temporal_id is constrained by \nthe sub-bitstream extraction process as specified in clause G.8.8.1. \nThe value of temporal_id shall be the same for all prefix NAL units and coded slice in scalable extension NAL units of an \naccess unit. When an access unit contains any NAL unit with nal_unit_type equal to 5 or idr_flag equal to 1, temporal_id \nshall be equal to 0. \nuse_ref_base_pic_flag equal to 1 specifies that  reference base pictures (when present) and decoded pictures (when \nreference base pictures are not present) are used as reference pictures for inter prediction as specified in clause G.8.2.3. \nuse_ref_base_pic_flag equal to 0 specifies that reference base pictures are not used as reference pictures for inter prediction \n(i.e., only decoded pictures are used for inter prediction). \nThe values of use_ref_base_pic_flag shall be the same for all NAL units of a dependency representation. \ndiscardable_flag equal to 1 specifies that the current NAL unit is not used for decoding dependency representations that \nare part of the current coded picture or any subsequent coded picture in decoding order and have a greater value of \ndependency_id than the current NAL unit. discardable_flag equal to 0 specifies that the current NAL unit may be used for \ndecoding dependency representations that are part of the current coded picture or any subsequent coded picture in decoding \norder and have a greater value of dependency_id than the current NAL unit. \noutput_flag affects the decoded picture output and removal processes as specified in Annex C. The value of output_flag \nshall be the same for all NAL units of a dependency representation. For any particular value of dependency_id, the value \nof output_flag shall be the same for both fields of a complementary field pair. \nreserved_three_2bits shall be equal to 3. Other values of reserved_three_2bits may be specified in the future by ITU-T | \nISO/IEC. Decoders shall ignore the value of reserved_three_2bits. \nG.7.4.1.2  Order of NAL units and association to coded pictures, access units, and video sequences \nThis clause specifies constraints on the order of NAL units in the bitstream. Any order of NAL units in the bitstream \nobeying these constraints is referred to in the text as the decoding order of NAL units. Within a NAL unit, the syntax in \nclauses 7.3, D.1, E.1, G.7.3, G.13.1, and G.14.1 specifies the decoding order of syntax elements. Decoders shall be capable \nof receiving NAL units and their syntax elements in decoding order. \nG.7.4.1.2.1  Order of SVC sequence parameter set RBSPs and picture parameter set RBSPs and their activation \nNOTE 1 – The sequence and picture parameter set mechanism decouples the transmission of infrequently changing information \nfrom the transmission of coded macroblock data. Sequence and picture parameter sets may, in some applications, be conveyed \"out-\nof-band\" using a reliable transport mechanism. \nA picture parameter set RBSP includes parameters that can be referred to by the coded slice NAL units of one or more \nlayer representations of one or more coded pictures. \nEach picture parameter set RBSP is initially considered not active at the start of the operation of the decoding process. At \nmost one picture parameter set RBSP is considered as the active picture parameter set RBSP at any given moment during \n    Rec. ITU-T H.264 (06/2019)  459 \n \nthe operation of the decoding process, and when any particular picture parameter set RBSP becomes the active picture \nparameter set RBSP, the previously-active picture parameter set RBSP (if any) is deactivated. \nIn addition to the active picture parameter set RBSP, zero or more picture parameter set RBSPs may be specifically active \nfor layer representations (with a particular value of DQId less than DQIdMax) that may be referred to through inter-layer \nprediction in decoding the target layer representation. Such a picture parameter set RBSP is referred to as active layer \npicture parameter set RBSP for the particular value of DQId (less than DQIdMax). The restrictions on active picture \nparameter set RBSPs also apply to active layer picture parameter set RBSPs with a particular value of DQId. \nWhen a picture parameter set RBSP (with a particular value of pic_parameter_set_id) is not the active picture parameter \nset  RBSP  and  it  is  referred  to  by  a  coded  slice  NAL  unit  with  DQId  equal  to  DQIdMax  (using  that  value  of \npic_parameter_set_id), it is activated. This picture parameter set RBSP is called the active picture parameter set RBSP \nuntil it is deactivated when another picture parameter set RBSP becomes the active picture parameter set RBSP. A picture \nparameter set RBSP, with that particular value of pic_parameter_set_id, shall be available to the decoding process prior to \nits activation. \nWhen a picture parameter set RBSP (with a particular value of pic_parameter_set_id) is not  the active layer picture \nparameter set for a particular value of DQId less than DQIdMax and it is referred to by a coded slice NAL unit with the \nparticular value of DQId (using that value of pic_parameter_set_id), it is activated for layer representations with the \nparticular value of DQId. This picture parameter set RBSP is called the active layer picture parameter set RBSP for the \nparticular value of DQId until it is deactivated when another picture parameter set RBSP becomes the active layer picture \nparameter set RBSP for the particular value of DQId or when decoding an access unit with DQIdMax less than or equal to \nthe particular value of DQId. A picture parameter set RBSP, with that particular value of pic_parameter_set_id, shall be \navailable to the decoding process prior to its activation. \nAny picture parameter set NAL unit containing the value of pic_parameter_set_id for the active picture parameter set \nRBSP for a coded picture shall have the same content as that of the active picture parameter set RBSP for the coded picture \nunless it follows the last VCL NAL unit of the coded picture and precedes the first VCL NAL unit of another coded picture. \nAny picture parameter set NAL unit containing the value of pic_parameter_set_id for the active layer picture parameter \nset RBSP for a particular value of DQId less than DQIdMax for a coded picture shall have the same content as that of the \nactive layer picture parameter set RBSP for the particular value of DQId for the coded picture unless it follows the last \nVCL NAL unit of the coded picture and precedes the first VCL NAL unit of another coded picture. \nWhen a picture parameter set NAL unit with a particular value of pic_parameter_set_id is received, its content replaces \nthe content of the previous picture parameter set NAL unit, in decoding order, with the same value of pic_parameter_set_id \n(when  a  previous  picture  parameter  set  NAL  unit  with  the  same  value  of  pic_parameter_set_id  was  present  in  the \nbitstream). \nNOTE 2 – A decoder must be capable of simultaneously storing the contents of the picture parameter sets for all values of \npic_parameter_set_id. The content of the picture parameter set with a particular value of pic_parameter_set_id is overwritten when \na new picture parameter set NAL unit with the same value of pic_parameter_set_id is received. \nAn SVC sequence parameter set RBSP includes parameters that can be referred to by one or more picture parameter set \nRBSPs or one or more SEI NAL units containing a buffering period SEI message. \nEach SVC sequence parameter set RBSP is initially considered not active at the start of the operation of the decoding \nprocess. At most one SVC sequence parameter set RBSP is considered as the active SVC sequence parameter set RBSP at \nany given moment during the operation of the decoding process, and when any particular SVC sequence parameter set \nRBSP becomes the active SVC sequence parameter set RBSP, the previously-active SVC sequence parameter set RBSP \n(if any) is deactivated. \nIn addition to the active SVC sequence parameter set RBSP, zero or more SVC sequence parameter set RBSPs may be \nspecifically active for layer representations (with a particular value of DQId less than DQIdMax) that may be referred to \nthrough inter-layer prediction in decoding the target layer representation. Such an SVC sequence parameter set RBSP is \nreferred to as active layer SVC sequence parameter set RBSP for the particular value of DQId (less than DQIdMax). The \nrestrictions on active SVC sequence parameter set RBSPs also apply to active layer SVC sequence parameter set RBSPs \nwith a particular value of DQId. \nFor the following specification in this clause, the activating buffering period SEI message is specified as follows: \n–  If the access unit contains one or more buffering period SEI messages that are included in a scalable nesting SEI \nmessage  and  are  associated  with  values  of  DQId  in  the  range  of  ( ( DQIdMax >> 4) << 4)  to \n( ( ( DQIdMax >> 4 ) << 4 ) + 15), inclusive, the last of these buffering period SEI messages in decoding order is the \nactivating buffering period SEI message. \n–  Otherwise, if DQIdMax is equal to 0 and the access unit contains a buffering period SEI message that is not included \nin a scalable nesting SEI message, this buffering period SEI message is the activating buffering period SEI message. \n–  Otherwise, the access unit does not contain an activating buffering period SEI message. \n460  Rec. ITU-T H.264 (06/2019) \n \nWhen a sequence parameter set RBSP (nal_unit_type is equal to 7) with a particular value of seq_parameter_set_id is not \nalready the active SVC sequence parameter set RBSP and it is referred to by activation of a picture parameter set RBSP \n(using that value of seq_parameter_set_id) and the picture parameter set RBSP is activated by a coded slice NAL unit with \nnal_unit_type equal to 1 or 5 (the picture parameter set RBSP becomes the active picture parameter set RBSP and \nDQIdMax is equal to 0) and the access unit does not contain an activating buffering period SEI message, the sequence \nparameter set RBSP is activated. This sequence parameter set RBSP, is called the active SVC sequence parameter set \nRBSP until it is deactivated when another SVC sequence parameter set RBSP becomes the active SVC sequence parameter \nset RBSP. A sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be available to the \ndecoding process prior to its activation. \nWhen a sequence parameter set RBSP (nal_unit_type is equal to 7) with a particular value of seq_parameter_set_id is not \nalready the active SVC sequence parameter set RBSP and it is referred to by an activating buffering period SEI message \n(using that value of seq_parameter_set_id) that is not included in a scalable nesting SEI message (DQIdMax is equal to 0), \nthe sequence parameter set RBSP is activated. This sequence parameter set RBSP is called the active SVC sequence \nparameter set RBSP until it is deactivated when another SVC sequence parameter set RBSP becomes the active SVC \nsequence parameter set RBSP. A sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall \nbe available to the decoding process prior to its activation. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active SVC sequence parameter set RBSP and it is referred to by activation of a picture parameter set \nRBSP (using that value of seq_parameter_set_id) and the picture parameter set RBSP is activated by a coded slice in \nscalable extension NAL unit (nal_unit_type is equal to 20) with DQId equal to DQIdMax (the picture parameter set RBSP \nbecomes the active picture parameter set RBSP) and the access unit does not contain an activating buffering period SEI \nmessage, the subset sequence parameter set RBSP is activated. This subset sequence parameter set RBSP is called the \nactive SVC sequence parameter set RBSP until it is deactivated when another SVC sequence parameter set RBSP becomes \nthe active SVC sequence parameter set RBSP. A subset sequence parameter set RBSP, with that particular value of \nseq_parameter_set_id, shall be available to the decoding process prior to its activation. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active SVC sequence parameter set RBSP and it is referred to by an activating buffering period SEI \nmessage (using that value of seq_parameter_set_id) that is included in a scalable nesting SEI message, the subset sequence \nparameter set RBSP is activated. This subset sequence parameter set RBSP, is called the active SVC sequence parameter \nset RBSP until it is deactivated when another SVC sequence parameter set RBSP becomes the active SVC sequence \nparameter set RBSP. A subset sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be \navailable to the decoding process prior to its activation. \nNOTE 3 – The active SVC sequence parameter set RBSP is either a sequence parameter set RBSP or a subset sequence parameter \nset RBSP. Sequence parameter set RBSPs are activated by coded slice NAL units with nal_unit_type equal to 1 or 5 or buffering \nperiod SEI messages that are not included in a scalable nesting SEI message. Subset sequence parameter set RBSPs are activated by \ncoded slice in scalable extension NAL units (nal_unit_type equal to 20) or buffering period SEI messages that are included in a \nscalable nesting SEI message. A sequence parameter set RBSP and a subset sequence parameter set RBSP may have the same value \nof seq_parameter_set_id. \nNOTE 4 – Buffering period SEI messages have a higher priority for activating SVC sequence parameter sets than coded slice NAL \nunits. When an SVC sequence parameter set RBSP is referred to by activation of a picture parameter set RBSP inside a particular \naccess unit and this picture parameter set RBSP is activated by a coded slice NAL unit with DQId equal to DQIdMax (the picture \nparameter set RBSP becomes the active picture parameter set RBSP) and this particular access unit also contains an activating \nbuffering period SEI message that refers to an SVC sequence parameter set RBSP that is different than the SVC sequence parameter \nset RBSP referred to by the activation of the picture parameter set RBSP, the SVC sequence parameter set RBSP that is referred to \nby the activating buffering period SEI message becomes the active SVC sequence parameter set. \nNOTE 5 – Compared to the specifications for profiles specified in Annex A, where an activated sequence parameter set RBSP must \nremain active for the entire coded video sequence, the specification for profiles specified in this annex differs. When an SVC \nsequence parameter set RBSP is already active (as the active SVC sequence parameter set RBSP), another SVC sequence parameter \nset RBSP becomes the active SVC sequence parameter set RBSP in a non-IDR access unit when it is referred to by an activating \nbuffering period SEI message or by the activation of a picture parameter set RBSP (as the active picture parameter set RBSP). In \nthis case, the contents of the de-activated and activated SVC sequence parameter set RBSP are mutually restricted as described \nbelow. Hence, within a coded video sequence, multiple successively activated/de-activated SVC sequence parameter set RBSPs can \nbe present. \nFor the following specification in this clause, the activating layer buffering period SEI message for a particular value of \nDQId is specified as follows: \n–  If the access unit contains a buffering period SEI messages that is included in a scalable nesting SEI message and is \nassociated with the particular value of DQId, this buffering period SEI message is the activating layer buffering period \nSEI message for the particular value of DQId. \n–  Otherwise, if the particular value of DQId is equal to 0 and the access unit contains a buffering period SEI message \nthat is not included in a scalable nesting SEI message, this buffering period SEI message is the activating layer \nbuffering period SEI message for the particular value of DQId. \n    Rec. ITU-T H.264 (06/2019)  461 \n \n–  Otherwise, the access unit does not contain an activating layer buffering period SEI message for the particular value \nof DQId. \nWhen a sequence parameter set RBSP (nal_unit_type is equal to 7) with a particular value of seq_parameter_set_id is not \nalready the active layer SVC sequence parameter set RBSP for DQId equal to 0 and it is referred to by activation of a \npicture parameter set RBSP (using that value of seq_parameter_set_id) and the picture parameter set RBSP is activated by \na coded slice NAL unit with nal_unit_type equal to 1 or 5 and DQIdMax is greater than 0 (the picture parameter set RBSP \nbecomes the active layer picture parameter set RBSP for DQId equal to 0) and the access unit does not contain an activating \nlayer  buffering  period  SEI  message  for  DQId  equal  to  0,  the  sequence  parameter  set  RBSP  is  activated  for  layer \nrepresentations with DQId equal to 0. This sequence parameter set RBSP is called the active layer SVC sequence parameter \nset RBSP for DQId equal to 0 until it is deactivated when another SVC sequence parameter set RBSP becomes the active \nlayer SVC sequence parameter set RBSP for DQId equal to 0 or when decoding an access unit with DQIdMax equal to 0. \nA sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be available to the decoding \nprocess prior to its activation. \nWhen a sequence parameter set RBSP (nal_unit_type is equal to 7) with a particular value of seq_parameter_set_id is not \nalready the active layer SVC sequence parameter set RBSP for DQId equal to 0 and it is referred to by an activating layer \nbuffering period SEI message for DQId equal to 0 (using that value of seq_parameter_set_id) that is not included in a \nscalable nesting SEI message and DQIdMax is greater than 0, the sequence parameter set RBSP is activated for layer \nrepresentations with DQId equal to 0. This sequence parameter set RBSP is called the active layer SVC sequence parameter \nset RBSP for DQId equal to 0 until it is deactivated when another SVC sequence parameter set RBSP becomes the active \nlayer SVC sequence parameter set RBSP for DQId equal to 0 or when decoding an access unit with DQIdMax equal to 0. \nA sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be available to the decoding \nprocess prior to its activation. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active layer SVC sequence parameter set RBSP for a particular value of DQId less than DQIdMax and \nit is referred to by activation of a picture parameter set RBSP (using that value of seq_parameter_set_id) and the picture \nparameter set RBSP is activated by a coded slice in scalable extension NAL unit (nal_unit_type is equal to 20) with the \nparticular value of DQId (the picture parameter set RBSP becomes the active layer picture parameter set RBSP for the \nparticular value of DQId) and the access unit does not contain an activating layer buffering period SEI message for the \nparticular value of DQId, the subset sequence parameter set is activated for layer representations with the particular value \nof DQId. This subset sequence parameter set RBSP is called the active layer SVC sequence parameter set RBSP for the \nparticular value of DQId until it is deactivated when another SVC sequence parameter set RBSP becomes the active layer \nSVC sequence parameter set RBSP for the particular value of DQId or when decoding an access unit with DQIdMax less \nthan or equal to the particular value of DQId. A subset sequence parameter set RBSP, with that particular value of \nseq_parameter_set_id, shall be available to the decoding process prior to its activation. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active layer SVC sequence parameter set RBSP for a particular value of DQId less than DQIdMax and \nit is referred to by an activating layer buffering period SEI message for the particular value of DQId (using that value of \nseq_parameter_set_id) that is included in a scalable nesting SEI message, the subset sequence parameter set RBSP is \nactivated for layer representations with the particular value of DQId. This subset sequence parameter set RBSP is called \nthe active layer SVC sequence parameter set RBSP for the particular value of DQId until it is deactivated when another \nSVC sequence parameter set RBSP becomes the active layer SVC sequence parameter set RBSP for the particular value \nof DQId or when decoding an access unit with DQIdMax less than or equal to the particular value of DQId. A subset \nsequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be available to the decoding \nprocess prior to its activation. \nA sequence parameter set RBSP or a subset sequence parameter set RBSP that includes a value of profile_idc not specified \nin Annex A or G shall not be referred to by activation of a picture parameter set RBSP as the active picture parameter set \nRBSP or as active layer picture parameter set RBSP (using that value of seq_parameter_set_id) or referred to by a buffering \nperiod SEI message (using that value of seq_parameter_set_id). A sequence parameter set RBSP or a subset sequence \nparameter set RBSP including a value of profile_idc not specified in Annex A or G is ignored in the decoding for profiles \nspecified in Annex A or G. \nLet spsA and spsB be two SVC sequence parameter set RBSPs with one of the following properties: \n–  spsA is the SVC sequence parameter set RBSP that is referred to by the coded slice NAL units (via the picture \nparameter set) of a layer representation with a particular value of dependency_id and quality_id equal to 0 and spsB \nis the SVC sequence parameter set RBSP that is referred to by the coded slice NAL units (via the picture parameter \nset) of another layer representation, in the same access unit, with the same value of dependency_id and quality_id \ngreater than 0, \n462  Rec. ITU-T H.264 (06/2019) \n \n–  spsA is the active SVC sequence parameter set RBSP for an access unit and spsB is the SVC sequence parameter set \nRBSP that is referred to by the coded slice NAL units (via the picture parameter set) of the layer representation with \nDQId equal to DQIdMax, \n–  spsA is the active SVC sequence parameter set RBSP for an IDR access unit and spsB is the active SVC sequence \nparameter set RBSP for any non-IDR access unit of the same coded video sequence. \nThe SVC sequence parameter set RBSPs spsA and spsB are restricted with regards to their contents as specified in the \nfollowing. \n–  The values of the syntax elements in the seq_parameter_set_data( ) syntax structure of spsA and spsB may only differ \nfor the following syntax elements and shall be the same otherwise: profile_idc, constraint_setX_flag (with X being \nequal  to  0  to  5,  inclusive),  reserved_zero_2bits,  level_idc,  seq_parameter_set_id,  timing_info_present_flag, \nnum_units_in_tick,  time_scale,  fixed_frame_rate_flag,  nal_hrd_parameters_present_flag, \nvcl_hrd_parameters_present_flag, low_delay_hrd_flag,  pic_struct_present_flag, and the hrd_parameters( ) syntax \nstructures. \n–  When spsA is the active SVC sequence parameter set RBSP and spsB is the SVC sequence parameter set RBSP that \nis referred to by the coded slice NAL units of the layer representation with DQId equal to DQIdMax, the level \nspecified by level_idc (or level_idc and constraint_set3_flag) in spsA shall not be less than the level specified by \nlevel_idc (or level_idc and constraint_set3_flag) in spsB. \n–  When the seq_parameter_set_svc_extension( ) syntax structure is present in both spsA and spsB, the values of all \nsyntax elements in the seq_parameter_set_svc_extension( ) syntax structure shall be the same. \nIt is a requirement of bitstream conformance that the following constraints are obeyed: \n–  For each particular value of DQId, all coded slice NAL units of a coded video sequence shall refer to the same value \nof seq_parameter_set_id (via the picture parameter set RBSP that is referred to by the value of pic_parameter_set_id). \n–  The value of seq_parameter_set_id in a buffering period SEI message that is not included in a scalable nesting SEI \nmessage shall be identical to the value of seq_parameter_set_id in the picture parameter set RBSP that is referred to \nby coded slice NAL units with nal_unit_type equal to 1 or 5 (via the value of pic_parameter_set_id) in the same access \nunit. \n–  The value of seq_parameter_set_id in a buffering period SEI message that is included in a scalable nesting SEI \nmessage and is associated with a particular value of DQId shall be identical to the value of seq_parameter_set_id in \nthe picture parameter set RBSP that is referred to by coded slice NAL units with the particular value of DQId (via the \nvalue of pic_parameter_set_id) in the same access unit. \nThe active layer SVC sequence parameter set RBSPs for different values of DQId may be the same SVC sequence \nparameter set RBSP. The active SVC sequence parameter set RBSP and an active layer SVC sequence parameter set RBSP \nfor a particular value of DQId may be the same SVC sequence parameter set RBSP. \nWhen the active SVC sequence parameter set RBSP for a coded picture is a sequence parameter set RBSP, any sequence \nparameter set RBSP with the value of seq_parameter_set_id for the active SVC sequence parameter set RBSP for the coded \npicture shall have the same content as that of the active SVC sequence parameter set RBSP for the coded picture unless it \nfollows the last access unit of the coded video sequence containing the coded picture and precedes the first VCL NAL unit \nand the first SEI NAL unit containing a buffering period SEI message (when present) of another coded video sequence. \nWhen the active SVC sequence parameter set RBSP for a coded picture is a subset sequence parameter set RBSP, any \nsubset sequence parameter set RBSP with the value of seq_parameter_set_id for the active SVC sequence parameter set \nRBSP for the coded picture shall have the same content as that of the active SVC sequence parameter set RBSP for the \ncoded picture unless it follows the last access unit of the coded video sequence containing the coded picture and precedes \nthe first VCL NAL unit and the first SEI NAL unit containing a buffering period SEI message (when present) of another \ncoded video sequence. \nFor each particular value of DQId, the following applies: \n–  When the active layer SVC sequence parameter set RBSP for a coded picture is a sequence parameter set RBSP, any \nsequence parameter set RBSP with the value of seq_parameter_set_id for the active layer SVC sequence parameter \nset RBSP for the coded picture shall have the same content as that of the active layer SVC sequence parameter set \nRBSP for the coded picture unless it follows the last access unit of the coded video sequence containing the coded \npicture and precedes the first VCL NAL unit and the first SEI NAL unit containing a buffering period SEI message \n(when present) of another coded video sequence. \n–  When the active layer SVC sequence parameter set RBSP for a coded picture is a subset sequence parameter set \nRBSP, any subset sequence parameter set RBSP with the value of seq_parameter_set_id for the active layer SVC \nsequence parameter set RBSP for the coded picture shall have the same content as that of the active layer SVC \n    Rec. ITU-T H.264 (06/2019)  463 \n \nsequence parameter set RBSP for the coded picture unless it follows the last access unit of the coded video sequence \ncontaining the coded picture and precedes the first VCL NAL unit and the first SEI NAL unit containing a buffering \nperiod SEI message (when present) of another coded video sequence. \nNOTE 6 – If picture parameter set RBSP or SVC sequence parameter set RBSP are conveyed within the bitstream, these constraints \nimpose an order constraint on the NAL units that contain the picture parameter set RBSP or SVC sequence parameter set RBSP, \nrespectively. Otherwise (picture parameter set RBSP or SVC sequence parameter set RBSP are conveyed by other means not \nspecified in this Recommendation | International Standard), they must be available to the decoding process in a timely fashion such \nthat these constraints are obeyed. \nWhen a sequence parameter set NAL unit with a particular value of seq_parameter_set_id is received, its content replaces \nthe  content  of  the  previous  sequence  parameter  set  NAL  unit,  in  decoding  order,  with  the  same  value  of \nseq_parameter_set_id (when a previous sequence parameter set NAL unit with the same value of seq_parameter_set_id \nwas  present  in  the  bitstream).  When  a  subset  sequence  parameter  set  NAL  unit  with  a  particular  value  of \nseq_parameter_set_id is received, its content replaces the content of the previous subset sequence parameter set NAL unit, \nin decoding order, with the same value of seq_parameter_set_id (when a previous subset sequence parameter set NAL unit \nwith the same value of seq_parameter_set_id was present in the bitstream). \nNOTE 7 – A decoder must be capable of simultaneously storing the contents of the sequence parameter sets and subset sequence \nparameter sets for all values of seq_parameter_set_id. The content of the sequence parameter set with a particular value of \nseq_parameter_set_id is overwritten when a new sequence parameter set NAL unit with the same value of seq_parameter_set_id is \nreceived, and the content of the subset sequence parameter set with a particular value of seq_parameter_set_id is overwritten when \na new subset sequence parameter set NAL unit with the same value of seq_parameter_set_id is received. \nWhen present, a sequence parameter set extension RBSP includes parameters having a similar function to those of a \nsequence parameter set RBSP. For purposes of establishing constraints on the syntax elements of the sequence parameter \nset extension RBSP and for purposes of determining activation of a sequence parameter set extension RBSP, the sequence \nparameter set extension RBSP shall be considered part of the preceding sequence parameter set RBSP with the same value \nof seq_parameter_set_id. When a sequence parameter set RBSP is present that is not followed by a sequence parameter \nset extension RBSP with the same value of seq_parameter_set_id prior to the activation of the sequence parameter set \nRBSP, the sequence parameter set extension RBSP and its syntax elements shall be considered not present for the active \nSVC sequence parameter set RBSP. The contents of sequence parameter set extension RBSPs only apply when the base \nlayer, which conforms to one or more of the profiles specified in Annex A, of a coded video sequence conforming to one \nor more of the profiles specified in Annex G is decoded. Subset sequence parameter set RBSPs shall not be followed by a \nsequence parameter set extension RBSP. \nNOTE 8 – Sequence parameter sets extension RBSPs are not considered to be part of a subset sequence parameter set RBSP and \nsubset sequence parameter set RBSPs must not be followed by a sequence parameter set extension RBSP. \nFor layer representations with DQId equal to DQIdMax, all constraints that are expressed on the relationship between the \nvalues of the syntax elements (and the values of variables derived from those syntax elements) in SVC sequence parameter \nsets and picture parameter sets and other syntax elements are expressions of constraints that apply only to the active SVC \nsequence parameter set and the active picture parameter set. For layer representations with a particular value of DQId less \nthan DQIdMax, all constraints that are expressed on the relationship between the values of the syntax elements (and the \nvalues of variables derived from those syntax elements) in SVC sequence parameter sets and picture parameter sets and \nother syntax elements are expressions of constraints that apply only to the active layer SVC sequence parameter set and \nthe active layer picture parameter set for the particular value of DQId. If any SVC sequence parameter set RBSP having \nprofile_idc equal to one of the profile_idc values specified in Annex A or G is present that is never activated in the bitstream \n(i.e., it never becomes the active SVC sequence parameter set or an active layer SVC sequence parameter set), its syntax \nelements shall have values that would conform to the specified constraints if it were activated by reference in an otherwise-\nconforming bitstream. If any picture parameter set RBSP is present that is never activated in the bitstream (i.e., it never \nbecomes the active picture parameter set or an active layer picture parameter set), its syntax elements shall have values \nthat would conform to the specified constraints if it were activated by reference in an otherwise-conforming bitstream. \nDuring operation of the decoding process (see clause G.8), for layer representations with DQId equal to DQIdMax, the \nvalues of parameters of the active picture parameter set and the active SVC sequence parameter set shall be considered in \neffect. For layer representations with a particular value of DQId less than DQIdMax, the values of the parameters of the \nactive layer picture parameter set and the active layer SVC sequence parameter set for the particular value of DQId shall \nbe considered in effect. For interpretation of SEI messages that apply to access units or dependency representations with \ndependency_id equal to DependencyIdMax or layer representation with DQId equal to DQIdMax, the values of the \nparameters of the active picture parameter set and the active SVC sequence parameter set for the access unit shall be \nconsidered in effect unless otherwise specified in the SEI message semantics. For interpretation of SEI messages that apply \nto dependency representations with a particular value of dependency_id less than DependencyIdMax, the values of the \nparameters of the active layer picture parameter set and the active layer SVC sequence parameter set for the layer \nrepresentation with DQId equal to ( dependency_id << 4 ) of the access unit shall be considered in effect unless otherwise \nspecified in the SEI message semantics. For interpretation of SEI messages that apply to layer representations with a \nparticular value of DQId less than DQIdMax, the values of the parameters of the active layer picture parameter set and the \nactive layer SVC sequence parameter set for the layer representation with the particular value of DQId of the access unit \nshall be considered in effect unless otherwise specified in the SEI message semantics. \n464  Rec. ITU-T H.264 (06/2019) \n \nG.7.4.1.2.2  Order of access units and association to coded video sequences \nThe specification of clause 7.4.1.2.2 applies with the following modifications. \nThe first access unit of the bitstream shall only contain coded slice NAL units with nal_unit_type equal to 5 or idr_flag \nequal to 1. \nThe order of NAL units and coded pictures and their association to access units is described in clause G.7.4.1.2.3. \nG.7.4.1.2.3  Order of NAL units and coded pictures and association to access units \nThe specification of clause 7.4.1.2.3 applies with the following modifications. \nNOTE – Some bitstreams that conform to one or more profiles specified in this annex do not conform to any profile specified in \nAnnex A  (prior  to  operation  of  the  base  layer  extraction  process  specified  in  clause G.8.8.2).  As  specified  in  clauses 7.4.1 \nand 7.4.1.2.3, for the profiles specified in Annex A, NAL units with nal_unit_type equal to 20 are classified as non-VCL NAL units \nthat must be preceded within each access unit by at least one NAL unit with nal_unit_type in the range of 1 to 5, inclusive. For this \nreason, any bitstream that conforms to one or more profiles specified in this annex does not conform to any profile specified in \nAnnex A when it contains any of the following: \n–  any access unit that does not contain any NAL units with nal_unit_type equal to 1 or 5, but contains one or more NAL units \nwith nal_unit_type equal to 6, 7, 8, 9, or 15; \n–  any access unit in which one or more NAL units with nal_unit_type equal to 7, 8, or 15 is present after the last NAL unit in the \naccess unit with nal_unit_type equal to 1 or 5. \nThe association of VCL NAL units to primary or redundant coded pictures is specified in clause G.7.4.1.2.5. When the \nprimary coded picture does not contain a layer representation with a particular value of DQId, all redundant coded pictures \n(when present) in the same access unit shall not contain a layer representation with the particular value of DQId. \nThe constraints for the detection of the first VCL NAL unit of a primary coded picture are specified in clause G.7.4.1.2.4. \nThe constraint expressed in clause 7.4.1.2.3 on the order of a buffering period SEI message is replaced by the following \nconstraints. \n–  When an SEI NAL unit containing a buffering period SEI message is present, the following applies: \n–  If the buffering period SEI message is the only buffering period SEI message in the access unit and it is not \nincluded in a scalable nesting SEI message, the buffering period SEI message shall be the first SEI message \npayload of the first SEI NAL unit in the access unit. \n–  Otherwise (the buffering period SEI message is not the only buffering period SEI message in the access unit or \nit is included in a scalable nesting SEI message), the following constraints are specified: \n–  When a buffering period SEI message that is not included in a scalable nesting SEI message is present, this \nbuffering period SEI message shall be the only SEI message payload of the first SEI NAL unit in the access \nunit. \n–  A scalable nesting SEI message that includes a buffering period SEI message shall not include any other \nSEI messages and the scalable nesting SEI message that includes a buffering period SEI message shall be \nthe only SEI message inside an SEI NAL unit. \n–  All SEI NAL units that precede an SEI NAL unit that contains a scalable nesting SEI message with a \nbuffering period SEI message as payload in an access unit shall only contain buffering period SEI messages \nor scalable nesting SEI messages with a buffering period SEI message as payload. \n–  When present, a scalable nesting SEI message with all_layer_representations_in_au_flag equal to 1 and a \nbuffering period SEI message as payload shall be the first scalable nesting SEI message in an access unit. \n–  Any scalable nesting SEI message  with a buffering period SEI message as  payload that immediately \nprecedes another scalable nesting SEI message with a buffering period SEI message as payload shall have \nvalues of 128 * sei_dependency_id[ i ] + 8 * sei_quality_id[ i ] + sei_temporal_id, for all present i, that are \nless than any of the values of 128 * sei_dependency_id[ i ] + 8 * sei_quality_id[ i ] + sei_temporal_id in the \nimmediately following scalable nesting SEI message with a buffering period SEI message as payload. \nThe following additional constraints shall be obeyed: \n–  Each NAL unit with nal_unit_type equal to 1 or 5 shall be immediately preceded by a prefix NAL unit. \n–  In  bitstreams  conforming  to  this  Recommendation | International Standard,  each  prefix  NAL  unit  shall  be \nimmediately followed by a NAL unit with nal_unit_type equal to 1 or 5. \nG.7.4.1.2.4  Detection of the first VCL NAL unit of a primary coded picture \nThis clause specifies constraints on VCL NAL unit syntax that are sufficient to enable the detection of the first VCL NAL \nunit of each primary coded picture. \n    Rec. ITU-T H.264 (06/2019)  465 \n \nThe first VCL NAL unit of the primary coded picture of the current access unit, in decoding order, shall be different from \nthe last VCL NAL unit of the primary coded picture of the previous access unit, in decoding order, in one or more of the \nfollowing ways: \n–  dependency_id of the first VCL NAL unit of the primary coded picture of the current access unit is less than \ndependency_id of the last VCL NAL unit of the primary coded picture of the previous access unit \n–  dependency_id of the  first VCL NAL unit of the primary coded picture of the current access unit  is equal to \ndependency_id of the last VCL NAL unit of the primary coded picture of the previous access unit and any of the \nfollowing conditions are true \n–  quality_id of the first VCL NAL unit of the primary coded picture of the current access unit is less than quality_id \nof the last VCL NAL unit of the primary coded picture of the previous access unit \n–  quality_id of the first VCL NAL unit of the primary coded picture of the current access unit and the last VCL \nNAL unit of the primary coded picture of the previous access unit is equal to 0, and any of the conditions \nspecified in clause 7.4.1.2.4 is fulfilled \nG.7.4.1.2.5  Order of VCL NAL units and association to coded pictures \nEach VCL NAL unit is part of a coded picture. \nLet dId be the value of dependency_id and let qId be the value of quality_id of any particular VCL NAL unit. The order \nof the VCL NAL units within a coded picture is constrained as follows: \n–  For all VCL NAL units following this particular VCL NAL unit, the value of dependency_id shall be greater than or \nequal to dId. \n–  For all VCL NAL units with a value of dependency_id equal to dId following this particular VCL NAL unit, the value \nof quality_id shall be greater than or equal to qId. \nFor each set of VCL NAL units within a layer representation, the following applies: \n–  If  arbitrary  slice  order,  as  specified  in  Annex A  or  clause G.10,  is  allowed,  coded  slice  NAL  units  of  a  layer \nrepresentation may have any order relative to each other. \n–  Otherwise (arbitrary slice order is not allowed), coded slice NAL units of a slice group shall not be interleaved with \ncoded slice NAL units of another slice group and the order of coded slice NAL units within a slice group shall be in \nthe order of increasing macroblock address for the first macroblock of each coded slice NAL unit of the same slice \ngroup. \nNAL units having nal_unit_type equal to 12 may be present in the access unit but shall not precede the first VCL NAL \nunit of the primary coded picture within the access unit. \nNAL units having nal_unit_type equal to 0 or in the range of 24 to 31, inclusive, which are unspecified, may be present in \nthe access unit but shall not precede the first VCL NAL unit of the primary coded picture within the access unit. \nNAL units having nal_unit_type in the range of 21 to 23, inclusive, which are reserved, shall not precede the first VCL \nNAL unit of the primary coded picture within the access unit (when specified in the future by ITU-T | ISO/IEC). \nG.7.4.2  Raw byte sequence payloads and RBSP trailing bits semantics \nG.7.4.2.1  Sequence parameter set RBSP semantics \nThe semantics specified in clause 7.4.2.1 apply. \nG.7.4.2.1.1  Sequence parameter set data semantics \nThe semantics specified in clause 7.4.2.1.1 apply with substituting SVC sequence parameter set for sequence parameter \nset. Additionally, the following applies. \nprofile_idc and level_idc indicate the profile and level to which the coded video sequence conforms when the SVC \nsequence parameter set is the active SVC sequence parameter set. \nconstraint_set0_flag is specified as follows: \n–  If the sequence parameter set data syntax structure is included in a sequence parameter set RBSP, the semantics \nspecified in clause 7.4.2.1.1 apply. \n–  Otherwise (the sequence parameter set data syntax structure is included in a subset sequence parameter set RBSP), \nconstraint_set0_flag equal to 1 specifies that all of the following conditions are obeyed: \n–  the coded video sequence obeys all constraints specified in clause G.10.1.1, \n466  Rec. ITU-T H.264 (06/2019) \n \n–  the output of the decoding process as specified in clause G.8 is identical to the output of the decoding process \nthat is obtained when profile_idc would be set equal to 83. \nconstraint_set0_flag equal to 0 specifies that the coded video sequence may or may not obey all constraints specified \nin clause G.10.1.1 and that the output of the decoding process as specified in clause G.8 may or may not be identical \nto the output of the decoding process that is obtained when profile_idc would be set equal to 83. \nNOTE 1 – The output of the decoding process may be different, if the array sTCoeff contains non-zero scaled luma \ntransform coefficient values for a transform block of a macroblock that is coded in an Inter macroblock prediction mode, \nbut all reconstructed luma residual samples of the array rS  that are associated with the transform blocks are equal to 0. \nL\nIn this case, the boundary filter strength that is derived as specified in clause G.8.7.4.3 can depend on the value of \nprofile_idc. \nconstraint_set1_flag is specified as follows: \n–  If the sequence parameter set data syntax structure is included in a sequence parameter set RBSP, the semantics \nspecified in clause 7.4.2.1.1 apply. \n–  Otherwise (the sequence parameter set data syntax structure is included in a subset sequence parameter set RBSP), \nconstraint_set1_flag equal to 1 specifies that all of the following conditions are obeyed: \n–  the coded video sequence obeys all constraints specified in clause G.10.1.2, \n–  the output of the decoding process as specified in clause G.8 is identical to the output of the decoding process \nthat is obtained when profile_idc would be set equal to 86. \nconstraint_set1_flag equal to 0 specifies that the coded video sequence may or may not obey all constraints specified \nin clause G.10.1.2 and that the output of the decoding process as specified in clause G.8 may or may not be identical \nto the output of the decoding process that is obtained when profile_idc would be set equal to 86. \nNOTE 2 – The output of the decoding process may be different, if the array sTCoeff contains non-zero scaled luma \ntransform coefficient values for a transform block of a macroblock that is coded in an Inter macroblock prediction mode, \nbut all reconstructed luma residual samples of the array rS  that are associated with the transform blocks are equal to 0. \nL\nIn this case, the boundary filter strength that is derived as specified in clause G.8.7.4.3 can depend on the value of \nprofile_idc. \nconstraint_set2_flag is specified as follows: \n–  If the sequence parameter set data syntax structure is included in a sequence parameter set RBSP, the semantics \nspecified in clause 7.4.2.1.1 apply. \n–  Otherwise (the sequence parameter set data syntax structure is included in a subset sequence parameter set RBSP), \nthe value of 1 for constraint_set2_flag is reserved for future use by ITU-T | ISO/IEC. constraint_set2_flag shall be \nequal  to 0  for  coded  video  sequences  with  profile_idc  equal  to  83  and  86  in  bitstreams  conforming  to  this \nRecommendation | International Standard. Decoders shall ignore the value of constraint_set2_flag when profile_idc \nis equal to 83 or 86. \nconstraint_set3_flag is specified as follows: \n–  If the sequence parameter set data syntax structure is included in a sequence parameter set RBSP, the semantics \nspecified in clause 7.4.2.1.1 apply. \n–  Otherwise (the sequence parameter set data syntax structure is included in a subset sequence parameter set RBSP), \nthe following applies: \n–  If profile_idc is equal to 86, constraint_set3_flag equal to 1 specifies that the coded video sequence obeys all \nconstraints specified in clause G.10.1.3, and constraint_set3_flag equal to 0 specifies that the coded video \nsequence may or may not obey these corresponding constraints. \n–  Otherwise (profile_idc is not equal to 86), the value of 1 for constraint_set3_flag is reserved for future use by \nITU-T | ISO/IEC. constraint_set3_flag shall be equal to 0 for coded video sequences with profile_idc not equal \nto 86 in bitstreams conforming to this Recommendation | International Standard. Decoders shall ignore the value \nof constraint_set3_flag when profile_idc is not equal to 86. \nconstraint_set5_flag is specified as follows: \n–  If the sequence parameter set data syntax structure is included in a sequence parameter set RBSP, the semantics \nspecified in clause 7.4.2.1.1 apply. \n–  Otherwise (the sequence parameter set data syntax structure is included in a subset sequence parameter set RBSP), \nthe following applies: \n–  If the profile_idc is equal to 83, constraint_set5_flag equal to 1 specifies that the coded video sequence obeys all \nconstraints specified in clause G.10.1.1.1. \n–  Otherwise, if the profile_idc is equal to 86, constraint_set5_flag equal to 1 specifies that the coded video \nsequence obeys all constraints specified in clause G.10.1.2.1. \n    Rec. ITU-T H.264 (06/2019)  467 \n \n–  Otherwise (profile_idc is not equal to 83 or 86), the value of 1 for constraint_set5_flag is reserved for future use \nby ITU-T | ISO/IEC. constraint_set5_flag shall be equal to 0 for coded video sequences with profile_idc not \nequal to 83 or 86 in bitstreams conforming to this Recommendation | International Standard. Decoders shall \nignore the value of constraint_set5_flag when profile_idc is not equal to 83 or 86. \nThe value of separate_colour_plane_flag shall be equal to 0 and the value of qpprime_y_zero_transform_bypass_flag shall \nbe equal to 0. \nWhen  the  seq_parameter_set_data( )  syntax  structure  is  present  in  a  subset  sequence  parameter  set  RBSP  and \nvui_parameters_present_flag is equal to 1, timing_info_present_flag shall be equal to 0, nal_hrd_parameters_present_flag \nshall be equal to 0, vcl_hrd_parameters_present_flag shall be equal to 0, and pic_struct_present_flag shall be equal to 0. \nThe value of 1 for timing_info_present_flag, nal_hrd_parameters_present_flag, vcl_hrd_parameters_present_flag, and \npic_struct_present_flag for subset sequence parameter set RBSPs is reserved for future use by ITU-T | ISO/IEC. When \ntiming_info_present_flag is equal to 1, decoders shall ignore the values of the directly following num_units_in_tick, \ntime_scale, fixed_frame_rate_flag syntax elements. When nal_hrd_parameters_present_flag is equal to 1, decoders shall \nignore  the  value  of  the  syntax  elements  in  the  directly  following  hrd_parameters( )  syntax  structure.  When \nvcl_hrd_parameters_present_flag is equal to 1, decoders shall ignore the value of the syntax elements in the directly \nfollowing hrd_parameters( ) syntax structure. \nWhen  the  seq_parameter_set_data( )  syntax  structure  is  present  in  a  sequence  parameter  set  RBSP  and \nvui_parameters_present_flag  is  equal  to  1,  the  values  of  timing_info_present_flag,  num_units_in_tick,  time_scale, \nfixed_frame_rate_flag,  nal_hrd_parameters_present_flag,  vcl_hrd_parameters_present_flag,  low_delay_hrd_flag, \npic_struct_present_flag and the values of syntax elements included in the hrd_parameters( ) syntax structures, when \npresent, shall be such that the bitstream activating the sequence parameter set is conforming to one or more of the profiles \nspecified in Annex A. \nmax_num_ref_frames specifies the maximum number of short-term and long-term reference frames, complementary \nreference field pairs, and non-paired reference fields that may be used by the decoding process for inter prediction of any \npicture in the coded video sequence. max_num_ref_frames also determines the size of the sliding window operation as \nspecified in clause G.8.2.4.2. The value of max_num_ref_frames shall be in the range of 0 to MaxDpbFrames (as specified \nin clause G.10), inclusive. \nThe allowed range of values for pic_width_in_mbs_minus1, pic_height_in_map_units_minus1, and frame_mbs_only_flag \nis specified by constraints in clause G.10. \nG.7.4.2.1.1.1 Scaling list semantics \nThe semantics specified in clause 7.4.2.1.1.1 apply. \nG.7.4.2.1.2  Sequence parameter set extension RBSP semantics \nThe semantics specified in clause 7.4.2.1.2 apply. Additionally, the following applies. \nSequence parameter set extension RBSPs can only follow sequence parameter set RBSPs in decoding order. Subset \nsequence parameter set RBSPs shall not be followed by a sequence parameter set extension RBSP. The contents of \nsequence parameter set extension RBSPs only apply when the base layer, which conforms to one or more of the profiles \nspecified in Annex A, of a coded video sequence conforming to one or more of the profiles specified in Annex G is \ndecoded. \nG.7.4.2.1.3  Subset sequence parameter set RBSP semantics \nThe semantics specified in clause 7.4.2.1.3 apply. \nG.7.4.2.1.4  Sequence parameter set SVC extension semantics \ninter_layer_deblocking_filter_control_present_flag equal to 1 specifies that a set of syntax elements controlling the \ncharacteristics  of  the  deblocking  filter  for  inter-layer  prediction  is  present  in  the  slice  header. \ninter_layer_deblocking_filter_control_present_flag equal to 0 specifies that the set of syntax elements controlling the \ncharacteristics of the deblocking filter for inter-layer prediction is not present in the slice headers and their inferred values \nare in effect. \nextended_spatial_scalability_idc specifies the presence of syntax elements related to geometrical parameters for the \nresampling processes. The value of extended_spatial_scalability_idc shall be in the range of 0 to 2, inclusive, and the \nfollowing applies: \n–  If  extended_spatial_scalability_idc  is  equal  to 0,  no  geometrical  parameters  are  present  in  the  subset  sequence \nparameter set and the slice headers referring to this subset sequence parameter set. \n–  Otherwise, if extended_spatial_scalability_idc is equal to 1, geometrical parameters are present in the subset sequence \nparameter set, but not in the slice headers referring to this subset sequence parameter set. \n468  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (extended_spatial_scalability_idc is equal to 2), geometrical parameters are not present in the  subset \nsequence parameter set, but they are present in the slice headers  with no_inter_layer_pred_flag equal to 0 and \nquality_id equal to 0 that refer to this subset sequence parameter set. \nchroma_phase_x_plus1_flag specifies the horizontal phase shift of the chroma components in units of half luma samples \nof a frame or layer frame. When chroma_phase_x_plus1_flag is not present, it shall be inferred to be equal to 1. \nWhen  ChromaArrayType  is  equal  to  1  and  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field are present, the following applies: \n–  If  chroma_phase_x_plus1_flag  is  equal  to  0,  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field should be equal to 0, 2, or 4. \n–  Otherwise  (chroma_phase_x_plus1_flag  is  equal  to  1),  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field should be equal to 1, 3, or 5. \nWhen ChromaArrayType is equal to 2, chroma_phase_x_plus1_flag should be equal to 1. \nchroma_phase_y_plus1 specifies the vertical phase shift of the chroma components in units of half luma samples of a \nframe or layer frame. When chroma_phase_y_plus1 is not present, it shall be inferred to be equal to 1. The value of \nchroma_phase_y_plus1 shall be in the range of 0 to 2, inclusive. \nWhen  ChromaArrayType  is  equal  to  1  and  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field are present, the following applies: \n–  If  chroma_phase_y_plus1  is  equal  to  0,  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field should be equal to 2 or 3. \n–  Otherwise,  if  chroma_phase_y_plus1  is  equal  to  1,  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field should be equal to 0 or 1. \n–  Otherwise  (chroma_phase_y_plus1  is  equal  to  2),  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field should be equal to 4 or 5. \nseq_ref_layer_chroma_phase_x_plus1_flag specifies the horizontal phase shift of the chroma components in units of \nhalf  luma  samples  of  a  layer  frame  for  the  layer  pictures  that  may  be  used  for  inter-layer  prediction.  When \nseq_ref_layer_chroma_phase_x_plus1_flag is not present, it shall be inferred to be equal to chroma_phase_x_plus1_flag. \nseq_ref_layer_chroma_phase_y_plus1 specifies the vertical phase shift of the chroma components in units of half luma \nsamples  of  a  layer  frame  for  the  layer  pictures  that  may  be  used  for  inter-layer  prediction.  When \nseq_ref_layer_chroma_phase_y_plus1 is not present, it shall be inferred to be equal to chroma_phase_y_plus1. The value \nof seq_ref_layer_chroma_phase_y_plus1 shall be in the range of 0 to 2, inclusive. \nseq_scaled_ref_layer_left_offset specifies the horizontal offset between the upper-left luma sample of a resampled layer \npicture used for inter-layer prediction and the upper-left luma sample of the current picture or current layer picture in units \nof two luma samples. When seq_scaled_ref_layer_left_offset is not present, it shall be inferred to be equal to 0. The value \nof seq_scaled_ref_layer_left_offset shall be in the range of −215 to 215 − 1, inclusive. \nseq_scaled_ref_layer_top_offset specifies the vertical offset between the upper-left luma sample of a resampled layer \npicture used for inter-layer prediction and the upper-left luma sample of the current picture or current layer picture. \nDepending on the value of frame_mbs_only_flag, the following applies: \n–  If frame_mbs_only_flag is equal to 1, the vertical offset is specified in units of two luma samples. \n–  Otherwise (frame_mbs_only_flag is equal to 0), the vertical offset is specified in units of four luma samples. \nWhen  seq_scaled_ref_layer_top_offset  is  not  present,  it  shall  be  inferred  to  be  equal  to 0.  The  value  of \nseq_scaled_ref_layer_top_offset shall be in the range of −215 to 215 − 1, inclusive. \nseq_scaled_ref_layer_right_offset specifies the horizontal offset between the bottom-right luma sample of a resampled \nlayer picture used for inter-layer prediction and the bottom-right luma sample of the current picture or current layer picture \nin units of two luma samples. When seq_scaled_ref_layer_right_offset is not present, it shall be inferred to be equal to 0. \nThe value of seq_scaled_ref_layer_right_offset shall be in the range of −215 to 215 − 1, inclusive. \nseq_scaled_ref_layer_bottom_offset specifies the vertical offset between the bottom-right luma sample of a resampled \nlayer picture used for inter-layer prediction and the bottom-right luma sample of the current picture or current layer picture. \nDepending on the value of frame_mbs_only_flag, the following applies: \n–  If frame_mbs_only_flag is equal to 1, the vertical offset is specified in units of two luma samples. \n–  Otherwise (frame_mbs_only_flag is equal to 0), the vertical offset is specified in units of four luma samples. \n    Rec. ITU-T H.264 (06/2019)  469 \n \nWhen  seq_scaled_ref_layer_bottom_offset  is  not  present,  it  shall  be  inferred  to  be  equal  to 0.  The  value  of \nseq_scaled_ref_layer_bottom_offset shall be in the range of −215 to 215 − 1, inclusive. \nseq_tcoeff_level_prediction_flag specifies the presence of the syntax element adaptive_tcoeff_level_prediction_flag in \nthe subset sequence parameter set. \nadaptive_tcoeff_level_prediction_flag specifies the presence of tcoeff_level_prediction_flag in slice headers that refer to \nthe subset sequence parameter set. When adaptive_tcoeff_level_prediction_flag is not present, it shall be inferred to be \nequal to 0. \nslice_header_restriction_flag specifies the presence of syntax elements in slice headers that refer to the subset sequence \nparameter set. \nG.7.4.2.2  Picture parameter set RBSP semantics \nThe semantics specified in clause 7.4.2.2 apply with substituting \"SVC sequence parameter set\" for \"sequence parameter \nset\" and substituting \"active SVC sequence parameter set or active layer SVC sequence parameter set\" for \"active sequence \nparameter set\". Additionally, the following applies. \nnum_slice_groups_minus1 plus 1 specifies the number of slice groups for a picture. When num_slice_groups_minus1 is \nequal to 0, all slices of the picture belong to the same slice group. The allowed range of num_slice_groups_minus1 is \nspecified in clause G.10. \nG.7.4.2.3  Supplemental enhancement information RBSP semantics \nThe semantics specified in clause 7.4.2.3 apply. \nG.7.4.2.3.1  Supplemental enhancement information message semantics \nThe semantics specified in clause 7.4.2.3.1 apply. \nG.7.4.2.4  Access unit delimiter RBSP semantics \nThe semantics specified in clause 7.4.2.4 apply. \nNOTE – The value of primary_pic_type applies to the slice_type values in all slice headers of the primary coded picture, including \nthe slice_type syntax elements in all NAL units with nal_unit_type equal to 1, 5, or 20. NAL units with nal_unit_type equal to 2 are \nnot present in bitstreams conforming to any of the profiles specified in this annex. \nG.7.4.2.5  End of sequence RBSP semantics \nThe end of sequence RBSP specifies that the next subsequent access unit in the bitstream in decoding order (if any) shall \nbe an access unit for which all layer representation of the primary coded picture have IdrPicFlag equal to 1. The syntax \ncontent of the SODB and RBSP for the end of sequence RBSP are empty. No normative decoding process is specified for \nan end of sequence RBSP. \nG.7.4.2.6  End of stream RBSP semantics \nThe semantics specified in clause 7.4.2.6 apply. \nG.7.4.2.7  Filler data RBSP semantics \nThe semantics specified in clause 7.4.2.7 apply with the following addition. \nFiller data NAL units shall be considered to contain the syntax elements dependency_id, quality_id, temporal_id, and \npriority_id with values that are inferred as follows: \n1.  Let prevSvcNalUnit be the most recent NAL unit in decoding order that has nal_unit_type equal to 14 or 20. \nNOTE – The most recent NAL unit in decoding order with nal_unit_type equal to 14 or 20 always belongs to the same access \nunit as the filler data NAL unit. \n2.  The values of dependency_id, quality_id, temporal_id, and priority_id for the filler data NAL unit are inferred to \nbe equal to the values of dependency_id, quality_id, temporal_id, and priority_id, respectively, of the NAL unit \nprevSvcNalUnit. \nG.7.4.2.8  Slice layer without partitioning RBSP semantics \nThe semantics specified in clause 7.4.2.8 apply. \nG.7.4.2.9  Slice data partition RBSP semantics \nSlice data partition syntax is not present in bitstreams conforming to any of the profiles specified in Annex G. \nG.7.4.2.10  RBSP slice trailing bits semantics \nThe semantics specified in clause 7.4.2.10 apply with the following modifications. \n470  Rec. ITU-T H.264 (06/2019) \n \nLet NumBytesInVclNALunits be the sum of the values of NumBytesInNALunit for all VCL NAL units of a layer \nrepresentation and let BinCountsInNALunits be the number of times that the parsing process function DecodeBin( ), \nspecified in clause 9.3.3.2, is invoked to decode the contents of all VCL NAL units of the layer representation. When \nentropy_coding_mode_flag is equal to 1, it is a requirement of bitstream conformance that BinCountsInNALunits shall \nnot exceed ( 32 ÷ 3 ) * NumBytesInVclNALunits + ( RawMbBits * PicSizeInMbs ) ÷ 32. \nNOTE – The constraint on the maximum number of bins resulting from decoding the contents of the slice layer NAL units of a layer \nrepresentation  can  be  met  by  inserting  a  number  of  cabac_zero_word  syntax  elements  to  increase  the  value  of \nNumBytesInVclNALunits. Each cabac_zero_word is represented in a NAL unit by the three-byte sequence 0x000003 (as a result of \nthe  constraints  on  NAL  unit  contents  that  result  in  requiring  inclusion  of  an  emulation_prevention_three_byte  for  each \ncabac_zero_word). \nG.7.4.2.11  RBSP trailing bits semantics \nThe semantics specified in clause 7.4.2.11 apply. \nG.7.4.2.12  Prefix NAL unit RBSP semantics \nThe semantics specified in clause 7.4.2.12 apply. \nG.7.4.2.12.1 Prefix NAL unit SVC semantics \nThe syntax element store_ref_base_pic_flag is considered as if it was present in the associated NAL unit. \nstore_ref_base_pic_flag equal to 1 specifies that, when the value of dependency_id as specified in the NAL unit header \nis equal to the maximum value of dependency_id for the VCL NAL units of the current coded picture, an additional \nrepresentation of the coded picture that may or may not be identical to the decoded picture is marked as \"used for \nreference\". This additional representation is also referred to as reference base picture and may be used for inter prediction \nof following pictures in decoding order, but it is not output. When store_ref_base_pic_flag is not present, it shall be inferred \nto be equal to 0. \nThe  syntax  element  store_ref_base_pic_flag  shall  have  the  same  value  for  all  VCL  NAL  units  of  a  dependency \nrepresentation. When nal_ref_idc is equal to 0, store_ref_base_pic_flag shall be equal to 0. \nWhen max_num_ref_frames is less than 2 in the SVC sequence parameter set that is referred to by the associated NAL \nunit, store_ref_base_pic_flag shall be equal to 0. \nadditional_prefix_nal_unit_extension_flag equal to 0 specifies that the prefix_nal_unit_svc( ) syntax structure does not \ncontain any additional_prefix_nal_unit_extension_data_flag syntax elements. additional_prefix_nal_unit_extension_flag \nshall  be  equal  to 0  in  bitstreams  conforming  to  this  Recommendation | International Standard.  The  value  of 1  for \nadditional_prefix_nal_unit_extension_flag is reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore all data \nthat follow the value 1 for additional_prefix_nal_unit_extension_flag in a prefix_nal_unit_svc( ) syntax structure. \nadditional_prefix_nal_unit_extension_data_flag may have any value. \nNOTE – The syntax elements additional_prefix_nal_unit_extension_flag and additional_prefix_nal_unit_extension_data_flag are \nnot used by the decoding process specified in this Recommendation | International Standard. \nG.7.4.2.13  Slice layer extension RBSP semantics \nThe semantics specified in clause 7.4.2.13 apply. \nG.7.4.3  Slice header semantics \nThe semantics specified in clause 7.4.3 apply with the following modifications. \na)  All referenced syntax elements and variables are syntax elements and variables for the dependency representation \nwith dependency_id equal to 0. \nb)  A frame, field, top field, bottom field, picture, and decoded picture is interpreted as layer frame, layer field, layer \ntop field, layer bottom field, layer picture, and decoded layer picture, respectively, that represent an intermediate \ndecoding result for the dependency representation with dependency_id equal to 0. \nc)  An IDR picture is interpreted as layer picture with IdrPicFlag equal to 1 for the dependency representation with \ndependency_id equal to 0. \nd)  An IDR access unit is interpreted as an access unit containing a primary coded picture with IdrPicFlag equal to 1 \nfor the dependency representation with dependency_id equal to 0. \ne)  A reference frame, reference field, and reference picture is interpreted as layer frame, layer field, and layer picture \nwith nal_ref_idc greater than 0 for the dependency representation with dependency_id equal to 0. \nf)  A non-reference frame, non-reference field, and non-reference picture is interpreted as layer frame, layer field, \nand layer picture with nal_ref_idc equal to 0 for the dependency representation with dependency_id equal to 0. \n    Rec. ITU-T H.264 (06/2019)  471 \n \ng)  All constraints specified in clause 7.4.3 apply only to layer representations with DQId equal to 0. \nh)  The slice_header( ) syntax structure  shall be considered to contain the following syntax elements  with the \nfollowing inferred values: \n–  ref_layer_dq_id is inferred to be equal to −1. \n–  scan_idx_start is inferred to be equal to 0. \n–  scan_idx_end is inferred to be equal to 15. \ni)  References to the decoded reference picture marking process as specified in  clause 8.2.5 are replaced with \nreference to the SVC decoded reference picture marking process as specified in clause G.8.2.4. \nj)  The value of direct_spatial_mv_pred_flag shall be equal to 1. \nk)  The variable MaxRefLayerDQId is set equal to −1. \nl)  The variable CroppingChangeFlag is set equal to 0. \nm)  The variable SpatialResolutionChangeFlag is set equal to 0. \nn)  In the semantics of first_mb_in_slice, the reference to Annex A is substituted with a reference to clause G.10. \nG.7.4.3.1  Reference picture list modification semantics \nThe semantics specified in clause 7.4.3.1 apply. For this specification, the modifications a) to f) specified in clause G.7.4.3 \napply. When quality_id is greater than 0, all syntax elements of the ref_pic_list_modification( ) syntax structure are \ninferred as specified in the beginning of clause G.7.4.3.4. \nG.7.4.3.2  Prediction weight table semantics \nThe  semantics  specified  in  clause 7.4.3.2  apply.  When  quality_id  is  greater  than 0,  all  syntax  elements  of  the \npred_weight_table( ) syntax structure are inferred as specified in the beginning of clause G.7.4.3.4. \nG.7.4.3.3  Decoded reference picture marking semantics \nThe semantics specified in clause 7.4.3.3 apply with substituting \"SVC sequence parameter set\" for \"sequence parameter \nset\" and with considering the reference pictures marked as \"reference base pictures\" as not present. The constraints \nspecified in clause 7.4.3.3 apply only to the dependency representation with dependency_id equal to the current value of \ndependency_id and the modifications a) and b) specified in clause G.8.2 apply with currDependencyId being equal to the \ncurrent value of dependency_id. \nWhen quality_id is greater than 0, all syntax elements of the dec_ref_pic_marking( ) syntax structure are inferred as \nspecified in the beginning of clause G.7.4.3.4. \nIn addition to the constraints specified in clause 7.4.3.3, the following constraints are specified: \na)  When  decoding  a  frame,  the  dec_ref_pic_marking( )  syntax  structure  shall  not  contain  a \nmemory_management_control_operation  command  equal  to  3  that  assigns  a  long-term  frame  index  to  a \ncomplementary reference field pair (not marked as \"reference base picture\") when any of the following conditions \nare true (when processing the memory_management_control_operation command equal to 3): \n–  there exists a non-paired reference base field (marked as \"reference base picture\") that is associated with one \nof the fields of the complementary reference field pair and that is marked as \"used for reference\", \n–  there exists a complementary reference base field pair (marked as \"reference base picture\") that is associated \nwith the complementary reference field pair and in which one field is marked as \"used for reference\" and \nthe other field is marked as \"unused for reference\". \nb)  When  decoding  a  field,  the  dec_ref_pic_marking( )  syntax  structure  shall  not  contain  a \nmemory_management_control_operation command equal to 3 that assigns a long-term frame index to a field (not \nmarked as \"reference base picture\") of a reference frame or a complementary reference field pair when both of \nthe following conditions are true (when processing the memory_management_control_operation command equal \nto 3): \n–  the other field of the reference frame or complementary reference field pair is marked as \"unused for \nreference\", \n–  there exists a reference base frame or a complementary reference base field pair (marked as \"reference base \npicture\") that is associated with the reference frame or complementary reference field pair, respectively, and \nin which both fields are marked as \"used for reference\". \n472  Rec. ITU-T H.264 (06/2019) \n \nc)  When  decoding  the  second  field  (in  decoding  order)  of  a  complementary  reference  field  pair,  the \ndec_ref_pic_marking( ) syntax structure shall not contain a memory_management_control_operation command \nequal to 6 that assigns a long-term frame index to this field when both of the following conditions are true: \n–  there exists a reference base field (marked as \"reference base picture\") that is associated with the first field \nof the complementary reference field pair and that is marked as \"used for short-term reference\" when the \nmemory_management_control_operation command equal to 6 is processed, \n–  the dec_ref_pic_marking( ) syntax structure does not contain a memory_management_control_operation \ncommand equal to 3 that assigns the same long-term frame index to the first field of the complementary \nreference field pair. \nNOTE – The additional constraints specified above (in connection with the constraints specified in clause 7.4.3.3) ensure that after \nprocessing all memory_management_control_operation commands of the decoded reference picture marking syntax structure the \nfollowing applies, with reference entry being a collective term for a non-paired reference field, a reference frame, or a complementary \nreference field pair (not marked as \"reference base picture\") and reference base entry being a collective term for a non-paired \nreference base field, a reference base frame, or a complementary reference base field pair (marked as \"reference base picture\"): \nWhen one or more fields of a reference entry are marked as \"used for reference\" and there exists a reference base entry that is \nassociated with the reference entry or one field of the reference entry and one or more fields of the reference base entry are marked \nas \"used for reference\", either all fields of the reference entry and the reference base entry that are marked as \"used for reference\" \nmust be marked as \"used for short-term reference\" or all fields of the reference entry and the reference base entry that are marked as \n\"used for reference\" must be marked as \"used for long-term reference\". When these fields are marked as \"used for long-term \nreference\", the same value of long-term frame index must be assigned to all fields of the reference entry and the reference base entry \nthat are marked as \"used for reference\". \nG.7.4.3.4  Slice header in scalable extension semantics \nUnless stated otherwise, for all references to clause 7.4.3 inside this clause, the following modifications apply. \na)  All referenced syntax elements and variables are syntax elements and variables for the dependency representation \nwith dependency_id equal to the current value of dependency_id. \nb)  A frame, field, top field, bottom field, picture, and decoded picture is interpreted as layer frame, layer field, layer \ntop field, layer bottom field, layer picture, and decoded layer picture, respectively, that represent an intermediate \ndecoding  result  for  the  dependency  representation  with  dependency_id  equal  to  the  current  value  of \ndependency_id. \nc)  An IDR picture is interpreted as layer picture with IdrPicFlag equal to 1 for the dependency representation with \ndependency_id equal to the current value of dependency_id. \nd)  An IDR access unit is interpreted as an access unit containing a primary coded picture with IdrPicFlag equal to 1 \nfor the dependency representation with dependency_id equal to the current value of dependency_id. \ne)  A reference frame, reference field, and reference picture is interpreted as layer frame, layer field, and layer picture \nwith nal_ref_idc greater than 0 for the dependency representation with dependency_id equal to the current value \nof dependency_id. \nf)  A non-reference frame, non-reference field, and non-reference picture is interpreted as layer frame, layer field, \nand layer picture with nal_ref_idc equal to 0 for the dependency representation with dependency_id equal to the \ncurrent value of dependency_id. \ng)  References to the decoded reference picture marking process as specified in clause 8.2.5 are replaced with \nreference to the SVC decoded reference picture marking process as specified in clause G.8.2.4. \nWhen quality_id is greater than 0, the following syntax elements (which are not present) shall be inferred to be equal to \nthe corresponding syntax elements of the slice header of the slice with dependency_id equal to the current value of \ndependency_id and quality_id equal to 0, in the same coded picture, that covers the macroblock with the macroblock \naddress  (first_mb_in_slice * ( 1 + MbaffFrameFlag )),  when  present  in  this  slice:  direct_spatial_mv_pred_flag, \nnum_ref_idx_active_override_flag, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1, all syntax elements \nof  the  syntax  structure  ref_pic_list_modification( ),  base_pred_weight_table_flag,  all  syntax  elements  of  the  syntax \nstructure pred_weight_table( ), all syntax elements of the syntax structure dec_ref_pic_marking( ), all syntax elements of \nthe syntax structure dec_ref_base_pic_marking( ), and store_ref_base_pic_flag. \nThe value of the following SVC sequence parameter set syntax elements shall be the same across all coded slice NAL units \nof an access unit: bit_depth_luma_minus8, bit_depth_chroma_minus8, and chroma_format_idc. \nThe value of the following picture parameter set syntax elements shall be the same across all coded slice NAL units of a \ndependency  representation:  bottom_field_pic_order_in_frame_present_flag,  num_ref_idx_l0_default_active_minus1, \nnum_ref_idx_l1_default_active_minus1, weighted_pred_flag, and weighted_bipred_idc. \nFor all coded slice NAL units of a coded picture in which the syntax element field_pic_flag is present, field_pic_flag shall \nhave the same value. \n    Rec. ITU-T H.264 (06/2019)  473 \n \nFor  all  coded  slice  NAL  units  of  a  coded  picture  in  which  the  syntax  element  bottom_field_flag  is  present, \nbottom_field_flag shall have the same value. \nWhen present in any coded slice NAL unit of a dependency representation, the value of the following slice header syntax \nelements shall be the same across all slices of the dependency representation including slice headers of NAL units with \nnal_unit_type  equal  to  1  or  5:  frame_num,  idr_pic_id,  pic_order_cnt_lsb,  delta_pic_order_cnt_bottom, \ndelta_pic_order_cnt[ 0 ], and delta_pic_order_cnt[ 1 ]. \nWhen present, the value of the following slice header syntax elements shall be the same across all slices of a layer \nrepresentation:  pic_parameter_set_id,  ref_layer_dq_id,  disable_inter_layer_deblocking_filter_idc, \ninter_layer_slice_alpha_c0_offset_div2,  inter_layer_slice_beta_offset_div2,  constrained_intra_resampling_flag, \nref_layer_chroma_phase_x_plus1_flag,  ref_layer_chroma_phase_y_plus1,  scaled_ref_layer_left_offset, \nscaled_ref_layer_top_offset,  scaled_ref_layer_right_offset,  scaled_ref_layer_bottom_offset,  slice_group_change_cycle, \nstore_ref_base_pic_flag,  tcoeff_level_prediction_flag,  and  all  syntax  elements  of  the  syntax  structures \ndec_ref_pic_marking( ) and dec_ref_base_pic_marking( ). \nLet setOfRefLayerSlices be the set of slices with dependency_id equal to the current value of dependency_id and quality_id \nequal to 0, inside the current coded picture, that are covered or partly covered by the macroblocks of the current slice. \nWhen quality_id is greater than 0, the value of (slice_type % 5) for all slices in the set setOfRefLayerSlices shall be the \nsame as the value of (slice_type % 5) for the current slice. \nWhen quality_id is greater than 0 and setOfRefLayerSlices contains more than one slice, the following constraints shall be \nobeyed: \na)  When slice_type specifies an EP or EB slice, the value of num_ref_idx_l0_active_minus1 (either the value \ntransmitted in the slice header when num_ref_idx_active_override_flag is equal to 1 or the inferred value when \nnum_ref_idx_active_override_flag is equal to 0) shall be the same across all slices of the set setOfRefLayerSlices. \nb)  When slice_type specifies an EB slice, the value of num_ref_idx_l1_active_minus1 (either the value transmitted \nin  the  slice  header  when  num_ref_idx_active_override_flag  is  equal  to 1  or  the  inferred  value  when \nnum_ref_idx_active_override_flag is equal to 0) shall be the same across all slices of the set setOfRefLayerSlices. \nc)  All elements of the syntax structure ref_pic_list_modification( ) shall be the same across all slices of the set \nsetOfRefLayerSlices. \nd)  When slice_type specifies an EP slice, the following applies: \ni)  When weighted_pred_flag is equal to 1, the value of base_pred_weight_table_flag shall be the same across \nall slices of the set setOfRefLayerSlices. \nii)  When  weighted_pred_flag  is  equal  to 1  and  pred_weight_table( )  is  present  in  the  slices  of  the  set \nsetOfRefLayerSlices, the values of all syntax elements inside the syntax structure pred_weight_table( ) shall \nbe the same across all slices of the set setOfRefLayerSlices. \ne)  When slice_type specifies an EB slice, the following applies: \ni)  When weighted_bipred_idc is equal to 1, the value of base_pred_weight_table_flag shall be the same across \nall slices of the set setOfRefLayerSlices. \nii)  When  weighted_bipred_idc  is  equal  to 1  and  pred_weight_table( )  is  present  in  the  slices  of  the  set \nsetOfRefLayerSlices, the values of all syntax elements inside the syntax structure pred_weight_table( ) shall \nbe the same across all slices of the set setOfRefLayerSlices. \nfirst_mb_in_slice has the same semantics as specified in clause 7.4.3 with the term current picture being substituted by \nthe term current layer representation and with the reference to Annex A being substituted by a reference to clause G.10. \nslice_type specifies the coding type of the slice according to Table G-1. \nTable G-1 – Name association to slice_type for NAL units with nal_unit_type equal to 20 \nslice_type  Name of slice_type \n0, 5  EP (P slice in scalable extension) \n1, 6  EB (B slice in scalable extension) \n2, 7  EI (I slice in scalable extension) \nWhen slice_type has a value in the range 5..7, it is a requirement of bitstream conformance that all other slices of the \ncurrent layer representation shall have a value of slice_type equal to the current value of slice_type or equal to the current \nvalue of slice_type minus 5. \n474  Rec. ITU-T H.264 (06/2019) \n \nNOTE 1 – Values of slice_type in the range 5..7 can be used by an encoder to indicate that all slices of a layer representation have \nthe same value of (slice_type % 5). Values of slice_type in the range 5..7 are otherwise equivalent to corresponding values in the \nrange 0..2. \nWhen idr_flag is equal to 1 or max_num_ref_frames is equal to 0, slice_type shall be equal to 2 or 7. \nIn the text (in particular when the clauses 7 to 9 are referenced in this annex), slices with ( slice_type % 5 ) equal to 0, 1, \nand 2 may be collectively referred to as P, B, and I slices, respectively, regardless of whether the slices are coded using \nNAL  units  with  nal_unit_type  equal  to 20 (slice_type  is present  in  the  slice_header_in_scalable_extension( )  syntax \nstructure) or NAL units with nal_unit_type in the range of 1 to 5, inclusive (slice_type is present in the slice_header( ) \nsyntax structure). \npic_parameter_set_id has the same semantics as specified in clause 7.4.3. \ncolour_plane_id has the same semantics as specified in clause 7.4.3. \nframe_num  is  used  as  an  identifier  for  dependency  representations  and  shall  be  represented  by \nlog2_max_frame_num_minus4 + 4 bits in the bitstream. \nframe_num is constrained as specified in clause 7.4.3. For this specification, the modifications a) to f) specified in the first \nparagraph of this clause apply. \nfield_pic_flag and bottom_field_flag have the same semantics as specified in clause 7.4.3. For this specification, the \nmodifications a) to d) specified in the first paragraph of this clause apply. \nidr_pic_id identifies an IDR picture when dependency_id is equal to the maximum present value of dependency_id in the \nVCL NAL units of the current coded picture. The value of idr_pic_id shall be in the range of 0 to 65535, inclusive. \nWhen two consecutive access units in decoding order are both IDR access units, the value of idr_pic_id in the slices of the \ntarget dependency representation in the primary coded pictures of the first such IDR access unit shall differ from the \nidr_pic_id in the slices of the target dependency representation in the primary coded pictures of the second such IDR access \nunit. \nNOTE 2 – The classification of an access unit as IDR access unit depends on the maximum present value of dependency_id. When \nNAL units are removed from a bitstream, e.g. in order to adjust the bitstream to the capabilities of a receiving device, the \nclassification of access units as IDR access units may change. Since all bitstreams for different conformance points supported in a \nscalable  bitstream  (in  particular  for  different  maximum  values  of  dependency_id)  must  conform  to  this \nRecommendation | International Standard (as specified in clause G.8.8.1), the constraints on idr_pic_id must be obeyed for all \nconformance points contained in a scalable bitstream. \npic_order_cnt_lsb,  delta_pic_order_cnt_bottom,  delta_pic_order_cnt[ 0 ],  and  delta_pic_order_cnt[ 1 ]  have  the \nsame semantics as specified in clause 7.4.3. For this specification, the modifications a) to f) specified in the first paragraph \nof this clause apply. \nredundant_pic_cnt has the same semantics as specified in clause 7.4.3. For this specification, the modifications a) to g) \nspecified in the first paragraph of this clause apply. \ndirect_spatial_mv_pred_flag specifies the method used in the decoding process to derive motion vectors and reference \nindices for inter prediction. When quality_id is greater than 0, direct_spatial_mv_pred_flag is inferred as specified in the \nbeginning of this clause. The value of direct_spatial_mv_pred_flag shall be equal to 1. \nnum_ref_idx_active_override_flag, num_ref_idx_l0_active_minus1, and num_ref_idx_l1_active_minus1 have the \nsame  semantics  as  specified  in  clause 7.4.3.  When  quality_id  is  greater  than 0,  num_ref_idx_active_override_flag, \nnum_ref_idx_l0_active_minus1, and num_ref_idx_l1_active_minus1 are inferred as specified in the beginning of this \nclause. \nbase_pred_weight_table_flag  equal  to 1  specifies  that  the  variables  for  weighted  prediction  are  inferred.  When \nbase_pred_weight_table_flag is not present, it shall be inferred as follows: \n–  If quality_id is greater than 0, base_pred_weight_table_flag is inferred as specified in the beginning of this clause. \n–  Otherwise (quality_id is equal to 0), base_pred_weight_table_flag is inferred to be equal to 0. \nWhen base_pred_weight_table_flag is equal to 1 and quality_id is equal to 0, let refSetOfSlices be the set of slices that is \nrepresented by the VCL NAL units with dependency_id equal to (ref_layer_dq_id >> 4) and quality_id equal to 0 inside \nthe current coded picture. \nWhen base_pred_weight_table_flag is equal to 1 and quality_id is equal to 0, the following constraints shall be obeyed: \na)  For all slices in refSetOfSlices, the value of (slice_type % 5) shall be equal to (slice_type % 5) of the current \nslice. \nb)  base_pred_weight_table_flag shall have the same value in all slices in refSetOfSlices. \n    Rec. ITU-T H.264 (06/2019)  475 \n \nc)  When the syntax structure pred_weight_table( ) is present in the slices of the set refSetOfSlices, the values of all \nsyntax elements inside the syntax structure pred_weight_table( ) shall be the same for all slices in refSetOfSlices. \nd)  When the current slice is an EP slice, the following applies: \ni)  The value of num_ref_idx_l0_active_minus1 of all slices in refSetOfSlices shall be identical to the value of \nnum_ref_idx_l0_active_minus1 of the current slice. \nii)  For each slice in refSetOfSlices, the syntax elements inside the syntax structure ref_pic_list_modification( ) \nshall be the same, and the syntax structure ref_pic_list_modification( ) for the slices in refSetOfSlices shall \ncontain syntax elements so that for useRefBasePicFlag equal to 0 and 1, an invocation of clause G.8.2.3 with \ncurrDependencyId set equal to (ref_layer_dq_id >> 4), useRefBasePicFlag, and any slice of refSetOfSlices \nas the inputs derives a reference picture list refPicList0RefLayer that is identical to the reference picture list \nrefPicList0,  which  is  derived  by  invoking  clause G.8.2.3  with  currDependencyId  set  equal  to \ndependency_id, useRefBasePicFlag, and the current slice as the inputs. The entries of two reference picture \nlists are considered the same when they represent entries that correspond to same coded frame, the same \ncomplementary reference field pair, the same coded field, or the same field of a coded frame. \niii)  weighted_pred_flag shall be equal to 1 for the slices in refSetOfSlices. \ne)  When the current slice is an EB slice, the following applies: \ni)  The  values  of  num_ref_idx_l0_active_minus1  and  num_ref_idx_l1_active_minus1  of  all  slices  in \nrefSetOfSlices  shall  be  identical  to  the  values  of  num_ref_idx_l0_active_minus1  and \nnum_ref_idx_l1_active_minus1, respectively, of the current slice. \nii)  For each slice in refSetOfSlices, the syntax elements inside the syntax structure ref_pic_list_modification( ) \nshall be the same, and the syntax structure ref_pic_list_modification( ) for the slices in refSetOfSlices shall \ncontain syntax elements so that for useRefBasePicFlag equal to 0 and 1, an invocation of clause G.8.2.3 with \ncurrDependencyId set equal to (ref_layer_dq_id >> 4), useRefBasePicFlag, and any slice of refSetOfSlices \nas the inputs derives reference picture lists refPicList0RefLayer and refPicList1RefLayer that are identical \nto  the  reference  picture  lists  refPicList0  and  refPicList1,  respectively,  which  are  derived  by  invoking \nclause G.8.2.3 with currDependencyId set equal to dependency_id, useRefBasePicFlag, and the current slice \nas the inputs. The entries of two reference picture lists are considered the same when they represent entries \nthat correspond to same coded frame, the same complementary reference field pair, the same coded field, or \nthe same field of a coded frame. \niii)  weighted_bipred_idc shall be equal to 1 for the slices in refSetOfSlices. \nstore_ref_base_pic_flag equal to 1 specifies that, when the value of dependency_id is equal to the maximum value of \ndependency_id for the VCL NAL units of the current coded picture, an additional representation of the coded picture that \nmay or may not be identical to the decoded picture is marked as \"used for reference\". This additional representation is also \nreferred to as reference base picture and may be used for inter prediction of following pictures in decoding order, but it is \nnot output. When store_ref_base_pic_flag is not present, it shall be inferred as follows: \n–  If quality_id is equal to 0, store_ref_base_pic_flag is inferred to be equal to 0. \n–  Otherwise (quality_id is greater than 0), store_ref_base_pic_flag is inferred as specified in the beginning of this \nclause. \nThe  syntax  element  store_ref_base_pic_flag  shall  have  the  same  value  for  all  VCL  NAL  units  of  a  dependency \nrepresentation. When nal_ref_idc is equal to 0, store_ref_base_pic_flag shall be equal to 0. \nWhen max_num_ref_frames is less than 2, store_ref_base_pic_flag shall be equal to 0. \ncabac_init_idc and slice_qp_delta have the same semantics as specified in clause 7.4.3. \ndisable_deblocking_filter_idc specifies whether the operation of the deblocking filter shall be disabled across some block \nedges of the slice, specifies for which edges the filtering is disabled, and specifies the order of deblocking filter operations. \nWhen disable_deblocking_filter_idc is not present in the slice header, the value of disable_deblocking_filter_idc shall be \ninferred to be equal to 0. \nThe value of disable_deblocking_filter_idc shall be in the range of 0 to 6, inclusive. disable_deblocking_filter_idc equal \nto 0 specifies that all luma and chroma block edges of the slice are filtered. disable_deblocking_filter_idc equal to 1 \nspecifies that deblocking is disabled for all block edges of the slice. disable_deblocking_filter_idc equal to 2 specifies that \nall luma and chroma block edges of the slice are filtered with exception of the block edges that coincide with slice \nboundaries. disable_deblocking_filter_idc equal to 3 specifies a two stage deblocking filter process for the slice: After \nfiltering  all  block  luma  and  chroma  block  edges  that  do  not  coincide  with  slice  boundaries  (as  if \ndisable_deblocking_filter_idc were equal to 2), the luma and chroma block edges that coincide with slice boundaries are \nfiltered. disable_deblocking_filter_idc equal to 4 specifies that all luma block edges of the slice are filtered, but the \n476  Rec. ITU-T H.264 (06/2019) \n \ndeblocking of the chroma block edges is disabled. disable_deblocking_filter_idc equal to 5 specifies that all luma block \nedges  of  the  slice  are  filtered  with  exception  of  the  block  edges  that  coincide  with  slice  boundaries  (as  if \ndisable_deblocking_filter_idc were equal to 2), and that deblocking for chroma block edges of the slice is disabled. \ndisable_deblocking_filter_idc equal to 6 specifies that the deblocking for chroma block edges is disabled and that the two \nstage deblocking filter process is used for luma block edges of the slice: After filtering all block luma block edges that do \nnot coincide with slice boundaries (as if disable_deblocking_filter_idc were equal to 2), the luma block edges that coincide \nwith slice boundaries are filtered. \nWhen  no_inter_layer_pred_flag  is  equal  to 1  or  tcoeff_level_prediction_flag  is  equal  to 1,  the  value  of \ndisable_deblocking_filter_idc shall be in the range of 0 to 2, inclusive. \nslice_alpha_c0_offset_div2, and slice_beta_offset_div2 have the same semantics as specified in clause 7.4.3. \nslice_group_change_cycle has the same semantics as specified in clause 7.4.3. \nref_layer_dq_id specifies the layer representation inside the current coded picture that is used for inter-layer prediction \nof the current layer representation. When present, the value of ref_layer_dq_id shall be in the range of 0 to DQId − 1, \ninclusive. When ref_layer_dq_id is not present, it shall be inferred as follows: \n–  If quality_id is greater than 0, ref_layer_dq_id is inferred to be equal to (DQId − 1). \n–  Otherwise (quality_id is equal to 0), ref_layer_dq_id is inferred to be equal to −1. \nWhen quality_id is equal to 0, the NAL units with DQId equal to ref_layer_dq_id shall have discardable_flag equal to 0. \nWhen  ref_layer_dq_id  is  greater  than  or  equal  to 0,  it  is  a  requirement  of  bitstream  conformance  that  the  layer \nrepresentation with DQId equal to ref_layer_dq_id is present in the bitstream. \nThe variable MaxRefLayerDQId is set equal to the maximum value of ref_layer_dq_id for the slices of the current layer \nrepresentation. \nWhen MinNoInterLayerPredFlag is equal to 0, the layer representation inside the current coded picture that has a value of \nDQId equal MaxRefLayerDQId is also referred to as reference layer representation. \nWhen MaxRefLayerDQId is not equal to −1, the following variables are derived as follows: \n–  RefLayerPicSizeInMbs is set equal to the value of the variable PicSizeInMbs for the reference layer representation. \n–  RefLayerPicWidthInMbs  is  set  equal  to  the  value  of  the  variable PicWidthInMbs  for  the  reference  layer \nrepresentation. \n–  RefLayerPicHeightInMbs  is  set  equal  to  the  value  of  the  variable  PicHeightInMbs  for  the  reference  layer \nrepresentation. \n–  RefLayerChromaFormatIdc is set equal to the value of the syntax element chroma_format_idc for the reference layer \nrepresentation. \n–  RefLayerChromaArrayType is set equal to the value of ChromaArrayType for the reference layer representation. \n–  RefLayerPicWidthInSamples  is set equal to the value of the variable PicWidthInSamples  for the reference layer \nL L\nrepresentation. \n–  RefLayerPicHeightInSamples  is set equal to the value of the variable PicHeightInSamples  for the reference layer \nL L\nrepresentation. \n–  RefLayerPicWidthInSamples  is set equal to the value of the variable PicWidthInSamples  for the reference layer \nC C\nrepresentation. \n–  RefLayerPicHeightInSamples  is set equal to the value of the variable PicHeightInSamples  for the reference layer \nC C\nrepresentation. \n–  RefLayerMbWidthC is set equal to the value of the variable MbWidthC for the reference layer representation. \n–  RefLayerMbHeightC is set equal to the value of the variable MbHeightC for the reference layer representation. \n–  RefLayerFrameMbsOnlyFlag is set equal to the value of the syntax element frame_mbs_only_flag for the reference \nlayer representation. \n–  RefLayerFieldPicFlag  is  set  equal  to  the  value  of  the  syntax  element  field_pic_flag  for  the  reference  layer \nrepresentation. \n–  RefLayerBottomFieldFlag is set equal to the value of the syntax element bottom_field_flag for the reference layer \nrepresentation. \n    Rec. ITU-T H.264 (06/2019)  477 \n \n–  RefLayerMbaffFrameFlag  is  set  equal  to  the  value  of  the  variable  MbaffFrameFlag  for  the  reference  layer \nrepresentation. \ndisable_inter_layer_deblocking_filter_idc specifies whether the operation of the deblocking filter for inter-layer intra \nprediction is disabled across some block edges of the reference layer representation, specifies for which edges the filtering \nis  disabled,  and  specifies  the  order  of  deblocking  filter  operations  for  inter-layer  intra  prediction.  When \ndisable_inter_layer_deblocking_filter_idc  is  not  present  in  the  slice  header,  the  value  of \ndisable_inter_layer_deblocking_filter_idc  shall  be  inferred  to  be  equal  to 0.  The  value  of \ndisable_inter_layer_deblocking_filter_idc  shall  be  in  the  range  of  0  to 6,  inclusive.  The  values 0  to 6  of \ndisable_inter_layer_deblocking_filter_idc specify the same deblocking filter operations as the corresponding values of \ndisable_deblocking_filter_idc,  but  for  the  deblocking  of  the  intra  macroblocks  of  the  reference  layer  representation \nspecified by ref_layer_dq_id before resampling. \nWhen disable_inter_layer_deblocking_filter_idc is present, quality_id is equal to 0, and SpatialResolutionChangeFlag as \nspecified in the following paragraphs is equal to 0, disable_inter_layer_deblocking_filter_idc shall be equal to 1. \ninter_layer_slice_alpha_c0_offset_div2 specifies the offset used in accessing the α and t  deblocking filter tables for \nC0\nfiltering operations of the intra macroblocks of the reference layer representation before resampling. From this value, the \noffset that is applied when addressing these tables shall be computed as: \nInterlayerFilterOffsetA = inter_layer_slice_alpha_c0_offset_div2 << 1  (G-64) \nThe  value  of  inter_layer_slice_alpha_c0_offset_div2  shall  be  in  the  range  of  −6  to +6,  inclusive.  When \ninter_layer_slice_alpha_c0_offset_div2  is  not  present  in  the  slice  header,  the  value  of \ninter_layer_slice_alpha_c0_offset_div2 shall be inferred to be equal to 0. \ninter_layer_slice_beta_offset_div2  specifies  the  offset  used  in  accessing  the  β  deblocking  filter  table  for  filtering \noperations of the intra macroblocks of the reference layer representation before resampling. From this value, the offset that \nis applied when addressing the β table of the deblocking filter is computed as: \nInterlayerFilterOffsetB = inter_layer_slice_beta_offset_div2 << 1  (G-65) \nThe  value  of  inter_layer_slice_beta_offset_div2  shall  be  in  the  range  of  −6  to +6,  inclusive.  When \ninter_layer_slice_beta_offset_div2 is not present in the slice header the value of inter_layer_slice_beta_offset_div2 shall \nbe inferred to be equal to 0. \nconstrained_intra_resampling_flag specifies whether slice boundaries in the layer picture that is used for inter-layer \nprediction (as specified by ref_layer_dq_id) are treated similar to layer picture boundaries for the intra resampling process. \nWhen constrained_intra_resampling_flag is equal to 1, disable_inter_layer_deblocking_filter_idc shall be equal to 1, 2, \nor 5. \nWhen constrained_intra_resampling_flag is equal to 1, a macroblock cannot be coded using the Intra_Base macroblock \nprediction mode when it covers more than one slice in the layer picture that is used for inter-layer prediction, as specified \nin clause G.8.6.2. \nWhen constrained_intra_resampling_flag is not present, it shall be inferred to be equal to 0. \nref_layer_chroma_phase_x_plus1_flag specifies the horizontal phase shift of the chroma components in units of half \nluma samples of a layer frame for the layer pictures that may be used for inter-layer prediction. \nWhen ref_layer_chroma_phase_x_plus1_flag is not present, it shall be inferred as follows: \n–  If  quality_id  is  greater  than  0,  ref_layer_chroma_phase_x_plus1_flag  is  inferred  to  be  equal  to \nchroma_phase_x_plus1_flag. \n–  Otherwise  (quality_id  is  equal  to  0),  ref_layer_chroma_phase_x_plus1_flag  is  inferred  to  be  equal  to \nseq_ref_layer_chroma_phase_x_plus1_flag. \nWhen no_inter_layer_pred_flag is equal to 0, the following is specified: \na)  When  ref_layer_dq_id  is  greater  than  0,  ref_layer_chroma_phase_x_plus1_flag  should  be  equal  to \nchroma_phase_x_plus1_flag of the subset sequence parameter set RBSP that is referred to by the reference layer \nrepresentation (with DQId equal to ref_layer_dq_id). \nb)  When  RefLayerChromaArrayType  is  equal  to  1  and  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field are present in the SVC sequence parameter set that is referred to by the \nreference layer representation (with DQId equal to ref_layer_dq_id), the following applies: \n–  If  ref_layer_chroma_phase_x_plus1_flag  is  equal  to  0,  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field of the SVC sequence parameter set that is referred to by the reference \nlayer representation should be equal to 0, 2, or 4. \n478  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (ref_layer_chroma_phase_x_plus1_flag is equal to 1), chroma_sample_loc_type_top_field and \nchroma_sample_loc_type_bottom_field of the SVC sequence parameter set that is referred to by the reference \nlayer representation should be equal to 1, 3, or 5. \nc)  When RefLayerChromaArrayType is not equal to 1, ref_layer_chroma_phase_x_plus1_flag should be equal to 1. \nref_layer_chroma_phase_y_plus1 specifies the vertical phase shift of the chroma components in units of half luma \nsamples of a layer frame for the layer pictures that may be used for inter-layer prediction. \nWhen ref_layer_chroma_phase_y_plus1 is not present, it shall be inferred as follows: \n–  If quality_id is greater than 0, ref_layer_chroma_phase_y_plus1 is inferred to be equal to chroma_phase_y_plus1. \n–  Otherwise  (quality_id  is  equal  to  0),  ref_layer_chroma_phase_y_plus1  is  inferred  to  be  equal  to \nseq_ref_layer_chroma_phase_y_plus1. \nThe value of ref_layer_chroma_phase_y_plus1 shall be in the range of 0 to 2, inclusive. \nWhen no_inter_layer_pred_flag is equal to 0, the following applies: \na)  When  ref_layer_dq_id  is  greater  than  0,  ref_layer_chroma_phase_y_plus1  should  be  equal  to \nchroma_phase_y_plus1 of the subset sequence parameter set RBSP that is referred to by the reference layer \nrepresentation (with DQId equal to ref_layer_dq_id). \nb)  When  RefLayerChromaArrayType  is  equal  to  1  and  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field are present in the SVC sequence parameter set that is referred to by the \nreference layer representation (with DQId equal to ref_layer_dq_id), the following applies: \n–  If  ref_layer_chroma_phase_y_plus1  is  equal  to  0,  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field of the SVC sequence parameter set that is referred to by the reference \nlayer representation should be equal to 2 or 3. \n–  Otherwise,  if  ref_layer_chroma_phase_y_plus1  is  equal  to  1,  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field of the SVC sequence parameter set that is referred to by the reference \nlayer representation should be equal to 0 or 1. \n–  Otherwise  (chroma_phase_y_plus1  is  equal  to  2),  chroma_sample_loc_type_top_field  and \nchroma_sample_loc_type_bottom_field of the SVC sequence parameter set that is referred to by the reference \nlayer representation should be equal to 4 or 5. \nc)  When RefLayerChromaArrayType is not equal to 1, ref_layer_chroma_phase_y_plus1 should be equal to 1. \nscaled_ref_layer_left_offset specifies the horizontal offset between the upper-left luma sample of a resampled layer \npicture used for inter-layer prediction and the upper-left luma sample of the current picture or current layer picture in units \nof two luma samples. \nWhen scaled_ref_layer_left_offset is not present, it shall be inferred as follows: \n–  If quality_id is greater than 0, scaled_ref_layer_left_offset is inferred to be equal to 0. \n–  Otherwise  (quality_id  is  equal  to  0),  scaled_ref_layer_left_offset  is  inferred  to  be  equal  to \nseq_scaled_ref_layer_left_offset. \nThe value of scaled_ref_layer_left_offset shall be in the range of −215 to 215 − 1, inclusive. \nscaled_ref_layer_top_offset specifies the vertical offset between the upper-left luma sample of a resampled layer picture \nused for inter-layer prediction and the upper-left luma sample of the current picture or current layer picture. The vertical \noffset is specified in units of two luma samples when frame_mbs_only_flag is equal to 1, and it is specified in units of four \nluma samples when frame_mbs_only_flag is equal to 0. \nWhen scaled_ref_layer_top_offset is not present, it shall be inferred as follows: \n–  If quality_id is greater than 0, scaled_ref_layer_top_offset is inferred to be equal to 0. \n–  Otherwise  (quality_id  is  equal  to  0),  scaled_ref_layer_top_offset  is  inferred  to  be  equal  to \nseq_scaled_ref_layer_top_offset. \nThe value of scaled_ref_layer_top_offset shall be in the range of −215 to 215 − 1, inclusive. \nscaled_ref_layer_right_offset specifies the horizontal offset between the bottom-right luma sample of a resampled layer \npicture used for inter-layer prediction and the bottom-right luma sample of the current picture or current layer picture in \nunits of two luma samples. \nWhen scaled_ref_layer_right_offset is not present, it shall be inferred as follows: \n    Rec. ITU-T H.264 (06/2019)  479 \n \n–  If quality_id is greater than 0, scaled_ref_layer_right_offset is inferred to be equal to 0. \n–  Otherwise  (quality_id  is  equal  to  0),  scaled_ref_layer_right_offset  is  inferred  to  be  equal  to \nseq_scaled_ref_layer_right_offset. \nThe value of scaled_ref_layer_right_offset shall be in the range of −215 to 215 − 1, inclusive. \nscaled_ref_layer_bottom_offset specifies the vertical offset between the bottom-right luma sample of a resampled layer \npicture used for inter-layer prediction and the bottom-right luma sample of the current picture or current layer picture. The \nvertical offset is specified in units of two luma samples when frame_mbs_only_flag is equal to 1, and it is specified in \nunits of four luma samples when frame_mbs_only_flag is equal to 0. \nWhen scaled_ref_layer_bottom_offset is not present, it shall be inferred as follows: \n–  If quality_id is greater than 0, scaled_ref_layer_bottom_offset is inferred to be equal to 0. \n–  Otherwise  (quality_id  is  equal  to  0),  scaled_ref_layer_bottom_offset  is  inferred  to  be  equal  to \nseq_scaled_ref_layer_bottom_offset. \nThe value of scaled_ref_layer_bottom_offset shall be in the range of −215 to 215 − 1, inclusive. \nThe variables scaledLeftOffset, scaledRightOffset, scaledTopOffset, and scaledBottomOffset are derived as follows: \n–  If  MinNoInterLayerPredFlag  is  equal  to  0,  scaledLeftOffset,  scaledRightOffset,  scaledTopOffset,  and \nscaledBottomOffset  are  set  equal  to  the  values  of  scaled_ref_layer_left_offset,  scaled_ref_layer_right_offset, \nscaled_ref_layer_top_offset, and scaled_ref_layer_bottom_offset, respectively, for the slices of the current layer \nrepresentation that have no_inter_layer_pred_flag equal to 0. \n–  Otherwise  (MinNoInterLayerPredFlag  is  equal  to  1),  scaledLeftOffset,  scaledRightOffset,  scaledTopOffset,  and \nscaledBottomOffset  are  set  equal  to  the  values  of  scaled_ref_layer_left_offset,  scaled_ref_layer_right_offset, \nscaled_ref_layer_top_offset, and scaled_ref_layer_bottom_offset, respectively. \nThe  variables  ScaledRefLayerLeftOffset,  ScaledRefLayerRightOffset,  ScaledRefLayerTopOffset, \nScaledRefLayerBottomOffset,  ScaledRefLayerPicWidthInSamples ,  and  ScaledRefLayerPicHeightInSamples   are \nL L\nderived by \nScaledRefLayerLeftOffset                    = 2 * scaledLeftOffset  (G-66) \nScaledRefLayerRightOffset                  = 2 * scaledRightOffset  (G-67) \nScaledRefLayerTopOffset                    = 2 * scaledTopOffset * ( 2 − frame_mbs_only_flag )  (G-68) \nScaledRefLayerBottomOffset               = 2 * scaledBottomOffset * ( 2 − frame_mbs_only_flag )  (G-69) \nScaledRefLayerPicWidthInSamples    = PicWidthInMbs * 16 − ScaledRefLayerLeftOffset − \nL\n                                                                  ScaledRefLayerRightOffset  (G-70) \nScaledRefLayerPicHeightInSamples  = PicHeightInMbs * 16 −  \nL\n                                                                  ( ScaledRefLayerTopOffset + ScaledRefLayerBottomOffset ) / \n                                                                  ( 1 + field_pic_flag )  (G-71) \nWhen no_inter_layer_pred_flag is equal to 0, the following constraints shall be obeyed: \na)  The  bitstream  shall  not  contain  data  that  result  in  ScaledRefLayerPicWidthInSamples   less  than \nL\nRefLayerPicWidthInSamples . \nL\nb)  When RefLayerFrameMbsOnlyFlag is equal to 0 or frame_mbs_only_flag is equal to 1, the bitstream shall not \ncontain  data  that  result  in  (ScaledRefLayerPicHeightInSamples  * ( 1 + field_pic_flag ))  less  than \nL\n(RefLayerPicHeightInSamples  * ( 1 + RefLayerFieldPicFlag )). \nL\nc)  When RefLayerFrameMbsOnlyFlag is equal to 1 and frame_mbs_only_flag is equal to 0, the bitstream shall not \ncontain  data  that  result  in  (ScaledRefLayerPicHeightInSamples  * ( 1 + field_pic_flag ))  less  than \nL\n(2 * RefLayerPicHeightInSamples ). \nL\nWhen  ChromaArrayType  is  not  equal  to  0,  the  variables  ScaledRefLayerPicWidthInSamples ,  and \nC\nScaledRefLayerPicHeightInSamples  are derived by \nC\nScaledRefLayerPicWidthInSamples   = ScaledRefLayerPicWidthInSamples  / SubWidthC  (G-72) \nC L  \nScaledRefLayerPicHeightInSamples  = ScaledRefLayerPicHeightInSamples  / SubHeightC  (G-73) \nC L\nThe variable CroppingChangeFlag is derived as follows: \n–  If MinNoInterLayerPredFlag is equal to 0, quality_id is equal to 0, and extended_spatial_scalability_idc is equal to 2, \nCroppingChangeFlag is set equal to 1. \n480  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (MinNoInterLayerPredFlag is equal to 1, quality_id is greater than 0, or extended_spatial_scalability_idc \nis less than 2), CroppingChangeFlag is set equal to 0. \nNOTE 3 – Encoder designers are encouraged to set the value of no_inter_layer_pred_flag equal to 0 for at least one slice of each \nlayer representation with extended_spatial_scalability_idc equal to 2 and quality_id equal to 0. \nThe variable SpatialResolutionChangeFlag is derived as follows: \n–  If MinNoInterLayerPredFlag is equal to 1, quality_id is greater than 0, or all of the following conditions are true, \nSpatialResolutionChangeFlag is set equal to 0: \n–  CroppingChangeFlag is equal to 0, \n–  ScaledRefLayerPicWidthInSamples  is equal to RefLayerPicWidthInSamples , \nL L\n–  ScaledRefLayerPicHeightInSamples  is equal to RefLayerPicHeightInSamples , \nL L\n–  ( ScaledRefLayerLeftOffset % 16 ) is equal to 0, \n–  ( ScaledRefLayerTopOffset % ( 16 * ( 1 + field_pic_flag + MbaffFrameFlag ) ) ) is equal to 0, \n–  field_pic_flag is equal to RefLayerFieldPicFlag, \n–  MbaffFrameFlag is equal to RefLayerMbaffFrameFlag, \n–  chroma_format_idc is equal to RefLayerChromaFormatIdc, \n–  chroma_phase_x_plus1_flag is equal to ref_layer_chroma_phase_x_plus1_flag for the slices with \nno_inter_layer_pred_flag equal to 0, \n–  chroma_phase_y_plus1 is equal to ref_layer_chroma_phase_y_plus1 for the slices with \nno_inter_layer_pred_flag equal to 0. \n–  Otherwise, SpatialResolutionChangeFlag is set equal to 1. \nThe variable RestrictedSpatialResolutionChangeFlag is derived as follows: \n–  If  SpatialResolutionChangeFlag  is  equal  to  0  or  all  of  the  following  conditions  are  true, \nRestrictedSpatialResolutionChangeFlag is set equal to 1: \n–  ScaledRefLayerPicWidthInSamples  is equal to RefLayerPicWidthInSamples  or \nL L\n(2 * RefLayerPicWidthInSamples ), \nL\n–  ScaledRefLayerPicHeightInSamples  is equal to RefLayerPicHeightInSamples  or \nL L\n(2 * RefLayerPicHeightInSamples ), \nL\n–  ( ScaledRefLayerLeftOffset % 16 ) is equal to 0, \n–  ( ScaledRefLayerTopOffset % ( 16 * ( 1 + field_pic_flag ) ) ) is equal to 0, \n–  MbaffFrameFlag is equal to 0, \n–  RefLayerMbaffFrameFlag is equal to 0, \n–  field_pic_flag is equal to RefLayerFieldPicFlag. \n–  Otherwise, RestrictedSpatialResolutionChangeFlag is set equal to 0. \nslice_skip_flag specifies the presence of the slice data in scalable extension syntax structure. When slice_skip_flag is not \npresent, it shall be inferred to be equal to 0. slice_skip_flag equal to 0 specifies that the slice data in scalable extension \nsyntax structure is present in the NAL unit. slice_skip_flag equal to 1 specifies that the slice data in scalable extension \nsyntax structure is not present in the NAL unit and that the syntax elements for the macroblock layer of the slice are derived \nby the following process: \n1.  CurrMbAddr is derived by \nCurrMbAddr = first_mb_in_slice * ( 1 + MbaffFrameFlag )  (G-74) \n2.  The variable mbIdx proceeds over the values 0..num_mbs_in_slice_minus1, and for each value of mbIdx, the \nfollowing ordered steps are specified: \na.  The bitstream shall not contain data that result in InCropWindow( CurrMbAddr ) equal to 0. \n    Rec. ITU-T H.264 (06/2019)  481 \n \nb.  For  the  macroblock  with  address  CurrMbAddr,  the  syntax  elements  mb_skip_flag  (when  applicable), \nmb_skip_run (when applicable), mb_field_decoding_flag, base_mode_flag, residual_prediction_flag and \ncoded_block_pattern shall be inferred as follows: \n–  mb_skip_flag (when applicable) and mb_skip_run (when applicable) are inferred to be equal to 0. \n–  mb_field_decoding_flag is inferred to be equal to 0. \nNOTE 4 – The frame/field mode used for decoding is inferred in clause G.8.1.5.1. \n–  base_mode_flag is inferred to be equal to 1. \n–  residual_prediction_flag is inferred to be equal to 1. \n–  coded_block_pattern is inferred to be equal to 0. \n–  QP  is inferred to be equal to SliceQP . \nY Y\n–  QP′  is inferred to be equal to (QP  + QpBdOffset ). \nY Y Y\nc.  When  the  variable  mbIdx  is  less  than  num_mbs_in_slice_minus1,  CurrMbAddr  is  set  to \nNextMbAddress( CurrMbAddr ). The bitstream shall not contain data that result in CurrMbAddr being set \nequal to a value that is not less than PicSizeInMbs. \nnum_mbs_in_slice_minus1 plus 1specifies the number of macroblocks for a slice with slice_skip_flag equal to 1. \nadaptive_base_mode_flag specifies the presence of syntax elements in the slice header and in the macroblock layer in \nscalable extension. When adaptive_base_mode_flag is not present, it shall be inferred to be equal to 0. \ndefault_base_mode_flag specifies how base_mode_flag is inferred when it is not present in macroblock layer in scalable \nextension. When default_base_mode_flag is not present, it shall be inferred to be equal to 0. \nadaptive_motion_prediction_flag specifies the presence of syntax elements in the macroblock layer in scalable extension. \nWhen adaptive_motion_prediction_flag is not present, it shall be inferred to be equal to 0. \ndefault_motion_prediction_flag  specifies  how  motion_prediction_flag_l0[ ]  and  motion_prediction_flag_l1[ ]  are \ninferred when they are not present in macroblock layer in scalable extension. When default_motion_prediction_flag is not \npresent, it shall be inferred to be equal to 0. \nadaptive_residual_prediction_flag  specifies  the  presence  of  syntax  elements  in  the  macroblock  layer  in  scalable \nextension. When adaptive_residual_prediction_flag is not present, it shall be inferred to be equal to 0. \ndefault_residual_prediction_flag  specifies  how  residual_prediction_flag  is  inferred  when  it  is  not  present  in  the \nmacroblock layer in scalable extension. When default_residual_prediction_flag is not present, it shall be inferred to be \nequal to 0. \ntcoeff_level_prediction_flag equal to 1 specifies that an alternative inter-layer prediction process is applied as specified \nin clause G.8. When tcoeff_level_prediction_flag is not present, it shall be inferred as follows: \n–  If no_inter_layer_pred_flag is equal to 1, tcoeff_level_prediction_flag is inferred to be equal to 0. \n–  Otherwise (no_inter_layer_pred_flag is equal to 0), tcoeff_level_prediction_flag is inferred to be equal to the value \nof seq_tcoeff_level_prediction_flag. \nWhen SpatialResolutionChangeFlag is equal to 1, tcoeff_level_prediction_flag shall be equal to 0. \nWhen tcoeff_level_prediction_flag is equal to 1, the following constraints shall be obeyed: \na)  The  slices  of  the  reference  layer  representation  (with  DQId  equal  to  ref_layer_dq_id)  shall  have \nno_inter_layer_pred_flag equal to 1 or tcoeff_level_prediction_flag equal to 1. \nb)  All elements of ScalingList4x4 shall be the same for the slices of the current layer representation and all slices \nof the reference layer representation (with DQId equal to the value of ref_layer_dq_id). \nc)  All elements of ScalingList8x8 shall be the same for the slices of the current layer representation and all slices \nof the reference layer representation (with DQId equal to the value of ref_layer_dq_id). \nd)  The value of the syntax element use_ref_base_pic_flag shall be equal to 0 for the slices of the current layer \nrepresentation  and  all  slices  of  the  reference  layer  representation  (with  DQId  equal  to  the  value  of \nref_layer_dq_id). \ne)  When slice_skip_flag is equal to 1, the value of constrained_intra_pred_flag for the current layer representation \nshall be identical to the value of constrained_intra_pred_flag for the reference layer representation (with DQId \nequal to ref_layer_dq_id). \n482  Rec. ITU-T H.264 (06/2019) \n \nThe variable MaxTCoeffLevelPredFlag is set equal to the maximum value of tcoeff_level_prediction_flag for the slices of \nthe current layer representation. \nscan_idx_start  specifies  the  first  scanning  position  for  the  transform  coefficient  levels  in  the  current  slice.  When \nscan_idx_start is not present, it shall be inferred to be equal to 0. \nscan_idx_end  specifies  the  last  scanning  position  for  the  transform  coefficient  levels  in  the  current  slice.  When \nscan_idx_end is not present, it shall be inferred to be equal to 15. \nWhen default_base_mode_flag is equal to 1, (slice_type % 5) is equal to 2, and entropy_coding_mode_flag is equal to 0, \nit is a requirement of bitstream conformance that the value of scan_idx_end is greater than or equal to scan_idx_start. \nG.7.4.3.5  Decoded reference base picture marking semantics \nThe specification of this clause applies to the current dependency representation. The modifications a) and b) specified in \nclause G.8.2 apply with currDependencyId being equal to the current value of dependency_id. \nThe  syntax  elements  adaptive_ref_base_pic_marking_mode_flag,  memory_management_base_control_operation, \ndifference_of_base_pic_nums_minus1,  and  long_term_base_pic_num  specify  marking  of  reference  base  pictures  as \n\"unused for reference\". \nWhen present in a prefix NAL unit, all syntax elements of the dec_ref_base_pic_marking( ) syntax structure are considered \nas if they were present in the associated NAL unit. \nWhen quality_id is greater than 0, all syntax elements of the dec_ref_base_pic_marking( ) syntax structure are inferred as \nspecified in the beginning of clause G.7.4.3.4. \nThe content of the decoded reference picture base marking syntax structure shall be the same in all slice headers of the \nprimary coded picture. When one or more redundant coded pictures are present, the content of the decoded reference base \npicture marking syntax structure shall be the same in all slice headers of a redundant coded picture with a particular value \nof redundant_pic_cnt. \nNOTE 1 – It is not required that the content of the decoded reference base picture marking syntax structure in a redundant coded \npicture with a particular value of redundant_pic_cnt is identical to the content of the decoded reference base picture marking syntax \nstructure in the corresponding primary coded picture or a redundant coded picture with a different value of redundant_pic_cnt. \nHowever, as specified in clause G.7.4.3.4 (by referencing clause 7.4.3), the content of the decoded reference base picture marking \nsyntax structure in a redundant coded picture is constrained in the way that the marking status of reference pictures and the value of \nframe_num after the SVC decoded reference picture marking process in clause G.8.2.4 must be identical regardless whether the \nprimary coded picture or any redundant coded picture of the access unit would be decoded. \nThe memory_management_base_control_operation commands of the dec_ref_base_pic_marking( ) syntax structure are \nprocessed  by  the  decoding  process  before  the  memory_management_control_operation  commands  of  the \ndec_ref_pic_marking( ) syntax structure are processed. \nadaptive_ref_base_pic_marking_mode_flag selects the reference base picture marking mode for the current picture or \nlayer picture as specified in Table G-2. When adaptive_ref_base_pic_marking_mode_flag is not present and quality_id is \nequal to 0, it shall be inferred to be equal to 0. \nTable G-2 – Interpretation of adaptive_ref_base_pic_marking_mode_flag \nadaptive_ref_base_pic_marking_mode_flag  Reference base picture marking mode specified \n0  Sliding window reference picture marking mode: A \nmarking  mode  providing  a  first-in,  first-out \nmechanism for short-term reference pictures \n1  Adaptive  reference  base  picture  marking  mode:  A \nreference  picture  marking  mode  providing  syntax \nelements  to  specify  marking  of  reference  base \npictures as \"unused for reference\" \n \nmemory_management_base_control_operation specifies a control operation to be applied to affect the  marking of \nreference base pictures. The memory_management_base_control_operation syntax element is followed by data necessary \nfor  the  operation  specified  by  the  value  of  memory_management_base_control_operation.  The  values  and  control \noperations  associated  with  memory_management_base_control_operation  are  specified  in  Table G-3.  The \nmemory_management_base_control_operation syntax elements are processed by the decoding process in the order in \nwhich they appear, and the semantics constraints expressed for each memory_management_base_control_operation apply \nat the specific position in that order at which that individual memory_management_base_control_operation is processed. \n    Rec. ITU-T H.264 (06/2019)  483 \n \nFor interpretation of memory_management_base_control_operation, the terms reference picture and reference base picture \nare interpreted as follows: \n–  If the current picture is a frame, the term reference picture refers either to a reference frame or a complementary \nreference field pair and the term reference base picture refers either to a reference base frame or a complementary \nreference base field pair. \n–  Otherwise (the current picture is a field), the term reference picture refers either to a reference field or a field of a \nreference frame and the term reference base picture refers either to a reference base field or a field of a reference base \nframe. \nmemory_management_base_control_operation shall not be equal to 1 unless the specified reference base picture is marked \nas  \"used  for  short-term  reference\"  (and  as  \"reference  base  picture\")  when  the \nmemory_management_base_control_operation is processed by the decoding process. \nmemory_management_base_control_operation shall not be equal to 2 unless the specified long-term picture number refers \nto a reference base picture that is marked as \"used for long-term reference\" (and as \"reference base picture\") when the \nmemory_management_base_control_operation is processed by the decoding process. \nWhen  the  dec_ref_pic_marking( )  syntax  structure  contains  a  memory_management_control_operation  equal  to 5, \nmemory_management_base_control_operation shall not be equal to 1 or 2. \nTable G-3 – Memory management base control operation (memory_management_base_control_operation) values \nmemory_management_base_control_operation  Memory Management Base Control Operation \n0  End  memory_management_base_control_operation \nsyntax element loop \n1  Mark  a  short-term  reference  base  picture  as \n\"unused for reference\" \n2  Mark  a  long-term  reference  base  picture  as \n\"unused for reference\" \ndifference_of_base_pic_nums_minus1 is used (with memory_management_base_control_operation equal to 1) to mark \na  short-term  reference  base  picture  as  \"unused  for  reference\".  When  the  associated \nmemory_management_base_control_operation is processed by the decoding process, the resulting picture number derived \nfrom difference_of_base_pic_nums_minus1 shall be a picture number assigned to one of the reference pictures marked as \n\"used for short-term reference\" and as \"reference base picture\". \nThe resulting picture number is constrained as follows: \n–  If field_pic_flag is equal to 0, the resulting picture number shall be one of the set of picture numbers assigned to \nreference frames or complementary reference field pairs marked as \"reference base picture\". \nNOTE 2 – When field_pic_flag is equal to 0, the resulting picture number must be a picture number assigned to a \ncomplementary reference field pair in which both fields are marked as \"used for short-term reference\" and \"reference \nbase picture\" or a reference frame in which both fields are marked as \"used for short-term reference\" and \"reference base \npicture\". \n–  Otherwise (field_pic_flag is equal to 1), the resulting picture number shall be one of the set of picture numbers \nassigned to reference fields marked as \"reference base picture\". \nlong_term_base_pic_num is used (with memory_management_base_control_operation equal to 2) to mark a long-term \nreference base picture as \"unused for reference\". When the associated memory_management_base_control_operation is \nprocessed by the decoding process, long_term_base_pic_num shall be equal to a long-term picture number assigned to one \nof the reference pictures marked as \"used for long-term reference\" and as \"reference base picture\". \nThe resulting long-term picture number is constrained as follows: \n–  If field_pic_flag is equal to 0, the resulting long-term picture number shall be one of the set of long-term picture \nnumbers assigned to reference frames or complementary reference field pairs marked as \"reference base picture\". \nNOTE 3 – When field_pic_flag is equal to 0, the resulting long-term picture number must be a long-term picture number \nassigned to a complementary reference field pair in which both fields are marked as \"used for long-term reference\" and \n\"reference base picture\" or a reference frame in which both fields are marked as \"used for long-term reference\" and \n\"reference base picture\". \n–  Otherwise (field_pic_flag is equal to 1), the resulting long-term picture number shall be one of the set of long-term \npicture numbers assigned to reference fields marked as \"reference base picture\". \n484  Rec. ITU-T H.264 (06/2019) \n \nG.7.4.4  Slice data semantics \nThe semantics specified in clause 7.4.4 apply. \nG.7.4.4.1  Slice data in scalable extension semantics \nThe semantics specified in clause 7.4.4 apply with the following modifications. \nmb_skip_run specifies the number of consecutive skipped macroblocks for which, when decoding an EP slice, mb_type \nshall be inferred to be P_Skip and the macroblock type is collectively referred to as a P macroblock type, or for which, \nwhen decoding an EB slice, mb_type shall be inferred to be B_Skip and the macroblock type is collectively referred to as \na B macroblock type. The value of mb_skip_run shall be in the range of 0 to PicSizeInMbs − CurrMbAddr, inclusive. \nmb_skip_flag equal to 1 specifies that for the current macroblock, when decoding an EP slice, mb_type shall be inferred \nto be P_Skip and the macroblock type is collectively referred to as P macroblock type, or for which, when decoding an EB \nslice, mb_type shall be inferred to be B_Skip and the macroblock type is collectively referred to as B macroblock type. \nmb_skip_flag equal to 0 specifies that the current macroblock is not skipped. \nG.7.4.5  Macroblock layer semantics \nThe semantics specified in clause 7.4.5 apply. Additionally, the following applies. \nThe macroblock_layer( ) syntax structure shall be considered to contain the following syntax elements with the following \ninferred values: \n–  base_mode_flag is inferred to be equal to 0. \n–  residual_prediction_flag is inferred to be equal to 0. \nG.7.4.5.1  Macroblock prediction semantics \nThe semantics specified in clause 7.4.5.1 apply. Additionally, the following applies. \nThe value of mvd_l0[ mbPartIdx ][ 0 ][ compIdx ] and mvd_l1[ mbPartIdx ][ 0 ][ compIdx ] shall be in the range of −8192 \nto 8191.75, inclusive. The range of mvd_l0[ mbPartIdx ][ 0 ][ compIdx ] and mvd_l1[ mbPartIdx ][ 0 ][ compIdx ] is also \nconstrained indirectly by constraints on the motion vector variable values derived from it as specified in clause G.10. \nThe mb_pred( ) syntax structure shall be considered to contain the following syntax elements with the following inferred \nvalues: \n–  motion_prediction_flag_l0[ mbPartIdx ] is inferred to be equal to 0 for each value of mbPartIdx in the range of 0 \nto NumMbPart( mb_type ) − 1, inclusive. \n–  motion_prediction_flag_l1[ mbPartIdx ] is inferred to be equal to 0 for each value of mbPartIdx in the range of 0 \nto NumMbPart( mb_type ) − 1, inclusive. \nG.7.4.5.2  Sub-macroblock prediction semantics \nThe semantics specified in clause 7.4.5.2 apply. Additionally, the following applies. \nThe  value  of  mvd_l0[ mbPartIdx ][ subMbPartIdx ][ compIdx ]  and  mvd_l1[ mbPartIdx ][ subMbPartIdx ][ compIdx ] \nshall be in the range of −8192 to 8191.75, inclusive. The range of mvd_l0[ mbPartIdx ][ subMbPartIdx ][ compIdx ] and \nmvd_l1[ mbPartIdx ][ subMbPartIdx ][ compIdx ]  is  also  constrained  indirectly  by  constraints  on  the  motion  vector \nvariable values derived from it as specified in clause G.10. \nThe sub_mb_pred( ) syntax structure shall be considered to contain the following syntax elements with the following \ninferred values: \n–  motion_prediction_flag_l0[ mbPartIdx ] is inferred to be equal to 0 for each value of mbPartIdx in the range of 0 to 3, \ninclusive. \n–  motion_prediction_flag_l1[ mbPartIdx ] is inferred to be equal to 0 for each value of mbPartIdx in the range of 0 to 3, \ninclusive. \nG.7.4.5.3  Residual data semantics \nThe semantics specified in clause 7.4.5.3 apply. \nG.7.4.5.3.1  Residual luma semantics \nThe semantics specified in clause 7.4.5.3.1 apply. \nG.7.4.5.3.2  Residual block CAVLC semantics \nThe semantics specified in clause 7.4.5.3.2 apply. \n    Rec. ITU-T H.264 (06/2019)  485 \n \nG.7.4.5.3.3  Residual block CABAC semantics \nThe semantics specified in clause 7.4.5.3.3 apply. \nG.7.4.6  Macroblock layer in scalable extension semantics \nThe semantics specified in clause 7.4.5 apply. Additionally, the following modifications and extensions are specified. \nThe function InCropWindow( mbAddr ) is specified by the following ordered steps: \n1.  The variable mbX is set equal to (( mbAddr / ( 1 + MbaffFrameFlag ) ) % PicWidthInMbs). \n2.  The variables mbY0 and mbY1 are derived as follows: \n–  If MbaffFrameFlag is equal to 0, mbY0 and mbY1 are set equal to (mbAddr / PicWidthInMbs). \n–  Otherwise (MbaffFrameFlag is equal to 1), mbY0 is set equal to (2 * ( ( mbAddr / PicWidthInMbs ) / 2 )) \nand mbY1 is set equal to (mbY0 + 1). \n3.  The variable scalMbH is set equal to (16 * ( 1 + field_pic_flag )). \n4.  The return value of InCropWindow( mbAddr ) is derived as follows: \n–  If all of the following conditions are true, the return value of InCropWindow( mbAddr ) is equal to TRUE. \n–  no_inter_layer_pred_flag is equal to 0 \n–  mbX is greater than or equal to (( ScaledRefLayerLeftOffset + 15 ) / 16) \n–  mbX is less than (( ScaledRefLayerLeftOffset + ScaledRefLayerPicWidthInSamples  ) / 16) \nL\n–  mbY0 is greater than or equal to (( ScaledRefLayerTopOffset + scalMbH − 1 ) / scalMbH) \n–  mbY1 is less than (( ScaledRefLayerTopOffset + ScaledRefLayerPicHeightInSamples  ) / scalMbH) \nL\n–  Otherwise, the return value of InCropWindow( mbAddr ) is equal to FALSE. \nbase_mode_flag equal to 1 specifies that the macroblock partitioning, the macroblock (partition) prediction mode(s), and \nthe corresponding motion data (when applicable) are inferred as specified in  clause G.8. base_mode_flag equal to 0 \nspecifies that the syntax element mb_type is present in the macroblock layer in scalable extension syntax structure or that \nmb_type shall be inferred as specified in clause G.7.4.4.1. \nWhen base_mode_flag is not present, base_mode_flag shall be inferred as follows: \n–  If InCropWindow( CurrMbAddr ) is equal to 0, the value of base_mode_flag is inferred to be equal to 0. \n–  Otherwise, if the syntax element mb_skip_run (when entropy_coding_mode_flag is equal to 0) or mb_skip_flag \n(when entropy_coding_mode_flag is equal to 1) specifies that mb_type is inferred to be equal to P_Skip or B_Skip \nas specified in clause G.7.4.4.1, the value of base_mode_flag is inferred to be equal to 0. \n–  Otherwise  (InCropWindow( CurrMbAddr )  is  equal  to 1  and  the  syntax  element  mb_skip_run  (when \nentropy_coding_mode_flag is equal to 0) or mb_skip_flag (when entropy_coding_mode_flag is equal to 1) does not \nspecify that mb_type is inferred to be equal to P_Skip or B_Skip), the value of base_mode_flag is inferred to be equal \nto default_base_mode_flag. \nWhen store_ref_base_pic_flag is equal to 1 and quality_id is greater than 0, base_mode_flag shall be equal to 1. \nmb_type specifies the macroblock type. The semantics of mb_type depend on the slice type. \nWhen mb_type is not present, it shall be inferred as follows: \n–  If base_mode_flag is equal to 1, mb_type is inferred to be equal to Mb_Inferred. \n–  Otherwise, (base_mode_flag is equal to 0), mb_type is inferred as specified in clause G.7.4.4.1. \nThe macroblock type Mb_Inferred specifies that the macroblock partitioning and the macroblock (partition) prediction \nmode(s) are not known during the parsing process. In the decoding process specified in clause G.8, the macroblock type \nused for decoding is inferred to be equal to any of the macroblock types specified in Tables 7-11, 7-13, 7-14, or G-5. For \nthe purpose of parsing the slice_data_in_scalable_extension( ) syntax structure including the processes specified in clause 9 \nand clause G.9, Mb_Inferred shall be considered an additional macroblock type that is different from all macroblock types \nspecified in Tables 7-11, 7-13, 7-14, and G-5 and the following applies: \n–  macroblocks with mb_type equal to Mb_Inferred are considered as coded in an Inter macroblock prediction mode \nand not coded in an Intra macroblock prediction mode, \n486  Rec. ITU-T H.264 (06/2019) \n \n–  NumMbPart( Mb_Inferred ) is considered to be equal to 1, \n–  MbPartWidth( Mb_Inferred ) and MbPartHeight( Mb_Inferred ) are considered to be equal to 16, \n–  MbPartPredMode( Mb_Inferred, 0 ) is considered to be not equal to Intra_4x4, Intra_8x8, Intra_16x16, Pred_L0, \nPred_L1, BiPred, and Direct. \nTables and semantics are specified for the various macroblock types for EI, EP, and EB slices. Each table presents the \nvalue of mb_type, the name of mb_type, the number of macroblock partitions used (given by NumMbPart( mb_type ) \nfunction),  the  prediction  mode  of  the  macroblock  (when  it  is  not  partitioned)  or  the  first  partition  (given  by  the \nMbPartPredMode( mb_type, 0 )  function)  and  the  prediction  mode  of  the  second  partition  (given  by  the \nMbPartPredMode( mb_type, 1 ) function). When a value is not applicable it is designated by \"na\". In the text, the value of \nmb_type may be referred to as the macroblock type and a value X of MbPartPredMode( ) may be referred to in the text by \n\"X macroblock (partition) prediction mode\" or as \"X prediction macroblocks\". The tables do not include the macroblock \ntype Mb_Inferred. \nTable G-4 shows the allowed collective macroblock types for each slice_type. \nTable G-4 – Allowed collective macroblock types for slice_type \nslice_type  allowed collective macroblock types \nEI (slice)  I (see Table 7-11 and Table G-5) (macroblock types) \nEP (slice)  P (see Table 7-13) and I (see Table 7-11 and Table G-5) (macroblock types) \nEB (slice)  B (see Table 7-14) and I (see Table 7-11 and Table G-5) (macroblock types) \n \nMacroblock types that may be collectively referred to as I macroblock types are specified in Tables G-5 and 7-11. mb_type \nvalues 0 to 25 are specified in Table 7-11. Table G-5 specifies the additional macroblock type I_BL that can be inferred in \nthe decoding process specified in clause G.8 for macroblocks with base_mode_flag equal to 1 (mb_type inferred to be \nequal to Mb_Inferred). \nThe macroblock types for EI slices are all I macroblock types. \n \nTable G-5 – Inferred macroblock type I_BL for EI slices \n \na\n \n  m a\ng\na   e o m\n  m b _ t y p e     o f   m b _ t y p e m _ s i z e _ 8 x 8 _ f l   r t P r e d M o d e       ) 0 b _ t y p e , x 1 6 P r e d M o d k P a t t e r n C h r c k P a t t e r n L u\nN a m e n s f o r M b P a   ( m t r a 1 6 d B l o c e d B l o\na n e d\nr I d o\nt o C\nC\ninferred  I_BL  na  Intra_Base  na  Equation 7-36  Equation 7-36 \nIntra_Base specifies the macroblock prediction mode and specifies that the intra prediction samples are derived using \nconstructed intra samples of the reference layer representation as specified in clause G.8. Intra_Base is an Intra macroblock \nprediction mode. \nMacroblock types that may be collectively referred to as P macroblock types are specified in Table 7-13. \nThe macroblock types for EP slices are specified in Tables 7-13, 7-11, and G-5. mb_type values 0 to 4 are specified in \nTable 7-13 and mb_type values 5 to 30 are specified in Table 7-11, indexed by subtracting 5 from the value of mb_type. \nTable G-5  specifies  the  additional  macroblock  type  I_BL  that  can  be  inferred  in  the  decoding  process  specified  in \nclause G.8 for macroblocks with base_mode_flag equal to 1 (mb_type inferred to be equal to Mb_Inferred). \nMacroblock types that may be collectively referred to as B macroblock types are specified in Table 7-14. \nThe macroblock types for EB slices are specified in Tables 7-14, 7-11, and G-5. mb_type values 0 to 22 are specified in \nTable 7-14 and mb_type values 23 to 48 are specified in Table 7-11, indexed by subtracting 23 from the value of mb_type. \n    Rec. ITU-T H.264 (06/2019)  487 \n \nTable G-5  specifies  the  additional  macroblock  type  I_BL  that  can  be  inferred  in  the  decoding  process  specified  in \nclause G.8 for macroblocks with base_mode_flag equal to 1 (mb_type inferred to be equal to Mb_Inferred). \ncoded_block_pattern specifies which of the four 8x8 luma blocks and associated chroma blocks of a macroblock may \ncontain  non-zero  transform  coefficient  values.  When  coded_block_pattern  is  present  in  the  bitstream,  the  variables \nCodedBlockPatternLuma and CodedBlockPatternChroma are derived as specified by Equation 7-36. \nWhen  scan_idx_end  is  less  than  scan_idx_start  and  one  of  the  following  conditions  is  true,  the  variables \nCodedBlockPatternLuma and CodedBlockPatternChroma are set equal to 0: \n–  base_mode_flag is equal to 1, \n–  base_mode_flag is equal to 0, the macroblock type is not equal to P_Skip, B_Skip, or I_PCM, and the macroblock \nprediction mode is not equal to Intra_16x16. \nWhen the macroblock type is not equal to P_Skip, B_Skip, or I_PCM, the following constraints shall be obeyed: \na)  When scan_idx_end is less than scan_idx_start, and the macroblock prediction mode is equal to Intra_16x16, the \nbitstream  shall  not  contain  data  that  result  in  derived  values  of  CodedBlockPatternLuma  and \nCodedBlockPatternChroma that are not equal to 0. \nb)  When scan_idx_start is equal to 0, scan_idx_end is equal to 0, and the macroblock prediction mode is equal to \nIntra_16x16, the bitstream shall not contain data that result in a derived value of CodedBlockPatternLuma that is \nnot equal to 0. \nc)  When scan_idx_start is equal to 0 and scan_idx_end is equal to 0, the bitstream shall not contain data that result \nin a derived value of CodedBlockPatternChroma that is equal to 2. \nThe meaning of CodedBlockPatternLuma and CodedBlockPatternChroma is specified in clause 7.4.5. \nresidual_prediction_flag equal to 1 specifies that the residual signal of the current macroblock is predicted as specified \nin clause G.8 using the reference layer representation specified by ref_layer_dq_id. residual_prediction_flag equal to 0 \nspecifies that the residual signal of the current macroblock is not predicted. \nWhen the syntax element residual_prediction_flag is not present, residual_prediction_flag shall be inferred as follows: \n–  If  all  of  the  following  conditions  are  true,  residual_prediction_flag  is  inferred  to  be  equal  to \ndefault_residual_prediction_flag: \n–  slice_type is not equal to EI, \n–  InCropWindow( CurrMbAddr ) is equal to 1, \n–  base_mode_flag is equal to 1 or mb_type does not specify an I macroblock type. \n–  Otherwise, residual_prediction_flag is inferred to be equal to 0. \nAll  elements  of  the  arrays  LumaLevel4x4,  LumaLevel8x8,  Intra16x16DCLevel,  Intra16x16ACLevel,  CbLevel4x4, \nCbLevel8x8,  CbIntra16x16DCLevel,  CbIntra16x16ACLevel,  CrLevel4x4,  CrLevel8x8,  CrIntra16x16DCLevel, \nCrIntra16x16ACLevel, ChromaDCLevel, and ChromaACLevel are set equal to 0 before parsing the residual( ) syntax \nstructure. All elements of these arrays are also set equal to 0 when the residual( ) syntax structure is not present. \nG.7.4.6.1  Macroblock prediction in scalable extension semantics \nThe semantics specified in clause 7.4.5.1 apply. Additionally, the following semantics are specified. \nmotion_prediction_flag_l0[ mbPartIdx ] equal to 1 specifies that an alternative  motion  vector prediction process as \nspecified in clause G.8 is used for deriving the list 0 motion vector of the macroblock partition mbPartIdx and that the list 0 \nreference index of the macroblock partition mbPartIdx is inferred as specified in clause G.8. \nWhen motion_prediction_flag_l0[ mbPartIdx ] is not present, motion_prediction_flag_l0[ mbPartIdx ] shall be inferred as \nfollows: \n–  If InCropWindow( CurrMbAddr ) is equal to 0, motion_prediction_flag_l0[ mbPartIdx ] is inferred to be equal to 0. \n–  Otherwise (InCropWindow( CurrMbAddr ) is equal to 1), motion_prediction_flag_l0[ mbPartIdx ] is inferred to be \nequal to default_motion_prediction_flag. \nmotion_prediction_flag_l1[ mbPartIdx ] has the same semantics as motion_prediction_flag_l0[ mbPartIdx ], with l0 and \nlist 0 replaced by l1 and list 1, respectively. \n488  Rec. ITU-T H.264 (06/2019) \n \nG.7.4.6.2  Sub-macroblock prediction in scalable extension semantics \nThe semantics specified in clause 7.4.5.2 apply. Additionally, the following semantics are specified. \nmotion_prediction_flag_l0[ mbPartIdx ]  and  motion_prediction_flag_l1[ mbPartIdx ]  have  the  same  semantics  as \nspecified in clause G.7.4.6.1. \nG.8  SVC decoding process \nThis clause describes the decoding process for an access unit, given syntax elements and upper-case variables from \nclause G.7 (with reference made to clause 7 in clause G.7) that are derived from the bitstream. \nNOTE 1 – All syntax elements and upper-case variables from clause G.7 are available for the entire current access unit. When syntax \nelements or upper-case variables appear with identical names in clause G.7 they are referred herein through unique identifiers. \nOutputs of this process are decoded samples of the current primary coded picture. \nThe decoding process is specified such that all decoders shall produce numerically identical results. Any decoding process \nthat produces identical results to the process described here conforms to the decoding process requirements of this \nRecommendation | International Standard. \nAll sub-bitstreams that can be derived using the sub-bitstream extraction process as specified in clause G.8.8.1 with any \ncombination of values for priority_id, temporal_id, dependency_id, or quality_id as the input shall result in a set of coded \nvideo sequences, with each coded video sequence conforming to one or more of the profiles specified in Annexes A and G. \nThis clause specifies the decoding process for an access unit of a coded video sequence conforming to one or more of the \nprofiles specified in clause G.10. \nEach picture referred to in this clause is a complete primary coded picture or part of a primary coded picture. Each \ndependency representation referred to in this clause is a dependency representation of a primary coded picture. Each layer \nrepresentation referred to in this clause is a layer representation of a primary coded picture. Each slice referred to in this \nclause is a slice of a primary coded picture. All syntax elements and derived variables referred to in this clause are syntax \nelements and derived variables for primary coded pictures. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the decoding process \nspecified in this clause and all child processes invoked from the process specified in this clause are the syntax elements \nand derived upper-case variables for the current access unit. \nThe derivation process for the set of layer representations required for decoding as specified in clause G.8.1.1 is invoked \nand the output is a list dqIdList of integer values specifying layer representation identifiers. The variables DQIdMin and \nDQIdMax are set equal to the minimum and maximum values, respectively, of the entries of the list dqIdList, and the \nvariable DependencyIdMax is set equal to (DQIdMax >> 4). DependencyIdMax shall be the same for all access units of \nthe coded video sequence. \nAt the start of the decoding process for an access unit, the following applies: \n1.  Variables and functions relating to picture order count are derived by invoking the SVC decoding process for \npicture order count as specified in clause G.8.2.1 with dqIdList as the input. \n2.  The SVC decoding process for gaps in frame_num as specified in clause G.8.2.5 is invoked with dqIdList as the \ninput. \n3.  For each value of currDQId that is contained in the list dqIdList, the following applies: \n–  The decoding process for macroblock to slice group map as specified in clause 8.2.2 is invoked with the \nsyntax elements of the NAL units with DQId equal to currDQId as the input. For this invocation of the \nprocess specified in clause 8.2.2, when currDQId is less than DQIdMax, \"active picture parameter set\" is \nsubstituted with \"active layer picture parameter set\". \n–  The function NextMbAddress( ) as specified in clause 8.2.2 is used for parsing the slice data syntax structures \nof all NAL units with DQId equal to currDQId and for inferring slice data and macroblock layer syntax \nelements for slices with slice_skip_flag equal to 1 and DQId equal to currDQId (see clause G.7.4.3.4). \nThe collective terms currentVars and refLayerVars are initially marked as not available. \nThe variable currDQId proceeds over the values DQIdMin..DQIdMax, and when a value of currDQId is present in the list \ndqIdList, the following ordered steps apply: \n1.  The  variable  spatResChangeFlag  is  set  equal  to  the  variable  SpatialResolutionChangeFlag  of  the  layer \nrepresentation with DQId equal to currDQId. \n2.  Depending on spatResChangeFlag, the following applies: \n    Rec. ITU-T H.264 (06/2019)  489 \n \n–  If spatResChangeFlag is equal to 0, the base decoding process for layer representations without resolution \nchange as specified in clause G.8.1.3.1 is invoked with currDQId and currentVars as the inputs and the \noutput is a modified version of currentVars. \n–  Otherwise (spatResChangeFlag is equal to 1), the base decoding process for layer representations with \nresolution change as specified in clause G.8.1.3.2 is invoked with currDQId and currentVars as the inputs \nand the outputs are variables assigned to the collective term refLayerVars and  a modified version of \ncurrentVars. \n3.  When  currDQId  is  equal  to  (DependencyIdMax << 4)  and  store_ref_base_pic_flag  for  the  dependency \nrepresentation with dependency_id equal to DependencyIdMax is equal to 1, the target layer representation \ndecoding  process  as  specified  in  clause G.8.1.3.3  is  invoked  with  currDQId,  refLayerVars  (when \nspatResChangeFlag is equal to 1), and currentVars as the inputs and the outputs are assigned to the sample array \nB  and, when ChromaArrayType is not equal to 0, the sample arrays B  and B . \nL Cb Cr\nNOTE 2  –  The  sample  arrays  B ,  B ,  and  B   represent  the  reference  base  picture  for  an  access  unit  with \nL Cb Cr\nstore_ref_base_pic_flag equal to 1 for the dependency representation with dependency_id equal to DependencyIdMax. \nThe target layer representation decoding process as specified in clause G.8.1.3.3 is invoked with currDQId set equal to \nDQIdMax, refLayerVars (when the variable SpatialResolutionChangeFlag of the layer representation with DQId equal to \nDQIdMax is equal to 1), and currentVars as the inputs and the outputs are assigned to the sample array S  and, when \nL\nChromaArrayType is not equal to 0, the sample arrays S  and S . \nCb Cr\nNOTE 3 – The sample arrays S , S , and S  represent the decoded picture for the access unit. \nL Cb Cr\nThe SVC decoded reference picture marking process as specified in clause G.8.2.4 is invoked with dqIdList as the input. \nG.8.1  SVC initialization and decoding processes \nClause G.8.1.1 specifies the derivation process for the set of layer representations required for decoding. \nClause G.8.1.2 specifies the array assignment, initialization, and restructuring processes. \nClause G.8.1.3 specifies the layer representation decoding processes. \nClause G.8.1.4 specifies the slice decoding processes. \nClause G.8.1.5 specifies the macroblock initialization and decoding processes. \nG.8.1.1  Derivation process for the set of layer representations required for decoding \nInputs to this process are the coded slice NAL units of an access unit. \nOutput of this process is a list dqIdList of integer values specifying layer representation identifiers. \nWith currDQId being set equal to the maximum value of DQId for all coded slice NAL units of the current access unit and \nwith refLayerDQId( dqId ) being a function that returns the value of MaxRefLayerDQId for the layer representation, of \nthe current access unit, with DQId equal to dqId, the list dqIdList is derived as specified by the following pseudo-code. \nnumEntries = 0 \ndqIdList[ numEntries++ ] = currDQId \nwhile( refLayerDQId( currDQId ) >= 0 )  { \n  dqIdList[ numEntries++ ] = refLayerDQId( currDQId )  (G-75) \n  currDQId = dqIdList[ numEntries − 1 ] \n} \nG.8.1.2  Array assignment, initialization, and restructuring processes \nClause G.8.1.2.1 specifies the array assignment and initialization process. \nClause G.8.1.2.2 specifies the array restructuring process. \nG.8.1.2.1  Array assignment and initialization process \nOutput of this process is a set of arrays that are assigned to the collective term currentVars. \nThe following arrays are collectively referred to as currentVars: \n–  A one-dimensional array sliceIdc with PicSizeInMbs elements specifying slice identifications for the macroblocks of \na  layer  representation.  An  element  of  this  array  for  a  macroblock  with  address  mbAddr  is  referred  to  as \nsliceIdc[ mbAddr ]. All elements of the array sliceIdc are initially marked as unspecified. \n–  A  one-dimensional  array  fieldMbFlag  with  PicSizeInMbs  elements  specifying  which  macroblocks  of  a  layer \nrepresentation are field macroblocks and which macroblocks are frame macroblocks. An element of this array for a \n490  Rec. ITU-T H.264 (06/2019) \n \nmacroblock with address mbAddr is referred to as fieldMbFlag[ mbAddr ]. All elements of the array fieldMbFlag are \ninitially marked as unspecified. \n–  A one-dimensional array cTrafo with PicSizeInMbs elements specifying the luma and, when ChromaArrayType is \nequal to 3, chroma transform types for the macroblocks of a layer representation. An element of this array for a \nmacroblock with address mbAddr is referred to as cTrafo[ mbAddr ]. Unless marked as unspecified, each element of \ncTrafo is equal to T_4x4, T_8x8, T_16x16, or T_PCM. All elements of the array cTrafo are initially marked as \nunspecified. \n–  A one-dimensional array baseModeFlag with PicSizeInMbs elements specifying the syntax element base_mode_flag \nfor the macroblocks of a layer representation. An element of this array for a macroblock with address mbAddr is \nreferred to as baseModeFlag[ mbAddr ]. All elements of the array baseModeFlag are initially marked as unspecified. \n–  A one-dimensional array mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of \na  layer  representation.  An  element  of  this  array  for  a  macroblock  with  address  mbAddr  is  referred  to  as \nmbType[ mbAddr ]. Unless marked as unspecified, each element of mbType is equal to I_4x4, I_8x8, I_16x16, \nI_PCM, I_BL, or one of the Inter macroblock types specified in Tables 7-13 and 7-14. All elements of the array \nmbType are initially marked as unspecified. \n–  A  (PicSizeInMbs)x4  array  subMbType  specifying  sub-macroblock  types  for  the  macroblocks  of  a  layer \nrepresentation. An element of this array for a macroblock with address mbAddr and a macroblock partition index \nmbPartIdx is referred to as subMbType[ mbAddr ][ mbPartIdx ]. A one-dimensional array specifying sub-macroblock \ntypes for the macroblock partitions of a macroblock with address mbAddr is referred to as subMbType[ mbAddr ]. \nUnless marked as unspecified, each element of subMbType is equal to one of the sub-macroblock types specified in \nTables 7-17 and 7-18. All elements of the array subMbType are initially marked as unspecified. \n–  A one-dimensional array  mvCnt  with PicSizeInMbs elements specifying the number of  motion  vectors for the \nmacroblocks of a layer representation. An element of this array for a macroblock with address mbAddr is referred to \nas mvCnt[ mbAddr ]. All elements of the array mvCnt are initially set equal to 0. \n–  A  one-dimensional  array  tQP   with  PicSizeInMbs  elements  specifying  luma  quantization  parameters  for  the \nY\nmacroblocks of a layer representation. An element of this array for a macroblock with address mbAddr is referred to \nas tQP [ mbAddr ]. All elements of the array tQP  are initially set equal to 0. \nY Y\n–  When ChromaArrayType is not equal to 0, two one-dimensional arrays tQP  and tQP  with PicSizeInMbs elements \nCb Cr\nspecifying Cb and Cr quantization parameters, respectively, for the macroblocks of a layer representation. An element \nof these arrays for a macroblock with address mbAddr is referred to as tQP [ mbAddr ] with CX being replaced by \nCX\nCb or Cr. All elements of the arrays tQP  and tQP  are initially set equal to 0. \nCb Cr\n–  A  (PicSizeInMbs)x16  array  ipred4x4  specifying  Intra_4x4  prediction  modes  for  the  macroblocks  of  a  layer \nrepresentation.  An  element  of  this  array  for  a  macroblock  with  address  mbAddr  and  a  4x4  block  with  index \nc4x4BlkIdx  is  referred  to  as  ipred4x4[ mbAddr ][ c4x4BlkIdx ].  A  one-dimensional  array  specifying  Intra_4x4 \nprediction modes for the 4x4 blocks of a macroblock with address mbAddr is referred to as ipred4x4[ mbAddr ]. All \nelements of the array ipred4x4 are initially marked as unspecified. \n–  A  (PicSizeInMbs)x4  array  ipred8x8  specifying  Intra_8x8  prediction  modes  for  the  macroblocks  of  a  layer \nrepresentation.  An  element  of  this  array  for  a  macroblock  with  address  mbAddr  and  a  8x8  block  with  index \nc8x8BlkIdx  is  referred  to  as  ipred8x8[ mbAddr ][ c8x8BlkIdx ].  A  one-dimensional  array  specifying  Intra_8x8 \nprediction modes for the 8x8 blocks of a macroblock with address mbAddr is referred to as ipred8x8[ mbAddr ]. All \nelements of the array ipred8x8 are initially marked as unspecified. \n–  A one-dimensional array ipred16x16 with PicSizeInMbs elements specifying Intra_16x16 prediction modes for the \nmacroblocks of a layer representation. An element of this array for a macroblock with address mbAddr is referred to \nas ipred16x16[ mbAddr ]. All elements of the array ipred16x16 are initially marked as unspecified. \n–  When ChromaArrayType is equal to 1 or 2, a one-dimensional array ipredChroma with PicSizeInMbs elements \nspecifying intra chroma prediction modes for the macroblocks of a layer representation. An element of this array for \na macroblock with address mbAddr is referred to as ipredChroma[ mbAddr ]. All elements of the array ipredChroma \nare initially marked as unspecified. \n–  Two (PicSizeInMbs)x4 arrays predFlagL0 and predFlagL1 specifying prediction utilization flags for the macroblocks \nof a layer representation. An element of these arrays for a macroblock with address mbAddr and a macroblock \npartition index mbPartIdx is referred to as predFlagLX[ mbAddr ][ mbPartIdx ] with X being replaced by 0 or 1. A \none-dimensional array specifying prediction utilization flags for the macroblock partitions of a macroblock with \naddress mbAddr is referred to as predFlagLX[ mbAddr ] with X being replaced by 0 or 1. All elements of the arrays \npredFlagL0 and predFlagL1 are initially set equal to 0. \n–  Two (PicSizeInMbs)x4 arrays refIdxL0 and refIdxL1 specifying reference indices for the macroblocks of a layer \nrepresentation. An element of these arrays for a macroblock with address mbAddr and a macroblock partition index \n    Rec. ITU-T H.264 (06/2019)  491 \n \nmbPartIdx is referred to as refIdxLX[ mbAddr ][ mbPartIdx ] with X being replaced by 0 or 1. A one-dimensional \narray specifying reference indices for the macroblock partitions of a macroblock with address mbAddr is referred to \nas refIdxLX[ mbAddr ] with X being replaced by 0 or 1. All elements of the arrays refIdxL0 and refIdxL1 are initially \nset equal to −1. \n–  Two (PicSizeInMbs)x4x4x2 arrays mvL0 and mvL1 specifying motion vector components for the macroblocks of a \nlayer representation. An element of these arrays for a macroblock with address mbAddr, a macroblock partition index \nmbPartIdx, a sub-macroblock partition index subMbPartIdx, and a motion vector component index c is referred to as \nmvLX[ mbAddr ][ mbPartIdx ][ subMbPartIdx ][ c ] with X being replaced by 0 or 1. A one-dimensional array with \n2 elements representing the motion vector for a sub-macroblock partition subMbPartIdx of a macroblock partition \nmbPartIdx inside a macroblock mbAddr is referred to as mvLX[ mbAddr ][ mbPartIdx ][ subMbPartIdx ] with X \nbeing replaced by 0 or 1. A 4x2 array representing the motion vectors for a macroblock partition mbPartIdx inside a \nmacroblock mbAddr is referred to as mvLX[ mbAddr ][ mbPartIdx ] with X being replaced by 0 or 1. A 4x4x2 array \nrepresenting the motion vectors for a macroblock mbAddr is referred to as mvLX[ mbAddr ] with X being replaced \nby 0 or 1. A motion vector component with component index c for a macroblock partition mbPartIdx of a macroblock \nmbAddr that is not split into sub-macroblock partitions can also be referred to as mvLX[ mbAddr ][ mbPartIdx ][ c ] \nwith X being replaced by 0 or 1, which is identical to mvLX[ mbAddr ][ mbPartIdx ][ 0 ][ c ]. A motion vector for a \nmacroblock partition mbPartIdx of a macroblock mbAddr that is not split into sub-macroblock partitions can also be \nreferred  to  as  mvLX[ mbAddr ][ mbPartIdx ]  with  X  being  replaced  by  0  or  1,  which  is  identical  to \nmvLX[ mbAddr ][ mbPartIdx ][ 0 ]. All elements of the arrays mvL0 and mvL1 are initially set equal to 0. \n–  A (PicSizeInMbs)x(256 + 2 * MbWidthC * MbHeightC) array tCoeffLevel specifying transform coefficient level \nvalues for the macroblocks of a layer representation. An element of this array for a macroblock with address mbAddr \nand a transform coefficient index tCoeffIdx is referred to as tCoeffLevel[ mbAddr ][ tCoeffIdx ]. A one-dimensional \narray specifying the transform coefficient level values for a macroblock with address mbAddr is referred to as \ntCoeffLevel[ mbAddr ]. All elements of the array tCoeffLevel are initially set equal to 0. \n–  A  (PicSizeInMbs)x(256 + 2 * MbWidthC * MbHeightC)  array  sTCoeff  specifying  scaled  transform  coefficient \nvalues for the macroblocks of a layer representation. An element of this array for a macroblock with address mbAddr \nand a transform coefficient index tCoeffIdx is referred to as sTCoeff[ mbAddr ][ tCoeffIdx ]. A one-dimensional array \nspecifying  the  scaled  transform  coefficient  values  for  a  macroblock  with  address  mbAddr  is  referred  to  as \nsTCoeff[ mbAddr ]. All elements of the array sTCoeff are initially set equal to 0. \n–  A (PicWidthInSamples )x(PicHeightInSamples ) array rS  specifying residual luma sample values for a layer picture. \nL L L\nAn element of this array for a luma location ( x, y ) relative to the upper-left luma sample of the macroblock with \naddress 0 is referred to as rS [ x, y ]. All elements of the array rS  are initially set equal to 0. \nL L\n–  When ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays rS  and rS  \nC C Cb Cr\nspecifying residual chroma sample values for a layer picture. An element of these arrays for a chroma location ( x, y ) \nrelative to the upper-left chroma sample of the macroblock with address 0 is referred to as rS [ x, y ] with CX being \nCX\nreplaced by Cb or Cr. All elements of the arrays rS  and rS  are initially set equal to 0. \nCb Cr\n–  A (PicWidthInSamples )x(PicHeightInSamples ) array cS  specifying constructed luma sample values for a layer \nL L L\npicture. An element of this array for a luma location ( x, y ) relative to the upper-left luma sample of the macroblock \nwith address 0 is referred to as cS [ x, y ]. All elements of the array cS  are initially set equal to 0. \nL L\n–  When ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays cS  and cS  \nC C Cb Cr\nspecifying constructed chroma sample values for a layer picture. An element of these arrays for a chroma location \n( x, y ) relative to the upper-left chroma sample of the macroblock with address 0 is referred to as cS [ x, y ] with \nCX\nCX being replaced by Cb or Cr. All elements of the arrays cS  and cS  are initially set equal to 0. \nCb Cr\nG.8.1.2.2  Array restructuring process \nThis process is only invoked when MinNoInterLayerPredFlag is equal to 0, SpatialResolutionChangeFlag is equal to 0, \nand  any  of  the  variables  ScaledRefLayerLeftOffset,  ScaledRefLayerRightOffset,  ScaledRefLayerTopOffset,  or \nScaledRefLayerBottomOffset is not equal to 0. \nInput to this process is a set of arrays collectively referred to as currentVars. \nOutput of this process is the set of arrays collectively referred to as currentVars with modifications related to the array \nsizes as well as the ordering of array elements. \nThe variables that are assigned to the collective term currentVars are assigned to the collective term refLayerVars. \nThe array assignment and initialization process as specified in clause G.8.1.2.1 is invoked and the output is the set of arrays \ncollectively referred to as currentVars. \nThe variables xOffset, yOffset, xOffsetC, and yOffsetC are derived by \n492  Rec. ITU-T H.264 (06/2019) \n \nxOffset    = ScaledRefLayerLeftOffset  (G-76) \nyOffset    = ScaledRefLayerTopOffset  / ( 1 + field_pic_flag )  (G-77) \nxOffsetC = ( xOffset >> 4 ) * MbWidthC  (G-78) \nyOffsetC = ( yOffset >> 4 ) * MbHeightC  (G-79) \nFor the macroblock address mbAddr proceeding over the values 0..(PicSizeInMbs − 1), the following ordered steps are \nspecified: \n1.  With eS set equal to (1 + MbaffFrameFlag), the variables refMbX and refMbY are derived by \nrefMbX = ( ( mbAddr / eS ) % PicWidthInMbs ) − ( xOffset / 16 )  (G-80) \nrefMbY = ( ( mbAddr / eS )  /  PicWidthInMbs ) * eS + ( mbAddr % eS ) − ( yOffset / 16 )  (G-81) \n2.  The reference layer macroblock address refMbAddr is derived as follows: \n–  If any of the following conditions are true, refMbAddr is marked as not available: \n–  refMbX is less than 0 or refMbX is greater than or equal to RefLayerPicWidthInMbs, \n–  refMbY is less than 0 or refMbY is greater than or equal to RefLayerPicHeightInMbs. \n–  Otherwise, with bS set equal to (1 + RefLayerMbaffFrameFlag), refMbAddr is derived by \nrefMbAddr = ( refMbY / bS ) * bS * RefLayerPicWidthInMbs + ( refMbY % bS ) + refMbX  (G-82) \n3.  When refMbAddr is available, for X being replaced by sliceIdc, fieldMbFlag, cTrafo, baseModeFlag, mbType, \nsubMbType, mvCnt, tQP , tQP  (when ChromaArrayType is not equal to 0), tQP  (when ChromaArrayType \nY Cb Cr\nis not equal to 0), ipred4x4, ipred8x8, ipred16x16, ipredChroma (when ChromaArrayType is equal to 1 or 2), \npredFlagL0,  predFlagL1,  refIdxL0,  refIdxL1,  mvL0,  mvL1,  tCoeffLevel,  and  sTCoeff  and  with  currArray \nrepresenting the array X of the collective term currentVars and refLayerArray representing the array X of the \ncollective term refLayerVars, the array element currArray[ mbAddr ], which can be a scalar or an array, is set \nequal to the array element refLayerArray[ refMbAddr ]. \nFor X being replaced by rS  and cS  and with currArray representing the array X of the collective term currentVars and \nL L\nrefLayerArray representing the array X of the collective term refLayerVars, the array currArray is modified by \ncurrArray[ x, y ] = refLayerArray[ x − xOffset, y − yOffset ] \n      (G-83) \nwith x = Max( 0, xOffset )..Min( PicWidthInSamples , RefLayerPicWidthInSamples   + xOffset ) − 1 \nL L\nand  y = Max( 0, yOffset )..Min( PicHeightInSamples , RefLayerPicHeightInSamples  + yOffset ) − 1 \nL L\nWhen  ChromaArrayType  is  not  equal  to  0,  for  X  being  replaced by  rS ,  rS ,  cS ,  and  cS   and  with  currArray \nCb Cr Cb Cr\nrepresenting the array X of the collective term currentVars and refLayerArray representing the array X of the collective \nterm refLayerVars, the array currArray is modified by \ncurrArray[ x, y ] = refLayerArray[ x − xOffsetC, y − yOffsetC ] \n      (G-84) \nwith x = Max( 0, xOffsetC )..Min( PicWidthInSamples , RefLayerPicWidthInSamples   + xOffsetC ) − 1 \nC C\nand  y = Max( 0, yOffsetC )..Min( PicHeightInSamples , RefLayerPicHeightInSamples  + yOffsetC ) − 1 \nC C\nG.8.1.3  Layer representation decoding processes \nClause G.8.1.3.1 specifies the base decoding process for layer representations without resolution change. \nClause G.8.1.3.2 specifies the base decoding process for layer representations with resolution change. \nClause G.8.1.3.3 specifies the target layer representation decoding process \nG.8.1.3.1  Base decoding process for layer representations without resolution change \nInputs to this process are: \n–  a variable currDQId specifying the current layer representation, \n–  a set of arrays collectively referred to as currentVars. \nOutput of this process is the modified set of arrays collectively referred to as currentVars. \nThis process modifies the variables assigned to currentVars using syntax elements and derived upper-case variables for the \ncurrent layer representation with DQId equal to currDQId. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the current layer representation with DQId equal to currDQId. \n    Rec. ITU-T H.264 (06/2019)  493 \n \nThe base decoding process for layer representations without resolution change proceeds in the following ordered steps: \n1.  Depending on MinNoInterLayerPredFlag, the following applies: \n–  If MinNoInterLayerPredFlag is equal to 1, the array assignment and initialization process as specified in \nclause G.8.1.2.1 is invoked and the output is a modified set of arrays collectively referred to as currentVars. \n–  Otherwise (MinNoInterLayerPredFlag is equal to 0), the following ordered steps are specified: \na.  When MaxTCoeffLevelPredFlag is equal to 0, the macroblock address mbAddr proceeds over the \nvalues 0..(RefLayerPicSizeInMbs − 1), and for each  macroblock address  mbAddr, the  macroblock \ndecoding  process  prior  to  decoding  a  layer  representation  without  resolution  change  and \nMaxTCoeffLevelPredFlag equal to 0 as specified in clause G.8.1.5.4 is invoked with currDQId set equal \nto MaxRefLayerDQId, mbAddr, and currentVars as the inputs and the output is a modified version of \ncurrentVars. \nb.  When  any  of  the  variables  ScaledRefLayerLeftOffset,  ScaledRefLayerRightOffset, \nScaledRefLayerTopOffset, or ScaledRefLayerBottomOffset is not equal to 0, the array restructuring \nprocess as specified in clause G.8.1.2.2 is invoked with currentVars as the input and the output is a \nmodified version of currentVars. \n2.  Let setOfSlices be the set of all slices of the current layer representation with DQId equal to currDQId. For each \nslice of the set setOfSlices, the base decoding process for slices without resolution change as specified in \nclause G.8.1.4.1 is invoked with currSlice representing the currently processed slice, currDQId, and currentVars \nas the inputs and the output is a modified version of currentVars. \n3.  When currDQId is less than or equal to (DependencyIdMax << 4), with sliceIdc being the array sliceIdc of the \ncollective  term  currentVars,  the  bitstream  shall  not  contain  data  that  result  in  any  value  of \n(sliceIdc[ mbAddr ] & 127) with mbAddr = 0..(PicSizeInMbs − 1) not equal to currDQId. \nNOTE – This constraint and a similar constraint in clause G.8.1.3.2 specify that all layer representations with quality_id equal \nto 0 and all layer representations that are used for inter-layer prediction must be completely covered by the slices of the access \nunit. An additional constraint for layer representations with dependency_id equal to DependencyIdMax and quality_id greater \nthan 0 is specified in clause G.8.1.5.1. \nG.8.1.3.2  Base decoding process for layer representations with resolution change \nInputs to this process are: \n–  a variable currDQId specifying the current layer representation, \n–  a set of arrays collectively referred to as currentVars. \nOutputs of this process are: \n–  a set of arrays collectively referred to as refLayerVars, \n–  the modified set of arrays collectively referred to as currentVars. \nThis process modifies the variables assigned to currentVars using syntax elements and derived upper-case variables for the \ncurrent layer representation with DQId equal to currDQId. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the current layer representation with DQId equal to currDQId. \nThe base decoding process for layer representations with resolution change proceeds in the following ordered steps: \n1.  The  macroblock  address  mbAddr  proceeds  over  the  values  0..(RefLayerPicSizeInMbs − 1),  and  for  each \nmacroblock  address  mbAddr,  the  macroblock  decoding  process  prior  to  resolution  change  as  specified  in \nclause G.8.1.5.5 is invoked with currDQId set equal to MaxRefLayerDQId, mbAddr, and currentVars as the \ninputs and the output is a modified version of currentVars. \n2.  The deblocking filter process for Intra_Base prediction as specified in clause G.8.7.1 is invoked with currDQId \nand currentVars as the inputs and the output is a modified version of currentVars. \n3.  The variables that are assigned to the collective term currentVars are assigned to the collective term refLayerVars. \n4.  The array assignment and initialization process as specified in clause G.8.1.2.1 is invoked and the output is \nassigned to the collective term currentVars. \n5.  Let setOfSlices be the set of all slices of the current layer representation with DQId equal to currDQId. For each \nslice  of  the  set  setOfSlices,  the  base  decoding  process  for  slices  with  resolution  change  as  specified  in \n494  Rec. ITU-T H.264 (06/2019) \n \nclause G.8.1.4.2 is invoked with currSlice representing the currently processed slice, currDQId, refLayerVars, \nand currentVars as the inputs and the output is a modified version of currentVars. \n6.  With sliceIdc being the array sliceIdc of the collective term currentVars, the bitstream shall not contain data that \nresult in any value of (sliceIdc[ mbAddr ] & 127) with mbAddr = 0..(PicSizeInMbs − 1) not equal to currDQId. \nNOTE – This constraint and a similar constraint in clause G.8.1.3.1 specify that all layer representations with quality_id equal \nto 0 and all layer representation that are used for inter-layer prediction must be completely covered by the slices of the access \nunit. An additional constraint for layer representations with dependency_id equal to DependencyIdMax and quality_id greater \nthan 0 is specified in clause G.8.1.5.1. \nG.8.1.3.3  Target layer representation decoding process \nInputs to this process are: \n–  a variable currDQId specifying the current layer representation, \n–  when present, a set of arrays collectively referred to as refLayerVars, \n–  a set of arrays collectively referred to as currentVars. \nOutputs of this process are: \n–  a (PicWidthInSamples )x(PicHeightInSamples ) array s  containing constructed luma sample values, \nL L L\n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays s  and s  \nC C Cb Cr\ncontaining constructed chroma sample values. \nIn this process the constructed samples of the array s  and, when ChromaArrayType is not equal to 0, the arrays s  and \nL Cb\ns  are derived using the variables that are assigned to currentVars. \nCr\nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the current layer representation with DQId equal to currDQId. \nThe target layer representation decoding process proceeds in the following ordered steps: \n1.  The variables that are assigned to the collective term currentVars are assigned to the collective term tempVars, \nand in the following of this clause, the arrays that are collectively referred to as tempVars are referred to by their \nnames as specified in clause G.8.1.2.1. \nNOTE 1 – Any following modification of the variables assigned to the collective term tempVars does not influence the \nvariables assigned to the collective term currentVars. \n2.  The macroblock address mbAddr proceeds over the values 0..(PicSizeInMbs − 1), and for each macroblock \naddress mbAddr, the following ordered steps are specified: \na.  Let  currSlice  specify  the  slice  of  the  layer  representation  with  DQId  equal  to \n( ( ( sliceIdc[ mbAddr ] & 127 ) >> 4 ) << 4 )  that  covers  the  macroblock  with  macroblock  address \n( ( sliceIdc[ mbAddr ] >> 7 ) * ( 1 + MbaffFrameFlag ) ). \nb.  Let  firstMbInSlice  and  sliceType  be  the  syntax  elements  first_mb_in_slice  and  slice_type  of  the  slice \ncurrSlice. \nc.  The variable firstMbAddrInSlice is set equal to (firstMbInSlice * ( 1 + MbaffFrameFlag )). \nd.  The reference picture lists refPicList0 and refPicList1 are marked as not available. \ne.  When (sliceType % 5) is less than 2, the following applies: \n–  If mbAddr is greater than firstMbAddrInSlice, the reference picture list refPicList0 is set equal to the \nreference  picture  list  refPicList0  that  was  derived  for  the  macroblock  address  mbAddr  equal  to \nfirstMbAddrInSlice inside this clause and, when (sliceType % 5) is equal to 1, the reference picture list \nrefPicList1 is set equal to the reference picture list refPicList1 that was derived for the macroblock \naddress mbAddr equal to firstMbAddrInSlice inside this clause. \n–  Otherwise (mbAddr is equal to firstMbAddrInSlice), the SVC decoding process for reference picture \nlists  construction  as  specified  in  clause G.8.2.3  is  invoked  with  currDependencyId  set  equal  to \ndependency_id, useRefBasePicFlag set equal to use_ref_base_pic_flag, and the slice currSlice as the \ninputs and the outputs are the modified reference picture list refPicList0 and, when (sliceType % 5) is \nequal to 1, the modified reference picture list refPicList1. \nNOTE 2 – The reference picture lists refPicList0 and refPicList1 are only constructed for the slices of the layer \nrepresentation  with  dependency_id  equal  to  DependencyIdMax  and  quality_id  equal  to  0.  For  slices  with \ndependency_id equal to DependencyIdMax and quality_id greater than 0, the reference picture lists are inferred. \n    Rec. ITU-T H.264 (06/2019)  495 \n \nf.  The target macroblock decoding process as specified in clause G.8.1.5.6 is invoked with currDQId, mbAddr, \nrefLayerVars (when present as input to this clause), tempVars, refPicList0 (when available), and refPicList1 \n(when available) as the inputs and the output is a modified version of tempVars. \nNOTE 3  –  Although  the  target  layer  representation  decoding  process  is  invoked  twice  for  pictures  with \nstore_ref_base_pic_flag equal to 1, only a single motion compensation operation is needed for each macroblock. \n3.  The deblocking filter process for target representations as specified in clause G.8.7.2 is invoked with currDQId \nand tempVars as the inputs and the output is a modified version of tempVars. \n4.  All sample values of the array cS  are copied to the array s , which is output of this clause. \nL L\n5.  When ChromaArrayType is not equal to 0, all sample values of the arrays cS  and cS  are copied to the arrays \nCb Cr\ns  and s , respectively, which are output of this clause. \nCb Cr\nG.8.1.4  Slice decoding processes \nClause G.8.1.4.1 specifies the base decoding process for slices without resolution change. \nClause G.8.1.4.2 specifies the base decoding process for slices with resolution change. \nG.8.1.4.1  Base decoding process for slices without resolution change \nInputs to this process are: \n–  the current slice currSlice, \n–  a variable currDQId specifying the current layer representation, \n–  a set of arrays collectively referred to as currentVars. \nOutput of this process is the modified set of arrays collectively referred to as currentVars. \nThis process modifies the variables assigned to currentVars using syntax elements and derived upper-case variables for the \ncurrent slice currSlice. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the slice header of the current slice currSlice, the current picture parameter, which is identified by the syntax element \npic_parameter_set_id inside the slice header of the current slice currSlice, and the current sequence parameter, which is \nidentified by the syntax element seq_parameter_set_id inside the current picture parameter set. \nWhen currDQId is equal to 0 and (slice_type % 5) is equal to 1, the SVC decoding process for reference picture lists \nconstruction as specified in clause G.8.2.3 is invoked with currDependencyId equal to 0, useRefBasePicFlag equal to \nuse_ref_base_pic_flag, and the current slice as input and the output is the reference picture list refPicList1. \nThe macroblocks of the current slice currSlice are processed in increasing order of their macroblock addresses. For each \nmacroblock with macroblock address mbAddr, the base decoding process for macroblocks in slices without resolution \nchange as specified in clause G.8.1.5.2 is invoked with currDQId, mbAddr, currentVars, and, when currDQId is equal to \n0 and (slice_type % 5) is equal to 1, the reference picture list refPicList1 as the inputs and the output is a modified version \nof currentVars. \nG.8.1.4.2  Base decoding process for slices with resolution change \nInputs to this process are: \n–  the current slice currSlice, \n–  a variable currDQId specifying the current layer representation, \n–  a set of arrays collectively referred to as refLayerVars, \n–  a set of arrays collectively referred to as currentVars. \nOutput of this process is the modified set of arrays collectively referred to as currentVars. \nThis process modifies the variables assigned to currentVars using syntax elements and derived upper-case variables for the \ncurrent slice currSlice. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the slice header of the current slice currSlice, the current picture parameter, which is identified by the syntax element \npic_parameter_set_id inside the slice header of the current slice currSlice, and the current sequence parameter, which is \nidentified by the syntax element seq_parameter_set_id inside the current picture parameter set. \n496  Rec. ITU-T H.264 (06/2019) \n \nWhen CroppingChangeFlag is equal to 1 and (slice_type % 5) is less than 2, the SVC decoding process for reference \npicture  lists  construction  as  specified  in  clause G.8.2.3  is  invoked  with  currDependencyId  equal  to  dependency_id, \nuseRefBasePicFlag equal to use_ref_base_pic_flag, and the current slice as the inputs and the outputs are the reference \npicture list refPicList0 and, when (sliceType % 5) is equal to 1, the reference picture list refPicList1. \nThe macroblocks of the current slice currSlice are processed in increasing order of their macroblock addresses. For each \nmacroblock with macroblock address mbAddr, the base decoding process for macroblocks in slices with resolution change \nas  specified  in  clause G.8.1.5.3  is  invoked  with  currDQId,  mbAddr,  refLayerVars,  currentVars,  refPicList0  (when \nCroppingChangeFlag is equal to 1 and (slice_type % 5) is less than 2), and refPicList1 (when CroppingChangeFlag is \nequal to 1 and (slice_type % 5) is equal to 1) as the inputs and the output is a modified version of currentVars. \nG.8.1.5  Macroblock initialization and decoding processes \nClause G.8.1.5.1 specifies the macroblock initialization process. \nClause G.8.1.5.2 specifies the base decoding process for macroblocks in slices without resolution change. \nClause G.8.1.5.3 specifies the base decoding process for macroblocks in slices with resolution change. \nClause G.8.1.5.4 specifies the macroblock decoding process prior to decoding a layer representation without resolution \nchange and MaxTCoeffLevelPredFlag equal to 0. \nClause G.8.1.5.5 specifies the macroblock decoding process prior to resolution change. \nClause G.8.1.5.6 specifies the target macroblock decoding process. \nG.8.1.5.1  Macroblock initialization process \nInputs to this process are: \n–  a set of arrays collectively referred to as refLayerVars, \n–  when CroppingChangeFlag is equal to 1 and (slice_type % 5) is less than 2, the reference picture list refPicList0, \n–  when CroppingChangeFlag is equal to 1 and (slice_type % 5) is equal to 1, the reference picture list refPicList1. \nOutputs of this process are: \n–  a variable sliceIdc specifying the slice identification for the current macroblock, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable cTrafo specifying the transform type for the current macroblock, \n–  a variable baseModeFlag specifying the syntax element base_mode_flag of the current macroblock, \n–  a variable mbType specifying the macroblock type of the current macroblock, \n–  a list subMbType with 4 elements specifying the sub-macroblock types of the current macroblock, \n–  a variable mvCnt specifying an initialization value for the motion vector count of the current macroblock, \n–  a variable tQP  specifying the luma quantization parameter for the current macroblock, \nY\n–  when  ChromaArrayType  is  not  equal  to  0,  two  variables  tQP   and  tQP   specifying  the  chroma  quantization \nCb Cr\nparameters for the current macroblock, \n–  two 2x2 arrays refIdxILPredL0 and refIdxILPredL1 specifying inter-layer predictors for the reference indices of the \ncurrent macroblock, \n–  two 4x4x2 arrays mvILPredL0 and mvILPredL1 specifying inter-layer predictors for the motion vector components \nof the current macroblock. \nInside  this  clause,  the  arrays  sliceIdc,  fieldMbFlag,  cTrafo,  mbType,  subMbType,  tQP ,  predFlagL0,  predFlagL1, \nY\nrefIdxL0, refIdxL1, mvL0, mvL1, tCoeffLevel, and sTCoeff that are collectively referred to as refLayerVars are referred \nto  as  refLayerSliceIdc,  refLayerFieldMbFlag,  refLayerCTrafo,  refLayerMbType,  refLayerSubMbType,  refLayerQP , \nY\nrefLayerPredFlagL0,  refLayerPredFlagL1,  refLayerRefIdxL0,  refLayerRefIdxL1,  refLayerMvL0,  refLayerMvL1, \nrefLayerTCoeffLevel, and refLayerSTCoeff, respectively. \nThe variable sliceIdc is set equal to ( (first_mb_in_slice << 7 ) + DQId ). \nThe variable baseModeFlag is set equal to base_mode_flag. \nThe variable fieldMbFlag is derived as follows: \n    Rec. ITU-T H.264 (06/2019)  497 \n \n–  If field_pic_flag is equal to 1, fieldMbFlag is set equal to 1. \n–  Otherwise, if SpatialResolutionChangeFlag is equal to 0 and slice_skip_flag is equal to 1, fieldMbFlag is set equal to \nrefLayerFieldMbFlag[ CurrMbAddr ]. \n–  Otherwise, fieldMbFlag is set equal to mb_field_decoding_flag. \nThe derivation process for macroblock type, sub-macroblock type, and inter-layer predictors for reference indices and \nmotion vectors as specified in clause G.8.1.5.1.1 is invoked with fieldMbFlag, refLayerFieldMbFlag, refLayerMbType, \nrefLayerSubMbType, refLayerPredFlagL0, refLayerPredFlagL1, refLayerRefIdxL0, refLayerRefIdxL1, refLayerMvL0, \nrefLayerMvL1, refPicList0 (when available), and refPicList1 (when available) as the inputs and the outputs are the variable \nmbType, the list subMbType, the 2x2 arrays refIdxILPredL0 and refIdxILPredL1, and the 4x4x2 arrays mvILPredL0 and \nmvILPredL1. \nThe derivation process for quantization parameters and transform type as specified in clause G.8.1.5.1.2 is invoked with \nmbType, subMbType, refLayerMbType, refLayerCTrafo, refLayerQP , refLayerTCoeffLevel, and refLayerSTCoeff as \nY\nthe inputs and the outputs are cTrafo, tQP , and, when ChromaArrayType is not equal to 0, tQP  and tQP . \nY Cb Cr\nThe variable mvCnt is set equal to 0. \nWhen  quality_id  is  greater  than  0,  the  bitstream  shall  not  contain  data  that  result  in \n(refLayerSliceIdc[ CurrMbAddr ] & 127) not equal to (DQId − 1). \nWhen no_inter_layer_pred_flag is equal to 0, SpatialResolutionChangeFlag is equal to 0, and fieldMbFlag is not equal to \nrefLayerFieldMbRef[ CurrMbAddr ], the following constraints shall be obeyed: \na)  The  bitstream  shall  not  contain  data  that  result  in  base_mode_flag  equal  to  1,  or  any \nmotion_prediction_flag_lX[ mbPartIdx ] with X being replaced by 0 and 1 and mbPartIdx = 0..3 equal to 1. \nb)  When residual_prediction_flag is equal to 1, refLayerMbType[ CurrMbAddr ] is not equal to I_PCM, I_16x16, \nI_8x8, I_4x4, or I_BL, and mbType is not equal to I_PCM, I_16x16, I_8x8, I_4x4, or I_BL, the following applies: \n–  If tcoeff_level_prediction_flag is equal to 0, the bitstream shall not contain data that result in any element \nrefLayerSTCoeff[ CurrMbAddr ][ i ] not equal to 0 for i = 0..(255 + 2 * MbWidthC * MbHeightC). \n–  Otherwise (tcoeff_level_prediction_flag is equal to 1), the bitstream shall not contain data that result in any \nelement  refLayerTCoeffLevel[ CurrMbAddr ][ i ]  not  equal  to  0  for \ni = 0..(255 + 2 * MbWidthC * MbHeightC). \nG.8.1.5.1.1  Derivation process for macroblock type, sub-macroblock type, and inter-layer predictors for reference \nindices and motion vectors \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  a one-dimensional array refLayerMbType with RefLayerPicSizeInMbs elements specifying the macroblock types for \nthe macroblocks of the reference layer representation, \n–  a (RefLayerPicSizeInMbs)x4 array refLayerSubMbType specifying the sub-macroblock types for the macroblocks of \nthe reference layer representation, \n–  two (RefLayerPicSizeInMbs)x4 arrays refLayerPredFlagL0 and refLayerPredFlagL1 specifying prediction utilization \nflags for the macroblocks of the reference layer representation, \n–  two (RefLayerPicSizeInMbs)x4 arrays refLayerRefIdxL0 and refLayerRefIdxL1 specifying reference indices for the \nmacroblocks of the reference layer representation, \n–  two (RefLayerPicSizeInMbs)x4x4x2 arrays refLayerMvL0 and refLayerMvL1 specifying motion vector components \nfor the macroblocks of the reference layer representation, \n–  when CroppingChangeFlag is equal to 1 and (slice_type % 5) is less than 2, the reference picture list refPicList0, \n–  when CroppingChangeFlag is equal to 1 and (slice_type % 5) is equal to 1, the reference picture list refPicList1. \nOutputs of this process are: \n–  a variable mbType specifying the macroblock type of the current macroblock, \n–  a list subMbType with 4 elements specifying the sub-macroblock types of the current macroblock, \n498  Rec. ITU-T H.264 (06/2019) \n \n–  two 2x2 arrays refIdxILPredL0 and refIdxILPredL1 specifying inter-layer predictors for the reference indices of the \ncurrent macroblock, \n–  two 4x4x2 arrays mvILPredL0 and mvILPredL1 specifying inter-layer predictors for the motion vector components \nof the current macroblock. \nThe variable mbTypeILPred, the list subMbTypeILPred, the 2x2 arrays refIdxILPredL0 and refIdxILPredL1, and the \n4x4x2 arrays mvILPredL0 and mvILPredL1 are derived as follows: \n–  If base_mode_flag is equal to 1 or any syntax element motion_prediction_flag_lX[ mbPartIdx ] with X being replaced \nby 0 and 1 and mbPartIdx = 0..3 is equal to 1, the derivation process for inter-layer predictors for macroblock type, \nsub-macroblock  type,  reference  indices,  and  motion  vectors  as  specified  in  clause G.8.6.1  is  invoked  with \nfieldMbFlag,  refLayerFieldMbFlag,  refLayerMbType,  refLayerSubMbType,  refLayerPredFlagL0, \nrefLayerPredFlagL1,  refLayerRefIdxL0,  refLayerRefIdxL1,  refLayerMvL0,  refLayerMvL1,  refPicList0  (when \navailable), and refPicList1 (when available) as the inputs and the outputs are the variable mbTypeILPred, the list \nsubMbTypeILPred, the 2x2 arrays refIdxILPredL0 and refIdxILPredL1, and the 4x4x2 arrays mvILPredL0 and \nmvILPredL1. \n–  Otherwise (base_mode_flag is equal to 0 and all syntax elements motion_prediction_flag_lX[ mbPartIdx ] with X \nbeing replaced by 0 and 1 and mbPartIdx = 0..3 are equal to 0), mbTypeILPred is marked as not available, all elements \nsubMbTypeILPred[ mbPartIdx ] with mbPartIdx = 0..3 of the list subMbTypeILPred are marked as not available, all \nelements of the 2x2 arrays refIdxILPredL0 and refIdxILPredL1 are set equal to −1, and all elements of the 4x4x2 \narrays mvILPredL0 and mvILPredL1 are set equal to 0. \nDepending  on  base_mode_flag,  mb_type,  SpatialResolutionChangeFlag,  refLayerMbType[ CurrMbAddr ], \nCodedBlockPatternLuma, and CodedBlockPatternChroma, the variable mbType is derived as follows: \n–  If base_mode_flag is equal to 1, the following applies: \n–  If  SpatialResolutionChangeFlag  is  equal  to  0,  refLayerMbType[ CurrMbAddr ]  is  equal  to  I_PCM, \nCodedBlockPatternLuma is equal to 0, and CodedBlockPatternChroma is equal to 0, mbType is set equal to \nI_PCM. \n–  Otherwise (SpatialResolutionChangeFlag is equal to 1, refLayerMbType[ CurrMbAddr ] is not equal to I_PCM, \nCodedBlockPatternLuma is not equal to 0, or CodedBlockPatternChroma is not equal to 0), mbType is set equal \nto mbTypeILPred. \n–  Otherwise, if MbPartPredMode( mb_type, 0 ) is equal to Intra_4x4, mbType is set equal to I_4x4. \n–  Otherwise, if MbPartPredMode( mb_type, 0 ) is equal to Intra_8x8, mbType is set equal to I_8x8. \n–  Otherwise, if MbPartPredMode( mb_type, 0 ) is equal to Intra_16x16, mbType is set equal to I_16x16. \n–  Otherwise, if mb_type is equal to I_PCM, mbType is set equal to I_PCM. \n–  Otherwise (base_mode_flag is equal to 0 and mb_type specifies a P or B macroblock type), mbType is set equal to \nmb_type. \nDepending on mbType and base_mode_flag, the list subMbType is derived as follows: \n–  If mbType is not equal to P_8x8, P_8x8ref0, or B_8x8, all elements subMbType[ mbPartIdx ] with mbPartIdx = 0..3 \nare marked as unspecified. \n–  Otherwise, if base_mode_flag is equal to 1, each element subMbType[ mbPartIdx ] with mbPartIdx = 0..3 is set equal \nto subMbTypeILPred[ mbPartIdx ]. \n–  Otherwise (mbType is equal to P_8x8, P_8x8ref0, or B_8x8 and base_mode_flag is equal to 0), each element \nsubMbType[ mbPartIdx ] with mbPartIdx = 0..3 is set equal to sub_mb_type[ mbPartIdx ]. \nWhen slice_type is equal to EP, base_mode_flag is equal to 1, and mbType is not equal to I_PCM, I_16x16, I_8x8, I_4x4, \nor I_BL, the bitstream shall not contain data that result in any element refIdxILPredL0[ mbPartIdx ] with mbPartIdx = 0..3 \nthat is less than 0. \nWhen residual_prediction_flag equal to 1 is present in the bitstream, the bitstream shall not contain data that result in \nmbType being equal to I_PCM, I_16x16, I_8x8, I_4x4, or I_BL. \nG.8.1.5.1.2  Derivation process for quantization parameters and transform type \nInputs to this process are: \n–  a variable mbType specifying the macroblock type for the current macroblock, \n–  a list subMbType with 4 elements specifying the sub-macroblock types for the current macroblock, \n    Rec. ITU-T H.264 (06/2019)  499 \n \n–  a one-dimensional array refLayerMbType specifying macroblock types for the macroblocks of the reference layer \nrepresentation, \n–  a one-dimensional array  refLayerCTrafo specifying transform types for the  macroblocks of the reference layer \nrepresentation, \n–  a one-dimensional array refLayerQP  specifying luma quantization parameters for the macroblocks of the reference \nY\nlayer representation, \n–  an (RefLayerPicSizeInMbs)x(256 + 2 * MbWidthC * MbHeightC) array refLayerTCoeffLevel specifying transform \ncoefficient level values for the macroblocks of the reference layer representation, \n–  an  (RefLayerPicSizeInMbs)x(256 + 2 * MbWidthC * MbHeightC)  array  refLayerSTCoeff  specifying  scaled \ntransform coefficient values for the macroblocks of the reference layer representation. \nOutputs of this process are: \n–  a variable cTrafo specifying the transform type for the current macroblock, \n–  a variable tQP  specifying the luma quantization parameter for the current macroblock, \nY\n–  when  ChromaArrayType  is  not  equal  to  0,  two  variables  tQP   and  tQP   specifying  the  chroma  quantization \nCb Cr\nparameters for the current macroblock. \nThe variable tQP  is derived as follows: \nY\n–  If SpatialResolutionChangeFlag is equal to 0, and any of the following conditions are true, tQP  is set equal to \nY\nrefLayerQP [ CurrMbAddr ]: \nY\n–  mbType  is  equal  to  I_PCM,  I_16x16,  I_8x8,  I_4x4,  or  I_BL,  base_mode_flag  is  equal  to  1, \nCodedBlockPatternLuma is equal to 0, and CodedBlockPatternChroma is equal to 0, \n–  mbType is equal to P_Skip or B_Skip and residual_prediction_flag is equal to 1, \n–  mbType is not equal to I_PCM, I_16x16, I_8x8, I_4x4, I_BL, P_Skip, or B_Skip, residual_prediction_flag is \nequal to 1, CodedBlockPatternLuma is equal to 0, and CodedBlockPatternChroma is equal to 0. \n–  Otherwise, tQP  is set equal to QP . \nY Y\nWhen ChromaArrayType is not equal to 0, for CX being replaced by Cb and Cr, the variable tQP  is set equal to the value \nCX\nof QP  that corresponds to a value of tQP  for QP  as specified in clause 8.5.8. \nCX Y Y\nThe variable predTrafoFlag is derived as follows: \n–  If SpatialResolutionChangeFlag is equal to 0 and any of the following conditions are true, predTrafoFlag is set equal \nto 1: \n–  base_mode_flag is equal to 1, tcoeff_level_prediction_flag is equal to 0, refLayerMbType[ CurrMbAddr ] is \nequal to I_BL, and CodedBlockPatternLuma is equal to 0, \n–  base_mode_flag is equal to 1, tcoeff_level_prediction_flag is equal to 0, refLayerMbType[ CurrMbAddr ] is \nequal to I_PCM, CodedBlockPatternLuma is equal to 0, and CodedBlockPatternChroma is equal to 0, \n–  base_mode_flag is equal to 1, tcoeff_level_prediction_flag is equal to 0, refLayerMbType[ CurrMbAddr ] is \nequal to I_8x8 or I_4x4, and CodedBlockPatternLuma is equal to 0, \n–  base_mode_flag is equal to 1, tcoeff_level_prediction_flag is equal to 1, and mbType is equal to I_PCM, \nI_16x16, I_8x8, or I_4x4, \n–  residual_prediction_flag is equal to 1, refLayerMbType[ CurrMbAddr ] is not equal to I_PCM, I_16x16, I_8x8, \nI_4x4, or I_BL, mbType is not equal to I_PCM, I_16x16, I_8x8, I_4x4, or I_BL, and CodedBlockPatternLuma \nis equal to 0. \n–  Otherwise, predTrafoFlag is set equal to 0. \nThe variable cTrafo is derived as follows: \n–  If mbType is equal to I_PCM, cTrafo is set equal to T_PCM. \n–  Otherwise, if mbType is equal to I_16x16, cTrafo is set equal to T_16x16. \n–  Otherwise, if mbType is equal to I_8x8 or transform_size_8x8_flag is equal to 1, cTrafo is set equal to T_8x8. \n–  Otherwise, if predTrafoFlag is equal to 1, cTrafo is set equal to refLayerCTrafo[ CurrMbAddr ]. \n500  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (predTrafoFlag is equal to 0, transform_size_8x8_flag is equal to 0, and mbType is not equal to I_PCM, \nI_16x16, or I_8x8), cTrafo is set equal to T_4x4. \nWhen cTrafo is equal to T_8x8, the SVC sequence parameter set that is referred to by the coded slice NAL unit (via \npic_parameter_set_id in the slice header and seq_parameter_set_id in referenced the picture parameter set) shall have \ntransform_8x8_mode_flag equal to 1. \nWhen base_mode_flag is equal to 1, the following constraints shall be obeyed: \na)  When mbType is equal to P_8x8, P_8x8ref0, or B8x8 and NumSubMbPart( subMbType[ mbPartIdx ] ) is not \nequal to 1 for any mbPartIdx = 0..3, the bitstream shall not contain transform_size_8x8_flag equal to 1. \nb)  When mbType is equal to I_PCM, the bitstream shall not contain data that result in CodedBlockPatternLuma not \nequal to 0 or CodedBlockPatternChroma not equal to 0. \nc)  When mbType is equal to I_16x16 or I_4x4, the bitstream shall not contain transform_size_8x8_flag equal to 1. \nd)  When mbType is equal to I_8x8 and transform_size_8x8_flag is equal to 0, the bitstream shall not contain data \nthat result in CodedBlockPatternLuma not equal to 0. \nThe variable constrainedCoeffFlag is derived as follows: \n–  If SpatialResolutionChangeFlag is equal to 0 and any of the following conditions are true, constrainedCoeffFlag is \nset equal to 1: \n–  base_mode_flag is equal to 1, tcoeff_level_prediction_flag is equal to 0, and refLayerMbType[ CurrMbAddr ] \nis equal to I_BL, \n–  residual_prediction_flag is equal to 1, refLayerMbType[ CurrMbAddr ] is not equal to I_PCM, I_16x16, I_8x8, \nI_4x4, or I_BL, and mbType is not equal to I_PCM, I_16x16, I_8x8, I_4x4, or I_BL. \n–  Otherwise, constrainedCoeffFlag is set equal to 0. \nWhen constrainedCoeffFlag is equal to 1, the following constraints shall be obeyed: \na)  When refLayerCTrafo[ CurrMbAddr ] is equal to T_8x8 and transform_size_8x8_flag is equal 0, any of the \nfollowing constraints shall be obeyed: \ni)  The bitstream shall not contain data that result in CodedBlockPatternLuma not equal to 0. \nii)  Depending on tcoeff_level_prediction_flag, the following applies: \n–  If tcoeff_level_prediction_flag is equal to 0, the bitstream shall not contain data that result in any \nelement refLayerSTCoeff[ CurrMbAddr ][ i ] not equal to 0 for \ni = 0..( ( ChromaArrayType  !=  3 )  ?  255  :  767). \n–  Otherwise (tcoeff_level_prediction_flag is equal to 1), the bitstream shall not contain data that \nresult in any element refLayerTCoeffLevel[ CurrMbAddr ][ i ] not equal to 0 for \ni = 0..( ( ChromaArrayType  !=  3 )  ?  255  :  767). \nb)  When refLayerCTrafo[ CurrMbAddr ] is equal to T_4x4 and transform_size_8x8_flag equal to 1, the following \napplies: \n–  If tcoeff_level_prediction_flag is equal to 0, the bitstream shall not contain data that result in any element \nrefLayerSTCoeff[ CurrMbAddr ][ i ] not equal to 0 for i = 0..( ( ChromaArrayType  !=  3 )  ?  255  :  767). \n–  Otherwise (tcoeff_level_prediction_flag is equal to 1), the bitstream shall not contain data that result in \nany element refLayerTCoeffLevel[ CurrMbAddr ][ i ] not equal to 0 for \ni = 0..( ( ChromaArrayType  !=  3 )  ?  255  :  767). \nG.8.1.5.2  Base decoding process for macroblocks in slices without resolution change \nInputs to this process are: \n–  a variable currDQId specifying the current layer representation, \n–  a variable mbAddr specifying the current macroblock inside the current layer representation, \n–  a set of arrays collectively referred to as currentVars, \n–  when currDQId is equal to 0 and (slice_type % 5) is equal to 1, the reference picture list refPicList1. \nOutput of this process is the modified set of arrays collectively referred to as currentVars. \n    Rec. ITU-T H.264 (06/2019)  501 \n \nThis process modifies the variables assigned to currentVars using syntax elements and derived upper-case variables for the \ncurrent macroblock, which is specified by its address mbAddr and the layer representation identifier currDQId. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the current macroblock, which is the macroblock with address mbAddr inside the layer representation with DQId equal \nto currDQId, the slice header of the current slice, which is the slice that contains the current macroblock, the current picture \nparameter, which is identified by the syntax element pic_parameter_set_id inside the slice header of the current slice, and \nthe current sequence parameter, which is identified by the syntax element seq_parameter_set_id inside the current picture \nparameter set. \nInside this clause, the arrays that are collectively referred to as currentVars are referred to by their names as specified in \nclause G.8.1.2.1. \nThe base decoding process for macroblocks in slices without resolution change is specified by the following ordered steps: \n1.  The variable CurrMbAddr is set equal to mbAddr. \n2.  When tcoeff_level_prediction_flag is equal to 1, the variable refQP  is set equal to tQP [ mbAddr ] and, when \nY Y\nChromaArrayType is not equal to 0, the variables refQP  and refQP  are set equal to tQP [ mbAddr ] and \nCb Cr Cb\ntQP [ mbAddr ], respectively. \nCr\n3.  When no_inter_layer_pred_flag is equal to 0, the variable refLayerIntraBLFlag is derived as follows: \n–  If mbType[ mbAddr ] is equal to I_BL, refLayerIntraBLFlag is set equal to 1. \n–  Otherwise (mbType[ mbAddr ] is not equal to I_BL), refLayerIntraBLFlag is set equal to 0. \n4.  The variable resPredFlag is derived as follows: \n–  If residual_prediction_flag is equal to 1 and mbType[ mbAddr ] is not equal to I_PCM, I_16x16, I_8x8, \nI_4x4, or I_BL, resPredFlag is set equal to 1. \n–  Otherwise (residual_prediction_flag is equal to 0 or mbType[ mbAddr ] is equal to I_PCM, I_16x16, I_8x8, \nI_4x4, or I_BL), resPredFlag is set equal to 0. \n5.  The macroblock initialization process as specified in clause G.8.1.5.1 is invoked with refLayerVars set equal to \ncurrentVars  as  the  input  and  the  outputs  are  assigned  to  sliceIdc[ mbAddr ],  fieldMbFlag[ mbAddr ], \ncTrafo[ mbAddr ], baseModeFlag[ mbAddr ], mbType[ mbAddr ], subMbType[ mbAddr ], mvCnt[ mbAddr ], \ntQP [ mbAddr ],  tQP [ mbAddr ]  (when  ChromaArrayType  is  not  equal  to 0),  tQP [ mbAddr ]  (when \nY Cb Cr\nChromaArrayType is not equal to 0), the 2x2 arrays refIdxILPredL0 and refIdxILPredL1, and the 4x4x2 arrays \nmvILPredL0 and mvILPredL1. \n6.  The SVC derivation process for motion vector components and reference indices as specified in clause G.8.4.1 \nis  invoked  with  sliceIdc,  fieldMbFlag,  mbType,  subMbType,  predFlagL0,  predFlagL1,  refIdxL0,  refIdxL1, \nmvL0,  mvL1,  mvCnt,  refIdxILPredL0,  refIdxILPredL1,  mvILPredL0,  mvILPredL1,  and  refPicList1  (when \navailable) as the inputs and the outputs are modified versions of the arrays predFlagL0, predFlagL1, refIdxL0, \nrefIdxL1, mvL0, mvL1, and mvCnt. \n7.  Depending on mbType[ mbAddr ], the following applies: \n–  If  mbType[ mbAddr ]  is  equal  to  I_PCM,  I_16x16,  I_8x8,  or  I_4x4,  the  following  ordered  steps  are \nspecified: \na.  When base_mode_flag is equal to 0, the SVC derivation process for intra prediction modes as specified \nin clause G.8.3.1 is invoked with sliceIdc, fieldMbFlag, baseModeFlag, mbType, ipred4x4, ipred8x8, \nipred16x16, and, when ChromaArrayType is equal to 1 or 2, ipredChroma as the inputs and the outputs \nare modified versions of ipred4x4, ipred8x8, ipred16x16, and, when ChromaArrayType is equal to 1 \nor 2, ipredChroma. \nb.  When tcoeff_level_prediction_flag is equal to 1 and  base_mode_flag is equal to 1, the transform \ncoefficient level scaling process prior to transform coefficient refinement as specified in clause G.8.5.2 \nis  invoked  with  cTrafo[ mbAddr ],  tCoeffLevel[ mbAddr ],  tQP [ mbAddr ],  refQP ,  and,  when \nY Y\nChromaArrayType is not equal to 0, tQP [ mbAddr ], tQP [ mbAddr ], refQP , and refQP  as the \nCb Cr Cb Cr\ninputs and the output is a modified version of tCoeffLevel[ mbAddr ]. \nc.  The transform coefficient scaling and refinement process as specified in clause G.8.5.1 is invoked with \nrefinementFlag  set  equal  to  base_mode_flag,  fieldMbFlag[ mbAddr ],  mbType[ mbAddr ], \ncTrafo[ mbAddr ],  sTCoeff[ mbAddr ],  tCoeffLevel[ mbAddr ],  tQP [ mbAddr ],  and,  when \nY\nChromaArrayType is not equal to 0, tQP [ mbAddr ] and tQP [ mbAddr ] as the inputs and the outputs \nCb Cr\nare modified versions of sTCoeff[ mbAddr ] and tCoeffLevel[ mbAddr ]. \n502  Rec. ITU-T H.264 (06/2019) \n \nd.  The  sample  array  re-initialization  process  as  specified  in  clause G.8.5.5  is  invoked  with \nfieldMbFlag[ mbAddr ], rS , and, when ChromaArrayType is not equal to 0, rS  and rS  as the inputs \nL Cb Cr\nand the outputs are a modified version of rS  and, when ChromaArrayType is not equal to 0, modified \nL\nversions of rS  and rS . \nCb Cr\ne.  The  sample  array  re-initialization  process  as  specified  in  clause G.8.5.5  is  invoked  with \nfieldMbFlag[ mbAddr ], cS , and, when ChromaArrayType is not equal to 0, cS  and cS  as the inputs \nL Cb Cr\nand the outputs are a modified version of cS  and, when ChromaArrayType is not equal to 0, modified \nL\nversions of cS  and cS . \nCb Cr\n–  Otherwise, if mbType[ mbAddr ] is equal to I_BL, the transform coefficient scaling and refinement process \nas  specified  in  clause G.8.5.1  is  invoked  with  refinementFlag  set  equal  to  refLayerIntraBLFlag, \nfieldMbFlag[ mbAddr ],  mbType[ mbAddr ],  cTrafo[ mbAddr ],  sTCoeff[ mbAddr ], \ntCoeffLevel[ mbAddr ], tQP [ mbAddr ], and, when ChromaArrayType is not equal to 0, tQP [ mbAddr ] \nY Cb\nand  tQP [ mbAddr ]  as  the  inputs  and  the  outputs  are  modified  versions  of  sTCoeff[ mbAddr ]  and \nCr\ntCoeffLevel[ mbAddr ]. \n–  Otherwise (mbType[ mbAddr ] is not equal to I_PCM, I_16x16, I_8x8, I_4x4, or I_BL), the following \nordered steps are specified: \na.  When tcoeff_level_prediction_flag is equal to 1 and resPredFlag is equal to 1, the transform coefficient \nlevel scaling process prior to transform coefficient refinement as specified in clause G.8.5.2 is invoked \nwith  cTrafo[ mbAddr ],  tCoeffLevel[ mbAddr ],  tQP [ mbAddr ],  refQP ,  and,  when \nY Y\nChromaArrayType is not equal to 0, tQP [ mbAddr ], tQP [ mbAddr ], refQP , and refQP  as the \nCb Cr Cb Cr\ninputs and the output is a modified version of tCoeffLevel[ mbAddr ]. \nb.  The transform coefficient scaling and refinement process as specified in clause G.8.5.1 is invoked with \nrefinementFlag  set  equal  to  resPredFlag,  fieldMbFlag[ mbAddr ],  mbType[ mbAddr ], \ncTrafo[ mbAddr ],  sTCoeff[ mbAddr ],  tCoeffLevel[ mbAddr ],  tQP [ mbAddr ],  and,  when \nY\nChromaArrayType is not equal to 0, tQP [ mbAddr ] and tQP [ mbAddr ] as the inputs and the outputs \nCb Cr\nare modified versions of sTCoeff[ mbAddr ] and tCoeffLevel[ mbAddr ]. \nc.  When resPredFlag is equal to 0, the sample array re-initialization process as specified in clause G.8.5.5 \nis invoked with fieldMbFlag[ mbAddr ], rS , and, when ChromaArrayType is not equal to 0, rS  and \nL Cb\nrS  as the inputs and the outputs are a modified versions of rS  and, when ChromaArrayType is not \nCr L\nequal to 0, modified versions of rS  and rS . \nCb Cr\nd.  When resPredFlag is equal to 0, the sample array re-initialization process as specified in clause G.8.5.5 \nis invoked with fieldMbFlag[ mbAddr ], cS , and, when ChromaArrayType is not equal to 0, cS  and \nL Cb\ncS  as the inputs and the outputs are a modified versions of cS  and, when ChromaArrayType is not \nCr L\nequal to 0, modified versions of cS  and cS . \nCb Cr\n8.  The variable MvCnt for the macroblock mbAddr is set equal to mvCnt[ mbAddr ]. \nG.8.1.5.3  Base decoding process for macroblocks in slices with resolution change \nInputs to this process are: \n–  a variable currDQId specifying the current layer representation, \n–  a variable mbAddr specifying the current macroblock inside the current layer representation, \n–  a set of arrays collectively referred to as refLayerVars, \n–  a set of arrays collectively referred to as currentVars, \n–  when CroppingChangeFlag is equal to 1 and (slice_type % 5) is less than 2, the reference picture list refPicList0, \n–  when CroppingChangeFlag is equal to 1 and (slice_type % 5) is equal to 1, the reference picture list refPicList1. \nOutput of this process is the modified set of arrays collectively referred to as currentVars. \nThis process modifies the variables assigned to currentVars using syntax elements and derived upper-case variables for the \ncurrent macroblock, which is specified by its address mbAddr and the layer representation identifier currDQId, as well as \nvariables assigned to refLayerVars. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the current macroblock, which is the macroblock with address mbAddr inside the layer representation with DQId equal \nto currDQId, the slice header of the current slice, which is the slice that contains the current macroblock, the current picture \nparameter, which is identified by the syntax element pic_parameter_set_id inside the slice header of the current slice, and \n    Rec. ITU-T H.264 (06/2019)  503 \n \nthe current sequence parameter, which is identified by the syntax element seq_parameter_set_id inside the current picture \nparameter set. \nInside this clause, the arrays that are collectively referred to as currentVars are referred to by their names as specified in \nclause G.8.1.2.1. \nInside this clause, the arrays sliceIdc, fieldMbFlag, cTrafo, mbType, cS , cS , cS , rS , rS , and rS  of the collective \nL Cb Cr L Cb Cr\nterm refLayerVars are referred to as refLayerSliceIdc, refLayerFieldMbFlag, refLayerCTrafo, refLayerMbType, refS , \nL\nrefS , refS , refR , refR , and refR , respectively. \nCb Cr L Cb Cr\nThe base decoding process for macroblocks in slices with resolution change is specified by the following ordered steps: \n1.  The variable CurrMbAddr is set equal to mbAddr. \n2.  The macroblock initialization process as specified in clause G.8.1.5.1 is invoked with refLayerVars, refPicList0 \n(when  available),  and  refPicList1  (when  available)  as  the  inputs  and  the  outputs  are  assigned  to \nsliceIdc[ mbAddr ], fieldMbFlag[ mbAddr ], cTrafo[ mbAddr ], baseModeFlag[ mbAddr ], mbType[ mbAddr ], \nsubMbType[ mbAddr ], mvCnt[ mbAddr ], tQP [ mbAddr ], tQP [ mbAddr ] (when ChromaArrayType is not \nY Cb\nequal to 0), tQP [ mbAddr ] (when ChromaArrayType is not equal to 0), the 2x2 arrays refIdxILPredL0 and \nCr\nrefIdxILPredL1, and the 4x4x2 arrays mvILPredL0 and mvILPredL1. \n3.  The SVC derivation process for motion vector components and reference indices as specified in clause G.8.4.1 \nis  invoked  with  sliceIdc,  fieldMbFlag,  mbType,  subMbType,  predFlagL0,  predFlagL1,  refIdxL0,  refIdxL1, \nmvL0, mvL1, mvCnt, refIdxILPredL0, refIdxILPredL1, mvILPredL0, and mvILPredL1 as the inputs and the \noutputs are modified versions of the arrays predFlagL0, predFlagL1, refIdxL0, refIdxL1, mvL0, mvL1, and \nmvCnt. \n4.  The variable intraResamplingFlag is derived as follows: \n–  If any of the following conditions are true, intraResamplingFlag is set equal to 1: \n–  mbType[ mbAddr ] is equal to I_BL, \n–  RestrictedSpatialResolutionChangeFlag  is  equal  to 0,  MbaffFrameFlag  is  equal  to 0, \nRefLayerMbaffFrameFlag is equal to 0, and base_mode_flag is equal to 1. \n–  Otherwise, intraResamplingFlag is set equal to 0. \n5.  When intraResamplingFlag is equal to 1, the resampling process for intra samples as specified in clause G.8.6.2 \nis invoked with fieldMbFlag[ mbAddr ], refLayerSliceIdc, refLayerFieldMbFlag, refLayerMbType, refS , cS , \nL L\nand, when ChromaArrayType is not equal to 0, refS , refS , cS , and cS  as the inputs and the outputs are a \nCb Cr Cb Cr\nmodified version of the array cS  and, when ChromaArrayType is not equal to 0, modified versions of the array \nL\ncS , and cS . \nCb Cr\n6.  Depending on mbType[ mbAddr ], the following applies: \n–  If mbType[ mbAddr ] is equal to I_PCM, I_16x16, I_8x8, or I_4x4, the SVC derivation process for intra \nprediction modes as  specified in  clause G.8.3.1 is invoked  with  sliceIdc, fieldMbFlag, baseModeFlag, \nmbType, ipred4x4, ipred8x8, ipred16x16, and, when ChromaArrayType is equal to 1 or 2, ipredChroma as \nthe  inputs  and  the  outputs  are  modified  versions  of  ipred4x4,  ipred8x8,  ipred16x16,  and,  when \nChromaArrayType is equal to 1 or 2, ipredChroma. \n–  Otherwise,  if  mbType[ mbAddr ]  is  not  equal  to  I_BL  and  residual_prediction_flag  is  equal  to 1,  the \nresampling  process  for  residual  samples  as  specified  in  clause G.8.6.3  is  invoked  with \nfieldMbFlag[ mbAddr ], refLayerFieldMbFlag, refLayerCTrafo, refR , rS , and, when ChromaArrayType \nL L\nis not equal to 0, refR , refR , rS , and rS  as the inputs and the outputs are a modified version of the \nCb Cr Cb Cr\narray rS  and, when ChromaArrayType is not equal to 0, modified versions of the array rS , and rS . \nL Cb Cr\n–  Otherwise, the arrays of the collective term currentVars are not modified. \n7.  The  transform  coefficient  scaling  and  refinement  process  as  specified  in  clause G.8.5.1  is  invoked  with \nrefinementFlag  set  equal  to  0,  fieldMbFlag[ mbAddr ],  mbType[ mbAddr ],  cTrafo[ mbAddr ], \nsTCoeff[ mbAddr ], tCoeffLevel[ mbAddr ], tQP [ mbAddr ], and, when ChromaArrayType is not equal to 0, \nY\ntQP [ mbAddr ] and tQP [ mbAddr ] as the inputs and the outputs are modified versions of sTCoeff[ mbAddr ] \nCb Cr\nand tCoeffLevel[ mbAddr ]. \n8.  The variable MvCnt for the macroblock mbAddr is set equal to mvCnt[ mbAddr ]. \n504  Rec. ITU-T H.264 (06/2019) \n \nG.8.1.5.4  Macroblock decoding process prior to decoding a layer representation without resolution change and \nMaxTCoeffLevelPredFlag equal to 0 \nInputs to this process are: \n–  a variable currDQId specifying the current layer representation, \n–  a variable mbAddr specifying the current macroblock inside the current layer representation, \n–  a set of arrays collectively referred to as currentVars. \nOutput of this process is the modified set of arrays collectively referred to as currentVars. \nThis process modifies the variables assigned to currentVars using syntax elements and derived upper-case variables for the \ncurrent macroblock, which is specified by its address mbAddr and the layer representation identifier currDQId. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the current layer representation with DQId equal to currDQId. \nInside this clause, the arrays that are collectively referred to as currentVars are referred to by their names as specified in \nclause G.8.1.2.1. \nThe  macroblock  decoding  process  prior  to  decoding  a  layer  representation  without  resolution  change  and \nMaxTCoeffLevelPredFlag equal to 0 is specified by the following ordered steps: \n1.  The variable CurrMbAddr is set equal to mbAddr. \n2.  The variable intraPredFlag is derived as follows: \n–  If (sliceIdc[ mbAddr ] & 127) is equal to currDQId or MaxTCoeffLevelPredFlag is equal to 1, intraPredFlag \nis set equal to 1. \n–  Otherwise ((sliceIdc[ mbAddr ] & 127) is not equal to currDQId and MaxTCoeffLevelPredFlag is equal \nto 0), intraPredFlag is set equal to 0. \n3.  When intraPredFlag is equal to 1 and mbType[ mbAddr ] is equal to I_PCM, I_16x16, I_8x8, or I_4x4, the SVC \nintra  sample  prediction  and  construction  process  as  specified  in  clause G.8.3.2  is  invoked  with  sliceIdc, \nfieldMbFlag,  baseModeFlag,  mbType,  ipred4x4[ mbAddr ],  ipred8x8[ mbAddr ],  ipred16x16[ mbAddr ], \nipredChroma[ mbAddr ], cTrafo[ mbAddr ], sTCoeff[ mbAddr ], cS , and, when ChromaArrayType is not equal \nL\nto  0,  cS   and  cS   as  the  inputs  and  the  outputs  are  a  modified  version  of  the  array  cS   and,  when \nCb Cr L\nChromaArrayType is not equal to 0, modified versions of the arrays cS  and cS . \nCb Cr\nG.8.1.5.5  Macroblock decoding process prior to resolution change \nInputs to this process are: \n–  a variable currDQId specifying the current layer representation, \n–  a variable mbAddr specifying the current macroblock inside the current layer representation, \n–  a set of arrays collectively referred to as currentVars. \nOutput of this process is the modified set of arrays collectively referred to as currentVars. \nThis process modifies the variables assigned to currentVars using syntax elements and derived upper-case variables for the \ncurrent macroblock, which is specified by its address mbAddr and the layer representation identifier currDQId. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the current macroblock, which is the macroblock with address mbAddr inside the layer representation with DQId equal \nto currDQId, the slice header of the current slice, which is the slice that contains the current macroblock, the current picture \nparameter, which is identified by the syntax element pic_parameter_set_id inside the slice header of the current slice, and \nthe current sequence parameter, which is identified by the syntax element seq_parameter_set_id inside the current picture \nparameter set. \nInside this clause, the arrays that are collectively referred to as currentVars are referred to by their names as specified in \nclause G.8.1.2.1. \nThe macroblock decoding process prior to resolution change is specified by the following ordered steps: \n1.  The variable CurrMbAddr is set equal to mbAddr. \n2.  Depending on mbType[ mbAddr ], the following applies: \n    Rec. ITU-T H.264 (06/2019)  505 \n \n–  If mbType[ mbAddr ] is equal to I_PCM, I_16x16, I_8x8, or I_4x4, the SVC intra sample prediction and \nconstruction process as specified in clause G.8.3.2 in invoked with sliceIdc, fieldMbFlag, baseModeFlag, \nmbType,  ipred4x4[ mbAddr ],  ipred8x8[ mbAddr ],  ipred16x16[ mbAddr ],  ipredChroma[ mbAddr ], \ncTrafo[ mbAddr ], sTCoeff[ mbAddr ], cS , and, when ChromaArrayType is not equal to 0, cS  and cS  \nL Cb Cr\nas the inputs and the outputs are a modified version of the array cS  and, when ChromaArrayType is not \nL\nequal to 0, modified versions of the arrays cS  and cS . \nCb Cr\n–  Otherwise, if mbType[ mbAddr ] is equal to I_BL, the following ordered steps are specified: \na.  The residual construction and accumulation process as specified in  clause G.8.5.3 is invoked with \naccumulationFlag set equal to 0, fieldMbFlag[ mbAddr ], cTrafo[ mbAddr ], sTCoeff[ mbAddr ], rS , \nL\nand, when ChromaArrayType is not equal to 0, rS  and rS  as the inputs and the outputs are a modified \nCb Cr\nversion of rS  and, when ChromaArrayType is not equal to 0, modified versions of rS  and rS . \nL Cb Cr\nb.  The  sample  array  accumulation  process  as  specified  in  clause G.8.5.4  is  invoked  with \nfieldMbFlag[ mbAddr ], rS , cS , and, when ChromaArrayType is not equal to 0, rS , rS  cS , and \nL L Cb Cr Cb\ncS  as the inputs and the outputs are a modified version of cS  and, when ChromaArrayType is not \nCr L\nequal to 0, modified versions of cS  and cS . \nCb Cr\nc.  The  sample  array  re-initialization  process  as  specified  in  clause G.8.5.5  is  invoked  with \nfieldMbFlag[ mbAddr ], rS , and, when ChromaArrayType is not equal to 0, rS  and rS  as the inputs \nL Cb Cr\nand the outputs are a modified version of rS  and, when ChromaArrayType is not equal to 0, modified \nL\nversions of rS  and rS . \nCb Cr\n–  Otherwise (mbType[ mbAddr ] is not equal to I_PCM, I_16x16, I_8x8, I_4x4, or I_BL), the  following \nordered steps are specified: \na.  The residual construction and accumulation process as specified in clause G.8.5.3 is invoked with \naccumulationFlag set equal to 1, fieldMbFlag[ mbAddr ], cTrafo[ mbAddr ], sTCoeff[ mbAddr ], rS , \nL\nand, when ChromaArrayType is not equal to 0, rS  and rS  as the inputs and the outputs are a modified \nCb Cr\nversion of rS  and, when ChromaArrayType is not equal to 0, modified versions of rS  and rS . \nL Cb Cr\nb.  The  sample  array  re-initialization  process  as  specified  in  clause G.8.5.5  is  invoked  with \nfieldMbFlag[ mbAddr ], cS , and, when ChromaArrayType is not equal to 0, cS  and cS  as the inputs \nL Cb Cr\nand the outputs are a modified version of cS  and, when ChromaArrayType is not equal to 0, modified \nL\nversions of cS  and cS . \nCb Cr\nG.8.1.5.6  Target macroblock decoding process \nInputs to this process are: \n–  a variable currDQId specifying the current layer representation, \n–  a variable mbAddr specifying the current macroblock inside the current layer representation, \n–  when present, a set of arrays collectively referred to as refLayerVars, \n–  a set of arrays collectively referred to as currentVars, \n–  when (slice_type % 5) is less than 2, the reference picture list refPicList0, \n–  when (slice_type % 5) is equal to 1, the reference picture list refPicList1. \nOutput of this process is the modified set of arrays collectively referred to as currentVars. \nThis process modifies the variables assigned to currentVars using syntax elements and derived upper-case variables for the \ncurrent macroblock, which is specified by its address mbAddr and the layer representation identifier currDQId. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the current layer representation with DQId equal to currDQId. \nInside this clause, the arrays that are collectively referred to as currentVars are referred to by their names as specified in \nclause G.8.1.2.1. \nInside this clause, the following applies: \n–  If  refLayerVars  is  present  as  input  to  this  clause,  the  arrays  fieldMbFlag  and  mbType  of  the  collective  term \nrefLayerVars are referred to as refLayerFieldMbFlag and refLayerMbType, respectively. \n–  Otherwise  (refLayerVars  are  not  present  as  input  to  this  clause),  the  variables  refLayerFieldMbFlag  and \nrefLayerMbType are marked as not available. \n506  Rec. ITU-T H.264 (06/2019) \n \nThe target macroblock decoding process is specified by the following ordered steps: \n1.  The variable CurrMbAddr is set equal to mbAddr. \n2.  When  MaxTCoeffLevelPredFlag  is  equal  to  1,  (sliceIdc[ mbAddr ] &127 )  is  not  equal  to  currDQId,  and \nChromaArrayType is not equal to 0, the following ordered steps are specified: \na.  The variable cQP  is set equal to tQP [ mbAddr ], and for CX being replaced by Cb and Cr, the variable \nY Y\ncQP  is set equal to the value of QP  that corresponds to a value of cQP  for QP  as specified in \nCX CX Y Y\nclause 8.5.8. \nb.  The transform coefficient level scaling process prior to transform coefficient refinement as specified in \nclause G.8.5.2 is invoked with cTrafo[ mbAddr ], tCoeffLevel[ mbAddr ], tQP  set equal to cQP , refQP  \nY Y Y\nset equal to tQP [ mbAddr ], and, when ChromaArrayType is not equal to 0, tQP  set equal to cQP , tQP  \nY Cb Cb Cr\nset equal to cQP , refQP  set equal to tQP [ mbAddr ], refQP  set equal to tQP [ mbAddr ] as the inputs \nCr Cb Cb Cr Cr\nand the output is a modified version of tCoeffLevel[ mbAddr ]. \nc.  The variables tQP [ mbAddr ] and tQP [ mbAddr ] are set equal to cQP  and cQP , respectively. \nCb Cr Cb Cr\nd.  The transform coefficient scaling and refinement process as specified in clause G.8.5.1 is invoked with \nrefinementFlag  equal  to  1,  fieldMbFlag[ mbAddr ],  mbType[ mbAddr ],  cTrafo[ mbAddr ], \nsTCoeff[ mbAddr ], tCoeffLevel[ mbAddr ], tQP [ mbAddr ], tQP [ mbAddr ], and tQP [ mbAddr ] as \nY Cb Cr\nthe inputs and the outputs are modified versions of sTCoeff[ mbAddr ] and tCoeffLevel[ mbAddr ]. For this \ninvocation of the process in clause G.8.5.1, all elements of the arrays LumaLevel4x4, LumaLevel8x8, \nIntra16x16DCLevel,  Intra16x16ACLevel,  CbLevel4x4,  CbLevel8x8,  CbIntra16x16DCLevel, \nCbIntra16x16ACLevel,  CrLevel4x4,  CrLevel8x8,  CrIntra16x16DCLevel,  CrIntra16x16ACLevel, \nChromaDCLevel, and ChromaACLevel are inferred to be equal to 0, tcoeff_level_prediction_flag is inferred \nto be equal to 1, and base_mode_flag is inferred to be equal to 1. \nNOTE – By the ordered steps specified above, the elements of the arrays tCoeffLevel[ mbAddr ] and sTCoeff[ mbAddr ] that \nare related to luma transform coefficients are not modified. The array elements that are related to chroma transform \ncoefficients are only modified when the chroma quantization parameter offsets of the current layer representation with DQId \nequal to currDQId and the layer representation with DQId equal to (sliceIdc[ mbAddr ] &127 ) are different. \n3.  Depending on mbType[ mbAddr ], the following applies: \n–  If  mbType[ mbAddr ]  is  equal  to  I_PCM,  I_16x16,  I_8x8,  or  I_4x4,  the  following  ordered  steps  are \nspecified: \na.  The variable intraPredFlag is derived as follows: \n–  If (sliceIdc[ mbAddr ] & 127) is equal to currDQId or MaxTCoeffLevelPredFlag is equal to 1, \nintraPredFlag is set equal to 1. \n–  Otherwise ((sliceIdc[ mbAddr ] & 127) is not equal to currDQId and MaxTCoeffLevelPredFlag is \nequal to 0), intraPredFlag is set equal to 0. \nb.  When intraPredFlag is equal to 1, the SVC intra sample prediction and construction process as specified \nin clause G.8.3.2 is invoked with sliceIdc, fieldMbFlag, baseModeFlag, mbType, ipred4x4[ mbAddr ], \nipred8x8[ mbAddr ],  ipred16x16[ mbAddr ],  ipredChroma[ mbAddr ],  cTrafo[ mbAddr ], \nsTCoeff[ mbAddr ], cS , and, when ChromaArrayType is not equal to 0, cS  and cS  as the inputs and \nL Cb Cr\nthe outputs are a modified version of the array cS  and, when ChromaArrayType is not equal to 0, \nL\nmodified versions of the arrays cS  and cS . \nCb Cr\n–  Otherwise, if mbType[ mbAddr ] is equal to I_BL, the following ordered steps are specified: \na.  The residual construction and accumulation process as specified in clause G.8.5.3 is invoked with \naccumulationFlag set equal to 0, fieldMbFlag[ mbAddr ], cTrafo[ mbAddr ], sTCoeff[ mbAddr ], rS , \nL\nand, when ChromaArrayType is not equal to 0, rS  and rS  as the inputs and the outputs are a modified \nCb Cr\nversion of rS  and, when ChromaArrayType is not equal to 0, modified versions of rS  and rS . \nL Cb Cr\nb.  The  sample  array  accumulation  process  as  specified  in  clause G.8.5.4  is  invoked  with \nfieldMbFlag[ mbAddr ], rS , cS , and, when ChromaArrayType is not equal to 0, rS , rS  cS , and \nL L Cb Cr Cb\ncS  as the inputs and the outputs are a modified version of cS  and, when ChromaArrayType is not \nCr L\nequal to 0, modified versions of cS  and cS . \nCb Cr\n–  Otherwise (mbType[ mbAddr ] is not equal to I_PCM, I_16x16, I_8x8, I_4x4, or I_BL), the following \nordered steps are specified: \na.  The SVC decoding process for Inter prediction samples as specified in clause G.8.4.2 is invoked with \ntargetQId  set  equal  to  (currDQId & 15),  fieldMbFlag[ mbAddr ],  sliceIdc[ mbAddr ], \n    Rec. ITU-T H.264 (06/2019)  507 \n \nmbType[ mbAddr ],  subMbType[ mbAddr ],  predFlagL0[ mbAddr ],  predFlagL1[ mbAddr ], \nrefIdxL0[ mbAddr ], refIdxL1[ mbAddr ], mvL0[ mbAddr ], mvL1[ mbAddr ], refLayerFieldMbFlag \n(when available), refLayerMbType (when available), refPicList0, refPicList1 (when available), cS , \nL\nrS , and, when ChromaArrayType is not equal to 0, cS , cS , rS , and rS  as the inputs and the \nL Cb Cr Cb Cr\noutputs are modified version of cS  and rS , and, when ChromaArrayType is not equal to 0, modified \nL L\nversions of cS , cS , rS , and rS . \nCb Cr Cb Cr\nb.  The residual construction and accumulation process as specified in  clause G.8.5.3 is invoked with \naccumulationFlag set equal to 1, fieldMbFlag[ mbAddr ], cTrafo[ mbAddr ], sTCoeff[ mbAddr ], rS , \nL\nand, when ChromaArrayType is not equal to 0, rS  and rS  as the inputs and the outputs are a modified \nCb Cr\nversion of rS  and, when ChromaArrayType is not equal to 0, modified versions of rS  and rS . \nL Cb Cr\nc.  The  sample  array  accumulation  process  as  specified  in  clause G.8.5.4  is  invoked  with \nfieldMbFlag[ mbAddr ], rS , cS , and, when ChromaArrayType is not equal to 0, rS , rS  cS , and \nL L Cb Cr Cb\ncS  as the inputs and the outputs are a modified version of cS  and, when ChromaArrayType is not \nCr L\nequal to 0, modified versions of cS  and cS . \nCb Cr\nG.8.2  SVC reference picture lists construction and decoded reference picture marking process \nThe SVC decoding process for picture order count is specified in clause G.8.2.1. \nThe SVC decoding process for picture numbers is specified in clause G.8.2.2. \nThe SVC decoding process for reference picture lists construction is specified in clause G.8.2.3. \nThe SVC decoded reference picture marking process is specified in clause G.8.2.4. \nThe SVC decoding process for gaps in frame_num is specified in clause G.8.2.5. \nThe decoding process for picture order counts is independently applied for different values of dependency_id. Syntax \nelements that are related to picture order count for a particular value of dependency_id do not influence the derivation of \npicture order counts for other values of dependency_id. \nThe reference picture marking is independently applied for different values of dependency_id. Syntax elements that are \nrelated to reference picture marking for a particular value of dependency_id do not influence the reference picture marking \nfor other values of dependency_id. \nThe decoding process for gaps is frame_num is independently applied for different values of dependency_id. \nReference picture lists for different dependency representations are constructed independently. Syntax elements that are \nrelated to reference picture lists construction for a particular value of dependency_id do not influence the reference picture \nlists construction for other values of dependency_id. Reference picture lists for a particular value of dependency_id are \nconstructed based on the reference picture marking for this particular value of dependency_id. The reference picture \nmarking for a particular value of dependency_id does not influence the reference picture lists construction for a different \nvalue of dependency_id. \nOnly the elements of the reference picture lists for dependency_id equal to DependencyIdMax represent decoded pictures \nthat are associated with decoded samples. Only the reference picture lists for dependency_id equal to DependencyIdMax \nare used for the derivation of inter prediction samples as specified in clause G.8.4.2. The elements of the reference picture \nlists for dependency representation with dependency_id less than DependencyIdMax represent layer pictures, which are \nnot associated with decoded samples. The elements of the reference picture lists for dependency_id equal to 0 are associated \nwith the arrays fieldMbFlag, mbType, subMbType, predFlagL0, predFlagL1, refIdxL0, refIdxL1, mvL0, and mvL1 as \nspecified in clause G.8.1.2.1 that were derived when decoding the layer representation with dependency_id equal to 0 and \nquality_id equal to 0 for the corresponding access unit. These arrays are used for the derivation of motion vectors and \nreference  indices  for  layer  representation  with  dependency_id  equal  to 0  and  quality_id  equal  to  0  as  specified  in \nclause G.8.4.1.2. The elements of the reference picture lists for all dependency representations with dependency_id greater \nthan  0  are  associated  with  the  variables  ScaledRefLayerLeftOffset,  ScaledRefLayerRightOffset, \nScaledRefLayerTopOffset, and ScaledRefLayerBottomOffset. These variables are used for deriving inter-layer motion \nvector predictions as specified in clause G.8.6.1.2. \nNOTE – For each access unit, decoded samples only need to be stored for the dependency representation with dependency_id equal \nto DependencyIdMax and motion data arrays only need to be stored for the dependency representation with dependency_id equal to \n0. \nThe SVC decoding processes for picture order count, reference picture lists construction, reference picture marking, and \ngaps in frame_num are specified using processes specified in clause 8. The following modifications to the processes \nspecified in this clause and the processes of clause 8 that are invoked from these processes apply with currDependencyId \nrepresenting the value of dependency_id for the dependency representation for which the processes are invoked: \n508  Rec. ITU-T H.264 (06/2019) \n \na)  All syntax elements and derived upper-case variables that are referred to in this process or in a child process invoked \nfrom  this  process  are  syntax  elements  and  upper-case  variables  for  the  dependency  representation  with \ndependency_id equal to currDependencyId. \nb)  When dependency_id is less than DependencyIdMax, the following applies: \n–  A frame, field, top field, bottom field, picture, and decoded picture is interpreted as layer frame, layer field, \nlayer top field, layer bottom field, layer picture, and decoded layer picture, respectively, for the dependency \nrepresentation with dependency_id equal to currDependencyId. A decoded layer picture is not associated \nwith the sample arrays S , S , or S . \nL Cb Cr\n–  An IDR picture is interpreted as layer picture with IdrPicFlag equal to 1 for the dependency representation \nwith dependency_id equal to currDependencyId. \n–  A reference frame, reference field, and reference picture is interpreted as layer frame, layer field, and layer \npicture with nal_ref_idc greater than 0 for the dependency representation with dependency_id equal to \ncurrDependencyId. \n–  A non-reference frame, non-reference field, and non-reference picture is interpreted as layer frame, layer \nfield, and layer picture with nal_ref_idc equal to 0 for the dependency representation with dependency_id \nequal to currDependencyId. \n–  A complementary non-reference field pair is interpreted as complementary non-reference layer field pair for \nthe  dependency  representation  with  dependency_id  equal  to  currDependencyId.  A  complementary \nnon-reference layer field pair for a particular value of dependency_id is a pair of two layer fields for the \nparticular value of dependency_id with the following properties: (i) the layer fields are in consecutive access \nunits  containing  a  dependency  representation  with  the  particular  value  of  dependency_id,  (ii) the \ndependency  representations  with  the  particular  value  of  dependency_id  in  these  access  units  have \nnal_ref_idc equal to 0, field_pic_flag equal to 1, different values of bottom_field_flag, and they share the \nsame value of the frame_num syntax element, (iii) the first layer field is not already a paired layer field. \n–  A complementary reference field pair is interpreted as complementary reference layer field pair for the \ndependency representation with dependency_id equal to currDependencyId. A complementary reference \nlayer field pair for a particular value of dependency_id is a pair of two layer fields for the particular value \nof dependency_id with the following properties: (i) the layer fields are in consecutive access units containing \na dependency representation with the particular value of dependency_id, (ii) the dependency representations \nwith  the  particular  value  of  dependency_id  in  these  access  units  have  nal_ref_idc  greater  than 0, \nfield_pic_flag equal to 1, and the same value of frame_num, (iii) the dependency representation with the \nparticular value of dependency_id of the second access unit in decoding order has IdrPicFlag equal to 0 and \ndoes not contain a memory_management_control_operation syntax element equal to 5. \n–  A  complementary  field  pair  is  interpreted  as  complementary  layer  field  pair  for  the  dependency \nrepresentation  with dependency_id equal to currDependencyId. A complementary layer field pair is a \ncollective term for a complementary reference layer field pair and a complementary non-reference layer \nfield pair. \n–  A non-paired non-reference field is interpreted as layer field with nal_ref_idc equal to 0 for the dependency \nrepresentation with dependency_id equal to currDependencyId that is not part of a complementary non-\nreference layer field pair. \n–  A non-paired reference field is interpreted as layer field with nal_ref_idc greater than 0 for the dependency \nrepresentation with dependency_id equal to currDependencyId that is not part of a complementary reference \nlayer field pair. \n–  A non-paired field is interpreted as layer field for the dependency representation with dependency_id equal \nto currDependencyId that is not part of a complementary layer field pair. \n–  A reference base frame is interpreted as reference layer base frame for the dependency representation with \ndependency_id  equal  to  currDependencyId.  A  reference  layer  base  frame  for  a  particular  value  of \ndependency_id represents a second representation of a layer frame for dependency representations with \nnal_ref_idc greater than 0, store_ref_base_pic_flag equal to 1, and field_pic_flag equal to 0. \n–  A reference base field is interpreted as reference layer base field for the dependency representation with \ndependency_id  equal  to  currDependencyId.  A  reference  layer  base  field  for  a  particular  value  of \ndependency_id represents a second representation of a layer field for dependency representations with \nnal_ref_idc greater than 0, store_ref_base_pic_flag equal to 1, and field_pic_flag equal to 1. \n–  A reference base picture is interpreted as reference layer base picture for the dependency representation with \ndependency_id equal to currDependencyId. A reference layer base picture is a collective term for a reference \n    Rec. ITU-T H.264 (06/2019)  509 \n \nlayer base field or a reference layer base frame. A reference layer base picture is not associated with the \nsample arrays B , B , or B . \nL Cb Cr\n–  A complementary reference base field pair is interpreted as complementary reference layer base field pair \nfor  the  dependency  representation  with  dependency_id  equal  to  currDependencyId.  A  complementary \nreference layer base field pair for a particular value of dependency_id is a pair of two reference layer base \nfields for the particular value of dependency_id with the following properties: (i) the reference layer base \nfields are in consecutive access units containing a dependency representation with the particular value of \ndependency_id, (ii) the dependency representations with the particular value of dependency_id in these \naccess units have nal_ref_idc greater than 0, store_ref_base_pic_flag equal to 1, field_pic_flag equal to 1 \nand  the  same  value  of  frame_num,  (iii) the  dependency  representation  with  the  particular  value  of \ndependency_id of the second of these access units in decoding order has IdrPicFlag equal to 0 and does not \ncontain a memory_management_control_operation syntax element equal to 5. \n–  A  non-paired  reference  base  field  is  interpreted  as  reference  layer  base  field  for  the  dependency \nrepresentation with dependency_id equal to currDependencyId that is not part of a complementary reference \nlayer base field pair. \nG.8.2.1  SVC decoding process for picture order count \nInput to this process is a list dqIdList of integer values specifying layer representation identifiers. \nOutputs of this process are the variables TopFieldOrderCnt (if applicable) and BottomFieldOrderCnt (if applicable) for all \ndependency representations of the set depRepSet specified in the following. \nLet depRepSet be the set of dependency representations for which (dependency_id << 4) is contained in the list dqIdList. \nFor  all  dependency  representations  of  the  set  depRepSet,  the  variables  TopFieldOrderCnt  (if  applicable)  and \nBottomFieldOrderCnt (if applicable) are derived by invoking the decoding process for picture order count as specified in \nclause 8.2.1.  For  these  invocations  of  the  process  specified  in  clause 8.2.1,  the  modifications a)  and  b)  specified  in \nclause G.8.2 apply with currDependencyId being equal to dependency_id of the corresponding dependency representation. \nFor  all  dependency  representations  of  the  set  depRepSet  for  an  access  unit,  either  TopFieldOrderCnt  or \nBottomFieldOrderCnt or both are derived. When both are derived in two or more dependency representations of an access \nunit, their difference shall be the same in these dependency representations of the access unit. \nThe values of TopFieldOrderCnt and BottomFieldOrderCnt are restricted as specified in the following ordered steps: \n1.  The set depRepSet for an access unit is the set depRepSet that has been derived in the process specified in this \nclause for the corresponding access unit. \n2.  For each access unit, the one-dimensional array picOrderCnt is derived as follows: \n–  If TopFieldOrderCnt is derived for all dependency representations of the set depRepSet for an access unit, \nfor each dependency representation of the set depRepSet for this access unit, the variable picOrderCnt[ dId ] \nis  set  equal  to  TopFieldOrderCnt  with  dId  being  the  value  of  dependency_id  for  the  dependency \nrepresentation. \n–  Otherwise (TopFieldOrderCnt is not derived for all dependency representations of the set depRepSet for an \naccess unit), for each dependency representation of the set depRepSet for this access unit, the variable \npicOrderCnt[ dId ] is set equal to BottomFieldOrderCnt with dId being the value of dependency_id for the \ndependency representation. \n3.  Let au0 and au1 be any pair of access units in the bitstream with au1 being later in decoding order than au0. \n4.  Let the flag idrConditionFlag be derived for each dependency representation of the set depRepSet for an access \nunit as follows: \n–  If  the  dependency  representation  in  the  access  unit  has  IdrPicFlag  equal  to  1  or  a \nmemory_management_control_operation syntax element equal to 5, idrConditionFlag is set equal to 1. \n–  Otherwise (the dependency representation in the access unit has IdrPicFlag equal to 0 and does not have a \nmemory_management_control_operation syntax element equal to 5), idrConditionFlag is set equal to 0. \n5.  Let the set dIdSet0 be the set of all dependency_id values of the set depRepSet for au0. \n6.  Let the set dIdSet1 be the set of all dependency_id values of the set depRepSet for au1 for which idrConditionFlag \nis not equal to 1 in any access unit in decoding order between the access unit that follows au0 and the access unit \nau1, inclusive. \n510  Rec. ITU-T H.264 (06/2019) \n \n7.  For all values of dId that are present in both sets dIdSet0 and dIdSet1, the differences between the value \npicOrderCnt[ dId ] in au0 and the value picOrderCnt[ dId ] in au1 shall be the same. \nG.8.2.2  SVC decoding process for picture numbers \nThis process is invoked when the SVC decoding process for reference picture lists construction specified in clause G.8.2.3, \nthe SVC reference picture marking process for a dependency representation specified in clause G.8.2.4.1, or the SVC \ndecoding process for gaps in frame_num specified in clause G.8.2.5 is invoked. \nInputs to this process are: \n–  a variable currDependencyId specifying a dependency representation, \n–  a  variable  refPicListConstructionFlag  specifying  whether  this  process  is  invoked  for  reference  picture  lists \nconstruction, \n–  when refPicListConstructionFlag is equal to 1, a variable useRefBasePicFlag specifying whether reference base \npictures are considered for reference picture lists construction. \nFrom here to the end of this clause, the modifications a) and b) specified in clause G.8.2 apply. \nThe variables FrameNum, FrameNumWrap, and PicNum are assigned to all short-term reference pictures and the variables \nLongTermFrameIdx and LongTermPicNum are assigned to all long-term reference pictures by invoking the decoding \nprocess for picture numbers as specified in clause 8.2.4.1. \nNOTE 1 – For this invocation of the process specified in clause 8.2.4.1, the pictures marked as \"reference base pictures\" and the \npictures not marked as \"reference base pictures\" are taken into account. \nFor the following specification of this clause, reference frames, complementary reference field pairs, and non-paired \nreference fields with at least one field marked as \"used for reference\" are referred to as reference entries. When only one \nfield of a reference entry is marked as \"used for reference\", the reference entry is considered to have the same marking(s) \nand the same assigned variables as its field marked as \"used for reference\". When a reference entry is marked as \"not \navailable for reference list construction\" in the following process, both of its fields are also marked as \"not available for \nreference list construction\". \nWhen refPicListConstructionFlag is equal to 1, the following applies: \n–  If useRefBasePicFlag is equal to 0, all reference entries that are marked as \"reference base picture\" are marked as \"not \navailable for reference list construction\". \nNOTE 2 – When useRefBasePicFlag is equal to 0, only reference entries that are not marked as \"reference base picture\" are \nconsidered as present for the purpose of reference picture lists construction. \n–  Otherwise (useRefBasePicFlag is equal to 1), all reference entries for which one of the following conditions is true \nare marked as \"not available for reference list construction\": \n–  the reference entry is not marked as \"reference base picture\", the reference entry is marked as \"used for \nshort-term reference\", and there exists a reference entry with the same value of FrameNum that is marked as \n\"reference base picture\" and \"used for short-term reference\", \n–  the reference entry is not marked as \"reference base picture\", the reference entry is marked as \"used for \nlong-term reference\", and there exists a reference entry with the same value of LongTermFrameIdx that is \nmarked as \"reference base picture\" and \"used for long-term reference\". \nNOTE 3 – When useRefBasePicFlag is equal to 1 and either two short-term reference entries have the same value of FrameNum \nor two long-term reference entries have the same value of LongTermFrameIdx (one of these reference entries is marked as \n\"reference base picture\" and the other reference entry is not marked as \"reference base picture\"), only the reference entry marked \nas \"reference base picture\" is considered as present for the purpose of reference picture lists construction. \nG.8.2.3  SVC decoding process for reference picture lists construction \nThis process is invoked at the beginning of the decoding process for each P, EP, B, or EB slice. \nInputs to this process are: \n–  a variable currDependencyId, \n–  a variable useRefBasePicFlag, \n–  the current slice currSlice. \nOutputs of this process are: \n–  a reference picture list refPicList0, \n–  for B and EB slices, a reference picture list refPicList1. \n    Rec. ITU-T H.264 (06/2019)  511 \n \nAfter applying the process described in this clause, the output reference picture lists refPicList0 and refPicList1 (when \napplicable) shall not contain any pictures for which the syntax element temporal_id is greater than the syntax element \ntemporal_id of the current picture. \nFrom here to the end of this clause, the modifications a) and b) specified in clause G.8.2 apply. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the slice header of the current slice currSlice, the current picture parameter, which is identified by the syntax element \npic_parameter_set_id inside the slice header of the current slice currSlice, and the current sequence parameter, which is \nidentified by the syntax element seq_parameter_set_id inside the current picture parameter set. \nA variable biPred is derived as follows: \n–  If the current slice currSlice is a B or EB slice, biPred is set equal to 1. \n–  Otherwise, biPred is set equal to 0. \nDecoded reference pictures are marked as \"used for short-term reference\" or \"used for long-term reference\" as specified \nby the bitstream and specified in clause G.8.2.4. Short-term reference pictures are identified by the value of frame_num \nthat is decoded in the slice header(s) with dependency_id equal to currDependencyId. Long-term reference pictures are \nidentified by a long-term frame index as specified by the bitstream and specified in clause G.8.2.4. \nClause G.8.2.2 is invoked with currDependencyId, refPicListConstructionFlag equal to 1, and useRefBasePicFlag as inputs \nto specify the following: \n–  the assignment of variables FrameNum, FrameNumWrap, and PicNum to each of the short-term reference pictures, \n–  the assignment of variables LongTermPicNum to each of the long-term reference pictures, \n–  the marking of reference pictures that are not used for reference picture lists construction as \"not available for \nreference list construction\" (depending on the value of useRefBasePicFlag). \nNOTE 1 – The marking of reference pictures as \"not available for reference list construction\" is removed after construction of the \nreference picture lists. \nReference pictures are addressed through reference indices as specified in clause 8.4.2.1 with the modification e) specified \nin clause G.8.4.2. A reference index is an index into a reference picture list. When biPred is equal to 0, a single reference \npicture list refPicList0 is constructed. When decoding a B or EB slice (biPred is equal to 1), a second independent reference \npicture list refPicList1 is constructed in addition to refPicList0. \nAt the beginning of the decoding process for each slice, reference picture list refPicList0, and for biPred equal to 1 \nrefPicList1, are derived as specified in the following ordered steps: \n1.  Initial reference picture lists RefPicList0 and, for biPred equal to 1, RefPicList1 are derived by invoking the \ninitialization process for reference picture lists as specified in clause 8.2.4.2. During the initialization process in \nclause 8.2.4.2 all reference frames, complementary reference field pairs, and non-paired reference fields that have \nbeen marked as \"not available for reference list construction\" by the invocation of clause G.8.2.2 are considered as \nnot present. \n2.  When ref_pic_list_modification_flag_l0 is equal to 1 or, when decoding a B or EB slice (biPred is equal to 1), \nref_pic_list_modification_flag_l1 is equal to 1, the initial reference picture list RefPicList0 and for biPred equal \nto 1 RefPicList1 are modified by invoking the modification process for reference picture lists as specified in \nclause 8.2.4.3. During the modification process in clause 8.2.4.3 all reference frames, complementary reference \nfield pairs, and non-paired reference fields that have been marked as \"not available for reference list construction\" \nby the invocation of clause G.8.2.2 are considered as not present. \n3.  RefPicList0 is assigned to refPicList0. \n4.  When biPred is equal to 1, RefPicList1 is assigned to refPicList1. \nNOTE 2 – By the invocation of the process in clause G.8.2.2 some reference frames, complementary reference field pairs, and non-\npaired reference fields might have been marked as \"not available for reference list construction\". Since, these pictures are not \nconsidered in the construction process for reference picture lists, the reference picture lists refPicList0 and, for biPred equal to 1, \nrefPicList1 are dependent on the value of the input parameter useRefBasePicFlag. \nThe number of entries in the modified reference picture list refPicList0 is num_ref_idx_l0_active_minus1 + 1, and for \nbiPred  equal  to 1  the  number  of  entries  in  the  modified  reference  picture  list  refPicList1  is \nnum_ref_idx_l1_active_minus1 + 1. A reference picture may appear at more than one index in the modified reference \npicture lists refPicList0 or refPicList1. \nFor all reference frames, complementary reference field pairs, and non-paired reference fields that have been marked as \n\"not available for reference list construction\" during the invocation of clause G.8.2.2, this marking is removed. \n512  Rec. ITU-T H.264 (06/2019) \n \nG.8.2.4  SVC decoded reference picture marking process \nInput to this process is a list dqIdList of integer values specifying layer representation identifiers. \nLet depRepSet be the set of dependency representations for which all of the following conditions are true: \n–  the list dqIdList contains the value (dependency_id << 4), \n–  nal_ref_idc is greater than 0. \nFor each dependency representation of the set depRepSet, the SVC reference picture marking process for a dependency \nrepresentation as specified in clause G.8.2.4.1 is invoked. For these invocations of the process specified in clause G.8.2.4.1, \nthe modifications a) and b) specified in clause G.8.2 apply with currDependencyId being equal to dependency_id for the \ncorresponding dependency representation. \nG.8.2.4.1  SVC reference picture marking process for a dependency representation \nInput to this process is a variable currDependencyId. \nOutput of this process is a modified reference picture marking for dependency representations with dependency_id equal \nto currDependencyId. \nThis process is invoked for a decoded picture when nal_ref_idc is not equal to 0 for the dependency representation with \ndependency_id being equal to currDependencyId. \nAll syntax elements and derived upper-case variables that are referred to by the process specified in this clause and all \nchild processes invoked from this process are syntax elements and derived upper-case variables for the dependency \nrepresentation with dependency_id equal to currDependencyId. \nA decoded picture with nal_ref_idc not equal to 0, referred to as a reference picture, is marked as \"used for short-term \nreference\" or \"used for long-term reference\". When store_ref_base_pic_flag is equal to 1, a second representation of the \ndecoded picture also referred to as reference base picture is marked as \"used for short-term reference\" or \"used for \nlong-term reference\" and additionally marked as \"reference base picture\". Pictures that are marked as \"reference base \npicture\" are only used as references for inter prediction of following pictures with use_ref_base_pic_flag equal to 1. These \npictures are not used for inter prediction of pictures with use_ref_base_pic_flag equal to 0, and these pictures do not \nrepresent an output of the decoding process. \nFor a decoded reference frame, both of its fields are marked the same as the frame. For a complementary reference field \npair, the pair is marked the same as both of its fields. A picture that is marked as \"used for short-term reference\" is identified \nby its FrameNum and, when it is a field, by its parity, and, when it is a reference base picture, by the marking \"reference \nbase picture\". A picture that is marked as \"used for long-term reference\" is identified by its LongTermFrameIdx and, when \nit is a field, by its parity, and, when it is a reference base picture, by the marking \"reference base picture\". \nWhile decoded pictures are represented by the sample arrays S  and, when ChromaArrayType is not equal to 0, S  and \nL Cb\nS , reference base pictures are represented by the sample arrays B  and, when ChromaArrayType is not equal to 0, B  \nCr L Cb\nand B . When reference base pictures are referenced in the inter prediction process via clause 8.4.2.1, the samples arrays \nCr\nB , B , and B  are referred to as S , S , and S , respectively. The sample arrays S , S , S , B , B , and B  that \nL Cb Cr L Cb Cr L Cb Cr L Cb Cr\nreferenced in the inter prediction process via clause 8.4.2.1 are constructed as specified in clause G.8. Reference base \npictures are associated with the same descriptive information such as the variables FrameNum, FrameNumWrap, PicNum, \nLongTermFrameIdx, and LongTermPicNum as decoded pictures. \nFrames or complementary field pairs marked as \"used for short-term reference\" or as \"used for long-term reference\" can \nbe used as a reference for inter prediction when decoding a frame until the frame, the complementary field pair, or one of \nits constituent fields is marked as \"unused for reference\". A field marked as \"used for short-term reference\" or as \"used for \nlong-term reference\" can be used as a reference for inter prediction when decoding a field until marked as \"unused for \nreference\". \nA picture can be marked as \"unused for reference\" by the sliding window reference picture marking process, a first-in, \nfirst-out mechanism specified in clause G.8.2.4.2, or by the adaptive memory control reference picture marking process, a \ncustomised adaptive marking operation specified in clauses G.8.2.4.3 and G.8.2.4.4. \nA short-term reference picture is identified for use in the decoding process by its variables FrameNum and FrameNumWrap \nand its picture number PicNum, and, when it is a reference base picture, by the marking as \"reference base picture\". A \nlong-term reference picture is identified for use in the decoding process by its variable LongTermFrameIdx, its long-term \npicture number LongTermPicNum, and, when it is a reference base picture, by the marking as \"reference base picture\". \nWhen the current picture is not an IDR picture, the variables FrameNum, FrameNumWrap, PicNum, LongTermFrameIdx, \nand LongTermPicNum are assigned to the reference pictures by invoking the SVC decoding process for picture numbers \nas specified in clause G.8.2.2 with currDependencyId and refPicListConstructionFlag set equal to 0 as the inputs. \nDecoded reference picture marking proceeds in the following ordered steps: \n    Rec. ITU-T H.264 (06/2019)  513 \n \n1.  All slices of the current access unit are decoded. \n2.  Depending on the current picture, the following applies: \n–  If the current picture is an IDR picture, the following ordered steps are specified: \na.  All reference pictures are marked as \"unused for reference\". \nb.  Depending on long_term_reference_flag, the following applies: \n–  If long_term_reference_flag is equal to 0, the following ordered steps are specified: \ni.  The IDR picture is marked as \"used for short-term reference\" and MaxLongTermFrameIdx \nis set equal to \"no long-term frame indices\". \nii.  When store_ref_base_pic_flag is equal to 1, the reference base picture of the IDR picture is \nmarked as \"used for short-term reference\" and as \"reference base picture\". \n–  Otherwise (long_term_reference_flag is equal to 1), the following ordered steps are specified: \ni.  The IDR picture is marked as \"used for long-term reference\", the LongTermFrameIdx for the \nIDR picture is set equal to 0, and MaxLongTermFrameIdx is set equal to 0. \nii.  When store_ref_base_pic_flag is equal to 1, the reference base picture of the IDR picture is \nmarked  as  \"used  for  long-term  reference\"  and  as  \"reference  base  picture\",  and  the \nLongTermFrameIdx for the reference base picture of the IDR picture is set equal to 0. \n–  Otherwise (the current picture is not an IDR picture), the following ordered steps are specified: \na.  When adaptive_ref_base_pic_marking_mode_flag is equal to 1, the SVC adaptive memory control \nreference base picture marking process as specified in clause G.8.2.4.3 is invoked. \nNOTE 1 – By this invocation of the process specified in clause G.8.2.4.3, pictures that are marked as \"used \nfor reference\" and \"reference base picture\" can be marked as \"unused for reference\". \nWith currTId being the value of temporal_id for the current access unit, the bitstream shall not contain \ndata that result in the marking of pictures with temporal_id less currTId as \"unused for reference\" during \nthis invocation of the process in clause G.8.2.4.3. \nb.  Depending on adaptive_ref_pic_marking_mode_flag, the following applies: \n–  If adaptive_ref_pic_marking_mode_flag is equal to 1, the SVC adaptive memory control decoded \nreference picture marking process as specified in clause G.8.2.4.4 is invoked. \nWith currTId being the value of temporal_id for the current access unit, the bitstream shall not \ncontain data that result in the marking of pictures with temporal_id less currTId as \"unused for \nreference\" during this invocation of the process in clause G.8.2.4.4. \n–  Otherwise (adaptive_ref_pic_marking_mode_flag is equal to 0), the SVC sliding window decoded \nreference picture marking process as specified in clause G.8.2.4.2 is invoked with refBasePicFlag \nequal to 0 as the input. \nc.  When  the  current  picture  was  not  marked  as  \"used  for  long-term  reference\"  by  a \nmemory_management_control_operation command equal to 6, the current picture is marked as \"used \nfor short-term reference\" and, when the current picture is the second field (in decoding order) of a \ncomplementary reference field pair and the first field is marked as \"used for short-term reference\", the \ncomplementary field pair is also marked as \"used for short-term reference\". \nd.  When store_ref_base_pic_flag is equal to 1 and the reference base picture for the current picture was \nnot marked as \"used for long-term reference\" by a memory_management_control_operation command \nequal to 6, the following ordered steps are specified: \ni.  When adaptive_ref_base_pic_marking_mode_flag is equal to 0, the following ordered steps are \nspecified: \n(1)  The SVC decoding process for picture numbers as specified in clause G.8.2.2 is invoked with \ncurrDependencyId and refPicListConstructionFlag set equal to 0 as the inputs. \n(2)  The  SVC  sliding  window  decoded  reference  picture  marking  process  as  specified  in \nclause G.8.2.4.2 is invoked with refBasePicFlag equal to 1 as the input. \nii.  The reference base picture of the current picture is marked as \"used for short-term reference\" and \nas \"reference base picture\" and, when the reference base picture of the current picture is the second \nreference base field (in decoding order) of a complementary reference base field pair and the first \n514  Rec. ITU-T H.264 (06/2019) \n \nreference base field is marked as \"used for short-term reference\" (and \"reference base picture\"), \nthe complementary reference base field pair is also marked as \"used for short-term reference\" and \n\"reference base picture\". \nNOTE 2 – When both the decoded picture and the reference base picture for an access unit (including the current access unit) \nare marked as \"used for reference\", either both pictures are marked as \"used for short-term reference\" or both pictures are \nmarked as \"used for long-term reference\" after the completion of the process specified in this clause. And in the latter case, \nthe same value of LongTermFrameIdx is assigned to both pictures. \nIt  is  a  requirement  of  bitstream  conformance  that,  after  marking  the  current  decoded  reference  picture  and,  when \nstore_ref_base_pic_flag is equal to 1, the current reference base picture, the total number of frames with at least one field \nmarked as \"used for reference\", plus the number of complementary field pairs with at least one field marked as \"used for \nreference\",  plus  the  number  of  non-paired  fields  marked  as  \"used  for  reference\"  shall  not  be  greater  than \nMax( max_num_ref_frames, 1 ). \nNOTE 3 – For this constraint, the pictures marked as \"reference base pictures\" and the pictures not marked as \"reference base \npicture\" are taken into account. \nG.8.2.4.2  SVC sliding window decoded reference picture marking process \nInput to this process is a variable refBasePicFlag. \nThe variable newFrameBufferFlag is derived as follows: \n–  If one of the following conditions is true, newFrameBufferFlag is set equal to 0: \n–  refBasePicFlag is equal to 0, the current picture is a coded field that is the second field in decoding order of a \ncomplementary reference field pair, and the first field of the complementary reference field pair has been marked \nas \"used for short-term reference\", \n–  refBasePicFlag is equal to 1, the current reference base picture is a reference base field that is the second field in \ndecoding order of a complementary reference base field pair, and the first field has been marked as \"used for \nshort-term reference\" (and \"reference base picture\"). \n–  Otherwise, newFrameBufferFlag is set equal to 1. \nWhen newFrameBufferFlag is equal to 1, the following ordered steps are specified: \n1.  Let numShortTerm be the total number of reference frames, complementary reference field pairs, and non-paired \nreference fields for which at least one field is marked as \"used for short-term reference\". Let numLongTerm be \nthe total number of reference frames, complementary reference field pairs, and non-paired reference fields for \nwhich at least one field is marked as \"used for long-term reference\". \nNOTE 1 – For this derivation of numShortTerm and numLongTerm, the pictures marked as \"reference base pictures\" \nand the pictures not marked as \"reference base picture\" are taken into account. \n2.  When numShortTerm + numLongTerm is equal to Max( max_num_ref_frames, 1 ), the following ordered steps \nare specified: \na.  The condition that numShortTerm is greater than 0 shall be fulfilled. \nb.  Let frameNumWrapDecPic be the smallest value of FrameNumWrap that is assigned to reference frames, \ncomplementary reference field pairs, and non-paired reference fields that are marked as \"used for short-term \nreference\" and not marked as \"reference base pictures\". When there doesn't exist any reference frame, \ncomplementary reference field pair, or non-paired reference field that is marked as \"used for short-term \nreference\"  and  not  marked  as  \"reference  base  picture\",  frameNumWrapDecPic  is  set  equal  to \nMaxFrameNum. \nc.  Let frameNumWrapBasePic be the smallest value of FrameNumWrap that is assigned to reference frames, \ncomplementary reference field pairs, and non-paired reference fields that are marked as \"used for short-\nterm reference\" and marked as \"reference base pictures\". When there doesn't exist any reference frame, \ncomplementary reference field pair, or non-paired reference field that is marked as \"used for short-term \nreference\" and marked as \"reference base picture\", frameNumWrapBasePic is set equal to MaxFrameNum. \nNOTE 2 – The value of MaxFrameNum is greater than all values of FrameNumWrap that are assigned to reference \nframes, complementary reference field pairs, and non-paired reference fields marked as \"used for short-term \nreference. \nd.  The short-term reference frame, complementary reference field pair, or non-paired reference field picX is \nderived as follows: \n–  If frameNumWrapDecPic is less than frameNumWrapBasePic, picX is the short-term reference frame, \ncomplementary reference field pair, or non-paired reference field that has the value of FrameNumWrap \nequal to frameNumWrapDecPic (and is not marked as \"reference base picture\"). \n    Rec. ITU-T H.264 (06/2019)  515 \n \n–  Otherwise (frameNumWrapDecPic is greater than or equal to frameNumWrapBasePic), picX is the \nshort-term reference frame, complementary reference field pair, or non-paired reference field that has \nthe value of FrameNumWrap equal to frameNumWrapBasePic and is marked as \"reference base \npicture\". \ne.  It is a requirement of bitstream conformance that the short-term reference frame, complementary reference \nfield pair, or non-paired reference field picX shall not be the current picture or the complementary field pair \nthat contains the current picture. \nNOTE 3 – When refBasePicFlag is equal to 1, the current picture has been marked as \"used for short-term \nreference\" in the same invocation of the process specified in clause G.8.2.4.1. \nf.  The short-term reference frame, complementary reference field pair, or non-paired reference field picX is \nmarked as \"unused for reference\". When it is a frame or a complementary field pair, both of its fields are \nalso marked as \"unused for reference\". \nG.8.2.4.3  SVC adaptive memory control reference base picture marking process \nThis process is invoked when adaptive_ref_base_pic_marking_mode_flag is equal to 1. \nThe memory_management_base_control_operation commands with values of 1 and 2 are processed in the order they occur \nin  the  dec_ref_base_pic_marking( )  syntax  structure  after  the  current  picture  has  been  decoded.  The \nmemory_management_base_control_operation  command  with  value  of  0  specifies  the  end  of  the \nmemory_management_base_control_operation commands. \nMemory management control base operations are applied to pictures as follows: \n–  If field_pic_flag is equal to 0, memory_management_base_control_operation commands are applied to the reference \nbase frames or complementary reference base field pairs specified. \n–  Otherwise (field_pic_flag is equal to 1), memory_management_base_control_operation commands are applied to the \nindividual reference base fields specified. \nFor each memory_management_base_control_operation command with a value not equal to 0, the following applies: \n–  If memory_management_base_control_operation is equal to 1, the marking process of a short-term reference picture \nas  \"unused  for  reference\"  as  specified  in  clause 8.2.5.4.1,  is  invoked  with  substituting \ndifference_of_pic_nums_minus1  with  difference_of_base_pic_nums_minus1.  For  this  invocation  of  the  process \nspecified in clause 8.2.5.4.1, all pictures that are not marked as \"reference base picture\" are considered as not present. \nNOTE 1 – Short-term reference pictures that are not marked as \"reference base pictures\" cannot be marked as \"unused \nfor reference\" by a memory_management_base_control_operation equal to 1. \n–  Otherwise,  if  memory_management_base_control_operation  is  equal  to  2,  the  marking  process  of  a  long-term \nreference  picture  as  \"unused  for  reference\"  as  specified  in  clause 8.2.5.4.2  is  invoked  with  substituting \nlong_term_pic_num with long_term_base_pic_num. For this invocation of the process specified in clause 8.2.5.4.2, \nall pictures that are not marked as \"reference base picture\" are considered as not present. \nNOTE 2 – Long-term reference pictures that are not marked as \"reference base pictures\" cannot be marked as \"unused \nfor reference\" by a memory_management_base_control_operation equal to 2. \nG.8.2.4.4  SVC adaptive memory control decoded reference picture marking process \nThis process is invoked when adaptive_ref_pic_marking_mode_flag is equal to 1. \nThe memory_management_control_operation commands with values of 1 to 6 are processed in the order they occur in the \ndec_ref_pic_marking( )  syntax  structure  after  the  current  picture  has  been  decoded.  The \nmemory_management_control_operation  command  with  value  of  0  specifies  the  end  of  the \nmemory_management_control_operation commands. \nMemory management control operations are applied to pictures as follows: \n–  If field_pic_flag is equal to 0, memory_management_control_operation commands are applied to the frames or \ncomplementary reference field pairs specified. \n–  Otherwise  (field_pic_flag  is  equal  to 1),  memory_management_control_operation  commands  are  applied  to  the \nindividual reference fields specified. \nFor each memory_management_control_operation command with a value not equal to 0, the following applies: \n–  If memory_management_control_operation is equal to 1, the marking process of a short-term reference picture as \n\"unused for reference\" as specified in clause 8.2.5.4.1 is invoked. For this invocation of the process specified in \nclause 8.2.5.4.1, all pictures that are marked as \"reference base picture\" are considered as not present. \n516  Rec. ITU-T H.264 (06/2019) \n \nNOTE 1 – Short-term reference pictures that are marked as \"reference base pictures\" cannot be marked as \"unused for \nreference\" by a memory_management_control_operation equal to 1. \n–  Otherwise, if memory_management_control_operation is equal to 2, the marking process of a long-term reference \npicture as \"unused for reference\" as specified in  clause 8.2.5.4.2 is invoked. For this invocation of the process \nspecified in clause 8.2.5.4.2, all pictures that are marked as \"reference base picture\" are considered as not present. \nNOTE 2 – Long-term reference pictures that are marked as \"reference base pictures\" cannot be marked as \"unused for \nreference\" by a memory_management_control_operation equal to 2. \n–  Otherwise, if memory_management_control_operation is equal to 3, the following ordered steps are specified: \n1.  The  assignment  process  of  a  LongTermFrameIdx  to  a  short-term  reference  picture  as  specified  in \nclause 8.2.5.4.3 is invoked. For this invocation of the process specified in clause 8.2.5.4.3, all pictures that are \nmarked as \"reference base picture\" are considered as not present. The variable picNumX is set equal to the \nvalue picNumX that is derived during the invocation of the process specified in clause 8.2.5.4.3. \n2.  Depending on whether there exists a picture that is marked as \"reference base picture\" and \"used for short-term \nreference\" and has a value of PicNum equal to picNumX, the following applies: \n–  If there exists a picture that is marked as \"reference base picture\" and \"used for short-term reference\" and \nhas a value of PicNum equal to picNumX, the assignment process of a LongTermFrameIdx to a short-term \nreference picture as specified in clause 8.2.5.4.3 is invoked again. For this second invocation of the process \nspecified in clause 8.2.5.4.3, all pictures that are not marked as \"reference base picture\" are considered as \nnot present. \nNOTE 3 – When the marking of a decoded picture (not marked as \"reference base picture\") is changed from \"used \nfor short-term reference\" to \"used for long-term reference\" and there exists a reference base picture (marked as \n\"reference base picture\") that has the same value of PicNum as the decoded picture (before the marking is \nmodified), the marking of this reference base picture is also changed from \"used for short-term reference\" to \"used \nfor long-term reference\" and the same value of LongTermFrameIdx is assigned to both the decoded picture and \nthe reference base picture. \n–  Otherwise, if LongTermFrameIdx equal to long_term_frame_idx is assigned to a long-term reference \nframe marked as \"reference base picture\" or a long-term complementary reference field pair marked as \n\"reference base picture\", that frame or complementary field pair and both of its fields are marked as \n\"unused for reference\". \n–  Otherwise, if LongTermFrameIdx equal to long_term_frame_idx is assigned to a long-term reference field \nmarked as \"reference base picture\", and the associated decoded picture (not marked as \"reference base \npicture\") is not part of a complementary field pair that includes the picture specified by picNumX (before \ninvoking the process specified in clause 8.2.5.4.3) and not marked as \"reference base picture\", that field is \nmarked as \"unused for reference\". \nNOTE 4 – When a particular value of LongTermFrameIdx is assigned to a reference base picture (marked as \n\"reference base picture\") and a decoded picture (not marked as \"reference base picture\"), the reference base picture \nis either associated with the same access unit as the decoded picture or with an access unit that represents a field \nthat is part of a complementary field pair that includes the decoded picture. \n–  Otherwise, the reference picture marking is not modified. \n–  Otherwise,  if  memory_management_control_operation  is  equal  to  4,  the  decoding  process  for \nMaxLongTermFrameIdx as specified in clause 8.2.5.4.4 is invoked. \nNOTE 5 – For this invocation of the process specified in clause 8.2.5.4.4, the pictures marked as \"reference base \npictures\" and the pictures not marked as \"reference base picture\" are taken into account. \n–  Otherwise, if memory_management_control_operation is equal to 5, the marking process of all reference pictures as \n\"unused  for  reference\"  and  setting  MaxLongTermFrameIdx  to  \"no  long-term  frame  indices\"  as  specified  in \nclause 8.2.5.4.5 is invoked. \nNOTE 6 – For this invocation of the process specified in clause 8.2.5.4.5, the pictures marked as \"reference base \npictures\" and the pictures not marked as \"reference base picture\" are taken into account. \n–  Otherwise (memory_management_control_operation is equal to 6), the following ordered steps are specified: \n1.  The process for assigning a long-term frame index to the current picture as specified in clause 8.2.5.4.6 in \ninvoked.  For  this  invocation  of  the  process  specified  in  clause 8.2.5.4.6,  all  pictures  that  are  marked  as \n\"reference base picture\" are considered as not present. \n2.  Depending on store_ref_base_pic_flag, the following applies: \n–  If store_ref_base_pic_flag is equal to 1, the reference base picture of the current picture is marked as \n\"reference base picture\" and the process for assigning a long-term frame index to the current picture as \nspecified in clause 8.2.5.4.6 is invoked again. For this second invocation of the process specified in \n    Rec. ITU-T H.264 (06/2019)  517 \n \nclause 8.2.5.4.6, the reference base picture is considered as the current picture and all pictures that are not \nmarked as \"reference base picture\" are considered as not present. When the reference base picture of the \ncurrent picture is the second reference base field (in decoding order) of a complementary reference base \nfield pair, the complementary reference base field pair is also marked as \"reference base picture\". \nNOTE 7  –  When  the  current  decoded  picture  is  marked  as  \"used  for  long-term  reference\"  and \nstore_ref_base_pic_flag is equal to 1, the current reference base picture is also marked as \"used for long-term \nreference\" and the same value of LongTermFrameIdx is assigned to both the current decoded picture and the \ncurrent reference base picture. The current reference base picture is additionally marked as \"reference base \npicture\". \n–  Otherwise, if LongTermFrameIdx equal to long_term_frame_idx is assigned to a long-term reference \nframe marked as \"reference base picture\" or a long-term complementary reference field pair marked as \n\"reference base picture\", that frame or complementary field pair and both of its fields are marked as \n\"unused for reference\". \n–  Otherwise, if LongTermFrameIdx equal to long_term_frame_idx is assigned to a long-term reference field \nmarked as \"reference base picture\", and the associated decoded picture (not marked as \"reference base \npicture\") is not part of a complementary field pair that includes the current picture, that field is marked as \n\"unused for reference\". \nNOTE 8 – When a particular value of LongTermFrameIdx is assigned to a reference base picture (marked as \n\"reference base picture\") and a decoded picture (not marked as \"reference base picture\"), the reference base picture \nis either associated with the same access unit as the decoded picture or with an access unit that represents a field \nthat is part of a complementary field pair that includes the decoded picture. \n–  Otherwise, the reference picture marking is not modified. \n3.  It is a requirement of bitstream conformance that, after marking the current decoded reference picture and, when \nstore_ref_base_pic_flag is equal to 1, the current reference base picture, the total number of frames with at least \none field marked as \"used for reference\", plus the number of complementary field pairs with at least one field \nmarked as \"used for reference\", plus the number of non-paired fields marked as \"used for reference\" shall not \nbe greater than Max( max_num_ref_frames, 1 ). \nNOTE 9 – For this constraint, the pictures marked as \"reference base pictures\" and the pictures not marked as \"reference \nbase picture\" are taken into account. \nNOTE 10  –  Under  some  circumstances,  the  above  statement  may  impose  a  constraint  on the  order  in  which  a \nmemory_management_control_operation syntax element equal to 6 can appear in the decoded reference picture marking \nsyntax relative to a memory_management_control_operation syntax element equal to 1, 2, 3, or 4, or it may impose a \nconstraint on the value of adaptive_ref_base_pic_marking_mode_flag. \nG.8.2.5  SVC decoding process for gaps in frame_num \nInput to this process is a list dqIdList of integer values specifying layer representation identifiers. \nLet depRepSet be the set of dependency representations for which (dependency_id << 4) is contained in the list dqIdList. \nFor all dependency representations of the set depRepSet, the following applies: \n–  The variable currDependencyId is set equal to the value of dependency_id for the currently considered dependency \nrepresentation of the set depRepSet. \n–  The syntax elements gaps_in_frame_num_value_allowed_flag and frame_num and the derived upper-case variables \nPrevRefFrameNum and MaxFrameNum are the syntax elements and derived upper-case variables for the considered \ndependency representation. \n–  When  gaps_in_frame_num_value_allowed_flag is equal to 0, the bitstream  shall not  contain data that result  in \nframe_num not being equal to PrevRefFrameNum or ( PrevRefFrameNum + 1 ) % MaxFrameNum. \nNOTE – When gaps_in_frame_num_value_allowed_flag is equal to 0 and frame_num is not equal to PrevRefFrameNum and \nis not equal to ( PrevRefFrameNum + 1 ) % MaxFrameNum, the decoding process should infer an unintentional loss of \npictures. \n–  When  frame_num  is  not  equal  to  PrevRefFrameNum  and  is  not  equal  to  ( PrevRefFrameNum + 1 ) % \nMaxFrameNum, the decoding process for gaps in frame_num as specified in clause 8.2.5.2 is invoked. For this \ninvocation of the process specified in clause 8.2.5.2, the modifications a) and b) specified in clause G.8.2 apply, the \ninvocation of the decoding process for picture numbers specified in clause 8.2.4.1 is substituted with the invocation \nof  the  SVC  decoding  process  for  picture  numbers  specified  in  clause G.8.2.2  with  currDependencyId  and \nrefPicListConstructionFlag equal to 0 as the inputs, and the invocation of sliding window picture marking process \nspecified in clause 8.2.5.3 is substituted with the invocation of the SVC sliding window decoded reference picture \nmarking process specified in clause G.8.2.4.2 with refBasePicFlag equal to 0 as the input. \n518  Rec. ITU-T H.264 (06/2019) \n \nG.8.3  SVC intra decoding processes \nClause G.8.3.1 specifies the SVC derivation process for intra prediction modes. \nClause G.8.3.2 specifies the SVC intra sample prediction and construction process. \nG.8.3.1  SVC derivation process for intra prediction modes \nThis process is only invoked when base_mode_flag is equal to 0 and mbType[ CurrMbAddr ] specified as input to this \nprocess is equal to I_PCM, I_16x16, I_8x8, or I_4x4. \nInputs to this process are: \n–  a one-dimensional array sliceIdc with PicSizeInMbs elements specifying slice identifications for the macroblocks of \nthe current layer representation, \n–  a list fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer representation are \ncoded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a list baseModeFlag with PicSizeInMbs elements specifying the syntax element base_mode_flag for the macroblocks \nof the current layer representation, \n–  a list mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of the current layer \nrepresentation, \n–  a (PicSizeInMbs)x16 array ipred4x4 specifying Intra_4x4 prediction modes for macroblocks of the current layer \nrepresentation, \n–  a (PicSizeInMbs)x4 array ipred8x8 specifying Intra_8x8 prediction modes for macroblocks of the current layer \nrepresentation, \n–  a list ipred16x16 with PicSizeInMbs elements specifying Intra_16x16 prediction modes for macroblocks of the \ncurrent layer representation, \n–  when ChromaArrayType is equal to 1 or 2, a list ipredChroma with PicSizeInMbs elements specifying intra chroma \nprediction modes for macroblocks of the current layer representation. \nOutputs of this process are: \n–  a modified version of the array ipred4x4, \n–  a modified version of the array ipred8x8, \n–  a modified version of the list ipred16x16, \n–  when ChromaArrayType is equal to 1 or 2, a modified version of the array ipredChroma. \nFor all processes specified in clause 6 that are invoked from the process specified in this clause or a child process of the \nprocess specified in this clause, the following modifications apply: \na)  In  clause 6.4.12.2,  a  macroblock  with  address  mbAddr  is  treated  as  field  macroblock  when \nfieldMbFlag[ mbAddr ] is equal to 1, and it is treated as frame macroblock when fieldMbFlag[ mbAddr ] is equal \nto 0. In particular, the current macroblock is treated as field macroblock when fieldMbFlag[ CurrMbAddr ] is \nequal to 1, and it is treated as frame macroblock when fieldMbFlag[ CurrMbAddr ] is equal to 0. \nb)  In clause 6.4.8, a macroblock with address mbAddr is treated to belong to a different slice than the current \nmacroblock CurrMbAddr, when sliceIdc[ mbAddr ] is not equal to sliceIdc[ CurrMbAddr ]. \nc)  In clause 6.4.12.2, a macroblock mbAddr is treated as top macroblock when (mbAddr % 2) is equal to 0, and it \nis treated as bottom macroblock when (mbAddr % 2) is equal to 1. \nWhen mbType[ CurrMbAddr ] is not equal to I_PCM, the following applies: \n–  If mbType[ CurrMbAddr ] is equal to I_4x4, the SVC derivation process for Intra_4x4 prediction modes as specified \nin clause G.8.3.1.1 is invoked with sliceIdc, fieldMbFlag, baseModeFlag, mbType, ipred4x4, and ipred8x8 as the \ninputs and the output is a modified version of the array ipred4x4. \n–  Otherwise, if mbType[ CurrMbAddr ] is equal to I_8x8, the SVC derivation process for Intra_8x8 prediction modes \nas  specified  in  clause G.8.3.1.2  is  invoked  with  sliceIdc,  fieldMbFlag,  baseModeFlag,  mbType,  ipred4x4,  and \nipred8x8 as the inputs and the output is a modified version of the array ipred8x8. \n–  Otherwise,  if  mbType[ CurrMbAddr ]  is  equal  to  I_16x16,  ipred16x16[ CurrMbAddr ]  is  set  equal  to \nIntra16x16PredMode. \n    Rec. ITU-T H.264 (06/2019)  519 \n \nWhen  ChromaArrayType  is  equal  to  1  or  2  and  mbType[ CurrMbAddr ]  is  not  equal  to  I_PCM, \nipredChroma[ CurrMbAddr ] is set equal to intra_chroma_pred_mode. \nG.8.3.1.1  SVC derivation process for Intra_4x4 prediction modes \nInputs to this process are: \n–  a one-dimensional array sliceIdc with PicSizeInMbs elements specifying slice identifications for the macroblocks of \nthe current layer representation, \n–  a list fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer representation are \ncoded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a list baseModeFlag with PicSizeInMbs elements specifying the syntax element base_mode_flag for the macroblocks \nof the current layer representation, \n–  a list mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of the current layer \nrepresentation, \n–  a (PicSizeInMbs)x16 array ipred4x4 specifying Intra_4x4 prediction modes for macroblocks of the current layer \nrepresentation, \n–  a (PicSizeInMbs)x4 array ipred8x8 specifying Intra_8x8 prediction modes for macroblocks of the current  layer \nrepresentation. \nOutput of this process is a modified version of the array ipred4x4. \nThe 4x4 blocks indexed by c4x4BlkIdx = 0..15 are processed in increasing order of c4x4BlkIdx, and for each 4x4 block, \nthe following ordered steps are specified: \n1.  The  derivation  process  for  neighbouring  4x4  luma  blocks  as  specified  in  clause 6.4.11.4  is  invoked  with \nc4x4BlkIdx as the input and the outputs are assigned to mbAddrA, c4x4BlkIdxA, mbAddrB, and c4x4BlkIdxB. \nFor  this  invocation  of  the  process  in  clause 6.4.11.4,  the  modifications  specified  in  items a)  through c)  in \nclause G.8.3.1 apply. \n2.  For N being replaced by A and B, the variables availableFlagN are derived as follows: \n–  If the macroblock mbAddrN is available and any of the following conditions are true, availableFlagN is set \nequal to 1: \n–  constrained_intra_pred_flag is equal to 0, \n–  mbType[ mbAddrN ] is equal to I_PCM and tcoeff_level_prediction_flag is equal to 1, \n–  mbType[ mbAddrN ] is equal to I_PCM and baseModeFlag[ mbAddrN ] is equal to 0, \n–  mbType[ mbAddrN ] is equal to I_16x16, I_8x8, or I_4x4. \n–  Otherwise, availableFlagN is set equal to 0. \n3.  The variable dcPredModePredictedFlag is derived as follows: \n–  If availableFlagA or availableFlagB is equal to 0, dcPredModePredictedFlag is set equal to 1. \n–  Otherwise (availableFlagA is equal to 1 and availableFlagB is equal to 1), dcPredModePredictedFlag is set \nequal to 0. \n4.  For N being replaced by A and B, the variables intraMxMPredModeN are derived as follows: \n–  If  dcPredModePredictedFlag  is  equal  to  0  and  mbType[ mbAddrN ]  is  equal  to  I_4x4, \nintraMxMPredModeN is set equal to ipred4x4[ mbAddrN ][ c4x4BlkIdxN ]. \n–  Otherwise,  if  dcPredModePredictedFlag  is  equal  to  0  and  mbType[ mbAddrN ]  is  equal  to  I_8x8, \nintraMxMPredModeN is set equal to ipred8x8[ mbAddrN ][ c4x4BlkIdxN >> 2 ]. \n–  Otherwise (dcPredModePredictedFlag is equal to 1 or (mbType[ mbAddrN ] is not equal to I_4x4 and \nmbType[ mbAddrN ] is not equal to I_8x8)), intraMxMPredModeN is set equal to 2. \n5.  The element ipred4x4[ CurrMbAddr ][ c4x4BlkIdx ] of the array ipred4x4 is derived by applying the procedure \nspecified in the following pseudo-code: \npredIntra4x4PredMode = Min( intraMxMPredModeA, intraMxMPredModeB ) \nif( prev_intra4x4_pred_mode_flag[ c4x4BlkIdx ] ) \n    ipred4x4[ CurrMbAddr ][ c4x4BlkIdx ] = predIntra4x4PredMode \n520  Rec. ITU-T H.264 (06/2019) \n \nelse if( rem_intra4x4_pred_mode[ c4x4BlkIdx ] < predIntra4x4PredMode )   (G-85) \n    ipred4x4[ CurrMbAddr ][ c4x4BlkIdx ] = rem_intra4x4_pred_mode[ c4x4BlkIdx ] \nelse \n    ipred4x4[ CurrMbAddr ][ c4x4BlkIdx ] = rem_intra4x4_pred_mode[ c4x4BlkIdx ] + 1 \nG.8.3.1.2  SVC derivation process for Intra_8x8 prediction modes \nInputs to this process are: \n–  a one-dimensional array sliceIdc with PicSizeInMbs elements specifying slice identifications for the macroblocks of \nthe current layer representation, \n–  a list fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer representation are \ncoded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a list baseModeFlag with PicSizeInMbs elements specifying the syntax element base_mode_flag for the macroblocks \nof the current layer representation, \n–  a list mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of the current layer \nrepresentation, \n–  a (PicSizeInMbs)x16 array ipred4x4 specifying Intra_4x4 prediction modes for macroblocks of the current layer \nrepresentation, \n–  a (PicSizeInMbs)x4 array ipred8x8 specifying Intra_8x8 prediction modes for macroblocks of the current layer \nrepresentation. \nOutput of this process is a modified version of the array ipred8x8. \nThe 8x8 blocks indexed by c8x8BlkIdx = 0..3 are processed in increasing order of c8x8BlkIdx, and for each 8x8 block, \nthe following ordered steps are specified: \n1.  The  derivation  process  for  neighbouring  8x8  luma  blocks  as  specified  in  clause 6.4.11.2  is  invoked  with \nc8x8BlkIdx as the input and the outputs are assigned to mbAddrA, c8x8BlkIdxA, mbAddrB, and c8x8BlkIdxB. \nFor  this  invocation  of  the  process  in  clause 6.4.11.2,  the  modifications  specified  in  items a)  through c)  in \nclause G.8.3.1 apply. \n2.  For N being replaced by A and B, the variables availableFlagN are derived as follows: \n–  If the macroblock mbAddrN is available and any of the following conditions are true, availableFlagN is set \nequal to 1: \n–  constrained_intra_pred_flag is equal to 0, \n–  mbType[ mbAddrN ] is equal to I_PCM and tcoeff_level_prediction_flag is equal to 1, \n–  mbType[ mbAddrN ] is equal to I_PCM and baseModeFlag[ mbAddrN ] is equal to 0, \n–  mbType[ mbAddrN ] is equal to I_16x16, I_8x8, or I_4x4. \n–  Otherwise, availableFlagN is set equal to 0. \n3.  The variable dcPredModePredictedFlag is derived as follows: \n–  If availableFlagA or availableFlagB is equal to 0, dcPredModePredictedFlag is set equal to 1. \n–  Otherwise (availableFlagA is equal to 1 and availableFlagB are equal to 1), dcPredModePredictedFlag is \nset equal to 0. \n4.  For N being replaced by A and B, the variables intraMxMPredModeN are derived as follows: \n–  If  dcPredModePredictedFlag  is  equal  to  0  and  mbType[ mbAddrN ]  is  equal  to  I_4x4, \nintraMxMPredModeN is set equal to ipred4x4[ mbAddrN ][ c8x8BlkIdxN * 4 + c4x4Idx ] with the variable \nc4x4Idx being derived as follows: \n–  If N is equal to B, c4x4Idx is set equal to 2. \n–  Otherwise, if fieldMbFlag[ CurrMbAddr ] is equal to 0, fieldMbFlag[ mbAddrN ] is equal to 1, and \nc8x8BlkIdx is equal to 2, c4x4Idx is set equal to 3. \n–  Otherwise (N is equal to A and (fieldMbFlag[ CurrMbAddr ] is equal to 1 or fieldMbFlag[ mbAddrN ] \nis equal to 0 or c8x8BlkIdx is not equal to 2)), c4x4Idx is set equal to 1. \n    Rec. ITU-T H.264 (06/2019)  521 \n \n–  Otherwise,  if  dcPredModePredictedFlag  is  equal  to  0  and  mbType[ mbAddrN ]  is  equal  to  I_8x8, \nintraMxMPredModeN is set equal to ipred8x8[ mbAddrN ][ c8x8BlkIdxN ]. \n–  Otherwise (dcPredModePredictedFlag is equal to 1 or (mbType[ mbAddrN ] is not equal to I_4x4 and \nmbType[ mbAddrN ] is not equal to I_8x8)), intraMxMPredModeN is set equal to 2. \n5.  The element ipred8x8[ CurrMbAddr ][ c8x8BlkIdx ] of the array ipred8x8 is derived by applying the procedure \nspecified in the following pseudo-code: \npredIntra8x8PredMode = Min( intraMxMPredModeA, intraMxMPredModeB ) \nif( prev_intra8x8_pred_mode_flag[ c8x8BlkIdx ] ) \n    ipred8x8[ CurrMbAddr ][ c8x8BlkIdx ] = predIntra8x8PredMode \nelse if( rem_intra8x8_pred_mode[ c8x8BlkIdx ] < predIntra8x8PredMode )   (G-86) \n    ipred8x8[ CurrMbAddr ][ c8x8BlkIdx ] = rem_intra8x8_pred_mode[ c8x8BlkIdx ] \nelse \n    ipred8x8[ CurrMbAddr ][ c8x8BlkIdx ] = rem_intra8x8_pred_mode[ c8x8BlkIdx ] + 1 \nG.8.3.2  SVC intra sample prediction and construction process \nThis process is only invoked when mbType specified as input to this process is equal to I_PCM, I_16x16, I_8x8, or I_4x4. \nInputs to this process are: \n–  a one-dimensional array sliceIdc with PicSizeInMbs elements specifying slice identifications for the macroblocks of \nthe current layer representation, \n–  a one-dimensional array fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer \nrepresentation are coded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a list baseModeFlag with PicSizeInMbs elements specifying the syntax element base_mode_flag for the macroblocks \nof the current layer representation, \n–  a one-dimensional array mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of \nthe current layer representation, \n–  a list ipred4x4 with 16 elements specifying Intra_4x4 prediction modes for the current macroblock, \n–  a list ipred8x8 with 4 elements specifying Intra_8x8 prediction modes for the current macroblock, \n–  a variable ipred16x16 specifying the Intra_16x16 prediction mode for the current macroblock, \n–  a variable ipredChroma specifying the intra chroma prediction mode for the current macroblock, \n–  a variable cTrafo specifying the transform type for the current macroblock, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  a (PicWidthInSamples )x(PicHeightInSamples ) array picSamples  containing constructed luma sample values for \nL L L\nthe current layer representation. \n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays picSamples  \nC C Cb\nand picSamples  containing constructed chroma sample values for the current layer representation. \nCr\nOutputs of this process are: \n–  a modified version of the array picSamples , \nL\n–  when ChromaArrayType is not equal to 0, modified versions of the arrays picSamples  and picSamples . \nCb Cr\nFor all processes specified in clauses 6 or 8 that are invoked from the process specified in this clause or a child process of \nthe process specified in this clause, the following modifications apply. \na)  In  clause 6.4.12.2,  a  macroblock  with  address  mbAddr  is  treated  as  field  macroblock  when \nfieldMbFlag[ mbAddr ] is equal to 1, and it is treated as frame macroblock when fieldMbFlag[ mbAddr ] is equal \nto 0. In particular, the current macroblock is treated as field macroblock when fieldMbFlag[ CurrMbAddr ] is \nequal to 1, and it is treated as frame macroblock when fieldMbFlag[ CurrMbAddr ] is equal to 0. \nb)  In clause 6.4.8, a macroblock with address mbAddr is treated to belong to a different slice than the current \nmacroblock  CurrMbAddr,  when  MbToSliceGroupMap[ mbAddr ]  is  not  equal  to \nMbToSliceGroupMap[ CurrMbAddr ]  or  mbAddr  is  less  than  ( ( sliceIdc[ CurrMbAddr ] >> 7 ) * \n( 1 + MbaffFrameFlag ) ), where MbToSliceGroupMap represents the variable that is derived as specified in \nclause 8.2.2 for the layer representation with DQId equal to (sliceIdc[ CurrMbAddr ] & 127). \n522  Rec. ITU-T H.264 (06/2019) \n \nNOTE 1 – When MaxTCoeffLevelPredFlag is equal to 0 or when all macroblocks of the current layer picture are covered \nby slices with the same value of DQId, the above condition can be simplified. In this case, two macroblocks mbAddrA \nand mbAddrB can be treated to belong to different slices, when sliceIdc[ mbAddrA ] is not equal to sliceIdc[ mbAddrB ]. \nc)  In clause 6.4.12.2, a macroblock mbAddr is treated as top macroblock when (mbAddr % 2) is equal to 0, and it \nis treated as bottom macroblock when (mbAddr % 2) is equal to 1. \nd)  In  clauses 8.3.1.2,  8.3.2.2,  8.3.3,  and  8.3.4,  the  variables  Intra4x4PredMode,  Intra8x8PredMode, \nIntra16x16PredMode,  and  intra_chroma_pred_mode  are  replaced  by  ipred4x4,  ipred8x8,  ipred16x16,  and \nipredChroma, respectively. \ne)  In clauses 8.3.1.2, 8.3.2.2, 8.3.3, and 8.3.4, the syntax element mb_type of a macroblock with macroblock address \nmbAddr is replaced by mbType[ mbAddr ]. \nf)  The value of constrained_intra_pred_flag that is referred to in clauses 8.3.1.2, 8.3.2.2, 8.3.3, and 8.3.4 is specified \nas follows: \n–  If (sliceIdc[ CurrMbAddr ] & 127) is less than DQIdMax, the value of constrained_intra_pred_flag is the \nvalue of constrained_intra_pred_flag of the active layer picture parameter set for the layer representation \nwith DQId equal to (sliceIdc[ CurrMbAddr ] & 127). \n–  Otherwise  ((sliceIdc[ CurrMbAddr ] & 127)  is  equal  to  DQIdMax),  the  value  of \nconstrained_intra_pred_flag is the value of constrained_intra_pred_flag of the active picture parameter set. \ng)  In  clauses 8.3.1.2,  8.3.2.2,  8.3.3,  and  8.3.4,  a  macroblock  with  mbAddrN  is  treated  as  coded  in  an  Inter \nmacroblock prediction mode when all of the following conditions are false: \n–  mbType[ mbAddrN ] is equal to I_PCM and tcoeff_level_prediction_flag for the slice with DQId equal to \n(sliceIdc[ mbAddrN ] & 127) and first_mb_in_slice equal to (sliceIdc[ mbAddrN ] >> 7) is equal to 1, \n–  mbType[ mbAddrN ] is equal to I_PCM and baseModeFlag[ mbAddrN ] is equal to 0, \n–  mbType[ mbAddrN ] is equal to I_16x16, I_8x8, or I_4x4, \n–  sliceIdc[ mbAddrN ] is not equal to sliceIdc[ CurrMbAddr ]. \nNOTE 2 – The latter condition does only have an impact on the decoding process when MaxTCoeffLevelPredFlag is \nequal to 1 and not all macroblocks of the current layer picture are covered by slices with the same value of DQId. \nNOTE 3 – Encoder designers are encouraged to generate bitstreams for which the removal of zero or more slice data \nNAL units with quality_id greater than 0 cannot result in a conforming bitstream for which a macroblock with address \nmbAddr  is  intra-predicted  from  a  macroblock  with  address  mbAddrN  and  sliceIdc[ mbAddrN ]  not  equal  to \nsliceIdc[ mbAddr ]. \nThe SVC intra sample prediction and construction process proceeds in the following ordered steps: \n1.  The construction process for luma residuals or chroma residuals with ChromaArrayType equal to 3 as specified \nin clause G.8.5.3.1 is invoked with cTrafo and sTCoeff as the inputs and the outputs are residual luma sample \nvalues as a 16x16 array mbRes  with elements mbRes [ x, y ]. \nL L\n2.  When  ChromaArrayType  is  not  equal  to  0,  the  construction  process  for  chroma  residuals  as  specified  in \nclause G.8.5.3.2 is invoked with cTrafo and sTCoeff as the inputs and the outputs are residual chroma sample \nvalues  as  two  (MbWidthC)x(MbHeightC)  arrays  mbRes   and  mbRes   with  elements  mbRes [ x, y ]  and \nCb Cr Cb\nmbRes [ x, y ], respectively. \nCr\n3.  The SVC intra prediction and construction process for luma samples or chroma samples with ChromaArrayType \nequal to 3 as specified in clause G.8.3.2.1 is invoked with BitDepth , sliceIdc, fieldMbFlag, mbType, ipred4x4, \nY\nipred8x8, ipred16x16, mbRes , and picSamples  as the inputs and the output is a modified version of the array \nL L\npicSamples . \nL\n4.  When ChromaArrayType is not equal to 0, the SVC intra prediction and construction process for chroma samples \nas specified in clause G.8.3.2.2 is invoked with sliceIdc, fieldMbFlag, mbType, ipred4x4, ipred8x8, ipred16x16, \nipredChroma, mbRes , mbRes , picSamples , and picSamples  as the inputs and the outputs are modified \nCb Cr Cb Cr\nversions of the arrays picSamples  and picSamples . \nCb Cr\nG.8.3.2.1  SVC  intra  prediction  and  construction  process  for  luma  samples  or  chroma  samples  with \nChromaArrayType equal to 3 \nInputs to this process are: \n–  a variable bitDepth specifying the bit depth, \n–  a one-dimensional array sliceIdc with PicSizeInMbs elements specifying slice identifications for the macroblocks of \nthe current layer representation, \n    Rec. ITU-T H.264 (06/2019)  523 \n \n–  a one-dimensional array fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer \nrepresentation are coded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a one-dimensional array mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of \nthe current layer representation, \n–  a list ipred4x4 with 16 elements specifying Intra_4x4 prediction modes for the current macroblock, \n–  a list ipred8x8 with 4 elements specifying Intra_8x8 prediction modes for the current macroblock, \n–  a variable ipred16x16 specifying the Intra_16x16 prediction mode for the current macroblock, \n–  a 16x16 array mbRes containing residual sample values for the current macroblock, \n–  a  (PicWidthInSamples )x(PicHeightInSamples )  array  picSamples  containing  constructed  sample  values  for  the \nL L\ncurrent layer representation. \nOutputs of this process is a modified version of the array picSamples. \nDepending on mbType[ CurrMbAddr ], the following applies: \n–  If mbType[ CurrMbAddr ] is equal to I_PCM, the SVC construction process for luma samples and chroma samples \nwith  ChromaArrayType  equal  to 3  of  I_PCM  macroblocks  as  specified  in  clause G.8.3.2.1.1  is  invoked  with \nfieldMbFlag, mbRes, and picSamples as the inputs and the output is a modified version of the array picSamples. \n–  Otherwise, if mbType[ CurrMbAddr ] is equal to I_4x4, the SVC Intra_4x4 sample prediction and construction \nprocess as specified in clause G.8.3.2.1.2 is invoked with bitDepth, sliceIdc, fieldMbFlag, mbType, ipred4x4, mbRes, \nand picSamples as the inputs and the output is a modified version of the array picSamples. \n–  Otherwise, if mbType[ CurrMbAddr ] is equal to I_8x8, the SVC Intra_8x8 sample prediction and construction \nprocess as specified in clause G.8.3.2.1.3 is invoked with bitDepth, sliceIdc, fieldMbFlag, mbType, ipred8x8, mbRes, \nand picSamples as the inputs and the output is a modified version of the array picSamples. \n–  Otherwise (mbType[ CurrMbAddr ] is equal to I_16x16), the SVC Intra_16x16 sample prediction and construction \nprocess as specified in clause G.8.3.2.1.4 is invoked with bitDepth, sliceIdc, fieldMbFlag, mbType, ipred16x16, \nmbRes, and picSamples as the inputs and the output is a modified version of the array picSamples. \nG.8.3.2.1.1  SVC construction process for luma samples and chroma samples with ChromaArrayType equal to 3 \nof I_PCM macroblocks \nInputs to this process are: \n–  a one-dimensional array fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer \nrepresentation are coded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a 16x16 array mbRes containing residual sample values for the current macroblock, \n–  a  (PicWidthInSamples )x(PicHeightInSamples )  array  picSamples  containing  constructed  sample  values  for  the \nL L\ncurrent layer representation. \nOutput of this process is a modified version of the array picSamples. \nThe picture sample array construction process for a signal component as specified in clause G.8.5.4.3 is invoked with \nfieldMbFlag[ CurrMbAddr ], mbW set equal to 16, mbH set equal to 16, mbRes, and picSamples as the inputs and the \noutput is a modified version of the array picSamples. \nG.8.3.2.1.2  SVC Intra_4x4 sample prediction and construction process \nInputs to this process are: \n–  a variable bitDepth specifying the bit depth, \n–  a one-dimensional array sliceIdc with PicSizeInMbs elements specifying slice identifications for the macroblocks of \nthe current layer representation, \n–  a one-dimensional array fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer \nrepresentation are coded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a one-dimensional array mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of \nthe current layer representation, \n–  a list ipred4x4 with 16 elements specifying Intra_4x4 prediction modes for the current macroblock, \n–  a 16x16 array mbRes containing residual sample values for the current macroblock, \n524  Rec. ITU-T H.264 (06/2019) \n \n–  a  (PicWidthInSamples )x(PicHeightInSamples )  array  picSamples  containing  constructed  sample  values  for  the \nL L\ncurrent layer representation. \nOutput of this process is a modified version of the array picSamples. \nLet mbSamples be a 16x16 array containing constructed intra sample values for the current macroblock. All elements of \nmbSamples are initially set equal to 0. \nThe 4x4 blocks indexed by c4x4BlkIdx = 0..15 are processed in increasing order of c4x4BlkIdx, and for each 4x4 block, \nthe following ordered steps are specified: \n1.  The  Intra_4x4  sample  prediction  process  as  specified  in  clause 8.3.1.2  is  invoked  with  c4x4BlkIdx  and \npicSamples as the inputs and the outputs are intra prediction sample values as a 4x4 array pred4x4 with elements \npred4x4[ x, y ]. For this invocation of the process in clause 8.3.1.2, the modifications  specified in items a) \nthrough g) of clause G.8.3.2 apply. Additionally in clause 8.3.1.2.3, which may be invoked as part of the process \nspecified in clause 8.3.1.2, the variable BitDepth  is replaced by bitDepth. \nY\n2.  The inverse 4x4 luma block scanning process as specified in clause 6.4.3 is invoked with c4x4BlkIdx as the input \nand the output is assigned to ( xP, yP ). \n3.  For x = xP..(xP + 3) and y = yP..(yP + 3) and with Clip( a ) specifying Clip3( 0, ( 1 << bitDepth ) − 1, a ), the \nelements mbSamples[ x, y ] of the 16x16 array mbSamples are derived by \nmbSamples[ x, y ] = Clip( pred4x4[ x − xP, y − yP ] + mbRes[ x, y ] )  (G-87) \n4.  The picture sample array construction process for a signal component as specified in clause G.8.5.4.3 is invoked \nwith fieldMbFlag[ CurrMbAddr ], mbW set equal to 16, mbH set equal to 16, mbSamples, and picSamples as the \ninputs and the output is a modified version of the array picSamples. \nNOTE – When c4x4BlkIdx is less than 15, the array mbSamples does only contain constructed intra samples for 4x4 \nblocks with c4x4BlkIdx less than or equal to the current value of c4x4BlkIdx. \nG.8.3.2.1.3  SVC Intra_8x8 sample prediction and construction process \nInputs to this process are: \n–  a variable bitDepth specifying the bit depth, \n–  a one-dimensional array sliceIdc with PicSizeInMbs elements specifying slice identifications for the macroblocks of \nthe current layer representation, \n–  a one-dimensional array fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer \nrepresentation are coded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a one-dimensional array mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of \nthe current layer representation, \n–  a list ipred8x8 with 4 elements specifying Intra_8x8 prediction modes for the current macroblock, \n–  a 16x16 array mbRes containing residual sample values for the current macroblock, \n–  a  (PicWidthInSamples )x(PicHeightInSamples )  array  picSamples  containing  constructed  sample  values  for  the \nL L\ncurrent layer representation. \nOutput of this process is a modified version of the array picSamples. \nLet mbSamples be a 16x16 array containing constructed intra sample values for the current macroblock. All elements of \nmbSamples are initially set equal to 0. \nThe 8x8 blocks indexed by c8x8BlkIdx = 0..3 are processed in increasing order of c8x8BlkIdx, and for each 8x8 block, \nthe following ordered steps are specified: \n1.  The  Intra_8x8  sample  prediction  process  as  specified  in  clause 8.3.2.2  is  invoked  with  c8x8BlkIdx  and \npicSamples as the inputs and the outputs are intra prediction sample values as an 8x8 array pred8x8 with elements \npred8x8[ x, y ]. For this invocation of the process in  clause 8.3.2.2, the modifications  specified in items a) \nthrough g) of clause G.8.3.2 apply. Additionally in clause 8.3.2.2.4, which may be invoked as part of the process \nspecified in clause 8.3.2.2, the variable BitDepth  is replaced by bitDepth. \nY\n2.  The inverse 8x8 luma block scanning process as specified in clause 6.4.5 is invoked with c8x8BlkIdx as the input \nand the output is assigned to ( xP, yP ). \n3.  For x = xP..(xP + 7) and y = yP..(yP + 7) and with Clip( a ) specifying Clip3( 0, ( 1 << bitDepth ) − 1, a ), the \nelements mbSamples[ x, y ] of the 16x16 array mbSamples are derived by \n    Rec. ITU-T H.264 (06/2019)  525 \n \nmbSamples[ x, y ] = Clip( pred8x8[ x − xP, y − yP ] + mbRes[ x, y ] )  (G-88) \n4.  The picture sample array construction process for a signal component as specified in clause G.8.5.4.3 is invoked \nwith fieldMbFlag[ CurrMbAddr ], mbW set equal to 16, mbH set equal to 16, mbSamples, and picSamples as the \ninputs and the output is a modified version of the array picSamples. \nNOTE – When c8x8BlkIdx is less than 3, the array mbSamples does only contain constructed intra samples for 8x8 \nblocks with c8x8BlkIdx less than or equal to the current value of c8x8BlkIdx. \nG.8.3.2.1.4  SVC Intra_16x16 sample prediction and construction process \nInputs to this process are: \n–  a variable bitDepth specifying the bit depth, \n–  a one-dimensional array sliceIdc with PicSizeInMbs elements specifying slice identifications for the macroblocks of \nthe current layer representation, \n–  a one-dimensional array fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer \nrepresentation are coded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a one-dimensional array mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of \nthe current layer representation, \n–  a variable ipred16x16 specifying the Intra_16x16 prediction mode for the current macroblock, \n–  a 16x16 array mbRes containing residual sample values for the current macroblock, \n–  a  (PicWidthInSamples )x(PicHeightInSamples )  array  picSamples  containing  constructed  sample  values  for  the \nL L\ncurrent layer representation. \nOutput of this process is a modified version of the array picSamples. \nThe SVC Intra_16x16 sample prediction and construction process proceeds in the following ordered steps: \n1.  The Intra_16x16 prediction process for luma samples as specified in clause 8.3.3 is invoked with picSamples as \nthe  input  and  the  outputs  are  intra  prediction  sample  values  as  a  16x16  array  pred16x16  with  elements \npred16x16[ x, y ]. For this invocation of the process in clause 8.3.3, the modifications specified in items a) \nthrough g) of clause G.8.3.2 apply. Additionally in clause 8.3.3.3, which may be invoked as part of the process \nspecified in clause 8.3.3, the variable BitDepth  is replaced by bitDepth. \nY\n2.  With Clip( a ) specifying Clip3( 0, ( 1 << bitDepth ) − 1, a ), the 16x16 array mbSamples is derived by \nmbSamples[ x, y ] = Clip( pred16x16[ x, y ] + mbRes[ x, y ] )              with x, y = 0..15  (G-89) \n3.  The picture sample array construction process for a signal component as specified in clause G.8.5.4.3 is invoked \nwith fieldMbFlag[ CurrMbAddr ], mbW set equal to 16, mbH set equal to 16, mbSamples, and picSamples as the \ninputs and the output is a modified version of the array picSamples. \nG.8.3.2.2  SVC intra prediction and construction process for chroma samples \nInputs to this process are: \n–  a one-dimensional array sliceIdc with PicSizeInMbs elements specifying slice identifications for the macroblocks of \nthe current layer representation, \n–  a one-dimensional array fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer \nrepresentation are coded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a one-dimensional array mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of \nthe current layer representation, \n–  a list ipred4x4 with 16 elements specifying Intra_4x4 prediction modes for the current macroblock, \n–  a list ipred8x8 with 4 elements specifying Intra_8x8 prediction modes for the current macroblock, \n–  a variable ipred16x16 specifying the Intra_16x16 prediction mode for the current macroblock, \n–  a variable ipredChroma specifying the intra chroma prediction mode for the current macroblock, \n–  two (MbWidthC)x(MbHeightC) arrays mbRes  and mbRes  containing residual chroma sample values for the \nCb Cr\ncurrent macroblock, \n–  two (PicWidthInSamples )x(PicHeightInSamples ) arrays picSamples  and picSamples  containing constructed \nC C Cb Cr\nsample values for the current layer representation. \n526  Rec. ITU-T H.264 (06/2019) \n \nOutputs of this process are modified versions of the arrays picSamples  and picSamples . \nCb Cr\nDepending on ChromaArrayType, the following applies: \n–  If ChromaArrayType is equal to 1 or 2, the following applies: \n–  If mbType[ CurrMbAddr ] is equal to I_PCM, the SVC construction process for chroma samples of I_PCM \nmacroblock as specified in clause G.8.3.2.2.1 is invoked with fieldMbFlag, mbRes , mbRes , picSamples , \nCb Cr Cb\nand picSamples  as the inputs and the outputs are modified versions of picSamples  and picSamples . \nCr Cb Cr\n–  Otherwise (mbType[ CurrMbAddr ] is not equal to I_PCM), the SVC intra prediction and construction process \nfor chroma samples with ChromaArrayType equal to 1 or 2 as specified in clause G.8.3.2.2.2 is invoked with \nsliceIdc, fieldMbFlag, mbType, ipredChroma, mbRes , mbRes , picSamples , and picSamples  as the inputs \nCb Cr Cb Cr\nand the outputs are modified versions of the arrays picSamples  and picSamples . \nCb Cr\n–  Otherwise (ChromaArrayType is equal to 3), for CX being replaced by Cb and Cr, the SVC intra prediction and \nconstruction  process  for  luma  samples  or  chroma  samples  with  ChromaArrayType  equal  to 3  as  specified  in \nclause G.8.3.2.1  is  invoked  with  BitDepth ,  sliceIdc,  fieldMbFlag,  mbType,  ipred4x4,  ipred8x8,  ipred16x16, \nC\nmbRes , and picSamples  as the inputs and the output is a modified version of the array picSamples . \nCX CX CX\nG.8.3.2.2.1  SVC construction process for chroma samples of I_PCM macroblocks \nInputs to this process are: \n–  a one-dimensional array fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer \nrepresentation are coded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  two (MbWidthC)x(MbHeightC) arrays mbRes  and mbRes  containing residual chroma sample values for the \nCb Cr\ncurrent macroblock, \n–  two (PicWidthInSamples )x(PicHeightInSamples ) arrays picSamples  and picSamples  containing constructed \nC C Cb Cr\nchroma sample values for the current layer representation. \nOutputs of this process are modified versions of the arrays picSamples  and picSamples . \nCb Cr\nFor CX being replaced by Cb and Cr, the picture sample array construction process for a signal component as specified in \nclause G.8.5.4.3 is invoked with fieldMbFlag[ CurrMbAddr ], mbW set equal to MbWidthC, mbH set equal to MbHeightC, \nmbRes , and picSamples  as the inputs and the output is a modified version of the array picSamples . \nCX CX CX\nG.8.3.2.2.2  SVC intra prediction and construction process for chroma samples with ChromaArrayType equal to 1 \nor 2 \nThis process is only invoked when ChromaArrayType is equal to 1 or 2. \nInputs to this process are: \n–  a one-dimensional array sliceIdc with PicSizeInMbs elements specifying slice identifications for the macroblocks of \nthe current layer representation, \n–  a one-dimensional array fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer \nrepresentation are coded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a one-dimensional array mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of \nthe current layer representation, \n–  a variable ipredChroma specifying the intra chroma prediction mode for the current macroblock, \n–  two (MbWidthC)x(MbHeightC) arrays mbRes  and mbRes  containing residual chroma sample values for the \nCb Cr\ncurrent macroblock, \n–  two (PicWidthInSamples )x(PicHeightInSamples ) arrays picSamples  and picSamples  containing constructed \nC C Cb Cr\nchroma sample values for the current layer representation. \nOutputs of this process are modified versions of the arrays picSamples  and picSamples . \nCb Cr\nThe SVC intra prediction and construction process for chroma samples with ChromaArrayType equal to 1 or 2 proceeds \nin the following ordered steps: \n1.  The intra prediction process for chroma samples as specified in clause 8.3.4 is invoked with picSamples  and \nCb\npicSamples   as  the  inputs  and  the  outputs  are  intra  prediction  chroma  sample  values  as  two \nCr\n(MbWidthC)x(MbHeightC) arrays pred  and pred  with elements pred [ x, y ] and pred [ x, y ], respectively. \nCb Cr Cb Cr\nFor  this  invocation  of  the  process  in  clause 8.3.4,  the  modifications  specified  in  items a)  through g)  of \nclause G.8.3.2 apply. \n    Rec. ITU-T H.264 (06/2019)  527 \n \n2.  For CX being replaced by Cb and Cr, the (MbWidthC)x(MbHeightC) array mbSamples  is derived by \nCX\nmbSamples [ x, y ] = Clip1 ( pred [ x, y ] + mbRes [ x, y ] )    with x = 0..(MbWidthC − 1) \nCX C CX CX\n                                                                                                            and  y = 0..(MbHeightC − 1)  (G-90) \n3.  For CX being replaced by Cb and Cr, the picture sample array construction process for a signal component as \nspecified in clause G.8.5.4.3 is invoked with fieldMbFlag[ CurrMbAddr ], mbW set equal to MbWidthC, mbH \nset equal to MbHeightC, mbSamples , and picSamples  as the inputs and the output is a modified version of \nCX CX\nthe array picSamples . \nCX\nG.8.4  SVC Inter prediction process \nClause G.8.4.1 specifies the SVC derivation process for motion vector components and reference indices. \nClause G.8.4.2 specifies the SVC decoding process for Inter prediction samples \nG.8.4.1  SVC derivation process for motion vector components and reference indices \nInputs to this process are: \n–  a one-dimensional array sliceIdc with PicSizeInMbs elements specifying slice identifications for the macroblocks of \nthe current layer representation, \n–  a one-dimensional array fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer \nrepresentation are coded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a one-dimensional array mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of \nthe current layer representation, \n–  a (PicSizeInMbs)x4 array subMbType specifying sub-macroblock types for the macroblocks of the current layer \nrepresentation, \n–  two (PicSizeInMbs)x4 arrays predFlagL0 and predFlagL1 specifying prediction utilization flags for the macroblocks \nof the current layer representation, \n–  two (PicSizeInMbs)x4 arrays refIdxL0 and refIdxL1 specifying reference indices for the macroblocks of the current \nlayer representation, \n–  two (PicSizeInMbs)x4x4x2 arrays mvL0 and mvL1 specifying motion vector components for the macroblocks of the \ncurrent layer representation, \n–  a  one-dimensional  array  mvCnt  with  PicSizeInMbs  elements  specifying  the  number  of  motion  vectors  for  the \nmacroblocks of the current layer representation, \n–  two 2x2 arrays refIdxILPredL0 and refIdxILPredL1 specifying inter-layer reference index predictors for the current \nmacroblock, \n–  two 4x4x2 arrays mvILPredL0 and mvILPredL1 specifying inter-layer motion vector predictors for the  current \nmacroblock, \n–  when DQId is equal to 0 and (slice_type % 5) is equal to 1, the reference list refPicList1. \nOutputs of this process are: \n–  modified versions of the arrays predFlagL0 and predFlagL1, \n–  modified versions of the arrays refIdxL0 and refIdxL1, \n–  modified versions of the arrays mvL0 and mvL1, \n–  a modified version of the array mvCnt. \nDepending on mbType[ CurrMbAddr ], the following applies: \n–  If mbType[ CurrMbAddr ] is equal to I_PCM, I_16x16, I_8x8, I_4x4, or I_BL, the arrays predFlagL0, predFlagL1, \nrefIdxL0, refIdxL1, mvL0, mvL1, and mvCnt are modified by: \npredFlagLX[ CurrMbAddr ][ m ]     = 0      with X = 0..1, m = 0..3  (G-91) \nrefIdxLX[ CurrMbAddr ][ m ]         = −1    with X = 0..1, m = 0..3  (G-92) \nmvLX[ CurrMbAddr ][ m ][ s ][ c ] = 0      with X = 0..1, m = 0..3, s = 0..3, c = 0..1  (G-93) \nmvCnt[ CurrMbAddr ]                     = 0  (G-94) \n528  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (mbType[ CurrMbAddr ] is not equal to I_PCM, I_16x16, I_8x8, I_4x4, or I_BL), the arrays predFlagL0, \npredFlagL1, refIdxL0, refIdxL1, mvL0, mvL1, and mvCnt are modified as specified by the following text. \nThe variable numMbPart is derived as follows: \n–  If mbType[ CurrMbAddr ] is equal to B_Skip or B_Direct_16x16 and DQId is equal to 0 (nal_unit_type is not equal \nto 20), numMbPart is set equal to 4. \n–  Otherwise, if  mbType[ CurrMbAddr ] is equal to B_Skip or B_Direct_16x16 (and DQId is greater than 0 and \nnal_unit_type is equal to 20), numMbPart is set equal to 1. \n–  Otherwise  (mbType[ CurrMbAddr ]  is  not  equal  to  B_Skip  or  B_Direct_16x16),  numMbPart  is  set  equal  to \nNumMbPart( mbType[ CurrMbAddr ] ). \nThe macroblock partition index mbPartIdx proceeds over the values 0..(numMbPart − 1), and for each value of mbPartIdx \nthe following ordered steps are specified: \n1.  The variable isDirectFlag is derived as follows: \n–  If any of the following conditions are true, isDirectFlag is set equal to 1: \n–  mbType[ CurrMbAddr ] is equal to B_Skip or B_Direct_16x16, \n–  mbType[ CurrMbAddr ] is equal to B_8x8 and subMbType[ CurrMbAddr ][ mbPartIdx ] is equal to \nB_Direct_8x8. \n–  Otherwise, isDirectFlag is set equal to 0. \n2.  The variable numSubMbPart is derived as follows: \n–  If isDirectFlag is equal to 1 and DQId is equal to 0 (nal_unit_type is not equal to 20), numSubMbPart is set \nequal to 4. \n–  Otherwise, if isDirectFlag is equal to 1 (and DQId is greater than 0 and nal_unit_type is equal to 20), \nnumSubMbPart is set equal to 1. \n–  Otherwise  (isDirectFlag  is  equal  to  0),  numSubMbPart  is  set  equal  to \nNumSubMbPart( subMbType[ CurrMbAddr ][ mbPartIdx ] ). \n3.  The sub-macroblock partition index subMbPartIdx proceeds over values 0..(numSubMbPart − 1), and for each \nvalue of subMbPartIdx the SVC derivation process for luma motion vector components and reference indices of \na  macroblock  or  sub-macroblock  partition  as  specified  in  clause G.8.4.1.1  is  invoked  with  mbPartIdx, \nsubMbPartIdx, isDirectFlag, sliceIdc, fieldMbFlag, mbType, subMbType, predFlagL0, predFlagL1, refIdxL0, \nrefIdxL1, mvL0, mvL1, mvCnt, refIdxILPredL0, refIdxILPredL1, mvILPredL0, mvILPredL1, and, when DQId \nis equal to 0 and (slice_type % 5) is equal to 1, the reference picture list refPicList1 as the inputs and the outputs \nare modified versions of the arrays predFlagL0, predFlagL1, refIdxL0, refIdxL1, mvL0, mvL1, and mvCnt. \nG.8.4.1.1  SVC derivation process for luma motion vector components and reference indices of a macroblock or \nsub-macroblock partition \nThis clause is only invoked when mbType[ CurrMbAddr ], which is specified as input to this clause, is not equal to I_PCM, \nI_16x16, I_8x8, I_4x4, or I_BL. \nInputs to this process are: \n–  a variable mbPartIdx specifying the current macroblock partition, \n–  a variable subMbPartIdx specifying the current sub-macroblock partition, \n–  a variable isDirectFlag specifying whether the current macroblock partition is coded in direct mode, \n–  a one-dimensional array sliceIdc with PicSizeInMbs elements specifying slice identifications for the macroblocks of \nthe current layer representation, \n–  a one-dimensional array fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer \nrepresentation are coded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a one-dimensional array mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of \nthe current layer representation, \n–  a (PicSizeInMbs)x4 array subMbType specifying sub-macroblock types for the macroblocks of the current layer \nrepresentation, \n    Rec. ITU-T H.264 (06/2019)  529 \n \n–  two (PicSizeInMbs)x4 arrays predFlagL0 and predFlagL1 specifying prediction utilization flags for the macroblocks \nof the current layer representation, \n–  two (PicSizeInMbs)x4 arrays refIdxL0 and refIdxL1 specifying reference indices for the macroblocks of the current \nlayer representation, \n–  two (PicSizeInMbs)x4x4x2 arrays mvL0 and mvL1 specifying motion vector components for the macroblocks of the \ncurrent layer representation, \n–  a  one-dimensional  array  mvCnt  with  PicSizeInMbs  elements  specifying  the  number  of  motion  vectors  for  the \nmacroblocks of the current layer representation, \n–  two 2x2 arrays refIdxILPredL0 and refIdxILPredL1 specifying inter-layer reference index predictors for the current \nmacroblock, \n–  two 4x4x2 arrays mvILPredL0 and mvILPredL1 specifying inter-layer motion vector predictors for the current \nmacroblock, \n–  when DQId is equal to 0 and (slice_type % 5) is equal to 1, the reference picture list refPicList1. \nOutputs of this process are: \n–  modified versions of the arrays predFlagL0 and predFlagL1, \n–  modified versions of the arrays refIdxL0 and refIdxL1, \n–  modified versions of the arrays mvL0 and mvL1, \n–  a modified version of the array mvCnt. \nFor all processes specified in clauses 6 or 8 that are invoked from the process specified in this clause or a child process of \nthe process specified in this clause, the following modifications apply: \na)  In clauses 6.4.12.2 and 8.4.1.3.2, a macroblock  with address  mbAddr is treated as  field  macroblock  when \nfieldMbFlag[ mbAddr ] is equal to 1, and it is treated as frame macroblock when fieldMbFlag[ mbAddr ] is equal \nto 0. In particular, the current macroblock is treated as field macroblock when fieldMbFlag[ CurrMbAddr ] is \nequal to 1, and it is treated as frame macroblock when fieldMbFlag[ CurrMbAddr ] is equal to 0. \nb)  In clause 6.4.8, a macroblock with address mbAddr is treated to belong to a different slice than the current \nmacroblock CurrMbAddr, when sliceIdc[ mbAddr ] is not equal to sliceIdc[ CurrMbAddr ]. \nc)  In clause 6.4.12.2, a macroblock mbAddr is treated as top macroblock when (mbAddr % 2) is equal to 0, and it \nis treated as bottom macroblock when (mbAddr % 2) is equal to 1. \nd)  In  clauses 6.4.2.1,  6.4.2.2,  6.4.11.7,  8.4.1.1,  8.4.1.3,  any  occurrence  of  mb_type  is  replaced  by \nmbType[ CurrMbAddr ] with mbType being the array mbType that is input to this clause. \ne)  In clauses 6.4.2.2 and 6.4.11.7, any occurrence of sub_mb_type is replaced by subMbType[ CurrMbAddr ] with \nsubMbType being the array subMbType that is input to this clause. \nf)  In  clause 6.4.11.7,  mb_type  for  a  macroblock  with  macroblock  address  mbAddrN  is  replaced  by \nmbType[ mbAddrN ] with mbType being the array mbType that is input to this clause and sub_mb_type for a \nmacroblock with macroblock address mbAddrN is replaced by subMbType[ mbAddrN ] with subMbType being \nthe array subMbType that is input to this clause. \ng)  In clause 6.4.11.7, a macroblock partition or sub-macroblock partition given by mbAddrN, mbPartIdxN, and \nsubMbPartIdxN  is  treated  as  not  yet  decoded  when  mbAddrN  is  equal  to  CurrMbAddr  and \n(4 * mbPartIdxN + subMbPartIdxN) is greater than (4 * mbPartIdx + subMbPartIdx). \nh)  In clause 8.4.1.3.2, a macroblock with mbAddrN is treated as coded in an Intra macroblock prediction mode \nwhen mbType[ mbAddrN ] is equal to I_PCM, I_16x16, I_8x8, I_4x4, or I_BL. \ni)  In  clause 8.4.1.3.2,  the  variable  predFlagLX  of  a  macroblock  or  sub-macroblock  partition  given  by \nmbAddrN\\mbPartIdxN\\subMbPartIdxN  is  replaced  by  predFlagLX[ mbAddrN ][ mbPartIdxN ]  with \npredFlagLX being the array predFlagLX that is input to this clause. \nj)  In  clause 8.4.1.3.2,  the  motion  vector  MvLX[ mbPartIdxN ][ subMbPartIdxN ]  and  the  reference  index \nRefIdxLX[ mbPartIdxN ]  of  a  macroblock  or  sub-macroblock  partition  given  by \nmbAddrN\\mbPartIdxN\\subMbPartIdxN are replaced by mvLX[ mbAddrN ][ mbPartIdxN ][ subMbPartIdxN ] \nand refIdxLX[ mbAddrN ][ mbPartIdxN ], respectively, with mvLX and refIdxLX being the arrays mvLX and \nrefIdxLX, respectively, that are input to this clause. \n530  Rec. ITU-T H.264 (06/2019) \n \nk)  In clause 8.4.1.2.1, any occurrence of RefPicList1[ 0 ] is replaced by refPicList1[ 0 ] with refPicList1[ 0 ] being \nthe first layer field (when field_pic_flag is equal to 1) or the first layer frame or layer complementary field pair \n(when field_pic_flag is equal to 0) in the reference picture list refPicList1 that is specified as input to this clause. \nThe reference picture list refPicList1 is a reference list of layer pictures that correspond to layer representations \nwith DQId equal to 0 of previously decoded access units. \nl)  In clause 8.4.1.2.1, the current picture CurrPic represents the current layer picture with DQId equal to 0 and the \nvariable colPic specifies the layer picture, for the layer representation with DQId equal to 0, that contains the co-\nlocated macroblock as specified in Table 8-6. \nm)  In clause 8.4.1.2.1, all picture order count values are picture order count value for the dependency representation \nwith dependency_id equal to 0. \nn)  In clause 8.4.1.2.1, the modification b) specified in clause G.8.2 applies with currDependencyId being equal to \n0. \no)  In clause 8.4.1.2.1, for deriving the variable fieldDecodingFlagX, the macroblock mbAddrX is treated as field \nmacroblock  when  fieldMbColPicFlag[ mbAddrX ]  is  equal  to  1,  it  is  treated  as  frame  macroblock  when \nfieldMbColPicFlag[ mbAddrX ] is equal to 0. The array fieldMbColPicFlag specifies the array fieldMbFlag that \nwas derived by the process in clause G.8.1.5.1 for the layer representation with DQId equal to 0. \np)  In  clause 8.4.1.2.1,  the  variables  PredFlagL0,  PredFlagL1,  RefIdxL0,  RefIdxL1,  MvL0,  and  MvL1  for  the \nmacroblock  mbAddrCol  inside  the  picture  colPic  are  replaced  with  the  predFlagL0[ mbAddrCol ], \npredFlagL1[ mbAddrCol ],  refIdxL0[ mbAddrCol ],  refIdxL1[ mbAddrCol ],  mvL0[ mbAddrCol ],  and \nmvL1[ mbAddrCol ], respectively, that have been derived for the layer picture colPic that is associated with DQId \nequal to 0. \nq)  In clause 8.4.1.2.1, the macroblock mbAddrCol is interpreted as coded in an Intra macroblock prediction mode \nwhen mbType[ mbAddrCol ] that has been derived for the layer picture colPic that is associated with DQId equal \nto 0 is equal to I_16x16, I_8x8, I_4x4, or I_PCM. \nr)  In clause 8.4.1.2.1, the syntax element mb_type of the macroblock with address mbAddrCol inside the picture \ncolPic is replaced with mbType[ mbAddrCol ] that has been derived for the layer picture colPic that is associated \nwith DQId equal to 0 and the syntax element list sub_mb_type of the macroblock with address mbAddrCol inside \nthe picture colPic is replaced with the list subMbType[ mbAddrCol ] that has been derived for the layer picture \ncolPic that is associated with DQId equal to 0. \ns)  In  clause 8.4.1.2.2,  the  co-located  macroblock  is  treated  as  field  macroblock  when \nfieldMbColPicFlag[ mbAddrCol ]  is  equal  to  1,  it  is  treated  as  frame  macroblock  when \nfieldMbColPicFlag[ mbAddrCol ] is equal to 0. The array fieldMbColPicFlag specifies the array fieldMbFlag \nthat was derived by the process in clause G.8.1.5.1 for the layer representation with DQId equal to 0. The \nmacroblock  address  mbAddrCol  is  the  macroblock  address  of  the  co-located  macroblock  as  derived  in \nclause 8.4.1.2.1. \nThe reference index predictors  refIdxPredL0 and refIdxPredL1, the motion vector predictors mvPredL0 and mvPredL1, \nand the variable mvCntInc are derived as follows: \n–  If mbType[ CurrMbAddr ] is equal to P_Skip, the reference index predictor refIdxPredL1 is set equal to −1, both \ncomponents of the motion vector predictor mvPredL1 are set equal to 0, the variable mvCntInc is set equal to 1, and \nthe derivation process for luma motion vectors for skipped macroblocks in P slices as specified in clause 8.4.1.1 is \ninvoked with the outputs being assigned to the motion vector predictor mvPredL0 and the reference index predictor \nrefIdxPredL0. For this invocation of the process in clause 8.4.1.1, the modifications specified above in items a) \nthrough j) of this clause apply. \n–  Otherwise, if isDirectFlag is equal to 1 and DQId is equal to 0 (nal_unit_type is not equal to 20), the derivation process \nfor spatial direct luma motion vector and reference index prediction mode as specified in clause 8.4.1.2.2 is invoked \nwith mbPartIdx and subMbPartIdx as the inputs and the output variables refIdxL0, refIdxL1, mvL0, mvL1, and \nsubMvCnt  are  assigned  to  the  reference  index  predictors  refIdxPredL0  and  refIdxPredL1,  the  motion  vectors \npredictors mvPredL0 and mvPredL1, and the variable mvCntInc, respectively. For this invocation of the process in \nclause 8.4.1.2.2, the modifications specified above in items a) through s) of this clause apply. \nNOTE – When the current clause is invoked, direct_spatial_mv_pred_flag is always equal to 1. \n–  Otherwise, if isDirectFlag is equal to 1 (and DQId is greater than 0 and nal_unit_type is equal to 20), the SVC \nderivation process for luma motion vectors and reference indices for B_Skip, B_Direct_16x16, and B_Direct_8x8 in \nNAL units with nal_unit_type equal to 20 as specified in clause G.8.4.1.2 is invoked with mbPartIdx, fieldMbFlag, \nmbType, subMbType, predFlagL0, predFlagL1, refIdxL0, refIdxL1, mvL0, and mvL1 as the inputs and the outputs \nare refIdxPredL0, refIdxPredL1, mvPredL0, mvPredL1, and mvCntInc. \n    Rec. ITU-T H.264 (06/2019)  531 \n \n–  Otherwise, the variable mvCntInc is initially set equal to 0, and for X being replaced by 0 and 1, the following applies: \n–  If any of the following conditions are true, refIdxPredLX is set equal to −1 and both components of mvPredLX \nare set equal to 0: \n–  mbType[ CurrMbAddr ]  is  not  equal  to  P_8x8,  P_8x8ref0,  or  B_8x8  and \nMbPartPredMode( mbType[ CurrMbAddr ], mbPartIdx ) is not equal to Pred_LX or BiPred, \n–  mbType[ CurrMbAddr ]  is  equal  to  P_8x8,  P_8x8ref0,  or  B_8x8  and \nSubMbPartPredMode( subMbType[ CurrMbAddr ][ mbPartIdx ] ) is not equal to Pred_LX or BiPred. \n–  Otherwise,  if  base_mode_flag  is  equal  to  1  or  motion_prediction_flag_lX[ mbPartIdx ]  is  equal  to  1,  the \nfollowing ordered steps are specified: \n1.  The  inverse  macroblock  partition  scanning  process  as  specified  in  clause 6.4.2.1  is  invoked  with \nmbPartIdx as the input and the output is assigned to ( xP, yP ). For this invocation of the process in \nclause 6.4.2.1, the modification specified above in item d) of this clause applies. \n2.  Inverse  sub-macroblock  partition  scanning  process  as  specified  in  clause 6.4.2.2  is  invoked  with \nmbPartIdx and subMbPartIdx as the inputs and the output is assigned to ( xS, yS ). For this invocation \nof the process in clause 6.4.2.2, the modifications specified above in items d) and e) of this clause apply. \n3.  The reference index predictor refIdxPredLX and the motion vector predictor mvPredLX are derived by \nrefIdxPredLX   = refIdxILPredLX[ ( xP + xS ) / 8, ( yP + yS ) / 8 ] \nmvPredLX[ c ] = mvILPredLX[ ( xP + xS ) / 4, ( yP + yS ) / 4 ][ c ]     with c = 0..1  (G-95) \nThe bitstream shall not contain data that result in refIdxPredLX less than 0 or refIdxPredLX greater \nthan num_ref_idx_active_lX_minus1. \nThe bitstream shall not contain data that result in horizontal motion vector components mvPredLX[ 0 ] \nor  vertical  motion  vector  components  mvPredLX[ 1 ]  that  exceed  the  range  for  motion  vector \ncomponents specified in clause G.10.2. \n4.  mvCntInc is set equal to (mvCntInc + 1). \n–  Otherwise, the following ordered steps are specified: \n1.  Depending  on  mbType[ CurrMbAddr ],  the  reference  index  predictor  refIdxPredLX  is  derived  as \nfollows: \n–  If mbType[ CurrMbAddr ] is equal to P_8x8ref0, refIdxPredLX is set equal to 0. \n–  Otherwise (mbType[ CurrMbAddr ] is not equal to P_8x8ref0), refIdxPredLX is set  equal to \nref_idx_lX[ mbPartIdx ]. \n2.  The derivation process for luma motion vector prediction as specified in clause 8.4.1.3 is invoked with \nmbPartIdx,  subMbPartIdx,  refIdxPredLX,  and  currSubMbType  set  equal  to \nsubMbType[ CurrMbAddr ][ mbPartIdx ] as the inputs and the output is assigned to mvPredLX. For \nthis invocation of the process in clause 8.4.1.3, the modifications specified in items a) through j) of this \nclause apply \n3.  mvCntInc is set equal to (mvCntInc + 1). \nFor X being replaced by 0 and 1, the arrays refIdxLX, predFlagLX, and mvLX are modified by applying the following \nordered steps: \n1.  When subMbPartIdx is equal to 0, the arrays refIdxLX and predFlagLX are modified by \nrefIdxLX[ CurrMbAddr ][ mbPartIdx]      = refIdxPredLX  (G-96) \npredFlagLX[ CurrMbAddr ][ mbPartIdx ] = ( ( refIdxPredLX < 0 )  ?  0  :  1 )  (G-97) \n2.  The array mvLX is modified by \nmvLX[ CurrMbAddr ][ mbPartIdx ][ subMbPartIdx ][ c ] = mvPredLX[ c ]     with c = 0..1  (G-98) \n3.  When predFlagLX[ CurrMbAddr ][ mbPartIdx ] is equal to 1, base_mode_flag is equal to 0, isDirectFlag is equal \nto 0, and mbType[ CurrMbAddr ] is not equal to P_Skip, the array mvLX is modified by \nmvLX[ CurrMbAddr ][ mbPartIdx ][ subMbPartIdx ][ c ] += \n                                                    mvd_lX[ mbPartIdx ][ subMbPartIdx ][ c ]     with c = 0..1  (G-99) \n532  Rec. ITU-T H.264 (06/2019) \n \nThe array mvCnt is modified as follows: \n–  If mbPartIdx is equal to 0 and subMbPartIdx is equal to 0, mvCnt[ CurrMbAddr ] is set equal to mvCntInc. \n–  Otherwise (mbPartIdx is greater than 0 or subMbPartIdx is greater than 0), the array mvCnt is modified by \nmvCnt[ CurrMbAddr ] += mvCntInc  (G-100) \nG.8.4.1.2  SVC derivation process for luma motion vectors and reference indices for B_Skip, B_Direct_16x16, and \nB_Direct_8x8 in NAL units with nal_unit_type equal to 20 \nInputs to this process are: \n–  a variable mbPartIdx specifying the current macroblock partition, \n–  a one-dimensional array fieldMbFlag with PicSizeInMbs elements specifying which macroblocks of the current layer \nrepresentation are coded as field macroblocks and which macroblocks are coded as frame macroblocks, \n–  a one-dimensional array mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of \nthe current layer representation, \n–  a (PicSizeInMbs)x4 array subMbType specifying sub-macroblock types for the macroblocks of the current layer \nrepresentation, \n–  two (PicSizeInMbs)x4 arrays predFlagL0 and predFlagL1 specifying prediction utilization flags for the macroblocks \nof the current layer representation, \n–  two (PicSizeInMbs)x4 arrays refIdxL0 and refIdxL1 specifying reference indices for the macroblocks of the current \nlayer representation, \n–  two (PicSizeInMbs)x4x4x2 arrays mvL0 and mvL1 specifying motion vector components for the macroblocks of the \ncurrent layer representation. \nOutputs of this process are: \n–  the reference index predictors refIdxPredL0 and refIdxPredL1, \n–  the motion vector predictors mvPredL0 and mvPredL1, \n–  the variable mvCntInc. \nThe variable currSubMbType is derived as follows: \n–  If mbType[ CurrMbAddr ] is equal to B_Skip or B_Direct_16x16, currSubMbType is marked as \"unspecified\". \n–  Otherwise (mbType[ CurrMbAddr ] is equal to B_8x8 and subMbType[ CurrMbAddr ][ mbPartIdx ] is equal to \nB_Direct_8x8), currSubMbType is set equal to B_Bi_8x8. \nNOTE – The variable currSubMbType is only used for deriving the variable predPartWidth in clause 6.4.11.7, which specifies the \npartition width of the current macroblock or sub-macroblock partition for determining neighbouring partitions that are used for \nmotion vector prediction. Inside clause 6.4.11.7, the variable predPartWidth is set equal to 16 when the current macroblock is \ncoded with macroblock type equal to B_Skip or B_Direct_16x16 or the current sub-macroblock is coded with sub macroblock \ntype equal B_Direct_8x8. When the current clause is invoked for a sub-macroblock coded with sub-macroblock type equal to \nB_Direct_8x8 (the current clause is only invoked for NAL units with nal_unit_type equal to 20), currSubMbType is set equal to \nB_Bi_8x8 in order to set the variable predPartWidth equal to 8 in clause 6.4.11.7. \nFor X being replaced by 0 and 1, the reference index predictor refIdxPredLX is derived by applying the following ordered \nsteps: \n1.  The derivation process for motion data of neighbouring partitions as specified in clause 8.4.1.3.2 is invoked with \nmbPartIdx, subMbPartIdx set equal to 0, currSubMbType, and listSuffixFlag set equal to X as the inputs and the \noutputs are the reference indices refIdxLXN with N being replaced by A, B, and C. For this invocation of the \nprocess in clause 8.4.1.3.2, the modifications specified in items a) through j) of clause G.8.4.1.1 apply. \n2.  The reference index predictor refIdxPredLX is derived by \nrefIdxPredLX = MinPositive( refIdxLXA, MinPositive( refIdxLXB, refIdxLXC ) )  (G-101) \nwith \nMin( x,y) if x  0and y  0\nMinPositiv e( x, y )  \nMax(x,y) otherwise\n\n  (G-102) \n    Rec. ITU-T H.264 (06/2019)  533 \n \nWhen both reference index predictors refIdxPredL0 and refIdxPredL1 are less than 0, refIdxPredL0 and refIdxPredL1 are \nset equal to 0. \nFor X being replaced by 0 and 1, the motion vector predictor mvPredLX is derived as follows: \n–  If refIdxPredLX is greater than or equal to 0, the derivation process for luma motion vector prediction as specified in \nclause 8.4.1.3 is invoked with mbPartIdx, subMbPartIdx set equal to 0, refIdxPredLX, and currSubMbType as the \ninputs and the output is assigned to mvPredLX. For this invocation of the process in clause 8.4.1.3, the modifications \nspecified in items a) through j) of clause G.8.4.1.1 apply. \n–  Otherwise, both components of the motion vector mvPredLX are set equal to 0. \nThe variable mvCntInc is derived as specified by the following ordered steps: \n1.  mvCntInc is set equal to 0 \n2.  When refIdxPredL0 is greater than or equal to 0, mvCntInc is set equal to (mvCntInc + 1). \n3.  When refIdxPredL1 is greater than or equal to 0, mvCntInc is set equal to (mvCntInc + 1). \nG.8.4.2  SVC decoding process for Inter prediction samples \nInputs to this process are: \n–  a variable targetQId specifying the quality_id value for the target layer representation, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable sliceIdc specifying the slice identification for the current macroblock, \n–  a variable mbType specifying the macroblock type for the current macroblock, \n–  a list subMbType with 4 elements specifying the sub-macroblock types for the current macroblock, \n–  two  lists  predFlagL0  and  predFlagL1  with  4  elements  specifying  prediction  utilization  flags  for  the  current \nmacroblock, \n–  two lists refIdxL0 and refIdxL1 with 4 elements specifying reference indices for the current macroblock, \n–  two 4x4x2 arrays mvL0 and mvL1 specifying motion vectors components for the current macroblock, \n–  when present, a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which \nmacroblocks  of  the  reference  layer  representation  are  field  macroblocks  and  which  macroblocks  are  frame \nmacroblocks, \n–  when  present,  a  one-dimensional  array  refLayerMbType  with  RefLayerPicSizeInMbs  elements  specifying \nmacroblock types for the macroblocks of the reference layer representation, \n–  the reference picture lists refPicList0 and refPicList1 (when available), \n–  a (PicWidthInSamples )x(PicHeightInSamples ) array picSamples  of luma sample values, \nL L L\n–  a (PicWidthInSamples )x(PicHeightInSamples ) array picRes  of residual luma sample values, \nL L L\n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays picSamples  \nC C Cb\nand picSamples  of chroma sample values, \nCr\n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays picRes  and \nC C Cb\npicRes  of residual chroma sample values. \nCr\nOutputs of this process are: \n–  a modified version of the array of luma sample values picSamples , \nL\n–  a modified version of the array of residual luma sample values picRes , \nL\n–  when ChromaArrayType is not equal to 0, modified versions of the two arrays of chroma sample values picSamples  \nCb\nand picSamples , \nCr\n–  when ChromaArrayType is not equal to 0, modified versions of the two arrays of residual chroma sample values \npicRes  and picRes . \nCb Cr\nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the current macroblock, which is the macroblock with address CurrMbAddr inside the layer representation with DQId \n534  Rec. ITU-T H.264 (06/2019) \n \nequal to (sliceIdc & 127), the slice header of the current slice, which is the slice that contains the current macroblock, the \ncurrent picture parameter, which is identified by the syntax element pic_parameter_set_id inside the slice header of the \ncurrent slice, and the current sequence parameter, which is identified by the syntax element seq_parameter_set_id inside \nthe current picture parameter set. \nFor all processes specified in clauses 6 or 8 that are invoked from the process specified in this clause or a child process of \nthe process specified in this clause, the following modifications apply: \na)  In clauses 8.4.3, 8.4.1.4, and 8.4.2.1, the current macroblock is treated as field macroblock when fieldMbFlag is \nequal to 1, and it is treated as frame macroblock when fieldMbFlag is equal to 0. When field_pic_flag is equal to \n0  and  the  current  macroblock  CurrMbAddr  is  a  field  macroblock,  its  parity  is  equal  to  top  when \n(CurrMbAddr % 2) is equal to 0 and its parity is equal to bottom when (CurrMbAddr % 2) is equal to 1. \nb)  In  clauses 8.4.3  and 8.4.2.1, any  occurrence  of  RefPicList0  or  RefPicList1  is  replaced  with  refPicList0  or \nrefPicList1, respectively, with refPicList0 and refPicList1 being the reference picture lists specified as inputs to \nthis clause. \nc)  In  clause 8.4.1.4,  the  reference  picture  referred  by  refIdxLX  is  specified  by  refPicListX[ refIdxLX ]  with \nrefPicList0 and refPicList1 specified as inputs to this clause. \nd)  In clauses 8.4.2.2.1 and 8.4.2.2.2, any occurrence of mb_field_decoding_flag is replaced by fieldMbFlag. \ne)  Decoded pictures are represented by the sample arrays S  and, when ChromaArrayType is not equal to 0, S  and \nL Cb\nS , reference base pictures are represented by the sample arrays B  and, when ChromaArrayType is not equal \nCr L\nto 0, B  and B . When reference base pictures are referenced in the inter prediction process via clause 8.4.2.1, \nCb Cr\nthe samples arrays B , B , and B  are referred to as S , S , and S , respectively. The sample arrays S , S , \nL Cb Cr L Cb Cr L Cb\nS , B , B , and B  that referenced in the inter prediction process via clause 8.4.2.1 are constructed as specified \nCr L Cb Cr\nin clause G.8. \nLet predMb  be a 16x16 array of luma prediction samples for the macroblock mbAddr. \nL\nWhen ChromaArrayType is not equal to 0, let predMb  and predMb  be two (MbWidthC)x(MbHeightC) arrays of \nCb Cr\nchroma prediction samples for the macroblock mbAddr. \nThe variable numMbPart is derived as follows: \n–  If  mbType is equal to B_Skip or B_Direct_16x16 and DQId is equal to 0 (nal_unit_type is not equal to 20), \nnumMbPart is set equal to 4. \n–  Otherwise, if mbType is equal to B_Skip or B_Direct_16x16 (and DQId is greater than 0 and nal_unit_type is equal \nto 20), numMbPart is set equal to 1. \n–  Otherwise (mbType is not equal to B_Skip or B_Direct_16x16), numMbPart is set equal to NumMbPart( mbType ). \nThe macroblock partition index mbPartIdx proceeds over the values 0..(numMbPart − 1), and for each value of mbPartIdx \nthe following ordered steps are specified: \n1.  The variable isDirectFlag is derived as follows: \n–  If any of the following conditions are true, isDirectFlag is set equal to 1: \n–  mbType is equal to B_Skip or B_Direct_16x16, \n–  mbType is equal to B_8x8 and subMbType[ mbPartIdx ] is equal to B_Direct_8x8. \n–  Otherwise, isDirectFlag is set equal to 0. \n2.  The variables implicitModeFlag and explicitModeFlag are derived as follows: \n–  If weighted_bipred_idc is equal to 2, (slice_type % 5) is equal to 1, predFlagL0[ mbPartIdx ] is equal to 1, \nand predFlagL1[ mbPartIdx ] is equal to 1, implicitModeFlag is set equal to 1 and explicitModeFlag is set \nequal to 0. \n–  Otherwise,  if  weighted_bipred_idc  is  equal  to 1,  (slice_type % 5)  is  equal  to 1,  and \npredFlagL0[ mbPartIdx ] + predFlagL1[ mbPartIdx ] is equal to 1 or 2, implicitModeFlag is set equal to 0 \nand explicitModeFlag is set equal to 1. \n–  Otherwise, if weighted_pred_flag is equal to 1, (slice_type % 5) is equal to 0, and predFlagL0[ mbPartIdx ] \nis equal to 1, implicitModeFlag is set equal to 0 and explicitModeFlag is set equal to 1. \n–  Otherwise, implicitModeFlag is set equal to 0 and explicitModeFlag is set equal to 0. \n    Rec. ITU-T H.264 (06/2019)  535 \n \n3.  When implicitModeFlag is equal to 1 or explicitModeFlag is equal to 1, the SVC derivation process for prediction \nweights  as  specified  in  clause G.8.4.2.1  is  invoked  with  fieldMbFlag,  refIdxL0[ mbPartIdx ], \nrefIdxL1[ mbPartIdx ], predFlagL0[ mbPartIdx ], predFlagL1[ mbPartIdx ], refPicList0, and refPicList1 (when \navailable) as inputs and the outputs are assigned to logWD , w , w , o ,o , and when ChromaArrayType is \nL 0L 1L 0L   1L\nnot equal to 0, logWD , w , w , o ,o  with C being replaced by Cb and Cr. \nC 0C 1C 0C   1C\n4.  The luma location ( xP, yP ) is derived as follows: \n–  If mbType is equal to B_Skip or B_Direct_16x16, xP is set equal to (8 * ( mbPartIdx % 2 )) and yP is set \nequal to (8 * ( mbPartIdx / 2 )). \n–  Otherwise (mbType is not equal to B_Skip or B_Direct_16x16), the inverse macroblock partition scanning \nprocess as specified in clause 6.4.2.1 is invoked with mbPartIdx as the input and the output is assigned to \n( xP, yP ). For this invocation of the process in clause 6.4.2.1, any occurrence of mb_type is replaced by \nmbType. \n5.  The variable numSubMbPart is derived as follows: \n–  If isDirectFlag is equal to 1 and DQId is equal to 0 (nal_unit_type is not equal to 20), numSubMbPart is set \nequal to 4. \n–  Otherwise, if isDirectFlag is equal to 1 (and DQId is greater than 0 and nal_unit_type is equal to 20), \nnumSubMbPart is set equal to 1. \n–  Otherwise  (isDirectFlag  is  equal  to  0),  numSubMbPart  is  set  equal  to \nNumSubMbPart( subMbType[ mbPartIdx ] ) \n6.  The  sub-macroblock  partition  index  proceeds  over  values  0..(numSubMbPart − 1),  and  for  each  value  of \nsubMbPartIdx the following ordered steps are specified: \na.  The variables partWidth and partHeight are derived as follows: \n–  If isDirectFlag is equal to 1 and DQId is equal to 0 (nal_unit_type is not equal to 20), partWidth and \npartHeight are set equal to 4. \n–  Otherwise, if isDirectFlag is equal to 1 (and DQId is greater than 0 and nal_unit_type is equal to 20), \nthe following applies: \n–  If mbType is equal to B_Skip or B_Direct_16x16, partWidth and partHeight are set equal to 16. \n–  Otherwise (mbType is equal to B_8x8 and subMbType[ mbPartIdx ] is equal to B_Direct_8x8), \npartWidth and partHeight are set equal to 8. \n–  Otherwise (isDirectFlag is equal to 0), the following applies: \n–  If mbType is not equal to P_8x8, P_8x8ref0, or B_8x8, partWidth and partHeight are derived by \npartWidth  = MbPartWidth( mbType )  (G-103) \npartHeight = MbPartHeight( mbType )  (G-104) \n–  Otherwise  (mbType  is  equal  to P_8x8,  P_8x8ref0,  or B_8x8),  partWidth  and  partHeight  are \nderived by \npartWidth  = SubMbPartWidth( subMbType[ mbPartIdx ] )  (G-105) \npartHeight = SubMbPartHeight( subMbType[ mbPartIdx ] )   (G-106) \nb.  When ChromaArrayType is not equal to 0, the variables partWidthC and partHeightC are derived by \npartWidthC  = partWidth / SubWidthC  (G-107) \npartHeightC = partHeight / SubWidthC   (G-108) \nc.  For X being replaced by 0 and 1, when ChromaArrayType is not equal to 0 and predFlagLX[ mbPartIdx ] is \nequal to 1, the derivation process for chroma motion vectors as specified in clause 8.4.1.4 is invoked with \nmvLX[ mbPartIdx ][ subMbPartIdx ] and refIdxLX[ mbPartIdx ] as the inputs and the output is the chroma \nmotion vector mvCLX. For this invocation of the process in clause 8.4.1.4, the modifications specified above \nin items a) and c) of this clause apply. \nd.  The decoding process for Inter prediction samples as specified in clause 8.4.2 is invoked with mbPartIdx, \nsubMbPartIdx, partWidth and partHeight, partWidthC and partHeightC (if available), luma motion vectors \nmvL0[ mbPartIdx ][ subMbPartIdx ]  and  mvL1[ mbPartIdx ][ subMbPartIdx ],  chroma  motion  vectors \nmvCL0  and  mvCL1  (if  available),  reference  indices  refIdxL0[ mbPartIdx ]  and  refIdxL1[ mbPartIdx ], \nprediction utilization flags predFlagL0[ mbPartIdx ] and predFlagL1[ mbPartIdx ] as well as variables for \n536  Rec. ITU-T H.264 (06/2019) \n \nweighted prediction logWD , w , w , o , o , and when ChromaArrayType is not equal to 0, logWD , \nL 0L 1L 1L   0L C\nw ,  w ,  o , and  o   (with  C  being  replaced  by  Cb  and  Cr)  as  the  inputs  and  the  outputs  are  a \n0C 1C 1C   0C\n(partWidth)x(partHeight) array predPart  of luma prediction samples and, when ChromaArrayType is not \nL\nequal to 0, two (partWidthC)x(partHeightC) arrays predPart  and predPart  of chroma prediction samples. \nCb Cr\nFor this invocation of the process in clause 8.4.2, the modifications specified above in items a), b), d), and \ne) of this clause apply. \ne.  The luma location ( xS, yS ) is derived as follows: \n–  If mbType is equal to B_8x8 and subMbType[ mbPartIdx ] is equal to B_Direct_8x8, xS is set equal to \n(4 * ( subMbPartIdx % 2 )) and yS is set equal to (4 * ( subMbPartIdx / 2 )). \n–  Otherwise (mbType is not equal to B_8x8 or subMbType[ mbPartIdx ] is not equal to B_Direct_8x8), \nthe inverse sub-macroblock partition scanning process as specified in clause 6.4.2.2 is invoked with \nmbPartIdx and subMbPartIdx as the inputs and the output is assigned to ( xS, yS ). For this invocation \nof the process in clause 6.4.2.2, any occurrence of mb_type is replaced by mbType and any occurrence \nof sub_mb_type is replaced by subMbType. \nf.  For x = 0..(partWidth − 1) and y = 0..(partHeight − 1), the 16x16 array predMb  is modified by \nL\npredMb [ xP + xS + x, yP + yS + y ] = predPart [ x, y ]  (G-109) \nL L\ng.  When ChromaArrayType is not equal to 0, for x = 0..(partWidthC − 1) and y = 0..(partHeightC − 1), the \n(MbWidthC)x(MbHeightC) arrays predMb  and predMb  are modified by \nCb Cr\npredMb [ ( xP + xS ) / SubWidthC + x, ( yP + yS ) / SubHeightC + y ] = predPart [ x, y ]  (G-110) \nCb Cb\npredMb [ ( xP + xS ) / SubWidthC + x, ( yP + yS ) / SubHeightC + y ] = predPart [ x, y ]  (G-111) \nCr Cr\nWhen targetQId is equal to 0, base_mode_flag is equal to 1, MbaffFrameFlag is equal to 0, RefLayerMbaffFrameFlag is \nequal  to  0,  and  RestrictedSpatialResolutionChangeFlag  is  equal  to  0,  the  intra-inter  prediction  combination  process \nspecified  in  clause G.8.4.2.2  is  invoked  with  fieldMbFlag,  refLayerFieldMbFlag,  refLayerMbType,  predMb , \nL\npicSamples , picRes , and, when ChromaArrayType is not equal to 0, predMb , predMb , picSamples , picSamples , \nL L Cb Cr Cb Cr\npicRes ,  and  picRes   as  the  inputs,  and  the  outputs  are  modified  versions  of  predMb   and  picRes ,  and,  when \nCb Cr L L\nChromaArrayType is not equal to 0, modified versions of predMb , predMb , picRes , and picRes . \nCb Cr Cb Cr\nThe picture sample array construction process as specified in clause G.8.5.4.1 is invoked with fieldMbFlag, predMb , \nL\npicSamples , and, when ChromaArrayType is not equal to 0, predMb , predMb , picSamples , and picSamples  as the \nL Cb Cr Cb Cr\ninputs and the outputs are a modified version of picSamples  and, when ChromaArrayType is not equal to 0, modified \nL\nversions of picSamples , and picSamples . \nCb Cr\nG.8.4.2.1  SVC derivation process for prediction weights \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  the reference indices refIdxL0 and refIdxL1 for the current macroblock partition, \n–  the prediction list utilization flags predFlagL0 and predFlagL1 for the current macroblock partition, \n–  the reference picture lists refPicList0 and refPicList1 (when available). \nOutputs of this process are: \n–  variables for weighted prediction of luma samples logWD , w , w , o ,o , \nL 0L 1L 0L   1L\n–  when ChromaArrayType is not equal to 0 (monochrome), variables for weighted prediction of chroma samples \nlogWD , w , w , o ,o  with C being replaced by Cb and Cr. \nC 0C 1C 0C   1C\nDepending on base_pred_weight_table_flag, the following applies: \n–  If base_pred_weight_table_flag is equal to 0, the derivation process for prediction weights as specified in clause 8.4.3 \nis invoked with refIdxL0, refIdxL1, predFlagL0, and predFlagL1 as inputs and the outputs are assigned to logWD , \nL\nw , w , o ,o , and when ChromaArrayType is not equal to 0, logWD , w , w , o ,o  with C being replaced \n0L 1L 0L   1L C 0C 1C 0C   1C\nby Cb and Cr. For this invocation of the process in clause 8.4.3, the modifications specified in items a) and b) of \nclause G.8.4.2 apply. \n–  Otherwise (base_pred_weight_table_flag is equal to 1), for X being replaced by 0 and 1, the following ordered steps \nare specified: \n1.  Let dqIdList be the list of DQId values that is derived by invoking the derivation process for the set of layer \nrepresentations required for decoding as specified in clause G.8.1.1. Let baseDQId be the largest value dqId, \n    Rec. ITU-T H.264 (06/2019)  537 \n \ninside the list dqIdList, that has the following properties: a) dqId is less than the current value of DQId; b) \nthe slices of the layer representation with DQId equal to dqId have base_pred_weight_table_flag equal to 0. \n2.  Let baseSlice be any slice of the layer representation with DQId equal to baseDQId. \n3.  Let refLayerLumaLogWD, aRefLayerLumaWeightLX[], and aRefLayerLumaOffsetLX[] be variables that \nare  set  equal  to  the  values  of  the  syntax  elements  luma_log2_weight_denom,  luma_weight_lX[],  and \nluma_offset_lX[], respectively, of baseSlice. \n4.  When ChromaArrayType is not equal to 0, let refLayerChromaLogWD, aRefLayerChromaWeightLX[][], \nand aRefLayerChromaOffsetLX[][] be variables that are set equal to the values of the syntax elements \nchroma_log2_weight_denom, chroma_weight_lX[], and chroma_offset_lX[], respectively, of baseSlice. \n5.  The variable refIdxLXWP is derived as follows: \n–  If MbaffFrame is equal to 1 and fieldMbFlag is equal to 1, \nrefIdxLXWP = refIdxLX >> 1  (G-112) \n–  Otherwise (MbaffFrameFlag is equal to 0 or fieldMbFlag is equal to 0), \nrefIdxLXWP = refIdxLX  (G-113) \n6.  The variables logWD , w , o  are derived by: \nL XL XL\nlogWD  = refLayerLumaLogWD  (G-114) \nL\nw         = aRefLayerLumaWeightLX[ refIdxLXWP ]  (G-115) \nXL\no          = aRefLayerLumaOffsetLX[ refIdxLXWP ] * ( 1 << ( BitDepth  − 8 ) )  (G-116) \nXL Y\n7.  When ChromaArrayType is not equal to 0, the variables logWD , w , o  (with C being replaced by Cb \nC XC XC\nand Cr and iCbCr = 0 for Cb and iCbCr = 1 for Cr) are derived by: \nlogWD  = refLayerChromaLogWD  (G-117) \nC\nw         = aRefLayerChromaWeightLX[ refIdxLXWP ][ iCbCr ]   (G-118) \nXC\no          = aRefLayerChromaOffsetLX[ refIdxLXWP ][ iCbCr ] * ( 1 << ( BitDepth  − 8 ) ) (G-119) \nXC C\n8.  When predFlagL0 and predFlagL1 are equal to 1, the following constraint shall be obeyed for C equal to L \nand, when ChromaArrayType is not equal to 0, Cb and Cr \n−128 <= w  + w  <= ( ( logWD   = =  7 ) ? 127 : 128 )   (G-120) \n0C 1C C\nG.8.4.2.2  Intra-inter prediction combination process \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  a one-dimensional array refLayerMbType with RefLayerPicSizeInMbs elements specifying macroblock types for the \nmacroblocks of the reference layer representation, \n–  a 16x16 array predMb  of luma inter prediction samples for the current macroblock, \nL\n–  a (PicWidthInSamples )x(PicHeightInSamples ) array picSamples  of luma sample values, \nL L L\n–  a (PicWidthInSamples )x(PicHeightInSamples ) array picRes  of residual luma sample values, \nL L L\n–  when ChromaArrayType is not equal to 0, two (MbWidthC)x(MbHeightC) arrays predMb  and predMb  of chroma \nCb Cr\nprediction samples for the macroblock mbAddr, \n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays picSamples  \nC C Cb\nand picSamples  of chroma sample values, \nCr\n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays picRes  and \nC C Cb\npicRes  of residual chroma sample values. \nCr\n538  Rec. ITU-T H.264 (06/2019) \n \nOutputs of this process are: \n–  a modified version of the array predMb  of luma prediction samples for the macroblock mbAddr, \nL\n–  a modified version of the array picRes  of residual luma sample values, \nL\n–  when ChromaArrayType is not equal to 0, modified versions of the two arrays predMb  and predMb  of chroma \nCb Cr\nprediction samples for the macroblock mbAddr, \n–  when ChromaArrayType is not equal to 0, modified versions of the two arrays picRes  and picRes  of residual \nCb Cr\nchroma sample values. \nLet predMbTemp  be a 16x16 array and, when ChromaArrayType is not equal to 0, let predMbTemp  and predMbTemp  \nL Cb Cr\nbe two (MbWidthC)x(MbHeightC) arrays. The macroblock sample array extraction process as specified in clause G.8.5.4.2 \nis invoked with fieldMbFlag, picSamples , and when ChromaArrayType is not equal to 0, picSamples  and picSamples  \nL Cb Cr\nas the inputs and the outputs are assigned to predMbTemp , and when ChromaArrayType is not equal to 0, predMbTemp  \nL Cb\nand predMbTemp . \nCr\nLet  resMb   be  a  16x16  array  and,  when  ChromaArrayType  is  not  equal  to 0,  let  resMb   and  resMb   be  two \nL Cb Cr\n(MbWidthC)x(MbHeightC) arrays. The macroblock sample array extraction process as specified in clause G.8.5.4.2 is \ninvoked with fieldMbFlag, picRes , and, when ChromaArrayType is not equal to 0, picRes  and picRes  as the inputs \nL Cb Cr\nand the outputs are assigned to resMb  and, when ChromaArrayType is not equal to 0, resMb  and resMb . \nL Cb Cr\nFor x proceeding over the values 0..15 and y proceeding over the values 0..15, the following ordered steps are specified: \n1.  The derivation process for reference layer macroblocks as specified in clause G.6.1 is invoked with the luma \nlocation ( x, y ), fieldMbFlag, refLayerFieldMbFlag, and refLayerMbType as the inputs and the outputs are \nassigned to mbAddrRefLayer and ( xRef, yRef ). \n2.  When refLayerMbType[ mbAddrRefLayer ] is equal to I_PCM, I_16x16, I_8x8, I_4x4, or I_BL, the following \napplies: \na.  The prediction luma sample predMb [ x, y ] is modified by \nL\npredMb [ x, y ] = predMbTemp [ x, y ]  (G-121) \nL L\nb.  When ChromaArrayType is not equal to 0, (x % SubWidthC) is equal to 0, and (y % SubHeightC) is equal \nto  0,  the  prediction  chroma  samples  predMb [ x / SubWidthC, y / SubHeightC ]  and \nCb\npredMb [ x / SubWidthC, y / SubHeightC ] are modified by \nCr\npredMb [ x / SubWidthC, y / SubHeightC ] = predMbTemp [ x / SubWidthC, y / SubHeightC ] \nCb Cb\n  (G-122) \npredMb [ x / SubWidthC, y / SubHeightC ] = predMbTemp [ x / SubWidthC, y / SubHeightC ] \nCr Cr\n  (G-123) \nc.  The residual luma sample resMb [ x, y ] is set equal to 0. \nL\nd.  When ChromaArrayType is not equal to 0, (x % SubWidthC) is equal to 0, and (y % SubHeightC) is equal \nto  0,  the  residual  chroma  samples  resMb [ x / SubWidthC, y / SubHeightC ]  and \nCb\nresMb [ x / SubWidthC, y / SubHeightC ] are set equal to 0. \nCr\nThe picture sample array construction process as specified in clause G.8.5.4.1 is invoked with fieldMbFlag, resMb , \nL\npicRes , and, when ChromaArrayType is not equal to 0, resMb , resMb , picRes , and picRes  as the inputs and the \nL Cb Cr Cb Cr\noutputs are a modified version of the array picRes  and, when ChromaArrayType is not equal to 0, modified versions of \nL\nthe arrays picRes  and picRes . \nCb Cr\nG.8.5  SVC transform coefficient decoding and sample array construction processes \nClause G.8.5.1 specifies the transform coefficient scaling and refinement process. \nClause G.8.5.2 specifies the transform coefficient level scaling process prior to transform coefficient refinement. \nClause G.8.5.3 specifies the residual construction and accumulation process. \nClause G.8.5.4 specifies the sample array accumulation process. \nClause G.8.5.5 specifies the sample array re-initialization process. \n    Rec. ITU-T H.264 (06/2019)  539 \n \nG.8.5.1  Transform coefficient scaling and refinement process \nInputs to this process are: \n–  a variable refinementFlag specifying whether the transform coefficients for the current macroblock are combined with \nthe  existent  transform  coefficients  for  the  current  macroblock,  which  were  obtained  from  the  reference  layer \nrepresentation, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable mbType specifying the macroblock type for the current macroblock, \n–  a variable cTrafo specifying the transform type for the current macroblock, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  a list of transform coefficient level values tCoeffLevel with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  the luma quantization parameter tQP , \nY\n–  when ChromaArrayType is not equal to 0, the chroma quantization parameters tQP  and tQP . \nCb Cr\nOutputs of this process are: \n–  a modified version of the list sTCoeff, \n–  a modified version of the list tCoeffLevel. \nThe scaling functions are derived as specified in clause 8.5.9. For this invocation of clause 8.5.9, the current macroblock \nis considered as coded using an Intra macroblock prediction mode when mbType is equal to I_PCM, I_16x16, I_8x8, \nI_4x4, or I_BL; otherwise it is considered as coded using an Inter macroblock prediction mode. \nThe variable qP′  is set equal to (tQP  + QpBdOffset ). When ChromaArrayType is not equal to 0, the variables qP′  and \nY Y Y Cb\nqP′  are set equal to (tQP  + QpBdOffset ) and (tQP  + QpBdOffset ), respectively. \nCr Cb C Cr C\nWhen refinementFlag is equal to 0, all (256 + 2 * MbWidthC * MbHeightC) elements of the lists sTCoeff and tCoeffLevel \nare set equal to 0. \nThe refinement process for luma transform coefficients as specified in clause G.8.5.1.1 is invoked with iYCbCr set equal \nto 0, fieldMbFlag, cTrafo, sTCoeff, tCoeffLevel, and qP′  as the inputs and the outputs are modified versions of the lists \nY\nsTCoeff and tCoeffLevel. \nWhen ChromaArrayType is not equal to 0, the refinement process for chroma transform coefficients as specified in \nclause G.8.5.1.2 is invoked with fieldMbFlag, cTrafo, sTCoeff, tCoeffLevel, qP′ , and qP′  as the inputs and the outputs \nCb Cr\nare modified versions of the lists sTCoeff and tCoeffLevel. \nG.8.5.1.1  Refinement  process  for  luma  transform  coefficients  or  chroma  transform  coefficients  with \nChromaArrayType equal to 3 \nInputs to this process are: \n–  a variable iYCbCr specifying the colour component, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable cTrafo specifying the transform type, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  a list of transform coefficient level values tCoeffLevel with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  when iYCbCr is equal to 0, the luma quantization parameter qP′ , \nY\n–  when iYCbCr is greater than 0, the chroma quantization parameters qP′  and qP′ . \nCb Cr\nOutputs of this process are: \n–  a modified version of the list sTCoeff, \n–  a modified version of the list tCoeffLevel. \nWhen iYCbCr is not present as input to this clause, it is inferred to be equal to 0. \nDepending on iYCbCr, the variables bitDepth, qP, cO, coeffLevel4x4, coeffLevel8x8, coeffDCLevel, and coeffACLevel \nare derived as follows: \n540  Rec. ITU-T H.264 (06/2019) \n \n–  If iYCbCr is equal to 0, bitDepth is set equal to BitDepth , qP is set equal to qP′ , cO is set equal to 0, coeffLevel4x4 \nY Y\nis  set  equal  to  LumaLevel4x4,  coeffLevel8x8  is  set  equal  to  LumaLevel8x8,  coeffDCLevel  is  set  equal  to \nIntra16x16DCLevel, and coeffACLevel is set equal to Intra16x16ACLevel. \n–  Otherwise, if iYCbCr is equal to 1, bitDepth is set equal to BitDepth , qP is set equal to qP′ , cO is set equal to 256, \nC Cb\ncoeffLevel4x4 is set equal to CbLevel4x4, coeffLevel8x8 is set equal to CbLevel8x8, coeffDCLevel is set equal to \nCbIntra16x16DCLevel, and coeffACLevel is set equal to CbIntra16x16ACLevel. \n–  Otherwise (iYCbCr is equal to 2), bitDepth is set equal to BitDepth , qP is set equal to qP′ , cO is set equal to \nC Cr\n(256 + MbWidthC * MbHeightC),  coeffLevel4x4  is  set  equal  to  CrLevel4x4,  coeffLevel8x8  is  set  equal  to \nCrLevel8x8,  coeffDCLevel  is  set  equal  to  CrIntra16x16DCLevel,  and  coeffACLevel  is  set  equal  to \nCrIntra16x16ACLevel. \nDepending on cTrafo, the following applies: \n–  If cTrafo is equal to T_PCM, the assignment process for luma transform coefficient values or chroma transform \ncoefficient values with ChromaArrayType equal to 3 for I_PCM macroblocks as specified in clause G.8.5.1.1.1 is \ninvoked with iYCbCr, sTCoeff, and tCoeffLevel as the inputs and the outputs are modified versions of sTCoeff and \ntCoeffLevel. \n–  Otherwise, if cTrafo is equal to T_4x4, the refinement process for transform coefficients of residual 4x4 blocks as \nspecified  in  clause G.8.5.1.1.2  is  invoked  with  fieldMbFlag,  bitDepth,  qP,  cO,  coeffLevel4x4,  sTCoeff,  and \ntCoeffLevel as the inputs and the outputs are modified versions of the lists sTCoeff and tCoeffLevel. \n–  Otherwise, if cTrafo is equal to T_8x8, the refinement process for transform coefficients of residual 8x8 blocks as \nspecified  in  clause G.8.5.1.1.3  is  invoked  with  fieldMbFlag,  bitDepth,  qP,  cO,  coeffLevel8x8,  sTCoeff,  and \ntCoeffLevel as the inputs and the outputs are modified versions of the lists sTCoeff and tCoeffLevel. \n–  Otherwise (cTrafo is equal to T_16x16), the refinement process for transform coefficients of Intra_16x16 macroblocks \nas specified in clause G.8.5.1.1.4 is invoked with fieldMbFlag, bitDepth, qP, cO, coeffDCLevel, coeffACLevel, \ncoeffLevel4x4, sTCoeff, and tCoeffLevel as the inputs and the outputs are modified versions of the lists sTCoeff and \ntCoeffLevel. \nG.8.5.1.1.1  Assignment process for luma transform coefficient values or chroma transform coefficient values with \nChromaArrayType equal to 3 for I_PCM macroblocks \nInputs to this process are: \n–  a variable iYCbCr specifying the colour component, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  a list of transform coefficient level values tCoeffLevel with (256 + 2 * MbWidthC * MbHeightC) elements. \nOutputs of this process are: \n–  a modified version of the list sTCoeff, \n–  a modified version of the list tCoeffLevel. \nWhen base_mode_flag is equal to 0, the following ordered steps are specified: \n1.  Depending on iYCbCr, the variables cO, cListOffset and pcmSample are derived by \ncO               =    iYCbCr * 256 \ncListOffset  = ( ( iYCbCr  = =  0 )  ?  0  :  ( iYCbCr − 1 ) * 256 )  (G-124) \npcmSample = ( ( iYCbCr  = =  0 )  ?  pcm_sample_luma  :  pcm_sample_chroma )  (G-125) \n2.  The lists tCoeffLevel and sTCoeff are modified by \ntCoeffLevel[ cO + k ] = 0                                             with k = 0..255  (G-126) \nsTCoeff[ cO + k ] = pcmSample[ cListOffset + k ]     with k = 0..255  (G-127) \nG.8.5.1.1.2  Refinement process for transform coefficients of residual 4x4 blocks \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable bitDepth specifying the bit depth, \n–  a variable qP specifying the quantization parameter value, \n    Rec. ITU-T H.264 (06/2019)  541 \n \n–  a variable cO specifying the first coefficient index in the list of scaled transform coefficient values sTCoeff and in the \nlist of transform coefficient values tCoeffLevel, \n–  a variable coeffLevel4x4 representing LumaLevel4x4, CbLevel4x4, or CrLevel4x4, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  a list of transform coefficient level values tCoeffLevel with (256 + 2 * MbWidthC * MbHeightC) elements. \nOutputs of this process are: \n–  a modified version of the list sTCoeff, \n–  a modified version of the list tCoeffLevel. \nDepending on tcoeff_level_prediction_flag, the following applies: \n–  If tcoeff_level_prediction_flag is equal to 1, the list sTCoeff is modified by \nsTCoeff[ cO + k ] = 0            with k = 0..255  (G-128) \n–  Otherwise (tcoeff_level_prediction_flag is equal to 0), the list tCoeffLevel is modified by \ntCoeffLevel[ cO + k ] = 0      with k = 0..255  (G-129) \nFor each residual 4x4 block indexed by c4x4BlkIdx = 0..15, the following ordered steps are specified: \n1.  The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is \ninvoked with coeffLevel4x4[ c4x4BlkIdx ] as the input and the outputs are transform coefficient level values as \na 4x4 array c with elements c . For this invocation of the process in clause 8.5.6, the current macroblock is treated \nij\nas field macroblock when fieldMbFlag is equal to 1, and it is treated as frame macroblock when fieldMbFlag is \nequal to 0. \n2.  The list tCoeffLevel and the 4x4 array c are modified by \ntCoeffLevel[ cO + 16 * c4x4BlkIdx + 4 * i + j ] += c       with i, j = 0..3  (G-130) \nij\nc  = tCoeffLevel[ cO + 16 * c4x4BlkIdx + 4 * i + j ]        with i, j = 0..3  (G-131) \nij\n3.  The scaling process for residual 4x4 blocks as specified in clause 8.5.12.1 is invoked with bitDepth, qP, and the \n4x4 array c as the inputs and the outputs are scaled transform coefficient values as a 4x4 array d with elements \nd . For this invocation of the process in clause 8.5.12.1, the array c is treated as not relating to a luma residual \nij\nblock coded using the Intra_16x16 macroblock prediction mode and as not relating to a chroma residual block. \n4.  The list sTCoeff is modified by \nsTCoeff[ cO + 16 * c4x4BlkIdx + 4 * i + j ] += d             with i, j = 0..3  (G-132) \nij\nThe bitstream shall not contain data that result in any element sTCoeff[ cO + k ] with k = 0..255 that exceeds the range of \ninteger values from −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nThe bitstream shall not contain data that result in any element tCoeffLevel[ cO + k ] with k = 0..255 that exceeds the range \nof integer values from −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nG.8.5.1.1.3  Refinement process for transform coefficients of residual 8x8 blocks \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable bitDepth specifying the bit depth, \n–  a variable qP specifying the quantization parameter value, \n–  a variable cO specifying the first coefficient index in the list of scaled transform coefficient values sTCoeff and in the \nlist of transform coefficient values tCoeffLevel, \n–  a variable coeffLevel8x8 representing LumaLevel8x8, CbLevel8x8, or CrLevel8x8, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  a list of transform coefficient level values tCoeffLevel with (256 + 2 * MbWidthC * MbHeightC) elements. \n542  Rec. ITU-T H.264 (06/2019) \n \nOutputs of this process are: \n–  a modified version of the list sTCoeff, \n–  a modified version of the list tCoeffLevel. \nDepending on tcoeff_level_prediction_flag, the following applies: \n–  If tcoeff_level_prediction_flag is equal to 1, the list sTCoeff is modified by \nsTCoeff[ cO + k ] = 0            with k = 0..255  (G-133) \n–  Otherwise (tcoeff_level_prediction_flag is equal to 0), the list tCoeffLevel is modified by \ntCoeffLevel[ cO + k ] = 0      with k = 0..255  (G-134) \nFor each residual 8x8 block indexed by c8x8BlkIdx = 0..3, the following ordered steps are specified: \n1.  The inverse scanning process for 8x8 transform coefficients and scaling lists as specified in clause 8.5.7 is \ninvoked with coeffLevel8x8[ c8x8BlkIdx ] as the input and the outputs are transform coefficient level values as \nan 8x8 array c with elements c . For this invocation of the process in clause 8.5.7, the current macroblock is \nij\ntreated  as  field  macroblock  when  fieldMbFlag  is  equal  to 1,  and  it  is  treated  as  frame  macroblock  when \nfieldMbFlag is equal to 0. \n2.  The list tCoeffLevel and the 8x8 array c are modified by \ntCoeffLevel[ cO + 64 * c8x8BlkIdx + 8 * i + j ] += c      with i, j = 0..7  (G-135) \nij\nc  = tCoeffLevel[ cO + 64 * c8x8BlkIdx + 8 * i + j ]       with i, j = 0..7  (G-136) \nij\n3.  The scaling process for residual 8x8 blocks as specified in clause 8.5.13.1 is invoked with bitDepth, qP, and the \n8x8 array c as the inputs and the outputs are scaled transform coefficient values as an 8x8 array d with elements \nd . \nij\n4.  The list sTCoeff is modified by \nsTCoeff[ cO + 64 * c8x8BlkIdx + 8 * i + j ] += d            with i, j = 0..7  (G-137) \nij\nThe bitstream shall not contain data that result in any element sTCoeff[ cO + k ] with k = 0..255 that exceeds the range of \ninteger values from −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nThe bitstream shall not contain data that result in any element tCoeffLevel[ cO + k ] with k = 0..255 that exceeds the range \nof integer values from −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nG.8.5.1.1.4  Refinement process for transform coefficients of Intra_16x16 macroblocks \nThis process is only invoked when base_mode_flag is equal to 0 or tcoeff_level_prediction_flag is equal to 1. \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable bitDepth specifying the bit depth, \n–  a variable qP specifying the quantization parameter value, \n–  a variable cO specifying the first coefficient index in the list of scaled transform coefficient values sTCoeff and in the \nlist of transform coefficient values tCoeffLevel, \n–  a variable coeffDCLevel representing Intra16x16DCLevel, CbIntra16x16DCLevel, or CrIntra16x16DCLevel, \n–  a variable coeffACLevel representing Intra16x16ACLevel, CbIntra16x16ACLevel, or CrIntra16x16ACLevel, \n–  a variable coeffLevel4x4 representing LumaLevel4x4, CbLevel4x4, or CrLevel4x4, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  a list of transform coefficient level values tCoeffLevel with (256 + 2 * MbWidthC * MbHeightC) elements. \nOutputs of this process are: \n–  a modified version of the list sTCoeff, \n–  a modified version of the list tCoeffLevel. \nNOTE 1 – When tcoeff_level_prediction_flag is equal to 0, this clause is always invoked as part of an invocation of clause G.8.5.1 \nwith refinementFlag equal to 0, in which case all elements of the list tCoeffLevel are set equal to 0 before invoking this clause. \n    Rec. ITU-T H.264 (06/2019)  543 \n \nFor the DC transform coefficients of all residual 4x4 blocks, the following ordered steps are specified: \n1.  Depending on base_mode_flag, the 4x4 array c with elements c  is derived as follows: \nij\n–  If base_mode_flag is equal to 0, the inverse scanning process for 4x4 transform coefficients and scaling lists \nas specified in clause 8.5.6 is invoked with coeffDCLevel as the input and the outputs are DC transform \ncoefficient level values for all residual 4x4 blocks as a 4x4 array c with elements c . For this invocation of \nij\nthe process in clause 8.5.6, the current macroblock is treated as field macroblock when fieldMbFlag is equal \nto 1, and it is treated as frame macroblock when fieldMbFlag is equal to 0. \n–  Otherwise (base_mode_flag is equal to 1), the 4x4 array c  with elements c  containing DC transform \nij\ncoefficient level values is derived by \nc  = coeffLevel4x4[ 8 * ( i / 2 ) + 4 * ( j / 2 ) + 2 * ( i % 2 ) + ( j % 2 ) ][ 0 ]        with i, j = 0..3  (G-138) \nij\n2.  The list tCoeffLevel and the 4x4 array c are modified by \ntCoeffLevel[ cO + 128 * ( i / 2 ) + 64 * ( j / 2 ) + 32 * ( i % 2 ) + 16 * ( j % 2 ) ] += c  \nij\n                                                                                                                                with i, j = 0..3  (G-139) \nc  = tCoeffLevel[ cO + 128 * ( i / 2 ) + 64 * ( j / 2 ) + 32 * ( i % 2 ) + 16 * ( j % 2 ) ] \nij\n                                                                                                                                with i, j = 0..3  (G-140) \n3.  The scaling and transformation process for DC transform coefficients  for Intra_16x16 macroblock type as \nspecified in clause 8.5.10 is invoked with bitDepth, qP, and c as the inputs and the output is the 4x4 array d with \nelements d  representing scaled DC transform coefficient values for all residual 4x4 blocks. \nij\n4.  The list sTCoeff is modified by \nsTCoeff[ cO + 128 * ( i / 2 ) + 64 * ( j / 2 ) + 32 * ( i % 2 ) + 16 * ( j % 2 ) ] = d  \nij\n                                                                                                                                with i, j = 0..3  (G-141) \nFor each residual 4x4 block indexed by c4x4BlkIdx = 0..15, the following ordered steps are specified: \n1.  Depending on base_mode_flag, the variable c4x4List, which is a list of 16 entries, is derived as follows: \n–  If base_mode_flag is equal to 0, the following applies: \nc4x4List[ k ] = ( ( k  = =  0 )  ?  0  :  coeffACLevel[ c4x4BlkIdx ][ k − 1 ] )          with k = 0..15  (G-142) \n–  Otherwise (base_mode_flag is equal to 1), the following applies: \nc4x4List[ k ] = ( ( k  = =  0 )  ?  0  :  coeffLevel4x4[ c4x4BlkIdx ][ k ] )                with k = 0..15  (G-143) \n2.  The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is \ninvoked with c4x4List as the input and the outputs are transform coefficient level values as a 4x4 array e with \nelements  e .  For  this  invocation  of  the  process  in  clause 8.5.6,  the  current  macroblock  is  treated  as  field \nij\nmacroblock when fieldMbFlag is equal to 1, and it is treated as frame macroblock when fieldMbFlag is equal \nto 0. \n3.  The list tCoeffLevel and the 4x4 array e are modified by \ntCoeffLevel[ cO + 16 * c4x4BlkIdx + 4 * i + j ] += e              with i, j = 0..3 and i + j > 0  (G-144) \nij\ne  = tCoeffLevel[ cO + 16 * c4x4BlkIdx + 4 * i + j ]               with i, j = 0..3 and i + j > 0  (G-145) \nij\n4.  The scaling process for residual 4x4 blocks as specified in clause 8.5.12.1 is invoked with bitDepth, qP, and the \n4x4 array e as the inputs and the outputs are scaled transform coefficient values as a 4x4 array d with elements \nd . During the process in clause 8.5.12.1, the array e is treated as relating to a luma residual block coded using \nij\nthe Intra_16x16 macroblock prediction mode. \n5.  The list sTCoeff is modified by \nsTCoeff[ cO + 16 * c4x4BlkIdx + 4 * i + j ] = d                    with i, j = 0..3 and i + j > 0  (G-146) \nij\nNOTE 2 – The elements tCoeffLevel[ cO + 16* c4x4BlkIdx ] and sTCoeff[ cO + 16* c4x4BlkIdx ] are not modified \nduring the process for a residual 4x4 block with index c4x4BlkIdx. \nThe bitstream shall not contain data that result in any element tCoeffLevel[ cO + k ] with k = 0..255 that exceeds the range \nof integer values from −2(7 + bitDepth) to 2(7 + bitDepth) − 1, inclusive. \nG.8.5.1.2  Refinement process for chroma transform coefficients \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n544  Rec. ITU-T H.264 (06/2019) \n \n–  a variable cTrafo specifying the transform type, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  a list of transform coefficient level values tCoeffLevel with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  the chroma quantization parameters qP′  and qP′ . \nCb Cr\nOutputs of this process are: \n–  a modified version of the list sTCoeff, \n–  a modified version of the list tCoeffLevel. \nFor both chroma components indexed by iCbCr = 0..1, the following applies: \n–  If ChromaArrayType is equal to 1 or 2, the following applies: \n–  If cTrafo is equal to T_PCM, the assignment process for chroma transform coefficient values for I_PCM \nmacroblocks as specified in clause G.8.5.1.2.1 is invoked with iCbCr, sTCoeff, and tCoeffLevel as the inputs \nand the outputs are modified versions of sTCoeff and tCoeffLevel. \n–  Otherwise (cTrafo is not equal to T_PCM), the refinement process for chroma transform coefficients with \nChromaArrayType equal to  1 or 2 as specified in  clause G.8.5.1.2.2 is invoked  with  iCbCr,  fieldMbFlag, \nsTCoeff, tCoeffLevel, qP′ , and qP′  as the inputs and the outputs are modified versions of the lists sTCoeff \nCb Cr\nand tCoeffLevel. \n–  Otherwise (ChromaArrayType is equal to 3), the refinement process for luma transform coefficients or chroma \ntransform coefficients with ChromaArrayType equal to 3 as specified in clause G.8.5.1.1 is invoked with iYCbCr set \nequal to (1 + iCbCr), fieldMbFlag, cTrafo, sTCoeff, tCoeffLevel, qP′ , and qP′  as the inputs and the outputs are \nCb Cr\nmodified versions of the lists sTCoeff and tCoeffLevel. \nG.8.5.1.2.1  Assignment process for chroma transform coefficient values for I_PCM macroblocks \nInputs to this process are: \n–  a variable iCbCr specifying the chroma component, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  a list of transform coefficient level values tCoeffLevel with (256 + 2 * MbWidthC * MbHeightC) elements. \nOutputs of this process are: \n–  a modified version of the list sTCoeff, \n–  a modified version of the list tCoeffLevel. \nThe variable numC is set equal to (MbWidthC * MbHeightC) and the variable cCO is set equal to (iCbCr * numC). \nWhen base_mode_flag is equal to 0, the lists tCoeffLevel and sTCoeff are modified by \ntCoeffLevel[ 256 + cCO + k ] = 0                                                 with k = 0..(numC − 1)  (G-147) \nsTCoeff[ 256 + cCO + k ] = pcm_sample_chroma[ cCO + k ]     with k = 0..(numC − 1)  (G-148) \nG.8.5.1.2.2  Refinement process for chroma transform coefficients with ChromaArrayType equal to 1 or 2 \nThis process is only invoked when ChromaArrayType is equal to 1 or 2. \nInputs to this process are: \n–  a variable iCbCr specifying the chroma component, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  a list of transform coefficient level values tCoeffLevel with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  the chroma quantization parameters qP′  and qP′ . \nCb Cr\nOutputs of this process are: \n–  a modified version of the list sTCoeff, \n–  a modified version of the list tCoeffLevel. \n    Rec. ITU-T H.264 (06/2019)  545 \n \nThe variables nW, nH, numB, cO, and qP are derived by \nnW    = MbWidthC / 4  (G-149) \nnH     = MbHeightC / 4  (G-150) \nnumB = nW * nH  (G-151) \ncO      = 256 + ( iCbCr * MbWidthC * MbHeightC )  (G-152) \nqP      = ( ( iCbCr  = =  0 )  ?  qP′   :  qP′  )  (G-153) \nCb Cr\nDepending on tcoeff_level_prediction_flag, the following applies: \n–  If tcoeff_level_prediction_flag is equal to 1, the list sTCoeff is modified by \nsTCoeff[ cO + k ] = 0            with k = 0..(MbWidthC * MbHeightC − 1)  (G-154) \n–  Otherwise (tcoeff_level_prediction_flag is equal to 0), the list tCoeffLevel is modified by \ntCoeffLevel[ cO + k ] = 0      with k = 0..(MbWidthC * MbHeightC − 1)  (G-155) \nFor the chroma DC transform coefficients of all residual 4x4 chroma blocks, the following ordered steps are specified: \n1.  Depending on ChromaArrayType, the (nW)x(nH) array c with elements c  is derived as follows: \nij\n–  If ChromaArrayType is equal to 1, \nc  = ChromaDCLevel[ iCbCr ][ 2 * i + j ]                            with i = 0..(nH − 1),  j = 0..(nW − 1)  (G-156) \nij\n–  Otherwise (ChromaArrayType is equal to 2), \nc  = ChromaDCLevel[ iCbCr ][ scan422ChromaDC[ 2 * i + j ] ] \nij\n                                                                                               with i = 0..(nH − 1),  j = 0..(nW − 1), \n                                                                           and scan422ChromaDC = { 0, 2, 1, 5, 3, 6, 4, 7 }  (G-157) \n2.  The list tCoeffLevel and the (nW)x(nH) array c are modified by \ntCoeffLevel[ cO + 32 * i + 16 * j ] += c                              with i = 0..(nH − 1),  j = 0..(nW − 1)  (G-158) \nij\nc  = tCoeffLevel[ cO + 32 * i + 16 * j ]                               with i = 0..(nH − 1),  j = 0..(nW − 1)  (G-159) \nij\n3.  The variable qP  is derived by \nDC\nqP  = ( ( ChromaArrayType  = =  1 )  ?  qP  :  ( qP + 3 ) )  (G-160) \nDC\n4.  The (nW)x(nH) array d with elements d  representing scaled chroma DC transform coefficient values for all \nij\nresidual 4x4 chroma blocks is derived by \nd  = c  * ( LevelScale4x4( qP  % 6, 0, 0 ) << ( qP  / 6 ) )    with i = 0..(nH − 1),  j = 0..(nW − 1) \nij ij DC DC\n    (G-161) \n5.  The list sTCoeff is modified by \nsTCoeff[ cO + 32 * i + 16 * j ] += d                                    with i = 0..(nH − 1),  j = 0..(nW − 1)  (G-162) \nij\nFor each residual 4x4 chroma block indexed by c4x4BlkIdx = 0..(numB − 1), the following ordered steps are specified: \n1.  The variable c4x4List, which is a list of 16 entries, is derived by \nc4x4List[ k ] = ( ( k  = =  0 )  ?  0  :  ChromaACLevel[ iCbCr ][ c4x4BlkIdx ][ k − 1 ] ) \n                                                                                                                            with k = 0..15  (G-163) \n2.  The inverse scanning process for 4x4 transform coefficients and scaling lists as specified in clause 8.5.6 is \ninvoked with c4x4List as the input and the outputs are chroma transform coefficient level values as a 4x4 array \ne with elements e . During the process in clause 8.5.6, the current macroblock is treated as field macroblock when \nij\nfieldMbFlag is equal to 1, and it is treated as frame macroblock when fieldMbFlag is equal to 0. \n3.  The list tCoeffLevel and the 4x4 array e are modified by \ntCoeffLevel[ cO + 16 * c4x4BlkIdx + 4 * i + j ] += e         with i, j = 0..3 and i + j > 0  (G-164) \nij\ne  = tCoeffLevel[ cO + 16 * c4x4BlkIdx + 4 * i + j ]          with i, j = 0..3 and i + j > 0  (G-165) \nij\n4.  The scaling process for residual 4x4 blocks as specified in clause 8.5.12.1 is invoked with BitDepth , qP, and the \nC\n4x4 array e as the inputs and the outputs are scaled chroma transform coefficient values as a 4x4 array d of with \nelements d . During the process in clause 8.5.12.1, the array e is treated as relating to a chroma residual block. \nij\n5.  The list sTCoeff is modified by \nsTCoeff[ cO + 16 * c4x4BlkIdx + 4 * i + j ] += d              with i, j = 0..3 and i + j > 0  (G-166) \nij\n546  Rec. ITU-T H.264 (06/2019) \n \nNOTE 1 – The elements tCoeffLevel[ cO + 16* c4x4BlkIdx ] and sTCoeff[ cO + 16* c4x4BlkIdx ] are not modified \nduring the process for a residual 4x4 chroma block with index c4x4BlkIdx. \nThe bitstream shall not contain data that result in any element sTCoeff[ cO + 16* b + k ] with b = 0..(numB − 1) and \nk = 1..15 that exceeds the range of integer values from −2(7 + BitDepthC) to 2(7 + BitDepthC) − 1, inclusive. \nThe bitstream shall not contain data that result in any element tCoeffLevel[ cO + 16* b + k ] with b = 0..(numB − 1) and \nk = 1..15 that exceeds the range of integer values from −2(7 + BitDepthC) to 2(7 + BitDepthC) − 1, inclusive. \nNOTE 2 – The elements tCoeffLevel[ cO + 16* b ] and sTCoeff[ cO + 16* b ] with b = 0..(numB − 1) can exceed the range of \ninteger values from −2(7 + BitDepth\nC\n) to 2(7 + BitDepth\nC\n) − 1, inclusive. \nG.8.5.2  Transform coefficient level scaling process prior to transform coefficient refinement \nInputs to this process are: \n–  a variable cTrafo specifying the luma transform type for the current macroblock, \n–  a list tCoeffLevel with (256 + 2 * MbWidthC * MbHeightC) elements specifying transform coefficient level values \nfor the current macroblock, \n–  a variable tQP  specifying the luma quantization parameter for the current macroblock, \nY\n–  a variable refQP  specifying the quantization parameter for the macroblock of the reference layer representation, \nY\n–  when ChromaArrayType is not equal to 0, two variables tQP  and tQP  specifying chroma quantization parameters \nCb Cr\nfor the current macroblock, \n–  when  ChromaArrayType  is  not  equal  to 0,  two  variables  refQP   and  refQP   specifying  chroma  quantization \nCb Cr\nparameters for the macroblock of the reference layer representation, \nOutput of this process is a modified version of the list tCoeffLevel. \nTable G-6 specifies the scale values cS for transform coefficient level scaling. \nTable G-6 – Scale values cS for transform coefficient level scaling \n( refQP − cQP + 54 ) % 6  scale value cS \n0  8 \n1  9 \n2  10 \n3  11 \n4  13 \n5  14 \n \nThe variable iYCbCr proceeds over the values from 0 to ( ( ChromaArrayType  = =  0 )  ?  0  :  2), inclusive, and for each \nvalue of iYCbCr, the following ordered steps are specified: \n1.  The variables cO, iMax, cQP, and refQP are derived by \ncO       = ( ( iYCbCr  = =  0 )  ?           0  :  ( 256 + ( iYCbCr − 1 ) * MbWidthC * MbHeightC ) )  (G-167) \niMax   = ( ( iYCbCr  = =  0 )  ?       255  :  ( MbWidthC * MbHeightC − 1 ) )  (G-168) \ncQP     = ( ( iYCbCr  = =  0 )  ?     tQP   :  ( iYCbCr  = =  1  ?     tQP   :     tQP  ) )  (G-169) \nY Cb Cr\nrefQP  = ( ( iYCbCr  = =  0 )  ?  refQP   :  ( iYCbCr  = =  1  ?  refQP   :  refQP  ) )  (G-170) \nY Cb Cr\n2.  The variable cS is set as specified in Table G-6 using the values of refQP and cQP. \n3.  The variable rShift is calculated by \nrShift = ( refQP − cQP + 54 ) / 6  (G-171) \n4.  The list tCoeffLevel of transform coefficient level values is modified by \ntCoeffLevel[ cO + i ] = ( ( cS * tCoeffLevel[ cO + i ] ) << rShift ) >> 12     with i = 0..iMax  (G-172) \nThe following constraints shall be obeyed: \n    Rec. ITU-T H.264 (06/2019)  547 \n \na)  The bitstream shall not contain data that result in any element tCoeffLevel[ k ] with k = 0..255 that exceeds the \nrange of integer values from −2(7 + BitDepth ) to 2(7 + BitDepth ) − 1, inclusive. \nY Y\nb)  When ChromaArrayType is equal to 1 or 2, the bitstream shall not contain data that result in any element \ntCoeffLevel[ 256 + 16* b + k ]  with  b = 0..(MbWidthC * MbHeightC / 8 − 1),  and  k = 1..15  that  exceeds  the \nrange of integer values from −2(7 + BitDepth ) to 2(7 + BitDepth ) − 1, inclusive. \nC C\nNOTE 1  –  When  ChromaArrayType  is  equal  to 1  or 2  and  cTrafo  is  not  equal  to T_PCM,  the  elements \ntCoeffLevel[ 256 + 16* b ]  with  b = 0..(MbWidthC * MbHeightC / 8 − 1)  can  exceed  the  range  of  integer  values  from \n−2(7 + BitDepth ) to 2(7 + BitDepth ) − 1, inclusive. \nC C\nc)  When  ChromaArrayType  is  equal  to 3,  the  bitstream  shall  not  contain  data  that  result  in  any  element \ntCoeffLevel[ 256 + k ]  with  k = 0..511  that  exceeds  the  range  of  integer  values  from  −2(7 + BitDepth ) \nC\nto 2(7 + BitDepth ) − 1, inclusive. \nC\nNOTE 2 – When tQP  is less than 10 and cTrafo is equal to T_16x16, the range of values that can be represented by an \nY\nalternative representation of the bitstream with entropy_coding_mode_flag equal to 0 and profile_idc equal to 66, 77, \nor 88, may not be sufficient to represent the full range of values of the elements tCoeffLevel[ 16 * b ] with b = 0..15 \nthat could be necessary to form a close approximation of the content of any possible source picture. \nNOTE 3 – When ChromaArrayType is equal to 1 or 2 and tQP  with CX being replaced by Cb and Cr is less than 4, \nCX\nthe  range  of  values  that  can  be  represented  by  an  alternative  representation  of  the  bitstream  with \nentropy_coding_mode_flag equal to 0 and profile_idc equal to 66, 77, or 88, may not be sufficient to represent the full \nrange of values of the elements tCoeffLevel[ 256 + 16 * b ] with b = 0..(MbWidthC * MbHeightC / 8 − 1) that could \nbe necessary to form a close approximation of the content of any possible source picture. \nG.8.5.3  Residual construction and accumulation process \nInputs to this process are: \n–  a variable accumulationFlag specifying whether the constructed residual sample values for the current macroblock \nare combined with the existent residual sample value for the macroblock, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable cTrafo specifying the transform type, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements, \n–  a (PicWidthInSamples )x(PicHeightInSamples ) array picRes  containing residual luma sample values for the current \nL L L\nlayer representation, \n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays picRes  and \nC C Cb\npicRes  containing residual chroma sample values for the current layer representation. \nCr\nOutputs of this process are: \n–  a modified version of the array picRes , \nL\n–  when ChromaArrayType is not equal to 0, modified versions of the arrays picRes  and picRes . \nCb Cr\nThe construction process for luma residuals as specified in clause G.8.5.3.1 is invoked with cTrafo and sTCoeff as the \ninputs and the outputs are residual luma sample values as a 16x16 array mbRes . \nL\nWhen ChromaArrayType is not equal to 0, the construction process for chroma residuals as specified in clause G.8.5.3.2 \nis  invoked  with  cTrafo  and  sTCoeff  as  the  inputs  and  the  outputs  are  residual  chroma  sample  values  as  two \n(MbWidthC)x(MbHeightC) arrays mbRes  and mbRes . \nCb Cr\nWhen accumulationFlag is equal to 1, the following ordered steps are specified: \n1.  The macroblock sample array extraction process as specified in clause G.8.5.4.2 is invoked with fieldMbFlag, \npicRes , and, when ChromaArrayType is equal to 0, picRes  and picRes  as the inputs and the outputs are a \nL Cb Cr\n16x16 array refLayerMbRes  and, when ChromaArrayType is not equal to 0, two (MbWidthC)x(MbHeightC) \nL\narrays refLayerMbRes  and refLayerMbRes . \nCb Cr\n2.  All elements mbRes [ x, y ] of the 16x16 array mbRes  with x, y = 0..15 are modified by \nL L\nmbRes [ x, y ] = Clip3( yMin, yMax, mbRes [ x, y ] + refLayerMbRes [ x, y ] )  (G-173) \nL L L\nwith \nyMin = − ( 1 << BitDepth  ) + 1  (G-174) \nY\nyMax =   ( 1 << BitDepth  ) − 1  (G-175) \nY\n548  Rec. ITU-T H.264 (06/2019) \n \n3.  When ChromaArrayType is not equal to 0, for CX being replaced by Cb and Cr, all elements mbRes [ x, y ] of \nCX\nthe (MbWidthC)x(MbHeightC) array  mbRes  with x = 0..(MbWidthC − 1) and y = 0..(MbHeightC − 1) are \nCX\nmodified by \nmbRes [ x, y ] = Clip3( cMin, cMax, mbRes [ x, y ] + refLayerMbRes [ x, y ] )  (G-176) \nCX CX CX\nwith \ncMin = − ( 1 << BitDepth  ) + 1  (G-177) \nC\ncMax =   ( 1 << BitDepth  ) − 1  (G-178) \nC\nThe picture sample array construction process as specified in clause G.8.5.4.1 is invoked with fieldMbFlag, mbRes , \nL\npicRes , and, when ChromaArrayType is not equal to 0, mbRes , mbRes , picRes , and picRes  as the inputs and the \nL Cb Cr Cb Cr\noutputs are a modified version of the array picRes  and, when ChromaArrayType is not equal to 0, modified versions of \nL\nthe arrays picRes  and picRes . \nCb Cr\nG.8.5.3.1  Construction process for luma residuals or chroma residuals with ChromaArrayType equal to 3 \nInputs to this process are: \n–  a variable iYCbCr specifying the colour component (when present), \n–  a variable cTrafo specifying the transform type, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements. \nOutputs of this process are residual sample values as a 16x16 array mbRes with elements mbRes[ x, y ]. \nWhen iYCbCr is not present as input to this clause, it is inferred to be equal to 0. \nDepending on iYCbCr, the variables bitDepth and cO are derived as follows: \n–  If iYCbCr is equal to 0, bitDepth is set equal to BitDepth  and cO is set equal to 0. \nY\n–  Otherwise, if iYCbCr is equal to 1, bitDepth is set equal to BitDepth  and cO is set equal to 256. \nC\n–  Otherwise  (iYCbCr  is  equal  to 2),  bitDepth  is  set  equal  to  BitDepth   and  cO  is  set  equal  to \nC\n(256 + MbWidthC * MbHeightC). \nDepending on cTrafo, the 16x16 array mbRes is derived as follows: \n–  If cTrafo is equal to T_PCM, the construction process for luma residuals or chroma residuals with ChromaArrayType \nequal to 3 of I_PCM macroblocks as specified in clause G.8.5.3.1.1 is invoked with cO  and sTCoeff as the inputs \nand the output is the 16x16 array mbRes of residual sample values. \n–  Otherwise,  if  cTrafo  is  equal  to  T_4x4,  the  construction  process  for  residual  4x4  blocks  as  specified  in \nclause G.8.5.3.1.2 is invoked with bitDepth, cO, and sTCoeff as the inputs and the output is the 16x16 array mbRes \nof residual sample values. \n–  Otherwise,  if  cTrafo  is  equal  to  T_8x8,  the  construction  process  for  residual  8x8  blocks  as  specified  in \nclause G.8.5.3.1.3 is invoked with bitDepth, cO, and sTCoeff as the inputs and the output is the 16x16 array mbRes \nof residual sample values. \n–  Otherwise (cTrafo is equal to T_16x16), the construction process for residuals of Intra_16x16 macroblocks as \nspecified in clause G.8.5.3.1.4 is invoked with bitDepth, cO, and sTCoeff as the inputs and the output is the 16x16 \narray mbRes of residual sample values. \nG.8.5.3.1.1  Construction process for luma residuals or chroma residuals with ChromaArrayType equal to 3 of \nI_PCM macroblocks \nInputs to this process are: \n–  a variable cO specifying the first coefficient index in the list of scaled transform coefficient values sTCoeff, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements. \nOutputs of this process are residual sample values as a 16x16 array mbRes with elements mbRes[ x, y ]. \nThe 16x16 array mbRes is derived by: \nmbRes[ x, y ] = sTCoeff[ cO + y * 16 + x ]      with x, y = 0..15  (G-179) \nG.8.5.3.1.2  Construction process for residual 4x4 blocks \nInputs to this process are: \n    Rec. ITU-T H.264 (06/2019)  549 \n \n–  a variable bitDepth specifying the bit depth, \n–  a variable cO specifying the first coefficient index in the list of scaled transform coefficient values sTCoeff, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements. \nOutputs of this process are residual sample values as a 16x16 array mbRes with elements mbRes[ x, y ]. \nFor each residual 4x4 block indexed by c4x4BlkIdx = 0..15, the following ordered steps are specified: \n1.  The 4x4 array d with elements d  is derived by: \nij\nd  = sTCoeff[ cO + 16 * c4x4BlkIdx + 4 * i + j ]          with i, j = 0..3  (G-180) \nij\n2.  The transformation process for residual 4x4 blocks as specified in clause 8.5.12.2 is invoked with bitDepth and \nthe 4x4 array d as the inputs and the outputs are residual sample value as a 4x4 array r with elements r . \nij\n3.  The inverse 4x4 luma block scanning process as specified in clause 6.4.3 is invoked with c4x4BlkIdx as the input \nand the output is assigned to ( xP, yP ). \n4.  The elements mbRes[ x, y ] of the 16x16 array mbRes with x = xP..(xP + 3) and y = yP..(yP + 3) are derived by \nmbRes[ xP + j, yP + i ] = r           with i, j = 0..3  (G-181) \nij\nG.8.5.3.1.3  Construction process for residual 8x8 blocks \nInputs to this process are: \n–  a variable bitDepth specifying the bit depth, \n–  a variable cO specifying the first coefficient index in the list of scaled transform coefficient values sTCoeff, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements. \nOutputs of this process are residual sample values as a 16x16 array mbRes with elements mbRes[ x, y ]. \nFor each residual 8x8 block indexed by c8x8BlkIdx = 0..3, the following ordered steps are specified: \n1.  The 8x8 array d with elements d  is derived by: \nij\nd  = sTCoeff[ cO + 64 * c8x8BlkIdx + 8 * i + j ]          with i, j = 0..7  (G-182) \nij\n2.  The transformation process for residual 8x8 blocks as specified in clause 8.5.13.2 is invoked with bitDepth and \nthe 8x8 array d as the inputs and the outputs are residual sample values as an 8x8 array r with elements r . \nij\n3.  The inverse 8x8 luma block scanning process as specified in clause 6.4.5 is invoked with c8x8BlkIdx as the input \nand the output is assigned to ( xP, yP ). \n4.  The elements mbRes[ x, y ] of the 16x16 array mbRes with x = xP..(xP + 7) and y = yP..(yP + 7) are derived by \nmbRes[ xP + j, yP + i ] = r           with i, j = 0..7  (G-183) \nij\nG.8.5.3.1.4  Construction process for residuals of Intra_16x16 macroblocks \nInputs to this process are: \n–  a variable bitDepth specifying the bit depth, \n–  a variable cO specifying the first coefficient index in the list of scaled transform coefficient values sTCoeff, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements. \nOutputs of this process are residual sample values as a 16x16 array mbRes with elements mbRes[ x, y ]. \nFor each residual 4x4 block indexed by c4x4BlkIdx = 0..15, the following ordered steps are specified: \n1.  The 4x4 array d with elements d  is derived by: \nij\nd  = sTCoeff[ cO + 16 * c4x4BlkIdx + 4 * i + j ]       with i, j = 0..3  (G-184) \nij\n2.  The transformation process for residual 4x4 blocks as specified in clause 8.5.12.2 is invoked with bitDepth and \nthe 4x4 array d as the inputs and the outputs are residual sample values as a 4x4 array r with elements r . \nij\n3.  The inverse 4x4 luma block scanning process as specified in clause 6.4.3 is invoked with c4x4BlkIdx as the input \nand the output is assigned to ( xP, yP ). \n4.  The elements mbRes[ x, y ] of the 16x16 array mbRes with x = xP..(xP + 3) and y = yP..(yP + 3) are derived by \n550  Rec. ITU-T H.264 (06/2019) \n \nmbRes[ xP + j, yP + i ] = r           with i, j = 0..3  (G-185) \nij\nG.8.5.3.2  Construction process for chroma residuals \nInputs to this process are: \n–  a variable cTrafo specifying the transform type, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements. \nOutputs of this process are residual chroma sample values as two (MbWidthC)x(MbHeightC) arrays mbRes  and mbRes  \nCb Cr\nwith elements mbRes [ x, y ] and mbRes [ x, y ], respectively. \nCb Cr\nFor both chroma components indexed by iCbCr = 0..1 and for CX being replaced by Cb for iCbCr equal to 0 and Cr for \niCbCr equal to 1, the following applies: \n–  If ChromaArrayType is equal to 1 or 2, the following applies: \n–  If cTrafo is equal to T_PCM, the construction process for chroma residuals of I_PCM macroblocks as specified \nin  clause G.8.5.3.2.1  is  invoked  with  iCbCr  and  sTCoeff  as  the  inputs  and  the  output  is  the \n(MbWidthC)x(MbHeightC) array mbRes  of residual chroma sample values. \nCX\n–  Otherwise  (cTrafo  is  not  equal  to  T_PCM),  the  construction  process  for  chroma  residuals  with \nChromaArrayType equal to 1 or 2 as specified in clause G.8.5.3.2.2 is invoked with iCbCr and sTCoeff as the \ninputs and the output is the (MbWidthC)x(MbHeightC) array mbRes  of residual chroma sample values. \nCX\n–  Otherwise (ChromaArrayType is equal to 3), the construction process for luma residuals or chroma residuals with \nChromaArrayType equal to 3 as specified in clause G.8.5.3.1 is invoked with iYCbCr set equal to (1 + iCbCr), cTrafo, \nand sTCoeff as the inputs and the output is the (MbWidthC)x(MbHeightC) array mbRes  of residual chroma sample \nCX\nvalues. \nG.8.5.3.2.1  Construction process for chroma residuals of I_PCM macroblocks \nInputs to this process are: \n–  a variable iCbCr specifying the chroma component, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements. \nOutputs of this process are residual chroma sample values as a (MbWidthC)x(MbHeightC) array mbRes with elements \nmbRes[ x, y ]. \nThe (MbWidthC)x(MbHeightC) array mbRes is derived by \nmbRes[ x, y ] = sTCoeff[ 256 + iCbCr * MbWidthC * MbHeightC + y * MbWidthC + x ] \n     (G-186) \n                                                                           with x = 0..(MbWidthC − 1)  and  y = 0..(MbHeightC − 1) \nG.8.5.3.2.2  Construction process for chroma residuals with ChromaArrayType equal to 1 or 2 \nThis process is only invoked when ChromaArrayType is equal to 1 or 2. \nInputs to this process are: \n–  a variable iCbCr specifying the chroma component, \n–  a list of scaled transform coefficient values sTCoeff with (256 + 2 * MbWidthC * MbHeightC) elements. \nOutputs of this process are residual chroma sample values as a (MbWidthC)x(MbHeightC) array mbRes with elements \nmbRes[ x, y ]. \nThe variables nW, nH, numB, and cO are derived by \nnW    = MbWidthC / 4  (G-187) \nnH     = MbHeightC / 4  (G-188) \nnumB = nW * nH  (G-189) \ncO      = 256 + ( iCbCr * MbWidthC * MbHeightC )  (G-190) \nFor the chroma DC transform coefficients of all residual 4x4 chroma blocks, the following ordered steps are specified: \n1.  The (nW)x(nH) array c with the elements c  is derived by \nij\nc  = sTCoeff[ cO + 32 * i + 16 * j ]          with i = 0..(nH − 1),  j = 0..(nW − 1)  (G-191) \nij\n    Rec. ITU-T H.264 (06/2019)  551 \n \n2.  The transformation process for chroma DC transform coefficients as specified in clause 8.5.11.1 is invoked with \nBitDepth  and the (nW)x(nH) array c as the inputs and the outputs are DC values for all residual 4x4 chroma \nC\nblocks as a (nW)x(nH) array f with elements f . \nij\n3.  Depending on ChromaArrayType, the (nW)x(nH) array dcC with elements dcC  is derived as follows: \nij\n–  If ChromaArrayType is equal to 1, \ndcC  = f  >> 5                                            with i = 0..(nH − 1),  j = 0..(nW − 1)  (G-192) \nij ij\n–  Otherwise (ChromaArrayType is equal to 2), \ndcC  = ( f  + ( 1 << 5 ) ) >> 6                    with i = 0..(nH − 1),  j = 0..(nW − 1)  (G-193) \nij ij\nThe  bitstream  shall  not  contain  data  that  result  in  any  element  dcC   of  dcC  with  i = 0..(nH − 1)  and \nij\nj = 0..(nW − 1) that exceeds the range of integer values from −2(7 + BitDepthC) to 2(7 + BitDepthC) − 1, inclusive. \nNOTE – For the layer representation with dependency_id equal to 0 and quality_id equal to 0, successive invocations \nof clause G.8.5.1.2 (as part of an invocation of clause G.8.5.1) and this clause yield an array dcC that is identical to the \narray dcC that would be obtained by an invocation of clause 8.5.11. However, the intermediate values c  and f  with \nij ij\ni = 0..(nH − 1)  and  j = 0..(nW − 1)  that  are  derived  in  this  clause  can  exceed  the  range  of  integer  values  from \n−2(7 + BitDepth\nC\n) to 2(7 + BitDepth\nC\n) − 1, inclusive. \nFor each residual 4x4 chroma block indexed by c4x4BlkIdx = 0..(numB − 1), the following ordered steps are specified. \n1.  The 4x4 array d with elements d  is derived as follows: \nij\n–  The element d  is derived by: \n00\nd  = dcC      with k = c4x4BlkIdx / 2  and  l = c4x4BlkIdx % 2  (G-194) \n00 kl\n–  The elements d  with i, j = 0..3 and i + j > 0 are derived by: \nij\nd  = sTCoeff[ cO + 16 * c4x4BlkIdx + 4 * i + j ]  (G-195) \nij\n2.  The transformation process for residual 4x4 blocks as specified in clause 8.5.12.2 is invoked with BitDepth  and \nC\nthe 4x4 array d as the inputs and the outputs are residual chroma sample values as a 4x4 array r with elements r . \nij\n3.  The chroma location ( xP, yP ) is derived by: \nxP = 4 * ( c4x4BlkIdx % 2 )  (G-196) \nyP = 4 * ( c4x4BlkIdx  /  2 )  (G-197) \n4.  The  elements  mbRes[ x, y ]  of  the  (MbWidthC)x(MbHeightC)  array  mbRes  with  x = xP..(xP + 3)  and \ny = yP..(yP + 3) are derived by: \nmbRes[ xP + j, yP + i ] = r           with i, j = 0..3  (G-198) \nij\nG.8.5.4  Sample array accumulation process \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a (PicWidthInSamples )x(PicHeightInSamples ) array picRes  containing residual luma sample values for the current \nL L L\nlayer representation, \n–  a (PicWidthInSamples )x(PicHeightInSamples ) array picSamples  containing constructed luma sample values for \nL L L\nthe current layer representation, \n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays picRes  and \nC C Cb\npicRes  containing residual chroma sample values for the current layer representation, \nCr\n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays picSamples  \nC C Cb\nand picSamples  containing constructed chroma sample values for the current layer representation. \nCr\nOutputs of this process are: \n–  a modified version of the array picSamples , \nL\n–  when ChromaArrayType is not equal to 0, modified versions of the arrays picSamples  and picSamples . \nCb Cr\nThe macroblock sample array extraction process as specified in clause G.8.5.4.2 is invoked with fieldMbFlag, picRes , \nL\nand, when ChromaArrayType is not equal to 0, picRes  and picRes  as the inputs and the outputs are assigned to mbRes  \nCb Cr L\nand, when ChromaArrayType is not equal to 0, mbRes  and mbRes . \nCb Cr\n552  Rec. ITU-T H.264 (06/2019) \n \nThe  macroblock  sample  array  extraction  process  as  specified  in  clause G.8.5.4.2  is  invoked  with  fieldMbFlag, \npicSamples , and, when ChromaArrayType is not equal to 0, picSamples  and picSamples  as the inputs and the outputs \nL Cb Cr\nare assigned to mbPred  and, when ChromaArrayType is not equal to 0, mbPred  and mbPred . \nL Cb Cr\nThe 16x16 array mbSamples  is derived by: \nL\nmbSamples [ x, y ] = Clip1 ( mbPred [ x, y ] + mbRes [ x, y ] )              with x, y = 0..15  (G-199) \nL Y L L\nWhen ChromaArrayType is not equal to 0, for CX being replaced by Cb and Cr, the (MbWidthC)x(MbHeightC) array \nmbSamples  is derived by: \nCX\nmbSamples [ x, y ] = Clip1 ( mbPred [ x, y ] + mbRes [ x, y ] )        with x = 0..(MbWidthC − 1) \nCX C CX CX\n                                                                                                                     and  y = 0..(MbHeightC − 1)  (G-200) \nThe picture sample array construction process as specified in clause G.8.5.4.1 is invoked with fieldMbFlag, mbSamples , \nL\npicSamples , and, when ChromaArrayType is not equal to 0, mbSamples , mbSamples , picSamples , and picSamples  \nL Cb Cr Cb Cr\nas inputs and the outputs are a modified version of picSamples  and, when ChromaArrayType is not equal to 0, modified \nL\nversions of picSamples  and picSamples . \nCb Cr\nG.8.5.4.1  Picture sample array construction process \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a 16x16 array mbArray  containing luma sample values for the current macroblock, \nL\n–  a (PicWidthInSamples )x(PicWidthInHeight ) array picArray  containing luma sample values for the current layer \nL L L\nrepresentation, \n–  when  ChromaArrayType  is  not  equal  to 0,  two  (MbWidthC)x(MbHeightC)  arrays  mbArray   and  mbArray  \nCb Cr\ncontaining chroma sample values for the current macroblock, \n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays picArray  and \nC C Cb\npicArray  containing chroma sample values for the current layer representation. \nCr\nOutputs of this process are: \n–  a modified version of the array picArray , \nL\n–  when ChromaArrayType is not equal to 0, modified versions of the arrays picArray  and picArray . \nCb Cr\nThe picture sample array construction process for a colour component as specified in clause G.8.5.4.3 is invoked with \nfieldMbFlag, mbW set equal to 16, mbH set equal to 16, mbArray , and picArray  as the inputs and the output is a modified \nL L\nversion of the array picArray . \nL\nWhen ChromaArrayType is not equal to 0, for CX being replaced with Cr and Cb, the picture sample array construction \nprocess for a colour component as specified in clause G.8.5.4.3 is invoked with fieldMbFlag, mbW set equal to MbWidthC, \nmbH set equal to MbHeightC, mbArray , and picArray  as the inputs and the output is a modified version of the array \nCX CX\npicArray . \nCX\nG.8.5.4.2  Macroblock sample array extraction process \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a (PicWidthInSamples )x(PicWidthInHeight ) array picArray  containing luma sample values for the current layer \nL L L\nrepresentation, \n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays picArray  and \nC C Cb\npicArray  containing chroma sample values for the current layer representation. \nCr\nOutputs of this process are: \n–  a 16x16 array mbArray  containing luma sample values for the current macroblock, \nL\n–  when  ChromaArrayType  is  not  equal  to 0,  two  (MbWidthC)x(MbHeightC)  arrays  mbArray   and  mbArray  \nCb Cr\ncontaining chroma sample values for the current macroblock. \nThe macroblock sample array extraction process for a colour component as specified in clause G.8.5.4.4 is invoked with \nfieldMbFlag, mbW set equal to 16, mbH set equal to 16, and picArray  as the inputs and the output is assigned to mbArray . \nL L\n    Rec. ITU-T H.264 (06/2019)  553 \n \nWhen ChromaArrayType is not equal to 0, for CX being replaced with Cr and Cb, the macroblock sample array extraction \nprocess for a colour component as specified in clause G.8.5.4.4 is invoked with fieldMbFlag, mbW set equal to MbWidthC, \nmbH set equal to MbHeightC, and picArray  as the inputs and the output is assigned to mbArray . \nCX CX\nG.8.5.4.3  Picture sample array construction process for a colour component \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable mbW specifying the width of a macroblock colour component in samples, \n–  a variable mbH specifying the height of a macroblock colour component in samples, \n–  an (mbW)x(mbH) array mbArray containing sample values for a colour component of the current macroblock, \n–  an  (mbW * PicWidthInMbs)x(mbH * PicHeightInMbs)  array  picArray  containing  sample  values  for  a  colour \ncomponent of the current layer representation. \nOutput of this process is a modified version of the array picArray. \nThe inverse macroblock scanning process as specified in clause 6.4.1 is invoked with CurrMbAddr as the input and the \noutput is assigned to ( xO, yO ). During the process in clause 6.4.1, the current macroblock is treated as field macroblock \nwhen fieldMbFlag is equal to 1, and it is treated as frame macroblock when fieldMbFlag is equal to 0. \nThe sample location ( xP, yP ) is derived by: \nxP =   ( xO >> 4 ) * mbW  (G-201) \nyP = ( ( yO >> 4 ) * mbH ) + ( yO % 2 )  (G-202) \nDepending on the variables MbaffFrameFlag and fieldMbFlag, the array picArray is modified as follows: \n–  If MbaffFrameFlag is equal to 1 and fieldMbFlag is equal to 1, \npicArray[ xP + x, yP + 2 * y ] = mbArray[ x, y ]          with x = 0..(mbW − 1),  y = 0..(mbH − 1)  (G-203) \n–  Otherwise (MbaffFrameFlag is equal to 0 or fieldMbFlag is equal to 0), \npicArray[ xP + x, yP + y ] = mbArray[ x, y ]                with x = 0..(mbW − 1),  y = 0..(mbH − 1)  (G-204) \nG.8.5.4.4  Macroblock sample array extraction process for a colour component \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable mbW specifying the width of a macroblock colour component in samples, \n–  a variable mbH specifying the height of a macroblock colour component in samples, \n–  an  (mbW * PicWidthInMbs)x(mbH * PicHeightInMbs)  array  picArray  containing  sample  values  for  a  colour \ncomponent of the current layer representation. \nOutput of this process is an (mbW)x(mbH) array mbArray containing sample values for a colour component of the current \nmacroblock. \nThe inverse macroblock scanning process as specified in clause 6.4.1 is invoked with CurrMbAddr as the input and the \noutput is assigned to ( xO, yO ). During the process in clause 6.4.1, the current macroblock is treated as field macroblock \nwhen fieldMbFlag is equal to 1, and it is treated as frame macroblock when fieldMbFlag is equal to 0. \nThe sample location ( xP, yP ) is derived by: \nxP =   ( xO >> 4 ) * mbW  (G-205) \nyP = ( ( yO >> 4 ) * mbH ) + ( yO % 2 )  (G-206) \nDepending on the variables MbaffFrameFlag and fieldMbFlag, the samples of the array mbArray are derived as follows: \n–  If MbaffFrameFlag is equal to 1 and fieldMbFlag is equal to 1, \nmbArray[ x, y ] = picArray[ xP + x, yP + 2 * y ]          with x = 0..(mbW − 1),  y = 0..(mbH − 1)  (G-207) \n–  Otherwise (MbaffFrameFlag is equal to 0 or fieldMbFlag is equal to 0), \nmbArray[ x, y ] = picArray[ xP + x, yP + y ]                with x = 0..(mbW − 1),  y = 0..(mbH − 1)  (G-208) \n554  Rec. ITU-T H.264 (06/2019) \n \nG.8.5.5  Sample array re-initialization process \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a (PicWidthInSamples )x(PicHeightInSamples ) array picSamples  containing luma sample values for the current \nL L L\nlayer representation, \n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays picSamples  \nC C Cb\nand picSamples  containing chroma sample values for the current layer representation. \nCr\nOutputs of this process are: \n–  a modified version of the array picSamples , \nL\n–  when ChromaArrayType is not equal to 0, modified versions of the arrays picSamples  and picSamples . \nCb Cr\nThe 16x16 array mbSamples  is derived by: \nL\nmbSamples [ x, y ] = 0              with x, y = 0..15  (G-209) \nL\nWhen ChromaArrayType is not equal to 0, for CX being replaced by Cb and Cr, the (MbWidthC)x(MbHeightC) array \nmbSamples  is derived by: \nCX\nmbSamples [ x, y ] = 0            with x = 0..(MbWidthC − 1)  and  y = 0..(MbHeightC − 1)  (G-210) \nCX\nThe picture sample array construction process as specified in clause G.8.5.4.1 is invoked with fieldMbFlag, mbSamples , \nL\npicSamples , and, when ChromaArrayType is not equal to 0, mbSamples , mbSamples , picSamples , and picSamples  \nL Cb Cr Cb Cr\nas inputs and the outputs are a modified version of picSamples  and, when ChromaArrayType is not equal to 0, modified \nL\nversions of picSamples  and picSamples . \nCb Cr\nG.8.6  Resampling processes for prediction data, intra samples, and residual samples \nClause G.8.6.1 specifies the  derivation process  for inter-layer predictors for  macroblock type, sub-macroblock type, \nreferences indices, and motion vectors. \nClause G.8.6.2 specifies the resampling process for intra samples. \nClause G.8.6.3 specifies the resampling process for residual samples. \nG.8.6.1  Derivation process for inter-layer predictors for macroblock type, sub-macroblock type, reference indices, \nand motion vectors \nThis process is only invoked when base_mode_flag is equal to 1 or any motion_prediction_flag_lX[ mbPartIdx ] with X \nbeing replaced by 0 and 1 and mbPartIdx = 0..3 is equal to 1. \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  a one-dimensional array refLayerMbType with RefLayerPicSizeInMbs elements specifying the macroblock types for \nthe macroblocks of the reference layer representation, \n–  a (RefLayerPicSizeInMbs)x4 array refLayerSubMbType specifying the sub-macroblock types for the macroblocks of \nthe reference layer representation, \n–  two (RefLayerPicSizeInMbs)x4 arrays refLayerPredFlagL0 and refLayerPredFlagL1 specifying prediction utilization \nflags for the macroblocks of the reference layer representation, \n–  two (RefLayerPicSizeInMbs)x4 arrays refLayerRefIdxL0 and refLayerRefIdxL1 specifying reference indices for the \nmacroblocks of the reference layer representation, \n–  two (RefLayerPicSizeInMbs)x4x4x2 arrays refLayerMvL0 and refLayerMvL1 specifying motion vector components \nfor the macroblocks of the reference layer representation, \n–  when CroppingChangeFlag is equal to 1 and (slice_type % 5) is less than 2, the reference picture list refPicList0, \n–  when CroppingChangeFlag is equal to 1 and (slice_type % 5) is equal to 1, the reference picture list refPicList1. \n    Rec. ITU-T H.264 (06/2019)  555 \n \nOutputs of this process are: \n–  a variable mbTypeILPred specifying a predictor for the macroblock type of the current macroblock, \n–  a list subMbTypeILPred with 4 elements specifying predictors for sub-macroblock types of the current macroblock, \n–  two 2x2 arrays refIdxILPredL0 and refIdxILPredL1 specifying inter-layer predictors for the reference indices of the \ncurrent macroblock, \n–  two 4x4x2 arrays mvILPredL0 and mvILPredL1 specifying inter-layer predictors for the motion vector components \nof the current macroblock. \nThe  derivation  process  for  reference  layer  partition  identifications  as  specified  in  clause G.8.6.1.1  is  invoked  with \nfieldMbFlag, refLayerFieldMbFlag, refLayerMbType, and refLayerSubMbType as the inputs and the outputs are a variable \nintraILPredFlag  and,  when  intraILPredFlag  is  equal  to 0,  reference  layer  partition  identifications  as  a  4x4  array \nrefLayerPartIdc with elements refLayerPartIdc[ x, y ]. \nWhen slice_type is equal to EI, the bitstream shall not contain data that result in intraILPredFlag equal to 0. \nDepending on intraILPredFlag, the 2x2 arrays refIdxILPredL0 and refIdxILPredL1 and the 4x4x2 array mvILPredL0 and \nmvILPredL1 are derived as follows: \n–  If intraILPredFlag is equal to 1, all elements of the 2x2 arrays refIdxILPredL0 and refIdxILPredL1 are set equal to −1 \nand all elements of the 4x4x2 arrays mvILPredL0 and mvILPredL1 are set equal to 0. \n–  Otherwise (intraILPredFlag is equal to 0), the derivation process for inter-layer predictors for reference indices and \nmotion  vectors  as  specified  in  clause G.8.6.1.2  is  invoked  with  fieldMbFlag,  refLayerFieldMbFlag, \nrefLayerPredFlagL0,  refLayerPredFlagL1,  refLayerRefIdxL0,  refLayerRefIdxL1,  refLayerMvL0,  refLayerMvL1, \nrefLayerPartIdc, refPicList0 (when available), and refPicList1 (when available) as the inputs and the outputs are the \narrays refIdxILPredL0, refIdxILPredL1, mvILPredL0, and mvILPredL1. \nDepending on intraILPredFlag, the variable mbTypeILPred and the list subMbTypeILPred are derived as follows: \n–  If intraILPredFlag is equal to 1, all elements subMbTypeILPred[ mbPartIdx ] of the list subMbTypeILPred with \nmbPartIdx = 0..3 are marked as unspecified, and the variable mbTypeILPred is derived as follows: \n–  If tcoeff_level_prediction_flag is equal to 1, mbTypeILPred is set equal to refLayerMbType[ CurrMbAddr ]. \n–  Otherwise (tcoeff_level_prediction_flag is equal to 0), mbTypeILPred is set equal to I_BL. \n–  Otherwise (intraILPredFlag is equal to 0), the derivation process for inter-layer predictors for P and B macroblock \nand  sub-macroblock  types  as  specified  in  clause G.8.6.1.3  is  invoked  with  refIdxILPredL0,  refIdxILPredL1, \nmvILPredL0,  and  mvILPredL1  as  the  inputs  and  the  outputs  are  the  variable  mbTypeILPred  and  the  list \nsubMbTypeILPred. \nG.8.6.1.1  Derivation process for reference layer partition identifications \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  a one-dimensional array refLayerMbType with RefLayerPicSizeInMbs elements specifying the macroblock types for \nthe macroblocks of the reference layer representation, \n–  a (RefLayerPicSizeInMbs)x4 array refLayerSubMbType specifying the sub-macroblock types for the macroblocks of \nthe reference layer representation. \nOutputs of this process are: \n–  a  variable  intraILPredFlag  specifying  whether  the  samples  of  the  current  macroblock  in  the  current  layer \nrepresentation can be predicted by inter-layer intra prediction or, in the case of tcoeff_level_prediction_flag equal \nto 1, by a combination of intra-layer intra prediction and inter-layer prediction, \n–  when intraILPredFlag is equal to 0, reference layer partition identifications for the current macroblock as a 4x4 array \nrefLayerPartIdc with elements refLayerPartIdc[ x, y ]. \nWhen the 4x4 array refLayerPartIdc is output of this process, each of its elements refLayerPartIdc[ x, y ] specifies the \nmacroblock address, the  macroblock partition index, and the  sub-macroblock partition index of  the partition in  the \nreference layer representation that can be used for inter-layer motion prediction of the macroblock or sub-macroblock \npartition of the current macroblock that contains the 4x4 block with coordinates x and y. \n556  Rec. ITU-T H.264 (06/2019) \n \nFor each 4x4 block with block coordinates x, y = 0..3, the element refLayerPartIdc[ x, y ] of the 4x4 array refLayerPartIdc \nis derived by applying the following ordered steps: \n1.  The derivation process for reference layer partitions as specified in clause G.6.2 is invoked with the luma location \n( 4 * x + 1, 4 * y + 1 ), fieldMbFlag, refLayerFieldMbFlag, refLayerMbType, and refLayerSubMbType as the \ninputs and the outputs are a macroblock address refMbAddr, a macroblock partition index refMbPartIdx, and a \nsub-macroblock partition index refSubMbPartIdx of a partition in the reference layer representation. \n2.  The element refLayerPartIdc[ x, y ] of the array refLayerPartIdc is derived as follows: \n–  If  refLayerMbType[ refMbAddr ]  is  equal  to  I_PCM,  I_16x16,  I_8x8,  I_4x4,  or  I_BL, \nrefLayerPartIdc[ x, y ] is set equal to −1. \n–  Otherwise  (refLayerMbType[ refMbAddr ]  is  not  equal  to  I_PCM,  I_16x16,  I_8x8,  I_4x4,  or  I_BL), \nrefLayerPartIdc[ x, y ] is derived by \nrefLayerPartIdc[ x, y ] = 16 * refMbAddr + 4 * refMbPartIdx + refSubMbPartIdx  (G-211) \nThe variable intraILPredFlag is derived as follows: \n–  If all elements refLayerPartIdc[ x, y ] with x, y = 0..3 are equal to −1, intraILPredFlag is set equal to 1. \n–  Otherwise (any element refLayerPartIdc[ x, y ] with x, y = 0..3 is not equal to −1), intraILPredFlag is set equal to 0. \nWhen intraILPredFlag is equal to 0 and RestrictedSpatialResolutionChangeFlag is equal to 0, the 4x4 array refLayerPartIdc \nis modified by the following ordered steps: \n1.  For each 8x8 block with block coordinates xP, yP = 0..1, the following ordered steps are specified. \na.  The variables xO and yO are set equal to (2 * xP) and (2 * yP), respectively. \nb.  All elements procI4x4Blk[ xS, yS ] of the 2x2 array procI4x4Blk with xS, yS = 0..1 are set equal to 0. \nc.  The 4x4 blocks of the current 8x8 block with block coordinates xS, yS = 0..1 are processed in increasing \norder of (2 * yS + xS), and when refLayerPartIdc[ xO + xS, yO + yS ] is equal to −1 for a 4x4 block, the \nelement procI4x4Blk[ xS, yS ] of the array procI4x4Blk is set equal to 1 and the following applies: \n–  If procI4x4Blk[ 1 − xS, yS ] is equal to 0 and refLayerPartIdc[ xO + 1 − xS, yO + yS ] is not equal \nto −1, the element refLayerPartIdc[ xO + xS, yO + yS ] is modified by \nrefLayerPartIdc[ xO + xS, yO + yS ] = refLayerPartIdc[ xO + 1 − xS, yO + yS ]  (G-212) \n–  Otherwise, if procI4x4Blk[ xS, 1 − yS ] is equal to 0 and refLayerPartIdc[ xO + xS, yO + 1 − yS ] is not \nequal to −1, the element refLayerPartIdc[ xO + xS, yO + yS ] is modified by \nrefLayerPartIdc[ xO + xS, yO + yS ] = refLayerPartIdc[ xO + xS, yO + 1 − yS ]  (G-213) \n–  Otherwise,  if  procI4x4Blk[ 1 − xS, 1 − yS ]  is  equal  to  0  and  refLayerPartIdc[ xO + 1 − xS, \nyO + 1 − yS ] is not equal to −1, the element refLayerPartIdc[ xO + xS, yO + yS ] is modified by \nrefLayerPartIdc[ xO + xS, yO + yS ] = refLayerPartIdc[ xO + 1 − xS, yO + 1 − yS ]  (G-214) \n–  Otherwise, the element refLayerPartIdc[ xO + xS, yO + yS ] is not modified. \n2.  All elements procI8x8Blk[ xP, yP ] of the 2x2 array procI8x8Blk with xP, yP = 0..1 are set equal to 0. \n3.  The 8x8 blocks with block coordinates xP, yP = 0..1 are processed in increasing order of (2 * yP + xP), and when \nrefLayerPartIdc[ 2 * xP, 2 * yP ] is equal to −1 for an 8x8 block, the element procI8x8Blk[ xP, yP ] of the array \nprocI8x8Blk is set equal to 1 and the following applies: \n–  If  procI8x8Blk[ 1 − xP, yP ]  is  equal  to 0  and  refLayerPartIdc[ 2 − xP, 2 * yP ]  is  not  equal  to −1,  the \nelements refLayerPartIdc[ 2 * xP + xS, 2 * yP + yS ] with xS, yS = 0..1 are modified by \nrefLayerPartIdc[ 2 * xP + xS, 2 * yP + yS ] = refLayerPartIdc[ 2 − xP, 2 * yP + yS ]  (G-215) \n–  Otherwise, if procI8x8Blk[ xP, 1 − yP ] is equal to 0 and refLayerPartIdc[ 2 * xP, 2 − yP ] is not equal \nto −1, the elements refLayerPartIdc[ 2 * xP + xS, 2 * yP + yS ] with xS, yS = 0..1 are modified by \nrefLayerPartIdc[ 2 * xP + xS, 2 * yP + yS ] = refLayerPartIdc[ 2 * xP + xS, 2 − yP ]  (G-216) \n    Rec. ITU-T H.264 (06/2019)  557 \n \n–  Otherwise, if procI8x8Blk[ 1 − xP, 1 − yP ] is equal to 0 and refLayerPartIdc[ 2 − xP, 2 − yP ] is not equal \nto −1, the elements refLayerPartIdc[ 2 * xP + xS, 2 * yP + yS ] with xS, yS = 0..1 are modified by \nrefLayerPartIdc[ 2 * xP + xS, 2 * yP + yS ] = refLayerPartIdc[ 2 − xP, 2 − yP ]  (G-217) \n–  Otherwise, the elements refLayerPartIdc[ 2 * xP + xS, 2 * yP + yS ] with xS, yS = 0..1 are not modified. \nNOTE – By the process specified above the elements refLayerPartIdc[ x, y ] that are equal to −1 are replaced by elements \nrefLayerPartIdc[ x, y ] that are not equal to −1. This process can also be applied when RestrictedSpatialResolutionChangeFlag is \nequal to 1 or intraILPredFlag is equal to 1, but in this case, the 4x4 array refLayerPartIdc is not modified. \nG.8.6.1.2  Derivation process for inter-layer predictors for reference indices and motion vectors \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  two (RefLayerPicSizeInMbs)x4 arrays refLayerPredFlagL0 and refLayerPredFlagL1 specifying prediction utilization \nflags for the macroblocks of the reference layer representation, \n–  two (RefLayerPicSizeInMbs)x4 arrays refLayerRefIdxL0 and refLayerRefIdxL1 specifying reference indices for the \nmacroblocks of the reference layer representation, \n–  two (RefLayerPicSizeInMbs)x4x4x2 arrays refLayerMvL0 and refLayerMvL1 specifying motion vector components \nfor the macroblocks of the reference layer representation, \n–  a 4x4 array refLayerPartIdc specifying reference layer partition identifications for the 4x4 blocks of the current \nmacroblock, \n–  when CroppingChangeFlag is equal to 1 and (slice_type % 5) is less than 2, the reference picture list refPicList0, \n–  when CroppingChangeFlag is equal to 1 and (slice_type % 5) is equal to 1, the reference picture list refPicList1. \nOutputs of this process are: \n–  two 2x2 arrays refIdxILPredL0 and refIdxILPredL1 specifying inter-layer predictors for the reference indices of the \ncurrent macroblock, \n–  two 4x4x2 arrays mvILPredL0 and mvILPredL1 specifying inter-layer predictors for the motion vector components \nof the current macroblock. \nLet  tempRefIdxPredL0  and  tempRefIdxPredL1  be  two  4x4  arrays  with  elements  tempRefIdxPredL0[ x, y ]  and \ntempRefIdxPredL1[ x, y ], respectively, that specify auxiliary inter-layer predictors for reference indices. \nFor each 4x4 block indexed by x, y = 0..3 and for X being replaced by 0 and 1, the auxiliary reference index predictor \ntempRefIdxPredLX[ x, y ] and the motion vector predictor mvILPredLX[ x, y ] are derived as follows: \n–  If refLayerPredFlagLX[ refLayerPartIdc[ x, y ] / 16 ][ ( refLayerPartIdc[ x, y ] % 16 ) / 4 ] is equal 0, the reference \nindex predictor tempRefIdxPredLX[ x, y ] and the motion vector predictor mvILPredLX[ x, y ] are derived by: \ntempRefIdxPredLX[ x, y ] = −1  (G-218) \nmvILPredLX[ x, y ][ 0 ]    = 0  (G-219) \nmvILPredLX[ x, y ][ 1 ]    = 0  (G-220) \n–  Otherwise  (refLayerPredFlagLX[ refLayerPartIdc[ x, y ] / 16 ][ ( refLayerPartIdc[ x, y ] % 16 ) / 4 ]  is  equal  to 1), \nthe following ordered steps are specified: \n1.  The variables refMbAddr, refMbPartIdx, and refSubMbPartIdx are derived by \nrefMbAddr          =   refLayerPartIdc[ x, y ]  /  16  (G-221) \nrefMbPartIdx      = ( refLayerPartIdc[ x, y ] % 16 ) / 4  (G-222) \nrefSubMbPartIdx =  refLayerPartIdc[ x, y ] % 4  (G-223) \n2.  The auxiliary reference index predictor tempRefIdxPredLX[ x, y ] is derived by: \ntempRefIdxPredLX[ x, y ] = refLayerRefIdxLX[ refMbAddr ][ refMbPartIdx ] \n                                              * ( 1 + fieldMbFlag − field_pic_flag )   (G-224) \n                                              /  ( 1 + refLayerFieldMbFlag[ refMbAddr ] − RefLayerFieldPicFlag ) \n558  Rec. ITU-T H.264 (06/2019) \n \n3.  The motion vector aMv is set equal to refLayerMvLX[ refMbAddr ][ refMbPartIdx ][ refSubMbPartIdx ], and \nafterwards its vertical component aMv[ 1 ] is modified by: \naMv[ 1 ] = aMv[ 1 ] * ( 1 + refLayerFieldMbFlag[ refMbAddr ] )  (G-225) \n4.  The variables scaledW, scaledH, refLayerW, and refLayerH are derived by: \nscaledW     = ScaledRefLayerPicWidthInSamples   (G-226) \nL\nscaledH      = ScaledRefLayerPicHeightInSamples  * ( 1 + field_pic_flag )  (G-227) \nL\nrefLayerW = RefLayerPicWidthInSamples   (G-228) \nL\nrefLayerH  = RefLayerPicHeightInSamples  * ( 1 + RefLayerFieldPicFlag )   (G-229) \nL\n5.  The variables dOX, dOY, dSW, and dSH are derived as follows: \n–  If CroppingChangeFlag is equal to 0 or the reference picture refPicListX[ tempRefIdxPredLX[ x, y ] ] is not \navailable, dOX, dOY, dSW, and dSH are set equal to 0. \n–  Otherwise  (CroppingChangeFlag  is  equal  to  1  and  the  reference  picture \nrefPicListX[ tempRefIdxPredLX[ x, y ] ]  is  available),  the  variables  refPicScaledRefLayerLeftOffset, \nrefPicScaledRefLayerRightOffset,  refPicScaledRefLayerTopOffset,  and \nrefPicScaledRefLayerBottomOffset  are  set  equal  to  the  variables  ScaledRefLayerLeftOffset, \nScaledRefLayerRightOffset,  ScaledRefLayerTopOffset,  and  ScaledRefLayerBottomOffset,  respectively, \nthat  are  associated  with  the  layer  representation  of  the  reference  picture \nrefPicListX[ tempRefIdxPredLX[ x, y ] ] that has the same value of DQId as the current layer representation, \nand the variables dOX, dOY, dSW, and dSH are derived by: \ndOX = ScaledRefLayerLeftOffset      − refPicScaledRefLayerLeftOffset  (G-230) \ndOY = ScaledRefLayerTopOffset      − refPicScaledRefLayerTopOffset  (G-231) \ndSW = ScaledRefLayerRightOffset    − refPicScaledRefLayerRightOffset    + dOX  (G-232) \ndSH  = ScaledRefLayerBottomOffset − refPicScaledRefLayerBottomOffset + dOY  (G-233) \n6.  The variables scaleX and scaleY are derived by: \nscaleX = ( ( ( scaledW + dSW ) << 16 ) + ( refLayerW >> 1 ) ) / refLayerW  (G-234) \nscaleY = ( ( ( scaledH  + dSH  ) << 16 ) + ( refLayerH  >> 1 ) ) / refLayerH  (G-235) \n7.  The motion vector aMv is scaled by: \naMv[ 0 ] = ( aMv[ 0 ] * scaleX + 32768 ) >> 16  (G-236) \naMv[ 1 ] = ( aMv[ 1 ] * scaleY + 32768 ) >> 16  (G-237) \n8.  When CroppingChangeFlag is equal to 1, the motion vector aMv is modified by applying the following ordered \nsteps: \na.  The inverse macroblock scanning process as specified in clause 6.4.1 is invoked with CurrMbAddr as the \ninput and the output is a luma location ( xMbPic, yMbPic ). For this invocation of the process specified in \nclause 6.4.1, the current macroblock is treated as field macroblock when fieldMbFlag is equal to 1, and it is \ntreated as frame macroblock when fieldMbFlag is equal to 0. \nb.  The luma location ( xFrm, yFrm ) is derived by: \nxFrm = ( xMbPic + ( 4 * x + 1 ) )  (G-238) \nyFrm = ( yMbPic + ( 4 * y + 1 ) * ( 1 + fieldMbFlag − field_pic_flag ) ) * ( 1 + field_pic_flag )  (G-239) \nc.  The variables scaleX and scaleY are modified by: \nscaleX = ( ( ( 4 * dSW ) << 16 ) + ( scaledW >> 1 ) ) / scaledW  (G-240) \nscaleY = ( ( ( 4 * dSH  ) << 16 ) + ( scaledH  >> 1 ) ) / scaledH  (G-241) \n    Rec. ITU-T H.264 (06/2019)  559 \n \nd.  The motion vector aMv is modified by: \naMv[ 0 ] += ( ( ( xFrm − ScaledRefLayerLeftOffset ) * scaleX + 32768 ) >> 16 ) − 4 * dOX  (G-242) \naMv[ 1 ] += ( ( ( yFrm − ScaledRefLayerTopOffset ) * scaleY + 32768 ) >> 16 ) − 4 * dOY  (G-243) \n9.  The motion vector predictor mvILPredLX[ x, y ] is derived by: \nmvILPredLX[ x, y ][ 0 ] = aMv[ 0 ]  (G-244) \nmvILPredLX[ x, y ][ 1 ] = aMv[ 1 ] / ( 1 + fieldMbFlag )  (G-245) \nFor  each  8x8  block  indexed  by  xP, yP = 0..1  and  for  X  being  replaced  by  0  or  1,  the  reference  index  predictor \nrefIdxILPredLX[ xP, yP ]  is  set  equal  to  tempRefIdxPredLX[ 2 * xP, 2 * yP ],  and  when \nRestrictedSpatialResolutionChangeFlag is equal to 0, the following ordered steps are specified: \n1.  The  4x4  blocks  indexed  by  xS, yS = 0..1  of  the  current  8x8  block  are  processed  in  increasing  order  of \n(2 * yS + xS), and for each 4x4 block, the reference index predictor refIdxILPredLX[ xP, yP ] is modified by: \nrefIdxILPredLX[ xP, yP ] = MinPositive( refIdxILPredLX[ xP, yP ], \n                                                                   tempRefIdxPredLX[ 2 * xP + xS, 2 * yP + yS ] )  (G-246) \nwith \nMin( a,b) if a  0and b  0\n  (G-247) \nMinPositiv e( a, b )  \nMax(a,b) otherwise\n\n2.  The  4x4  blocks  indexed  by  xS, yS = 0..1  of  the  current  8x8  block  are  processed  in  increasing  order  of \n(2 * yS + xS), and for each 4x4 block, when tempRefIdxPredLX[ 2 * xP + xS, 2 * yP + yS ] is not equal to the \nreference index predictor refIdxILPredLX[ xP, yP ], the following applies: \n–  If  tempRefIdxPredLX[ 2 * xP + 1 − xS, 2 * yP + yS ]  is  equal  to  refIdxILPredLX[ xP, yP ],  the  motion \nvector predictor mvILPredLX[ 2 * xP + xS, 2 * yP + yS ] is modified by: \nmvILPredLX[ 2 * xP + xS, 2 * yP + yS ] = mvILPredLX[ 2 * xP + 1 − xS, 2 * yP + yS ]  (G-248) \n–  Otherwise, if tempRefIdxPredLX[ 2 * xP + xS, 2 * yP + 1 − yS ] is equal to refIdxILPredLX[ xP, yP ], the \nmotion vector predictor mvILPredLX[ 2 * xP + xS, 2 * yP + yS ] is modified by: \nmvILPredLX[ 2 * xP + xS, 2 * yP + yS ] = mvILPredLX[ 2 * xP + xS, 2 * yP + 1 − yS ]  (G-249) \n–  Otherwise (tempRefIdxPredLX[ 2 * xP + 1 − xS, 2 * yP + 1 − yS ] is equal to refIdxILPredLX[ xP, yP ]), \nthe motion vector predictor mvILPredLX[ 2 * xP + xS, 2 * yP + yS ] is modified by: \nmvILPredLX[ 2 * xP + xS, 2 * yP + yS ] = mvILPredLX[ 2 * xP + 1 − xS, 2 * yP + 1 − yS ]  (G-250) \nNOTE – The process specified above can also be applied when RestrictedSpatialResolutionChangeFlag is equal to 1, but in this \ncase,  the  reference  index  predictor  refIdxILPredLX[ xP, yP ]  and  the  motion  vector  predictors \nmvILPredLX[ 2 * xP + xS, 2 * yP + yS ] with xS, yS = 0..1 will not be modified. \nWhen RestrictedSpatialResolutionChangeFlag is equal to 0, slice_type is equal to EB, and direct_8x8_inference_flag is \nequal to 1, for each 8x8 block indexed by xP, yP = 0..1 and for X being replaced by 0 or 1, the following ordered steps are \nspecified: \n1.  The motion vector tempMv with components tempMv[ 0 ] and tempMv[ 1 ] is derived by: \ntempMv[ c ] = mvILPredX[ 3 * xP, 3 * yP ][ c ]     with c = 0..1  (G-251) \n2.  The array mvILPredLX is modified by: \nmvILPredLX[ 2 * xP + xS, 2 * yP + yS ][ c ] = tempMv[ c ]    with xS, yS = 0..1  and  c = 0..1  (G-252) \nWhen RestrictedSpatialResolutionChangeFlag is equal to 0, for each 8x8 block indexed by xP, yP = 0..1, the motion vector \npredictor arrays mvILPredL0 and mvILPredL1 are modified by applying the following ordered steps: \n1.  The variable maxX is derived as follows: \n–  If slice_type is equal to EB, maxX is set equal to 1. \n560  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise (slice_type is equal to EP), maxX is set equal to 0. \n2.  The variables xO and yO are set equal to (2 * xP) and (2 * yP), respectively. \n3.  The function mvDiff( mv , mv  ) of two motion vectors mv  and mv  is defined by \n1 2 1 2\nmvDiff( mv , mv  ) = Abs( mv [ 0 ] − mv [ 0 ] ) + Abs( mv [ 1 ] − mv [ 1 ] )  (G-253) \n1 2 1 2 1 2\n4.  The variable subPartSize is derived as follows: \n–  If for X = 0..maxX, all of the following conditions are true, subPartSize is set equal to 8x8. \n–  mvDiff( mvILPredLX[ xO, yO ], mvILPredLX[ xO + 1, yO ] ) is less than or equal to 1 \n–  mvDiff( mvILPredLX[ xO, yO ], mvILPredLX[ xO, yO + 1 ] ) is less than or equal to 1 \n–  mvDiff( mvILPredLX[ xO, yO ], mvILPredLX[ xO + 1, yO + 1 ] ) is less than or equal to 1 \n–  Otherwise, if for X = 0..maxX, all of the following conditions are true, subPartSize is set equal to 8x4. \n–  mvDiff( mvILPredLX[ xO, yO ], mvILPredLX[ xO + 1, yO ] ) is less than or equal to 1 \n–  mvDiff( mvILPredLX[ xO, yO + 1 ], mvILPredLX[ xO + 1, yO + 1 ] ) is less than or equal to 1 \n–  Otherwise, if for X = 0..maxX, all of the following conditions are true, subPartSize is set equal to 4x8. \n–  mvDiff( mvILPredLX[ xO, yO ], mvILPredLX[ xO, yO + 1 ] ) is less than or equal to 1 \n–  mvDiff( mvILPredLX[ xO + 1, yO ], mvILPredLX[ xO + 1, yO + 1 ] ) is less than or equal to 1 \n–  Otherwise, subPartSize is set equal to 4x4. \n5.  When subPartSize is not equal to 4x4, for X = 0..maxX, the motion vectors tempMvALX and tempMvBLX (when \nsubPartSize is equal to 8x4 or 4x8) are derived as follows: \n–  If subPartSize is equal to 8x8, tempMvALX is derived by \ntempMvALX[ c ] = ( mvILPredLX[ xO,       yO       ][ c ] + \n                                   mvILPredLX[ xO + 1, yO       ][ c ] + \n                                   mvILPredLX[ xO,       yO + 1 ][ c ] + \n                                   mvILPredLX[ xO + 1, yO + 1 ][ c ] + 2 ) >> 2      with c = 0..1  (G-254) \n–  Otherwise, if subPartSize is equal to 8x4, tempMvALX and tempMvBLX are derived by \ntempMvALX[ c ] = ( mvILPredLX[ xO,       yO ][ c ] + \n                                   mvILPredLX[ xO + 1, yO ][ c ] + 1 ) >> 1            with c = 0..1  (G-255) \n \ntempMvBLX[ c ] = ( mvILPredLX[ xO,       yO + 1 ][ c ] + \n                                   mvILPredLX[ xO + 1, yO + 1 ][ c ] + 1 ) >> 1      with c = 0..1  (G-256) \n–  Otherwise (subPartSize is equal to 4x8), tempMvALX and tempMvBLX are derived by \ntempMvALX[ c ] = ( mvILPredLX[ xO, yO       ][ c ] + \n                                   mvILPredLX[ xO, yO + 1 ][ c ] + 1 ) >> 1            with c = 0..1  (G-257) \n \ntempMvBLX[ c ] = ( mvILPredLX[ xO + 1, yO       ][ c ] + \n                                   mvILPredLX[ xO + 1, yO + 1 ][ c ] + 1 ) >> 1      with c = 0..1  (G-258) \n6.  When subPartSize is not equal to 4x4, for X = 0..maxX, the motion vector predictor array mvILPredLX is modified \nas follows: \n–  If subPartSize is equal to 8x8, the array mvILPredLX is modified by \nmvILPredLX[ xO + xS, yO + yS ][ c ] = tempMvALX[ c ]    with xS, yS = 0..1  and  c = 0..1 (G-259) \n–  Otherwise, if subPartSize is equal to 8x4, the array mvILPredLX is modified by \nmvILPredLX[ xO + xS, yO       ][ c ] = tempMvALX[ c ]       with xS = 0..1  and  c = 0..1  (G-260) \nmvILPredLX[ xO + xS, yO + 1 ][ c ] = tempMvBLX[ c ]       with xS = 0..1  and  c = 0..1  (G-261) \n    Rec. ITU-T H.264 (06/2019)  561 \n \n–  Otherwise (subPartSize is equal to 4x8), the array mvILPredLX is modified by \nmvILPredLX[ xO ,      yO + yS ][ c ] = tempMvALX[ c ]       with yS = 0..1  and  c = 0..1  (G-262) \nmvILPredLX[ xO + 1, yO + yS ][ c ] = tempMvBLX[ c ]       with yS = 0..1  and  c = 0..1  (G-263) \nG.8.6.1.3  Derivation process for inter-layer predictors for P and B macroblock and sub-macroblock types \nThis process is only invoked when slice_type is equal to EP or EB. \nInputs to this process are: \n–  two 2x2 arrays refIdxILPredL0 and refIdxILPredL1 specifying predictors for the reference indices of the current \nmacroblock, \n–  two  4x4x2  arrays  mvILPredL0  and  mvILPredL1  specifying  predictors  for  the  motion  vectors  of  the  current \nmacroblock. \nOutputs of this process are: \n–  a variable mbTypeILPred specifying a predictor for the macroblock type of the current macroblock, \n–  a list subMbTypeILPred with 4 elements specifying predictors for sub-macroblock types of the current macroblock. \nThe variable maxX is derived as follows: \n–  If slice_type is equal to EB, maxX is set equal to 1. \n–  Otherwise (slice_type is equal to EP), maxX is set equal to 0. \nThe macroblock type predictor mbTypeILPred is derived by applying the following ordered steps: \n1.  The variable partitionSize is derived as follows: \n–  If for X = 0..maxX, all of the following conditions are true, partitionSize is set equal to 16x16. \n–  all elements refIdxILPredLX[ x, y ] with x, y = 0..1 are the same \n–  all elements mvILPredLX[ x, y ] with x, y = 0..3 are the same \n–  Otherwise, if for X = 0..maxX, all of the following conditions are true, partitionSize is set equal to 16x8. \n–  refIdxILPredLX[ 0, 0 ] is equal to refIdxILPredLX[ 1, 0 ] \n–  refIdxILPredLX[ 0, 1 ] is equal to refIdxILPredLX[ 1, 1 ] \n–  all elements mvILPredLX[ x, y ] with x = 0..3 and y = 0..1 are the same \n–  all elements mvILPredLX[ x, y ] with x = 0..3 and y = 2..3 are the same \n–  Otherwise, if for X = 0..maxX, all of the following conditions are true, partitionSize is set equal to 8x16. \n–  refIdxILPredLX[ 0, 0 ] is equal to refIdxILPredLX[ 0, 1 ] \n–  refIdxILPredLX[ 1, 0 ] is equal to refIdxILPredLX[ 1, 1 ] \n–  all elements mvILPredLX[ x, y ] with x = 0..1 and y = 0..3 are the same \n–  all elements mvILPredLX[ x, y ] with x = 2..3 and y = 0..3 are the same \n–  Otherwise, partitionSize is set equal to 8x8. \n2.  When slice_type is equal to EB and partitionSize is not equal to 8x8, the variable partPredModeA is derived by \npartPredModeA = ( ( refIdxILPredL1[ 0, 0 ]  >=  0 )  ?  2  :  0 ) +  \n                              ( ( refIdxILPredL0[ 0, 0 ]  >=  0 )  ?  1  :  0 )  (G-264) \n3.  When slice_type is equal to EB and partitionSize is equal to 16x8 or 8x16, the variable partPredModeB is derived \nby \npartPredModeB = ( ( refIdxILPredL1[ 1, 1 ]  >=  0 )  ?  2  :  0 ) +  \n                              ( ( refIdxILPredL0[ 1, 1 ]  >=  0 )  ?  1  :  0 )  (G-265) \n4.  Depending  on  slice_type,  partitionSize,  partPredModeA  (when  applicable),  and  partPredModeB  (when \napplicable), the macroblock type predictor mbTypeILPred is derived as specified in Table G-7. \n562  Rec. ITU-T H.264 (06/2019) \n \nAll  elements  subMbTypeILPred[ mbPartIdx ]  of  the  list  subMbTypeILPred  with  mbPartIdx = 0..3  are  marked  as \n\"unspecified\". \nWhen mbTypeILPred is equal to P_8x8 or B_8x8, each element subMbTypeILPred[ mbPartIdx ] with mbPartIdx = 0..3 is \nmodified by applying the following ordered steps: \n1.  The coordinate offset ( xO, yO ) is set equal to ( 2 * ( mbPartIdx % 2 ), 2 * ( mbPartIdx / 2 ) ). \n2.  The variable subPartitionSize is derived as follows: \n–  If  for  X = 0..maxX,  all  elements  mvILPredLX[ xO + xS, yO + yS ]  with  xS, yS = 0..1  are  the  same, \nsubPartitionSize is set equal to 8x8. \n–  Otherwise,  if  for  X = 0..maxX,  mvILPredLX[ xO, yO ]  is  equal  to  mvILPredLX[ xO + 1, yO ]  and \nmvILPredLX[ xO, yO + 1 ] is equal to mvILPredLX[ xO + 1, yO + 1 ], subPartitionSize is set equal to 8x4. \n–  Otherwise,  if  for  X = 0..maxX,  mvILPredLX[ xO, yO ]  is  equal  to  mvILPredLX[ xO, yO + 1 ]  and \nmvILPredLX[ xO + 1, yO ] is equal to mvILPredLX[ xO + 1, yO + 1 ], subPartitionSize is set equal to 4x8. \n–  Otherwise, subPartitionSize is set equal to 4x4. \n3.  When slice_type is equal to EB, the variable partPredMode is derived by \npartPredMode = ( ( refIdxILPredL1[ xO / 2, yO / 2 ]  >=  0 )  ?  2  :  0 ) +  \n                           ( ( refIdxILPredL0[ xO / 2, yO / 2 ]  >=  0 )  ?  1  :  0 )  (G-266) \n4.  Depending  on  slice_type,  subPartitionSize,  and  partPredMode  (when  applicable),  the  sub-macroblock  type \npredictor subMbTypeILPred[ mbPartIdx ] is derived as specified in Table G-8. \nTable G-7 – Macroblock type predictors mbTypeILPred \n  A   B   d   A   B   d\n  e e e e   e e e e\n  z d d r   z d d r\np e S i o o P p e S i o o P\ny n M M L y n M M L\n_ t o d d e I _ t o d d e I\ne t i e e p e t i e e p\nl i c r t i P r P r T y l i c r t i P r P r T y\ns a t t s a t t\np r r b p r r b\na a m a a m\np p p p\nEB  16x16  1  na  B_L0_16x16  EB  16x8  2  3  B_L1_Bi_16x8 \nEB  16x16  2  na  B_L1_16x16  EB  8x16  2  3  B_L1_Bi_8x16 \nEB  16x16  3  na  B_Bi_16x16  EB  16x8  3  1  B_Bi_L0_16x8 \nEB  16x8  1  1  B_L0_L0_16x8  EB  8x16  3  1  B_Bi_L0_8x16 \nEB  8x16  1  1  B_L0_L0_8x16  EB  16x8  3  2  B_Bi_L1_16x8 \nEB  16x8  2  2  B_L1_L1_16x8  EB  8x16  3  2  B_Bi_L1_8x16 \nEB  8x16  2  2  B_L1_L1_8x16  EB  16x8  3  3  B_Bi_Bi_16x8 \nEB  16x8  1  2  B_L0_L1_16x8  EB  8x16  3  3  B_Bi_Bi_8x16 \nEB  8x16  1  2  B_L0_L1_8x16  EB  8x8  na  na  B_8x8 \nEB  16x8  2  1  B_L1_L0_16x8  EP  16x16  na  na  P_L0_16x16 \nEB  8x16  2  1  B_L1_L0_8x16  EP  16x8  na  na  P_L0_L0_16x8 \nEB  16x8  1  3  B_L0_Bi_16x8  EP  8x16  na  na  P_L0_L0_8x16 \nEB  8x16  1  3  B_L0_Bi_8x16  EP  8x8  na  na  P_8x8 \n \n    Rec. ITU-T H.264 (06/2019)  563 \n \nTable G-8 – Sub-macroblock type predictors subMbTypeILPred[ mbPartIdx ] \n   \nd d\n  z e   e r e   ]   z e   e r e   ]\ni d P  i d P \n \np\ne\nn\nS\nM\no Ld x  \np\ne\nn\nS\nM\no Ld x\nt y t i o d p e I r t I t y t i o d p e I r t I\ne _ r t i r e T y P a e _ r t i r e T y P a\ns l i c P a r t P M b m b s l i c P a r t P M b m b\nb a b a\n   \nu p b[ u p b[\ns u s u\ns s\nEB  8x8  1  B_L0_8x8  EB  4x8  3  B_Bi_4x8 \nEB  8x8  2  B_L1_8x8  EB  4x4  1  B_L0_4x4 \nEB  8x8  3  B_Bi_8x8  EB  4x4  2  B_L1_4x4 \nEB  8x4  1  B_L0_8x4  EB  4x4  3  B_Bi_4x4 \nEB  8x4  2  B_L1_8x4  EP  8x8  na  P_L0_8x8 \nEB  8x4  3  B_Bi_8x4  EP  8x4  na  P_L0_8x4 \nEB  4x8  1  B_L0_4x8  EP  4x8  na  P_L0_4x8 \nEB  4x8  2  B_L1_4x8  EP  4x4  na  P_L0_4x4 \n \nG.8.6.2  Resampling process for intra samples \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a one-dimensional array refLayerSliceIdc with RefLayerPicSizeInMbs elements specifying slice identifications for \nthe macroblocks of the reference layer representation, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  a one-dimensional array refLayerMbType with RefLayerPicSizeInMbs elements specifying macroblock types for the \nmacroblocks of the reference layer representation, \n–  a (RefLayerPicWidthInSamples )x(RefLayerPicHeightInSamples ) array refLayerPicSamples  of luma samples for \nL L L\nthe reference layer representation, \n–  a (PicWidthInSamples )x(PicHeightInSamples ) array picSamples  of luma samples, \nL L L\n–  when ChromaArrayType is not equal to 0, two (RefLayerPicWidthInSamples )x(RefLayerPicHeightInSamples ) \nC C\narrays refLayerPicSamples  and refLayerPicSamples  of chroma samples for the reference layer representation, \nCb Cr\n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays picSamples  \nC C Cb\nand picSamples  of chroma samples. \nCr\nOutputs of this process are: \n–  a modified version of the array picSamples  of luma samples, \nL\n–  when ChromaArrayType is not equal to 0, modified versions of the arrays picSamples  and picSamples  of chroma \nCb Cr\nsamples. \nThe resampling process for intra samples of a macroblock colour component as specified in clause G.8.6.2.1 is invoked \nwith chromaFlag equal to 0, mbW equal to 16, mbH equal to 16, fieldMbFlag, refLayerPicSamples , refLayerSliceIdc, \nL\nrefLayerFieldMbFlag, and refLayerMbType as the inputs and the output is the 16x16 array  mbPred  of Intra_Base \nL\nprediction samples for the luma component of the current macroblock. \nWhen ChromaArrayType is not equal to 0, for CX being replaced by Cb and Cr, the resampling process for intra samples \nof a macroblock colour component as specified in clause G.8.6.2.1 is invoked with chromaFlag equal to 1, mbW equal to \nMbWidthC, mbH equal to MbHeightC, fieldMbFlag, refLayerPicSamples , refLayerSliceIdc, refLayerFieldMbFlag, and \nCX\nrefLayerMbType as the inputs and the output is the (MbWidthC)x(MbHeightC) array mbPred  of Intra_Base prediction \nCX\nsamples for the CX component of the current macroblock. \n564  Rec. ITU-T H.264 (06/2019) \n \nThe picture sample array construction process as specified in clause G.8.5.4.1 is invoked with fieldMbFlag, mbPred , \nL\npicSamples  and, when ChromaArrayType is not equal to 0, mbPred , mbPred , picSamples , and picSamples  as the \nL Cb Cr Cb Cr\ninputs and the outputs are a modified version of picSamples  and, when ChromaArrayType is not equal to 0, modified \nL\nversions of picSamples , and picSamples . \nCb Cr\nG.8.6.2.1  Resampling process for intra samples of a macroblock colour component \nInputs to this process are: \n–  a variable chromaFlag specifying whether the luma or a chroma component is subject to the resampling process, \n–  two variables mbW and mbH specifying the width and height, respectively, of a macroblock for the considered colour \ncomponent, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  an  array  refLayerPicSamples,  which  is  a  (RefLayerPicWidthInSamples )x(RefLayerPicHeightInSamples )  array \nL L\ncontaining constructed intra luma sample values for the reference layer representation when chromaFlag is equal to 0 \nor  a  (RefLayerPicWidthInSamples )x(RefLayerPicHeightInSamples )  array  containing  constructed  intra  chroma \nC C\nsample values for the reference layer representation when chromaFlag is equal to 1, \n–  a one-dimensional array refLayerSliceIdc with RefLayerPicSizeInMbs elements specifying slice identifications for \nthe macroblocks of the reference layer representation, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  a one-dimensional array refLayerMbType with RefLayerPicSizeInMbs elements specifying macroblock types for the \nmacroblocks of the reference layer representation. \nOutput of this process is an (mbW)x(mbH) array mbPred of Intra_Base prediction samples. \nThe variable botFieldFlag is derived as follows: \n–  If RefLayerFrameMbsOnlyFlag is equal to 1, botFieldFlag is set equal to 0. \n–  Otherwise, if field_pic_flag is equal to 1, botFieldFlag is set equal to bottom_field_flag. \n–  Otherwise, if RefLayerFieldPicFlag is equal to 1, botFieldFlag is set equal to RefLayerBottomFieldFlag. \n–  Otherwise, if fieldMbFlag is equal to 1, botFieldFlag is set equal to (CurrMbAddr % 2). \n–  Otherwise, botFieldFlag is set equal to 0. \nThe variable frameBasedResamplingFlag is derived as follows: \n–  If all of the following conditions are true, frameBasedResamplingFlag is set equal to 1: \n–  RefLayerFrameMbsOnlyFlag is equal to 1, \n–  frame_mbs_only_flag is equal to 1. \n–  Otherwise, frameBasedResamplingFlag is set equal to 0. \nThe variable topAndBotResamplingFlag is derived as follows: \n–  If all of the following conditions are true, topAndBotResamplingFlag is set equal to 1: \n–  RefLayerFrameMbsOnlyFlag is equal to 0, \n–  RefLayerFieldPicFlag is equal to 0, \n–  frame_mbs_only_flag is equal to 0, \n–  fieldMbFlag is equal to 0. \n–  Otherwise, topAndBotResamplingFlag is set equal to 0. \nThe variable botFieldFrameMbsOnlyRefFlag is derived as follows: \n–  If RefLayerFrameMbsOnlyFlag is equal to 1, fieldMbFlag is equal to 1, and any of the following conditions are true, \nbotFieldFrameMbsOnlyRefFlag is set equal to 1: \n–  field_pic_flag is equal to 1 and bottom_field_flag is equal to 1, \n–  field_pic_flag is equal to 0 and ( CurrMbAddr % 2 ) is equal to 1, \n    Rec. ITU-T H.264 (06/2019)  565 \n \n–  Otherwise, botFieldFrameMbsOnlyRefFlag is set equal to 0. \nThe variable filteringModeFlag is derived as follows: \n–  If chromaFlag is equal to 0 or ChromaArrayType is equal to 3, filteringModeFlag is set equal to 0. \n–  Otherwise (chromaFlag is equal to 1 and ChromaArrayType is not equal to 3), filteringModeFlag is set equal to 1. \nThe array predArray is derived as specified in the following. \n–  If botFieldFrameMbsOnlyRefFlag is equal to 1, the following ordered steps are specified: \n1.  The reference layer sample array construction process prior to intra resampling as specified in clause G.8.6.2.2 \nis invoked with chromaFlag, mbW, mbH, fieldMbFlag, botFieldFlag, refLayerPicSamples, refLayerSliceIdc, \nrefLayerFieldMbFlag,  and  refLayerMbType  as  the  inputs  and  the  outputs  are  the  variables  refArrayW, \nrefArrayH, the array refSampleArray of reference layer sample values, and the variables xOffset and yOffset. \n2.  The variable yBorder is set equal to ( 2 − chromaFlag ). \n3.  The  interpolation  process  for  Intra_Base  prediction  as  specified  in  clause G.8.6.2.3  is  invoked  with \nfilteringModeFlag,  chromaFlag,  mbW,  mbH,  fieldMbFlag,  botFieldFlag,  fldPrdInFrmMbFlag  equal  to 0, \nyBorder,  refArrayW,  refArrayH,  refSampleArray,  xOffset,  and  yOffset  as  the  inputs  and  the  output  is  the \n(mbW)x(mbH + 2 * yBorder) array topFldPredArray of top field prediction samples. \n4.  The vertical interpolation process for Intra_Base prediction as specified in clause G.8.6.2.4 is invoked with \nfilteringModeFlag,  chromaFlag,  mbW,  mbH,  botFieldFlag,  yBorder,  frameMbFlag  equal  to 0,  and \ntopFldPredArray as the inputs and the output is the (mbW)x(mbH) array mbPred of Intra_Base prediction \nsamples. \n–  Otherwise, if frameBasedResamplingFlag is equal to 1 or fieldMbFlag is equal to 1, the following ordered steps are \nspecified: \n1.  The reference layer sample array construction process prior to intra resampling as specified in clause G.8.6.2.2 \nis invoked with chromaFlag, mbW, mbH, fieldMbFlag, botFieldFlag, refLayerPicSamples, refLayerSliceIdc, \nrefLayerFieldMbFlag,  and  refLayerMbType  as  the  inputs  and  the  outputs  are  the  variables  refArrayW, \nrefArrayH, the array refSampleArray of reference layer sample values, and the variables xOffset and yOffset. \n2.  The  interpolation  process  for  Intra_Base  prediction  as  specified  in  clause G.8.6.2.3  is  invoked  with \nfilteringModeFlag,  chromaFlag,  mbW,  mbH,  fieldMbFlag,  botFieldFlag,  fldPrdInFrmMbFlag  equal  to  0, \nyBorder equal to 0, refArrayW, refArrayH, refSampleArray, xOffset, and yOffset as the inputs and the output is \nthe (mbW)x(mbH) array mbPred of Intra_Base prediction samples. \n–  Otherwise, if topAndBotResamplingFlag is equal to 0, the following ordered steps are specified: \n1.  The reference layer sample array construction process prior to intra resampling as specified in clause G.8.6.2.2 \nis invoked with chromaFlag, mbW, mbH, fieldMbFlag, botFieldFlag, refLayerPicSamples, refLayerSliceIdc, \nrefLayerFieldMbFlag,  and  refLayerMbType  as  the  inputs  and  the  outputs  are  the  variables  refArrayW, \nrefArrayH, the array refSampleArray of reference layer sample values, and the variables xOffset and yOffset. \n2.  The variable yBorder is set equal to ( 2 − chromaFlag ). \n3.  The  interpolation  process  for  Intra_Base  prediction  as  specified  in  clause G.8.6.2.3  is  invoked  with \nfilteringModeFlag,  chromaFlag,  mbW,  mbH,  fieldMbFlag,  botFieldFlag,  fldPrdInFrmMbFlag  equal  to  1, \nyBorder,  refArrayW,  refArrayH,  refSampleArray,  xOffset,  and  yOffset  as  the  inputs  and  the  output  is  the \n(mbW)x(mbH / 2 + 2* yBorder) array fieldPredArray of field prediction samples. \n4.  The vertical interpolation process for Intra_Base prediction as specified in clause G.8.6.2.4 is invoked with \nfilteringModeFlag,  chromaFlag,  mbW,  mbH,  botFieldFlag,  yBorder,  frameMbFlag  equal  to 1,  and \nfieldPredArray as the inputs and the output is the (mbW)x(mbH) array mbPred of Intra_Base prediction samples. \n–  Otherwise (topAndBotResamplingFlag is equal to 1), the following ordered steps are specified: \n1.  The reference layer sample array construction process prior to intra resampling as specified in clause G.8.6.2.2 \nis  invoked  with  chromaFlag,  mbW,  mbH,  fieldMbFlag,  botFieldFlag  equal  to 0,  refLayerPicSamples, \nrefLayerSliceIdc, refLayerFieldMbFlag, and refLayerMbType as the inputs and the outputs are the variables \nrefArrayTopW, refArrayTopH, the array refSampleArrayTop of top field reference layer sample values, and the \nvariables xOffsetTop and yOffsetTop. \n2.  The  interpolation  process  for  Intra_Base  prediction  as  specified  in  clause G.8.6.2.3  is  invoked  with \nfilteringModeFlag, chromaFlag, mbW, mbH, fieldMbFlag, botFieldFlag equal to 0, fldPrdInFrmMbFlag equal \n566  Rec. ITU-T H.264 (06/2019) \n \nto 1, yBorder equal to 0, refArrayTopW, refArrayTopH, refSampleArrayTop, xOffsetTop, and yOffsetTop as the \ninputs and the output is the (mbW)x(mbH / 2) array topFieldPredArray of top field prediction samples. \n3.  The reference layer sample array construction process prior to intra resampling as specified in clause G.8.6.2.2 \nis  invoked  with  chromaFlag,  mbW,  mbH,  fieldMbFlag,  botFieldFlag  equal  to 1,  refLayerPicSamples, \nrefLayerSliceIdc, refLayerFieldMbFlag, and refLayerMbType as the inputs and the outputs are the variables \nrefArrayBotW, refArrayBotH, the array refSampleArrayBot of bottom field reference layer sample values, and \nthe variables xOffsetBot and yOffsetBot. \n4.  The  interpolation  process  for  Intra_Base  prediction  as  specified  in  clause G.8.6.2.3  is  invoked  with \nfilteringModeFlag, chromaFlag, mbW, mbH, fieldMbFlag, botFieldFlag equal to 1, fldPrdInFrmMbFlag equal \nto 1, yBorder equal to 0, refArrayBotW, refArrayBotH, refSampleArrayBot, xOffsetBot, and yOffsetBot as the \ninputs and the output is the (mbW)x(mbH / 2) array botFieldPredArray of bottom field prediction samples. \n5.  Each sample predArray[ x, y ] with x = 0..(mbW − 1) and y = 0..(mbH − 1) of the array mbPred of Intra_Base \nprediction samples is derived by: \nmbPred[ x, y ] = ( ( ( y % 2 )  = =  0 )  ?  topFieldPredArray[ x, y >> 1 ] \n                                                              :  botFieldPredArray[ x, y >> 1 ] )  (G-267) \nG.8.6.2.2  Reference layer sample array construction process prior to intra resampling \nInputs to this process are: \n–  a variable chromaFlag specifying whether the luma or a chroma component is subject to the resampling process, \n–  two variables mbW and mbH specifying the width and height, respectively, of a macroblock for the considered colour \ncomponent, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable botFieldFlag specifying whether a top or a bottom field is subject to the resampling process (when \nRefLayerFrameMbsOnlyFlag is equal to 0 or frame_mbs_only_flag is equal to 0), \n–  an  array  refLayerPicSamples,  which  is  a  (RefLayerPicWidthInSamples )x(RefLayerPicHeightInSamples )  array \nL L\ncontaining constructed intra luma sample values for the reference layer representation when chromaFlag is equal to 0 \nor  a  (RefLayerPicWidthInSamples )x(RefLayerPicHeightInSamples )  array  containing  constructed  intra  chroma \nC C\nsample values for the reference layer representation when chromaFlag is equal to 1, \n–  a one-dimensional array refLayerSliceIdc with RefLayerPicSizeInMbs elements specifying slice identifications for \nthe macroblocks of the reference layer representation, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  a one-dimensional array refLayerMbType with RefLayerPicSizeInMbs elements specifying macroblock types for the \nmacroblocks of the reference layer representation. \nOutputs of this process are: \n–  two variables refArrayW and refArrayH specifying the width and height, respectively, of the constructed array of \nreference layer sample values, \n–  a (refArrayW)x(refArrayH) array refSampleArray of reference layer sample values, \n–  two variables xOffset and yOffset specifying the x and y coordinate, respectively, of the reference layer sample \nlocation that corresponds to the sample refSampleArray[ 0, 0 ] of the array refSampleArray. \nThe  variables  refW,  refH,  refMbW,  refMbH,  xOffset,  yOffset,  refArrayW,  refArrayH,  xMin,  yMin,  xMax,  yMax, \nyRefScale, and yRefAdd are derived as specified in the following ordered steps: \n1.  The derivation process for reference layer sample locations in resampling as specified in clause G.6.3 is invoked \nwith chromaFlag, the sample location ( 0, 0 ), fieldMbFlag, and botFieldFlag as the inputs and the output is the \nsample location ( xRefMin16, yRefMin16 ) in units of 1/16-th sample. \n2.  The derivation process for reference layer sample locations in resampling as specified in clause G.6.3 is invoked \nwith chromaFlag, the sample location ( mbW − 1, mbH − 1 ), fieldMbFlag, and botFieldFlag as the inputs and \nthe output is the sample location ( xRefMax16, yRefMax16 ) in units of 1/16-th sample. \n3.  With Z being replaced by L for chromaFlag equal to 0 and C for chromaFlag equal to 1, the variables refW, refH, \nrefMbW, and refMbH are derived by: \n    Rec. ITU-T H.264 (06/2019)  567 \n \nrefW      = RefLayerPicWidthInSamples   (G-268) \nZ\nrefH       = RefLayerPicHeightInSamples   (G-269) \nZ\nrefMbW = ( ( chromaFlag  = =  0 )  ?  16  :  RefLayerMbWidthC )  (G-270) \nrefMbH  = ( ( chromaFlag  = =  0 )  ?  16  :  RefLayerMbHeightC )  (G-271) \n4.  The variables xOffset, yOffset, refArrayW, and refArrayH are derived by: \nxOffset      = ( ( ( xRefMin16 − 64 ) >> 8 ) << 4 ) − ( refMbW >> 1 )  (G-272) \nyOffset      = ( ( ( yRefMin16 − 64 ) >> 8 ) << 4 ) − ( refMbH  >> 1 )  (G-273) \nrefArrayW = ( ( ( xRefMax16 + 79 ) >> 8 ) << 4 ) + 3 * ( refMbW >> 1 ) − xOffset  (G-274) \nrefArrayH  = ( ( ( yRefMax16 + 79 ) >> 8 ) << 4 ) + 3 * ( refMbH  >> 1 ) − yOffset  (G-275) \nNOTE 1 – The derived array size might be larger than the array size that is actually required by the interpolation process \nfor Intra_Base prediction specified in clause G.8.6.2.3. \n5.  The variables xMin, yMin, xMax, and yMax are derived by: \nxMin  = ( xRefMin16 >> 4 ) − xOffset  (G-276) \nyMin  = ( yRefMin16 >> 4 ) − yOffset  (G-277) \nxMax = ( ( xRefMax16 + 15 ) >> 4 ) − xOffset  (G-278) \nyMax = ( ( yRefMax16 + 15 ) >> 4 ) − yOffset  (G-279) \n6.  The variables yRefScale and yRefAdd are derived as follows: \n–  If RefLayerFrameMbsOnlyFlag is equal to 1 or RefLayerFieldPicFlag is equal to 1, yRefScale is set equal \nto 1 and yRefAdd is set equal to 0. \n–  Otherwise (RefLayerFrameMbsOnlyFlag is equal to 0 and RefLayerFieldPicFlag is equal to 0), yRefScale \nis set equal to 2 and yRefAdd is set equal to botFieldFlag. \nThe variable refSliceIdcMb is marked as \"not available\". \nWhen constrained_intra_resampling_flag is equal to 1, the variable y proceeds over the values (yMin + 1)..(yMax − 1) and \nfor each value of y, the variable x proceeds over the values (xMin + 1)..(xMax − 1), and for each pair ( x, y ), the following \nordered steps are specified: \n1.  A reference layer sample location ( xRef, yRef ) is derived by: \nxRef = Max( 0, Min( refW − 1, x + xOffset ) )  (G-280) \nyRef = yRefScale * Max( 0, Min( refH / yRefScale − 1, y + yOffset ) ) + yRefAdd  (G-281) \n2.  The  derivation  process  for  reference  layer  slice  and  intra  macroblock  identifications  as  specified  in \nclause G.8.6.2.2.1  is  invoked  with  the  reference  layer  sample  location  ( xRef, yRef ),  refMbW,  refMbH, \nrefLayerSliceIdc, refLayerFieldMbFlag, and refLayerMbType as the inputs and the outputs are the reference \nlayer slice identification refSliceIdc and the variable refIntraMbFlag. \n3.  When refIntraMbFlag is equal to 1 and refSliceIdcMb is marked as \"not available\", the variable refSliceIdcMb \nis marked as \"available\" and set equal to refSliceIdc. \nWhen constrained_intra_resampling_flag is equal to 1, the following ordered steps are specified: \n1.  The variable useIntraPredFlag is set equal to 0. \n2.  For x proceeding over the values 0..15 and y proceeding over the values 0..15, the following ordered steps are \nspecified: \na.  The derivation process for reference layer macroblocks as specified in clause G.6.1 is invoked with the luma \nlocation ( x, y ), fieldMbFlag, refLayerFieldMbFlag, and refLayerMbType as the inputs and the outputs are \nassigned to mbAddrRefLayer and ( xRef, yRef ). \nb.  When refLayerMbType[ mbAddrRefLayer ] is equal to I_PCM, I_16x16, I_8x8, I_4x4, or I_BL, the variable \nuseIntraPredFlag is set equal to 1. \n3.  When useIntraPredFlag is equal to 1, it is a requirement of bitstream conformance that the bitstream shall not \ncontain data that result in refSliceIdcMb being marked as \"not available\". \n568  Rec. ITU-T H.264 (06/2019) \n \nEach sample refSampleArray[ x, y ] with x = 0..(refArrayW − 1) and y = 0..(refArrayH − 1) is derived as specified in the \nfollowing ordered steps: \n1.  A reference layer sample location ( xRef, yRef ) is derived by \nxRef = Max( 0, Min( refW − 1, x + xOffset ) )  (G-282) \nyRef = yRefScale * Max( 0, Min( refH / yRefScale − 1, y + yOffset ) ) + yRefAdd  (G-283) \n2.  The  derivation  process  for  reference  layer  slice  and  intra  macroblock  identifications  as  specified  in \nclause G.8.6.2.2.1  is  invoked  with  the  reference  layer  sample  location  ( xRef, yRef ),  refMbW,  refMbH, \nrefLayerSliceIdc, refLayerFieldMbFlag, and refLayerMbType as the inputs and the outputs are the reference \nlayer slice identification refSliceIdc and the variable refIntraMbFlag. \n3.  When constrained_intra_resampling_flag is equal to 1, refIntraMbFlag is equal to 1, x is greater than xMin, x is \nless than xMax, y is greater than yMin, and y is less than yMax, it is a requirement of bitstream conformance that \nthe bitstream shall not contain data that result in refSliceIdc being not equal to refSliceIdcMb. \nNOTE 2 – This constraint specifies that a macroblock cannot be coded with base_mode_flag equal to 1 when it \ncovers  intra-coded  macroblocks  of  more  than  one  slice  in  the  reference  layer  representation, \nconstrained_intra_resampling_flag is equal to 1, and either the inferred macroblock type is equal to I_BL or the \nconditions for invoking the intra-inter prediction combination process as specified in clause G.8.4.2.2 are fulfilled. \n4.  Depending on refIntraMbFlag, constrained_intra_resampling_flag, and refSliceIdc, the following applies: \n–  If any of the following conditions are true, the sample refSampleArray[ x, y ] is marked as \"not available for \nIntra_Base prediction\" and its value is set equal to 0: \n–  refIntraMbFlag is equal to 0, \n–  constrained_intra_resampling_flag is equal to 1 and refSliceIdcMb is marked as \"not available\", \n–  constrained_intra_resampling_flag is equal to 1 and refSliceIdc is not equal to refSliceIdcMb. \n–  Otherwise, the sample refSampleArray[ x, y ] is marked as \"available for Intra_Base prediction\" and its \nvalue is derived by \nrefSampleArray[ x, y ] = refLayerPicSamples[ xRef, yRef ]  (G-284) \nThe construction process for not available sample values prior to intra resampling as specified in clause G.8.6.2.2.2 is \ninvoked with refMbW, refMbH, refArrayW, refArrayH, refSampleArray, xOffset, and yOffset as the inputs and the output \nis a modified version of the sample array refSampleArray. \nG.8.6.2.2.1  Derivation process for reference layer slice and intra macroblock identifications \nInputs to this process are: \n–  a reference layer sample location ( xRef, yRef ) relative to the upper-left sample of the considered colour component \nof the reference layer picture, \n–  two variables refMbW and refMbH specifying the width and height, respectively, of a reference layer macroblock for \nthe considered colour component, \n–  a one-dimensional array refLayerSliceIdc with RefLayerPicSizeInMbs elements specifying slice identifications for \nthe macroblocks of the reference layer representation, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  a one-dimensional array refLayerMbType with RefLayerPicSizeInMbs elements specifying macroblock types for the \nmacroblocks of the reference layer representation. \nOutputs of this process are: \n–  a reference layer slice identification refSliceIdc for the slice that covers the input reference layer sample location, \n–  a variable refIntraMbFlag specifying whether the reference layer macroblock that covers the input reference layer \nsample location is intra coded. \nThe reference layer macroblock address refMbAddr is derived as follows: \n–  If RefLayerMbaffFrameFlag is equal to 0, the variable refMbAddr is derived by \nrefMbAddr = ( yRef / refMbH ) * RefLayerPicWidthInMbs + ( xRef / refMbW )  (G-285) \n    Rec. ITU-T H.264 (06/2019)  569 \n \n–  Otherwise (RefLayerMbaffFrameFlag is equal to 1), the variable refMbAddr is derived as specified in the following \nordered steps: \n1.  A variable refMbAddrTop is derived by \nrefMbAddrTop = 2 * ( ( yRef / ( 2 * refMbH ) ) * RefLayerPicWidthInMbs \n                                      + ( xRef / refMbW ) )  (G-286) \n2.  Depending on refLayerFieldMbFlag[ refMbAddrTop ], the variable refMbAddr is derived as follows: \n–  If refLayerFieldMbFlag[ refMbAddrTop ] is equal to 0, the variable refMbAddr is derived by \nrefMbAddr = refMbAddrTop + ( yRef % ( 2 * refMbH ) ) / refMbH  (G-287) \n–  Otherwise (refLayerFieldMbFlag[ refMbAddrTop ] is equal to 1), the variable refMbAddr is derived by \nrefMbAddr = refMbAddrTop + ( yRef % 2 )  (G-288) \nThe reference layer slice identification refSliceIdc is set equal to refLayerSliceIdc[ refMbAddr ]. \nDepending on refLayerMbType[ refMbAddr ], the variable refIntraMbFlag is derived as follows: \n–  If refLayerMbType[ refMbAddr ] is equal to I_4x4, I_8x8, I_16x16, I_PCM, or I_BL, refIntraMbFlag is set equal \nto 1. \n–  Otherwise (refLayerMbType[ refMbAddr ] is not equal to I_4x4, I_8x8, I_16x16, I_PCM, or I_BL), refIntraMbFlag \nis set equal to 0. \nG.8.6.2.2.2  Construction process for not available sample values prior to intra resampling \nInputs to this process are: \n–  two variables refMbW and refMbH specifying the width and height, respectively, of a reference layer macroblock for \nthe considered colour component, \n–  two variables refArrayW and refArrayH specifying the width and height, respectively, of the array of reference layer \nsample values, \n–  a (refArrayW)x(refArrayH) array refSampleArray of reference layer sample values, \n–  two variables xOffset and yOffset specifying the x and y coordinates, respectively, of the reference layer sample \nlocation that corresponds to the sample refSampleArray[ 0, 0 ] of the array refSampleArray. \nOutput of this process is a modified version of the array refSampleArray. \nFor  each  sample  refSampleArray[ x, y ]  with  x = (refMbW / 2)..(refArrayW  − refMbW / 2 − 1)  and \ny = (refMbH / 2)..(refArrayH − refMbH / 2 − 1) that is marked as \"not available for Intra_Base prediction\", the following \nordered steps are specified: \n1.  The sample location difference ( xD, yD ) and the variable yA are derived by \nxR = ( x + xOffset ) % refMbW  (G-289) \nyR = ( y + yOffset ) % refMbH  (G-290) \n \nxD = ( ( xR >= refMbW / 2 )  ?  ( xR − refMbW )  :  ( xR + 1 ) )  (G-291) \nyD = ( ( yR >= refMbH  / 2 )  ?  ( yR − refMbH  )  :  ( yR + 1 ) )  (G-292) \n \nyA = yD − ( refMbH / 2 + 1 ) * Sign( yD )  (G-293) \n2.  When any of the following conditions are true, yD is set equal to yA: \n–  the sample refSampleArray[ x, y − yD ] is marked as \"not available for Intra_Base prediction\", the sample \nrefSampleArray[ x, y − yA ]  is  marked  as  \"available  for  Intra_Base  prediction\",  and  the  sample \nrefSampleArray[ x − xD, y ] is marked as \"available for Intra_Base prediction\", \n–  all  of  the  samples  refSampleArray[ x − xD, y ],  refSampleArray[ x, y − yD ],  and \nrefSampleArray[ x − xD, y − yD ] are marked as \"not available for Intra_Base prediction\" and any of the \nsamples refSampleArray[ x, y − yA ] and refSampleArray[ x − xD, y − yA ] is marked as \"available for \nIntra_base prediction\", \n–  Abs( yA ) is less than Abs( yD ) and any of the following conditions are true: \n–  both samples refSampleArray[ x, y − yD ] and refSampleArray[ x, y − yA ] are marked as \"available \nfor Intra_Base prediction\", \n570  Rec. ITU-T H.264 (06/2019) \n \n–  any of the samples refSampleArray[ x, y − yD ] and refSampleArray[ x − xD, y − yD ] is marked as \n\"available  for  Intra_Base  prediction\",  any  of  the  samples  refSampleArray[ x, y − yA ]  and \nrefSampleArray[ x − xD, y − yA ] is marked as \"available for Intra_Base prediction\", and the sample \nrefSampleArray[ x − xD, y ] is marked as \"not available for Intra_Base prediction\". \nNOTE – The variable yD is never set equal to yA when RefLayerFrameMbsOnlyFlag is equal to 1 or RefLayerFieldPicFlag \nis equal to 1. \n3.  The sample value refSampleArray[ x, y ] is derived as follows: \n–  If  the  sample  refSampleArray[ x − xD, y ]  and  the  sample  refSampleArray[ x, y − yD ]  are  marked  as \n\"available for Intra_Base prediction\", the following ordered steps are specified: \na.  A variable cornerSampleAvailableFlag is derived as follows: \n–  If  the  sample  refSampleArray[ x − xD, y − yD ]  is  marked  as  \"available  for  Intra_Base \nprediction\", the variable cornerSampleAvailableFlag is set equal to 1. \n–  Otherwise  (the  sample  refSampleArray[ x − xD, y − yD ]  is  marked  as  \"not  available  for \nIntra_Base prediction\"), the variable cornerSampleAvailable is set equal to 0. \nb.  The diagonal construction process for not available sample values as specified in clause G.8.6.2.2.2.1 \nis invoked with refArrayW, refArrayH, refSampleArray, the sample location difference ( xD, yD ), the \nsample location ( x, y ), and the variable cornerSampleAvailableFlag as the inputs and the output is the \nsample array refSampleArray with a modified sample value at sample location ( x, y ). \n–  Otherwise (the sample refSampleArray[ x − xD, y ] or the sample refSampleArray[ x, y − yD ] is marked \nas \"not available for Intra_Base prediction\"), the following applies: \n–  If the sample refSampleArray[ x − xD, y ] is marked as \"available for Intra_Base prediction\", the \nsample value refSampleArray[ x, y ] is set equal to refSampleArray[ x − xD, y ]. \n–  Otherwise,  if  the  sample  refSampleArray[ x, y − yD ]  is  marked  as  \"available  for  Intra_Base \nprediction\", the sample value refSampleArray[ x, y ] is set equal to refSampleArray[ x, y − yD ]. \n–  Otherwise, if the sample refSampleArray[ x − xD, y − yD ] is marked as \"available for Intra_Base \nprediction\", the sample value refSampleArray[ x, y ] is set equal to refSampleArray[ x − xD, y − yD ]. \n–  Otherwise  (the  samples  refSampleArray[ x − xD, y ],  refSampleArray[ x, y − yD ],  and \nrefSampleArray[ x − xD, y − yD ] are marked as \"not available for Intra_Base prediction\"), the sample \nvalue refSampleArray[ x, y ] is not modified. \nAll samples refSampleArray[ x, y ] with x = 0..(refArrayW − 1) and y = 0..(refArrayH − 1) are marked as \"available for \nIntra_Base prediction\". \nG.8.6.2.2.2.1 Diagonal construction process for not available sample values \nInputs to this process are: \n–  two variables refArrayW and refArrayH specifying the width and height, respectively, of the array of reference layer \nsample values, \n–  a (refArrayW)x(refArrayH) array p of reference layer sample values, \n–  a sample location difference ( xD, yD ), \n–  a sample location ( x, y ) inside the reference layer sample array refSampleArray, \n–  a variable cornerSampleAvailableFlag. \nOutput of this process is the sample array p with a modified sample value at sample location ( x, y ). \nThe variables diffHorVer and sgnXY are derived by \ndiffHorVer = Abs( xD ) − Abs( yD )  (G-294) \nsgnXY        = Sign( xD * yD )  (G-295) \nWhen cornerSampleAvailableFlag is equal to 0, the following ordered steps are specified: \n1.  The variable cornerSample is set equal to p[ x − xD, y − yD ]. \n2.  The sample location ( xC, yC ) is set equal to ( x − xD + Sign( xD ), y − yD + Sign( yD ) ) and the sample value \np[ x − xD, y − yD ] is modified by \np[ x − xD, y − yD ] = ( p[ x − xD, yC ] + p[ xC, y − yD ] + 1 ) >> 1  (G-296) \n    Rec. ITU-T H.264 (06/2019)  571 \n \nThe sample value p[ x, y ] is derived as follows: \n–  If diffHorVer is greater than 0, the sample location ( xC, yC ) is set equal to ( x − sgnXY * yD, y − yD ) and the \nsample value p[ x, y ] is derived by \np[ x, y ] = ( p[ xC − 1, yC ] + 2 * p[ xC, yC ] + p[ xC + 1, yC ] + 2 ) >> 2  (G-297) \n–  Otherwise, if diffHorVer is less than 0, the sample location ( xC, yC ) is set equal to ( x − xD, y − sgnXY * xD ) and \nthe sample value p[ x, y ] is derived by \np[ x, y ] = ( p[ xC, yC − 1 ] + 2 * p[ xC, yC ] + p[ xC, yC + 1 ] + 2 ) >> 2  (G-298) \n–  Otherwise  (diffVerHor  is  equal  to 0),  the  sample  location  ( xC, yC )  is  set  equal  to \n( x − xD +Sign( xD ), y − yD + Sign( yD ) ) and the sample value p[ x, y ] is derived by \np[ x, y ] = ( p[ xC, y − yD ] + 2 * p[ x − xD, y − yD ] + p[ x − xD, yC ] + 2 ) >> 2  (G-299) \nWhen cornerSampleAvailableFlag is equal to 0, the sample value p[ x − xD, y − yD ] is set equal to cornerSample. \nG.8.6.2.3  Interpolation process for Intra_Base prediction \nInputs to this process are: \n–  a variable filteringModeFlag specifying the interpolation method, \n–  a variable chromaFlag specifying whether the luma or a chroma component is subject to the resampling process, \n–  two variables mbW and mbH specifying the width and height, respectively, of a macroblock for the considered colour \ncomponent, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable botFieldFlag specifying whether a top or a bottom field is subject to the resampling process (when \nRefLayerFrameMbsOnlyFlag is equal to 0 or frame_mbs_only_flag is equal to 0), \n–  a variable fldPrdInFrmMbFlag specifying whether field prediction for a frame macroblock is applied, \n–  a variable yBorder specifying the vertical border for the output sample array predSamples, \n–  two variables refArrayW and refArrayH specifying the width and height, respectively, of the array of reference layer \nsample values, \n–  a (refArrayW)x(refArrayH) array refSampleArray of reference layer sample values, \n–  two variables xOffset and yOffset specifying the x and y coordinate, respectively, of the reference layer sample \nlocation that corresponds to the sample refSampleArray[ 0, 0 ] of the array refSampleArray. \nOutput of this process is an (mbW)x(mbH / ( 1 + fldPrdInFrmMbFlag ) + 2 * yBorder) array predArray of interpolated \nsample values. \nTable G-9 specifies the filter coefficients eF[ p, x ] with p = 0..15 and x = 0..3 of the luma interpolation filter eF for \nresampling in Intra_Base prediction. \n572  Rec. ITU-T H.264 (06/2019) \n \nTable G-9 – 16-phase luma interpolation filter for resampling in Intra_Base prediction \ninterpolation filter coefficients \nphase p \neF[ p, 0 ]  eF[ p, 1 ]  eF[ p, 2 ]  eF[ p, 3 ] \n0  0  32  0  0 \n1  −1  32  2  −1 \n2  −2  31  4  −1 \n3  −3  30  6  −1 \n4  −3  28  8  −1 \n5  −4  26  11  −1 \n6  −4  24  14  −2 \n7  −3  22  16  −3 \n8  −3  19  19  −3 \n9  −3  16  22  −3 \n10  −2  14  24  −4 \n11  −1  11  26  −4 \n12  −1  8  28  −3 \n13  −1  6  30  −3 \n14  −1  4  31  −2 \n15  −1  2  32  −1 \n \nLet  tempArray  be  a  (refArrayW)x(mbH / ( 1 + fldPrdInFrmMbFlag ) + 2 * yBorder)  array  of  samples.  Each  sample \ntempArray[ x, y ] with x = 0..(refArrayW − 1) and y = 0..(mbH / ( 1 + fldPrdInFrmMbFlag ) + 2 * yBorder − 1) is derived \nas specified in the following ordered steps: \n1.  The variable yP is derived by \nyP = ( y − yBorder ) * ( 1 + fldPrdInFrmMbFlag ) + botFieldFlag  (G-300) \n2.  The derivation process for reference layer sample locations in resampling as specified in clause G.6.3 is invoked \nwith chromaFlag, the sample location ( 0, yP ), fieldMbFlag, and botFieldFlag as the inputs and the output is the \nsample location ( xRef16, yRef16 ) in units of 1/16-th sample. \nNOTE 1 – In this invocation of the process in clause G.6.3, only the vertical component yRef16 of the sample location needs \nto be derived. \n3.  The variables yRef and yPhase are derived by \nyRef     = ( yRef16 >> 4 ) − yOffset  (G-301) \nyPhase = ( yRef16 − 16 * yOffset ) % 16  (G-302) \n4.  Depending on filteringModeFlag, the sample value tempArray[ x, y ] is derived as follows: \n–  If filteringModeFlag is equal to 0, the sample value tempArray[ x, y ] is derived by \ntempArray[ x, y ] = eF[ yPhase, 0 ] * refSampleArray[ x, yRef − 1 ] + \n                                eF[ yPhase, 1 ] * refSampleArray[ x, yRef ] + \n                                eF[ yPhase, 2 ] * refSampleArray[ x, yRef + 1 ] +  (G-303) \n                                eF[ yPhase, 3 ] * refSampleArray[ x, yRef + 2 ] \n–  Otherwise (filteringModeFlag is equal to 1), the sample value tempArray[ x, y ] is derived by \ntempArray[ x, y ] = ( 16 − yPhase ) * refSampleArray[ x, yRef ] + \n                                           yPhase  * refSampleArray[ x, yRef + 1 ]  (G-304) \nEach sample predArray[ x, y ] with x = 0..(mbW − 1) and y = 0..(mbH / ( 1 + fldPrdInFrmMbFlag ) + 2 * yBorder − 1) is \nderived as specified in the following ordered steps: \n1.  The derivation process for reference layer sample locations in resampling as specified in clause G.6.3 is invoked \nwith chromaFlag, the sample location ( x, 0 ), fieldMbFlag, and botFieldFlag as the inputs and the output is the \nsample location ( xRef16, yRef16 ) in units of 1/16-th sample. \nNOTE 2 – In this invocation of the process in clause G.6.3, only the horizontal component xRef16 of the sample location \nneeds to be derived. \n    Rec. ITU-T H.264 (06/2019)  573 \n \n2.  The variables xRef and xPhase are derived by \nxRef     = ( xRef16 >> 4 ) − xOffset  (G-305) \nxPhase = ( xRef16 − 16 * xOffset ) % 16  (G-306) \n3.  Depending on filteringModeFlag, and with Clip1 being replaced by Clip1  for chromaFlag equal to 0 and Clip1  \nY C\nfor chromaFlag equal to 1, the sample value predArray[ x, y ] is derived as follows: \n–  If filteringModeFlag is equal to 0, the sample value tempArray[ x, y ] is derived by \npredArray[ x, y ] = Clip1( ( eF[ xPhase, 0 ] * tempArray[ xRef − 1, y ] + \n                                             eF[ xPhase, 1 ] * tempArray[ xRef , y] + \n                                             eF[ xPhase, 2 ] * tempArray[ xRef + 1, y ] +  (G-307) \n                                             eF[ xPhase, 3 ] * tempArray[ xRef + 2, y ] + 512 ) >> 10 ) \n–  Otherwise (filteringModeFlag is equal to 1), the sample value tempArray[ x, y ] is derived by \npredArray[ x, y ] = ( ( 16 − xPhase ) * tempArray[ xRef, y ] + \n                                             xPhase  * tempArray[ xRef + 1, y ] + 128 ) >> 8  (G-308) \nG.8.6.2.4  Vertical interpolation process for Intra_Base prediction \nInputs to this process are: \n–  a variable filteringModeFlag specifying the interpolation method, \n–  a variable chromaFlag specifying whether the luma or a chroma component is subject to the resampling process, \n–  two variables mbW and mbH specifying the width and height, respectively, of a macroblock for the considered colour \ncomponent, \n–  a variable botFieldFlag specifying whether the sample array fieldPredArray contains interpolated samples for the top \nor bottom field, \n–  a variable yBorder specifying the vertical border for the sample array fieldPredArray, \n–  a variable frameMbFlag specifying whether the current macroblock is a frame or a field macroblock, \n–  an (mbW)x(mbH / ( 1 + frameMbFlag ) + 2 * yBorder) array fieldPredArray of sample values. \nOutput of this process is an (mbW)x(mbH) array predArray of interpolated sample values. \nEach sample predArray[ x, y ] with x = 0..(mbW − 1) and y = 0..(mbH − 1) is derived as follows: \n–  If frameMbFlag is equal to 1 and ( y % 2 ) is equal to botFieldFlag, the sample value predArray[ x, y ] is derived by \npredArray[ x, y ] = fieldPredArray[ x, ( y >> 1 ) + yBorder ]  (G-309) \n–  Otherwise (frameMbFlag is equal to 0 or ( y % 2 ) is not equal to botFieldFlag), the following ordered steps are \nspecified: \n1.  The variable yFld is derived by \nyFld = ( y >> frameMbFlag ) + yBorder − botFieldFlag  (G-310) \n2.  Depending on filteringModeFlag, and with Clip1 being replaced by Clip1  for chromaFlag equal to 0 and Clip1  \nY C\nfor chromaFlag equal to 1, the sample value predArray[ x, y ] is derived as follows: \n–  If filteringModeFlag is equal to 0, the sample value predArray[ x, y ] is derived by \npredArray[ x, y ] = Clip1( ( 19 * ( fieldPredArray[ x, yFld ] +  \n                                                        fieldPredArray[ x, yFld + 1 ] ) − \n                                               3 * ( fieldPredArray[ x, yFld − 1 ] + \n                                                        fieldPredArray[ x, yFld + 2 ] ) + 16 ) >> 5 )  (G-311) \n–  Otherwise (filteringModeFlag is equal to 1), the sample value predArray[ x, y ] is derived by \npredArray[ x, y ] = ( fieldPredArray[ x, yFld ] + \n                                  fieldPredArray[ x, yFld + 1 ] + 1 ) >> 1  (G-312) \nG.8.6.2.5  Derivation process for variables related to inter-layer intra prediction \nThis clause is only invoked when MinNoInterLayerPredFlag is equal to 0. \nInput to this process is a variable currDQId. \nOutputs of this process are: \n574  Rec. ITU-T H.264 (06/2019) \n \n–  a variable numILIntraPredSamples, \n–  a variable numRefLayerILIntraPredMbs. \nUnless stated otherwise, all syntax elements and derived upper-case variables that are referred to inside this clause are \nsyntax elements and derived upper case variables for the layer representation with DQId equal to currDQId. \nInside this clause, the collective terms currentVars and refLayerVars are specified as follows: \n–  If SpatialResolutionChangeFlag is equal to 1, the following applies: \n–  currentVars  is  the  collective  term  currentVars  after  completion  of  the  base  decoding  process  for  layer \nrepresentations with resolution change as specified in clause G.8.1.3.2 for the layer representation with DQId \nequal to currDQId, \n–  refLayerVars  is  the  collective  term  refLayerVars  after  completion  of  the  base  decoding  process  for  layer \nrepresentations with resolution change as specified in clause G.8.1.3.2 for the layer representation with DQId \nequal to currDQId. \n–  Otherwise (SpatialResolutionChangeFlag is equal to 0), the following applies: \n–  currentVars  is  the  collective  term  currentVars  after  completion  of  the  base  decoding  process  for  layer \nrepresentations without resolution change as specified in clause G.8.1.3.1 for the layer representation with DQId \nequal to currDQId, \n–  refLayerVars  is  of  the  collective  term  currentVars  before  invoking  the  base  decoding  process  for  layer \nrepresentations without resolution change as specified in clause G.8.1.3.1 for the layer representation with DQId \nequal to currDQId. \nInside  this  clause,  the  arrays  of  the  collective  term  currentVars  are  referred  to  by  their  names  as  specified  in \nclause G.8.1.2.1. \nInside  this  clause,  the  arrays  fieldMbFlag  and  mbType  of  the  collective  term  refLayerVars  are  referred  to  as \nrefLayerFieldMbFlag and refLayerMbType, respectively. \nLet  currILIntraPredFlag  be  a  (PicWidthInSamples )x(PicHeightInSamples )  array  and  let  refILIntraPredFlag  be  a \nL L\none-dimensional  array  with  RefLayerPicSizeInMbs  elements.  All  elements  of  the  arrays  currILIntraPredFlag  and \nrefILIntraPredFlag are initially set equal to 0. \nThe variable yC proceeds over the values 0..(PicHeightInSamples  − 1). For each value of yC, the variable xC proceeds \nL\nover the values 0..(PicWidthInSamples  − 1). For each combination of the values yC and xC, the following ordered steps \nL\nare specified: \n1.  The variable mbAddr is set equal to the address of the macroblock that contains the luma sample at location \n( xC, yC ) relative to the upper-left sample of the layer picture. \n2.  Depending on SpatialResolutionChangeFlag, the following applies: \n–  If SpatialResolutionChangeFlag is equal to 0, the following ordered steps are specified: \na.  The array element currILIntraPredFlag[ xC, yC ] is derived as follows: \n–  If mbType[ mbAddr ] is equal to I_BL, currILIntraPredFlag[ xC, yC ] is set equal to 1. \n–  Otherwise (mbType[ mbAddr ] is not equal to I_BL), currILIntraPredFlag[ xC, yC ] is set equal \nto 0. \nb.  When currILIntraPredFlag[ xC, yC ] is equal to 1, the following ordered steps are specified: \ni.  The variable refMbAddr is derived as specified in clause G.8.1.2.2 with mbAddr being the value \nof mbAddr derived in step 1 of this clause. \nii.  The array element refILIntraPredFlag[ refMbAddr ] is set equal to 1. \niii.  When refLayerMbType[ refMbAddr ] is equal to I_16x16, I_8x8, or I_4x4, let setRefIntraMbs \nbe the set of macroblocks that contain luma or chroma samples that are directly (by the invocation \nof  clause G.8.3.2  for  the  macroblock  with  address  refMbAddr)  or  indirectly  (by  multiple \ninvocations of clause G.8.3.2 for macroblocks with mbAddr less than or equal to refMbAddr) \nused for construction of the intra prediction signal of the macroblock with address refMbAddr in \nthe layer representation with DQId equal to MaxRefLayerDQId. \niv.  For refIntraMbAddr proceeding over the macroblock addresses for the macroblocks of the set \nsetRefIntraMbs, refILIntraPredFlag[ refIntraMbAddr ] is set equal to 1. \n    Rec. ITU-T H.264 (06/2019)  575 \n \n–  Otherwise (SpatialResolutionChangeFlag is equal to 1), the following ordered steps are specified: \na.  When  RestrictedSpatialResolutionFlag  is  equal  to 0,  MbaffFrameFlag  is  equal  to 0, \nRefLayerMbaffFrameFlag is equal to 0, and base_mode_flag for the macroblock with address mbAddr \nis equal to 1, the derivation process for reference layer macroblocks as specified in clause G.6.1 is \ninvoked  with  the  luma  location  ( xC % 16, yC % 16),  fieldMbFlag,  refLayerFieldMbFlag,  and \nrefLayerMbType as the inputs and the outputs are assigned to mbAddrRefLayer and ( xRef, yRef ). \nFor this invocation of clause G.6.1, CurrMbAddr is set equal to mbAddr. \nb.  The element currILIntraPredFlag[ xC, yC ] is derived as follows: \n–  If any of the following conditions are true, currILIntraPredFlag[ xC, yC ] is set equal to 1: \n–  mbType[ mbAddr ] is equal to I_BL, \n–  RestrictedSpatialResolutionFlag  is  equal  to 0,  MbaffFrameFlag  is  equal  to 0, \nRefLayerMbaffFrameFlag is equal to 0, base_mode_flag for the macroblock with address \nmbAddr  is  equal  to 1,  and  refLayerMbType[ mbAddrRefLayer ]  is  equal  to  I_PCM, \nI_16x16, I_8x8, I_4x4, or I_BL. \n–  Otherwise, currILIntraPredFlag[ xC, yC ] is set equal to 0. \nc.  When currILIntraPredFlag[ xC, yC ] is equal to 1, the following ordered steps are specified: \ni.  Let setOfRefSamples be the set of reference layer luma sample locations ( xR, yR ) of the luma \nsample values that are used in the filtering processes specified in clause G.8.6.2.3 and, when \napplicable,  clause G.8.6.2.4 for deriving the inter-layer intra prediction sample for the luma \nsample at location ( xC, yC ) relative to the upper-left luma sample of the layer picture. \nii.  For each of the reference layer luma sample locations ( xR, yR ) of the set setOfRefSamples that \ncorrespond to luma samples marked \"available for Intra_Base prediction\" in the invocation of \nclause G.8.6.2.2 for the macroblock with address mbAddr of the layer representation with DQId \nequal to currDQId, the following ordered steps are specified: \n(1)  Let refMbAddr be the macroblock address of the macroblock in the layer representation with \nDQId equal to MaxRefLayerDQId that contains the luma sample at location ( xR, yR ). \n(2)  The array element refILIntraPredFlag[ refMbAddr ] is set equal to 1. \n(3)  When  refLayerMbType[ refMbAddr ]  is  equal  to  I_16x16,  I_8x8,  or  I_4x4,  let \nsetRefIntraMbs be the set of macroblocks that contain luma or chroma samples that are \ndirectly (by the invocation of clause G.8.3.2 for the macroblock with address refMbAddr) or \nindirectly (by multiple invocations of clause G.8.3.2 for macroblocks with mbAddr less than \nor equal to refMbAddr) used for construction of the intra prediction signal of the macroblock \nwith address refMbAddr in the layer representation with DQId equal to MaxRefLayerDQId. \n(4)  For refIntraMbAddr proceeding over the macroblock addresses for the macroblocks of the \nset setRefIntraMbs, refILIntraPredFlag[ refIntraMbAddr ] is set equal to 1. \nThe  variable  numILIntraPredSamples  is  set  equal  to  the  number  of  elements  of  the \n(PicWidthInSamples )x(PicHeightInSamples ) array currILIntraPredFlag that are equal to 1. \nL L\nNOTE 1 – The variable numILIntraPredSamples is a measure for the number of luma samples in the layer representation with \nDQId equal to currDQId that are predicted by inter-layer intra prediction. \nThe variable numRefLayerILIntraPredMbs is set equal to the number of elements of the array refILIntraPredFlag that are \nequal to 1. \nNOTE 2 – The variable numRefLayerILIntraPredMbs is a measure for the number of intra-coded macroblocks in the reference \nlayer representation that need to be decoded for constructing the inter-layer intra prediction samples of the layer representation \nwith DQId equal to currDQId. \nG.8.6.3  Resampling process for residual samples \nInputs to this process are: \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  a one-dimensional array refLayerCTrafo with RefLayerPicSizeInMbs elements specifying the luma transform types \nfor the macroblocks of the reference layer representation, \n576  Rec. ITU-T H.264 (06/2019) \n \n–  a (RefLayerPicWidthInSamples )x(RefLayerPicHeightInSamples ) array refLayerPicSamples  of luma samples for \nL L L\nthe reference layer representation, \n–  a (PicWidthInSamples )x(PicHeightInSamples ) array picSamples  of luma samples, \nL L L\n–  when ChromaArrayType is not equal to 0, two (RefLayerPicWidthInSamples )x(RefLayerPicHeightInSamples ) \nC C\narrays refLayerPicSamples  and refLayerPicSamples  of chroma samples for the reference layer representation, \nCb Cr\n–  when ChromaArrayType is not equal to 0, two (PicWidthInSamples )x(PicHeightInSamples ) arrays picSamples  \nC C Cb\nand picSamples  of chroma samples. \nCr\nOutputs of this process are: \n–  a modified version of the array picSamples  of luma samples, \nL\n–  when ChromaArrayType is not equal to 0, modified versions of the arrays picSamples  and picSamples  of chroma \nCb Cr\nsamples. \nThe resampling process for residual samples of a macroblock colour component as specified in clause G.8.6.3.1 is invoked \nwith chromaFlag equal to 0, mbW equal to 16, mbH equal to 16, fieldMbFlag, refLayerPicSamples , refLayerFieldMbFlag, \nL\nand refLayerCTrafo as the inputs and the output is the 16x16 array mbPred  of residual prediction samples for the luma \nL\ncomponent of the current macroblock. \nWhen ChromaArrayType is not equal to 0, for CX being replaced by Cb and Cr, the resampling process for residual \nsamples of a macroblock colour component as specified in clause G.8.6.3.1 is invoked with chromaFlag equal to 1, mbW \nequal  to  MbWidthC,  mbH  equal  to  MbHeightC,  fieldMbFlag,  refLayerPicSamples ,  refLayerFieldMbFlag,  and \nCX\nrefLayerCTrafo as the inputs and the output is the (MbWidthC)x(MbHeightC) array mbPred  of residual prediction \nCX\nsamples for the CX component of the current macroblock. \nThe picture sample array construction process as specified in clause G.8.5.4.1 is invoked with fieldMbFlag, mbPred , \nL\npicSamples  and, when ChromaArrayType is not equal to 0, mbPred , mbPred , picSamples , and picSamples  as the \nL Cb Cr Cb Cr\ninputs and the outputs are a modified version of picSamples  and, when ChromaArrayType is not equal to 0, modified \nL\nversions of picSamples , and picSamples . \nCb Cr\nG.8.6.3.1  Resampling process for residual samples of a macroblock colour component \nInputs to this process are: \n–  a variable chromaFlag specifying whether the luma or a chroma component is subject to the resampling process, \n–  two variables mbW and mbH specifying the width and height, respectively, of a macroblock for the considered colour \ncomponent, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  an  array  refLayerPicSamples,  which  is  a  (RefLayerPicWidthInSamples )x(RefLayerPicHeightInSamples )  array \nL L\ncontaining constructed residual luma sample values for the reference layer representation when chromaFlag is equal \nto 0  or  a  (RefLayerPicWidthInSamples )x(RefLayerPicHeightInSamples )  array  containing  constructed  residual \nC C\nchroma sample values for the reference layer representation when chromaFlag is equal to 1, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  a one-dimensional array refLayerCTrafo with RefLayerPicSizeInMbs elements specifying the luma transform types \nfor the macroblocks of the reference layer representation. \nOutput of this process is an (mbW)x(mbH) array mbPred of residual prediction samples. \nThe variable botFieldFlag is derived as follows: \n–  If RefLayerFrameMbsOnlyFlag is equal to 1, botFieldFlag is set equal to 0. \n–  Otherwise, if field_pic_flag is equal to 1, botFieldFlag is set equal to bottom_field_flag. \n–  Otherwise, if RefLayerFieldPicFlag is equal to 1, botFieldFlag is set equal to RefLayerBottomFieldFlag. \n–  Otherwise, if fieldMbFlag is equal to 1, botFieldFlag is set equal to (CurrMbAddr % 2). \n–  Otherwise, botFieldFlag is set equal to 0. \nThe variable frameBasedResamplingFlag is derived as follows: \n–  If all of the following conditions are true, frameBasedResamplingFlag is set equal to 1: \n    Rec. ITU-T H.264 (06/2019)  577 \n \n–  RefLayerFrameMbsOnlyFlag is equal to 1, \n–  frame_mbs_only_flag is equal to 1. \n–  Otherwise, frameBasedResamplingFlag is set equal to 0. \nThe variable topAndBotResamplingFlag is derived as follows: \n–  If all of the following conditions are true, topAndBotResamplingFlag is set equal to 1: \n–  RefLayerFrameMbsOnlyFlag is equal to 0, \n–  RefLayerFieldPicFlag is equal to 0, \n–  frame_mbs_only_flag is equal to 0, \n–  fieldMbFlag is equal to 0. \n–  Otherwise, topAndBotResamplingFlag is set equal to 0. \nThe variable botFieldFrameMbsOnlyRefFlag is derived as follows: \n–  If RefLayerFrameMbsOnlyFlag is equal to 1, fieldMbFlag is equal to 1, and any of the following conditions are true, \nbotFieldFrameMbsOnlyRefFlag is set equal to 1: \n–  field_pic_flag is equal to 1 and bottom_field_flag is equal to 1, \n–  field_pic_flag is equal to 0 and ( CurrMbAddr % 2 ) is equal to 1. \n–  Otherwise, botFieldFrameMbsOnlyRefFlag is set equal to 0. \nThe array predArray is derived as specified in the following. \n–  If botFieldFrameMbsOnlyRefFlag is equal to 1, the following ordered steps are specified: \n1.  The reference layer sample array construction process prior to residual resampling as specified in clause G.8.6.3.2 \nis invoked with chromaFlag, mbW, mbH, fieldMbFlag, botFieldFlag, yBorder equal to 1, refLayerPicSamples, \nrefLayerFieldMbFlag, and refLayerCTrafo as the inputs and the outputs are the variables refArrayW, refArrayH, \nthe array refSampleArray of reference layer sample values, the array refTransBlkIdc of reference layer transform \nblock identifications, and the variables xOffset and yOffset. \n2.  The interpolation process for residual prediction as specified in clause G.8.6.3.3 is invoked with chromaFlag, \nmbW,  mbH,  fieldMbFlag,  botFieldFlag,  fldPrdInFrmMbFlag  equal  to 0,  yBorder  equal  to 1,  refArrayW, \nrefArrayH,  refSampleArray,  refTransBlkIdc,  xOffset,  and  yOffset  as  the  inputs  and  the  output  is  the \n(mbW)x(mbH + 2) array topFldPredArray of top field prediction samples. \n3.  The vertical interpolation process for residual prediction as specified in clause G.8.6.3.4 is invoked with mbW, \nmbH, botFieldFlag, yBorder equal to 1, frameMbFlag equal to 0, and topFldPredArray as the inputs and the \noutput is the (mbW)x(mbH) array mbPred of residual prediction samples. \n–  Otherwise, if frameBasedResamplingFlag is equal to 1 or fieldMbFlag is equal to 1, the following ordered steps are \nspecified: \n1.  The reference layer sample array construction process prior to residual resampling as specified in clause G.8.6.3.2 \nis invoked with chromaFlag, mbW, mbH, fieldMbFlag, botFieldFlag, yBorder equal to 0, refLayerPicSamples, \nrefLayerFieldMbFlag, and refLayerCTrafo as the inputs and the outputs are the variables refArrayW, refArrayH, \nthe array refSampleArray of reference layer sample values, the array refTransBlkIdc of reference layer transform \nblock identifications, and the variables xOffset and yOffset. \n2.  The interpolation process for residual prediction as specified in clause G.8.6.3.3 is invoked with chromaFlag, \nmbW,  mbH,  fieldMbFlag,  botFieldFlag,  fldPrdInFrmMbFlag  equal  to  0,  yBorder  equal  to 0,  refArrayW, \nrefArrayH,  refSampleArray,  refTransBlkIdc,  xOffset,  and  yOffset  as  the  inputs  and  the  output  is  the \n(mbW)x(mbH) array mbPred of residual prediction samples. \n–  Otherwise, if topAndBotResamplingFlag is equal to 0, the following ordered steps are specified: \n1.  The reference layer sample array construction process prior to residual resampling as specified in clause G.8.6.3.2 \nis invoked with chromaFlag, mbW, mbH, fieldMbFlag, botFieldFlag, yBorder equal to 1, refLayerPicSamples, \nrefLayerFieldMbFlag, and refLayerCTrafo as the inputs and the outputs are the variables refArrayW, refArrayH, \nthe array refSampleArray of reference layer sample values, the array refTransBlkIdc of reference layer transform \nblock identifications, and the variables xOffset and yOffset. \n578  Rec. ITU-T H.264 (06/2019) \n \n2.  The interpolation process for residual prediction as specified in clause G.8.6.3.3 is invoked with chromaFlag, \nmbW,  mbH,  fieldMbFlag,  botFieldFlag,  fldPrdInFrmMbFlag  equal  to  1,  yBorder  equal  to 1,  refArrayW, \nrefArrayH,  refSampleArray,  refTransBlkIdc,  xOffset,  and  yOffset  as  the  inputs  and  the  output  is  the \n(mbW)x(mbH / 2 + 2) array fieldPredArray of field prediction samples. \n3.  The vertical interpolation process for residual prediction as specified in clause G.8.6.3.4 is invoked with mbW, \nmbH, botFieldFlag, yBorder equal to 1, frameMbFlag equal to 1, and fieldPredArray as the inputs and the output \nis the (mbW)x(mbH) array mbPred of residual prediction samples. \n–  Otherwise (topAndBotResamplingFlag is equal to 1), the following ordered steps are specified: \n1.  The reference layer sample array construction process prior to residual resampling as specified in clause G.8.6.3.2 \nis  invoked  with  chromaFlag,  mbW,  mbH,  fieldMbFlag,  botFieldFlag  equal  to  0,  yBorder  equal  to 0, \nrefLayerPicSamples, refLayerFieldMbFlag, and refLayerCTrafo as the inputs and the outputs are the variables \nrefArrayTopW,  refArrayTopH,  the  array  refSampleArrayTop  of  reference  layer  sample  values,  the  array \nrefTransBlkIdcTop  of  reference  layer  transform  block  identifications,  and  the  variables  xOffsetTop  and \nyOffsetTop. \n2.  The interpolation process for residual prediction as specified in clause G.8.6.3.3 is invoked with chromaFlag, \nmbW,  mbH,  fieldMbFlag,  botFieldFlag  equal  to  0,  fldPrdInFrmMbFlag  equal  to  1,  yBorder  equal  to 0, \nrefArrayTopW, refArrayTopH, refSampleArrayTop, refTransBlkIdcTop, xOffsetTop, and yOffsetTop as the \ninputs and the output is the (mbW)x(mbH / 2) array topFieldPredArray of top field prediction samples. \n3.  The reference layer sample array construction process prior to residual resampling as specified in clause G.8.6.3.2 \nis  invoked  with  chromaFlag,  mbW,  mbH,  fieldMbFlag,  botFieldFlag  equal  to  1,  yBorder  equal  to 0, \nrefLayerPicSamples, refLayerFieldMbFlag, and refLayerCTrafo as the inputs and the outputs are the variables \nrefArrayBotW,  refArrayBotH,  the  array  refSampleArrayBot  of  reference  layer  sample  values,  the  array \nrefTransBlkIdcBot  of  reference  layer  transform  block  identifications,  and  the  variables  xOffsetBot  and \nyOffsetBot. \n4.  The interpolation process for residual prediction as specified in clause G.8.6.3.3 is invoked with chromaFlag, \nmbW,  mbH,  fieldMbFlag,  botFieldFlag  equal  to  1,  fldPrdInFrmMbFlag  equal  to  1,  yBorder  equal  to 0, \nrefArrayBotW, refArrayBotH, refSampleArrayBot, refTransBlkIdcBot, xOffsetBot, and yOffsetBot as the inputs \nand the output is the (mbW)x(mbH / 2) array botFieldPredArray of bottom field prediction samples. \n5.  Each sample predArray[ x, y ] with x = 0..(mbW − 1) and y = 0..(mbH − 1) of the array mbPred of residual \nprediction samples is derived by \nmbPred[ x, y ] = ( ( ( y % 2 )  = =  0 )  ?  topFieldPredArray[ x, y >> 1 ] \n                                                              :  botFieldPredArray[ x, y >> 1 ] )  (G-313) \nG.8.6.3.2  Reference layer sample array construction process prior to residual resampling \nInputs to this process are: \n–  a variable chromaFlag specifying whether the luma or a chroma component is subject to the resampling process, \n–  two variables mbW and mbH specifying the width and height, respectively, of a macroblock for the considered colour \ncomponent, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable botFieldFlag specifying whether a top or a bottom field is subject to the resampling process (when \nRefLayerFrameMbsOnlyFlag is equal to 0 or frame_mbs_only_flag is equal to 0), \n–  a variable yBorder specifying the vertical border for determining the vertical size of the output arrays, \n–  an  array  refLayerPicSamples,  which  is  a  (RefLayerPicWidthInSamples )x(RefLayerPicHeightInSamples )  array \nL L\ncontaining constructed residual luma sample values for the reference layer representation when chromaFlag is equal \nto 0  or  a  (RefLayerPicWidthInSamples )x(RefLayerPicHeightInSamples )  array  containing  constructed  residual \nC C\nchroma sample values for the reference layer representation when chromaFlag is equal to 1, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n–  a one-dimensional array refLayerCTrafo with RefLayerPicSizeInMbs elements specifying the luma transform types \nfor the macroblocks of the reference layer representation. \nOutputs of this process are: \n–  two variables refArrayW and refArrayH specifying the width and height, respectively, of the constructed arrays of \nreference layer sample values and reference layer transform block identification, \n    Rec. ITU-T H.264 (06/2019)  579 \n \n–  a (refArrayW)x(refArrayH) array refSampleArray of reference layer sample values, \n–  a (refArrayW)x(refArrayH) array refTransBlkIdc of reference layer transform block identifications, \n–  two variables xOffset and yOffset specifying the x and y coordinate, respectively, of the reference layer sample \nlocation that corresponds to the sample refSampleArray[ 0, 0 ] of the array refSampleArray and the transform block \nidentification refTransBlkIdc[ 0, 0 ] of the array refTransBlkIdc. \nThe variables refW, refH, refMbW, refMbH, xOffset, yOffset, refArrayW, refArrayH, yRefScale, and yRefAdd are derived \nas specified in the following ordered steps: \n1.  The derivation process for reference layer sample locations in resampling as specified in clause G.6.3 is invoked \nwith chromaFlag, the sample location ( 0, −yBorder ), fieldMbFlag, and botFieldFlag as the inputs and the output \nis the sample location ( xRefMin16, yRefMin16 ) in units of 1/16-th sample. \n2.  The derivation process for reference layer sample locations in resampling as specified in clause G.6.3 is invoked \nwith chromaFlag, the sample location ( mbW − 1, mbH − 1 + yBorder ), fieldMbFlag, and botFieldFlag as the \ninputs and the output is the sample location ( xRefMax16, yRefMax16 ) in units of 1/16-th sample. \n3.  With Z being replaced by L for chromaFlag equal to 0 and C for chromaFlag equal to 1, the variables refW, refH, \nrefMbW, and refMbH are derived by \nrefW      = RefLayerPicWidthInSamples   (G-314) \nZ\nrefH       = RefLayerPicHeightInSamples   (G-315) \nZ\nrefMbW = ( ( chromaFlag  = =  0 )  ?  16  :  RefLayerMbWidthC )  (G-316) \nrefMbH  = ( ( chromaFlag  = =  0 )  ?  16  :  RefLayerMbHeightC )  (G-317) \n4.  The variables xOffset, yOffset, refArrayW, and refArrayH are derived by \nxOffset      = ( xRefMin16 >> 4 )  (G-318) \nyOffset      = ( yRefMin16 >> 4 )  (G-319) \nrefArrayW = ( xRefMax16 >> 4 ) − xOffset + 2  (G-320) \nrefArrayH  = ( yRefMax16 >> 4 ) − yOffset + 2  (G-321) \n5.  The variables yRefScale and yRefAdd are derived as follows: \n–  If RefLayerFrameMbsOnlyFlag is equal to 1 or RefLayerFieldPicFlag is equal to 1, yRefScale is set equal \nto 1 and yRefAdd is set equal to 0. \n–  Otherwise (RefLayerFrameMbsOnlyFlag is equal to 0 and RefLayerFieldPicFlag is equal to 0), yRefScale \nis set equal to 2 and yRefAdd is set equal to botFieldFlag. \nEach  sample  refSampleArray[ x, y ]  and  each  transform  block  identification  refTransBlkIdc[ x, y ]  with \nx = 0..(refArrayW − 1) and y = 0..(refArrayH − 1) are derived as specified in the following ordered steps: \n1.  A reference layer sample location ( xRef, yRef ) is derived by: \nxRef = Max( 0, Min( refW − 1, x + xOffset ) )  (G-322) \nyRef = yRefScale * Max( 0, Min( refH / yRefScale − 1, y + yOffset ) ) + yRefAdd  (G-323) \n2.  The sample refSampleArray[ x, y ] is derived by \nrefSampleArray[ x, y ] = refLayerPicSamples[ xRef, yRef ]  (G-324) \n3.  The  transform  block  identification  refTransBlkIdc[ x, y ]  is  derived  by  invoking  the  derivation  process  for \nreference layer transform block identifications as specified in clause G.8.6.3.2.1 with the reference layer sample \nlocation ( xRef, yRef ), chromaFlag, refMbW, refMbH, refLayerFieldMbFlag, and refLayerCTrafo as the inputs \nand assigning the output to refTransBlkIdc[ x, y ]. \nG.8.6.3.2.1  Derivation process for reference layer transform block identifications \nInputs to this process are: \n–  a reference layer sample location ( xRef, yRef ) relative to the upper-left sample of the considered colour component \nof the reference layer picture, \n–  a variable chromaFlag specifying whether the luma or a chroma component is subject to the resampling process, \n–  two variables refMbW and refMbH specifying the width and height, respectively, of a reference layer macroblock for \nthe considered colour component, \n–  a one-dimensional array refLayerFieldMbFlag with RefLayerPicSizeInMbs elements specifying which macroblocks \nof the reference layer representation are field macroblocks and which macroblocks are frame macroblocks, \n580  Rec. ITU-T H.264 (06/2019) \n \n–  a one-dimensional array refLayerCTrafo with RefLayerPicSizeInMbs elements specifying the luma transform types \nfor the macroblocks of the reference layer representation. \nOutput of this process is a variable refTransBlkIdc specifying an identification for the reference layer transform block that \ncontains the sample at location ( xRef, yRef ). \nThe reference layer macroblock address refMbAddr and the reference layer sample location ( xM, yM ) inside the reference \nlayer macroblock are derived as follows: \n–  If RefLayerMbaffFrameFlag is equal to 0, the variable refMbAddr and the sample location ( xM, yM ) are derived by \nrefMbAddr = ( yRef / refMbH ) * RefLayerPicWidthInMbs + ( xRef / refMbW )  (G-325) \nxM             = xRef % refMbW  (G-326) \nyM             = yRef % refMbH  (G-327) \n–  Otherwise (RefLayerMbaffFrameFlag is equal to 1), the variable refMbAddr is derived as specified in the following \nordered steps: \n1.  A variable refMbAddrTop and the horizontal sample location xM are derived by \nrefMbAddrTop = 2 * ( ( yRef / ( 2 * refMbH ) ) * RefLayerPicWidthInMbs \n                                      + ( xRef / refMbW ) )  (G-328) \nxM                    = xRef % refMbW  (G-329) \n2.  Depending on refLayerFieldMbFlag[ refMbAddrTop ], the variable refMbAddr and the vertical sample location \nyM are derived as follows: \n–  If refLayerFieldMbFlag[ refMbAddrTop ] is equal to 0, the variables refMbAddr and yM are derived by \nrefMbAddr = refMbAddrTop + ( yRef % ( 2 * refMbH) ) / refMbH  (G-330) \nyM              = yRef % refMbH  (G-331) \n–  Otherwise (refLayerFieldMbFlag[ refMbAddrTop ] is equal to 1), the variables refMbAddr and yM are \nderived by \nrefMbAddr = refMbAddrTop + ( yRef % 2 )  (G-332)  \nyM              = ( yRef % ( 2 * refMbH ) ) >> 1  (G-333) \nDepending on chromaFlag, RefLayerChromaArrayType, and refLayerCTrafo[ refMbAddr ], the following applies: \n–  If (chromaFlag is equal to 0 or RefLayerChromaArrayType is equal to 3) and refLayerCTrafo[ refMbAddr ] is equal \nto T_8x8, the variable refTransBlkIdc is derived by: \nrefTransBlkIdc = 1 + 2 * ( 4 * refMbAddr + 2 * ( yM / 8 ) + ( xM / 8 ) )  (G-334) \n–  Otherwise  ((chromaFlag  is  equal  to  1  and  RefLayerChromaArrayType  is  not  equal  to  3)  or \nrefLayerCTrafo[ refMbAddr ] is not equal to T_8x8), the variable refTransBlkIdc is derived by \nrefTransBlkIdc = 2 * ( 16 * refMbAddr + 4 * ( yM / 4 ) + ( xM / 4 ) )  (G-335) \nG.8.6.3.3  Interpolation process for residual prediction \nInputs to this process are: \n–  a variable chromaFlag specifying whether the luma or a chroma component is subject to the resampling process, \n–  two variables mbW and mbH specifying the width and height, respectively, of a macroblock for the considered colour \ncomponent, \n–  a variable fieldMbFlag specifying whether the current macroblock is a field or a frame macroblock, \n–  a variable botFieldFlag specifying whether a top or a bottom field is subject to the resampling process (when \nRefLayerFrameMbsOnlyFlag is equal to 0 or frame_mbs_only_flag is equal to 0), \n–  a variable fldPrdInFrmMbFlag specifying whether field prediction for a frame macroblock is applied, \n–  a variable yBorder specifying the vertical border for the output sample array predSamples, \n–  two variables refArrayW and refArrayH specifying the width and height, respectively, of the array of reference layer \nsample values and the array of transform block identifications, \n–  a (refArrayW)x(refArrayH) array refSampleArray of reference layer sample values, \n–  a (refArrayW)x(refArrayH) array refTransBlkIdc of transform block identifications, \n    Rec. ITU-T H.264 (06/2019)  581 \n \n–  two variables xOffset and yOffset specifying the x and y coordinate, respectively, of the reference layer sample \nlocation that corresponds to the sample refSampleArray[ 0, 0 ] of the array refSampleArray and the transform block \nidentification refTransBlkIdc[ 0, 0 ] of the array refTransBlkIdc. \nOutput of this process is an (mbW)x(mbH / ( 1 + fldPrdInFrmMbFlag ) + 2 * yBorder) array predArray of interpolated \nsample values. \nEach sample predArray[ x, y ] with x = 0..(mbW − 1) and y = 0..(mbH / ( 1 + fldPrdInFrmMbFlag ) + 2 *yBorder − 1) is \nderived as specified in the following ordered steps: \n1.  The variable yP is derived by: \nyP = ( y − yBorder ) * ( 1 + fldPrdInFrmMbFlag ) + botFieldFlag  (G-336) \n2.  The derivation process for reference layer sample locations in resampling as specified in clause G.6.3 is invoked \nwith chromaFlag, the sample location ( x, yP ), fieldMbFlag, and botFieldFlag as the inputs and the output is the \nsample location ( xRef16, yRef16 ) in units of 1/16-th sample. \n3.  The variables xRef, yRef, xPhase, and yPhase are derived by: \nxRef     = ( xRef16 >> 4 ) − xOffset  (G-337) \nyRef     = ( yRef16 >> 4 ) − yOffset  (G-338) \nxPhase = ( xRef16 − 16 * xOffset ) % 16  (G-339) \nyPhase = ( yRef16 − 16 * yOffset ) % 16  (G-340) \n4.  Let tempPred be a one-dimensional array with 2 elements. Each sample value tempPred[ dY ] with dY = 0..1 is \nderived as follows: \n–  If refTransBlkIdc[ xRef, yRef + dY ] is equal to refTransBlkIdc[ xRef + 1, yRef + dY ], the sample value \ntempPred[ dY ] is derived by: \ntempPred[ dY ] = ( 16 − xPhase ) * refSampleArray[ xRef, yRef + dY ] + \n                                        xPhase   * refSampleArray[ xRef + 1, yRef + dY ]  (G-341) \n–  Otherwise (refTransBlkIdc[ xRef, yRef + dY ] is not equal to refTransBlkIdc[ xRef + 1, yRef + dY ]), the \nsample value tempPred[ dY ] is derived by: \ntempPred[ dY ] = ( ( xPhase < 8 )  ?  refSampleArray[ xRef, yRef + dY ] \n                                                        :  refSampleArray[ xRef + 1, yRef + dY ] ) << 4  (G-342) \n5.  With xRefRound set equal to (xRef + ( xPhase / 8 )), the sample value predArray[ x, y ] is derived as follows: \n–  If refTransBlkIdc[ xRefRound, yRef ] is equal to refTransBlkIdc[ xRefRound, yRef + 1 ], the sample value \npredArray[ x, y ] is derived by: \npredArray[ x, y ] = ( ( 16 − yPhase ) * tempPred[ 0 ] + \n                                            yPhase   * tempPred[ 1 ] + 128 ) >> 8  (G-343) \n–  Otherwise (refTransBlkIdc[ xRefRound, yRef ] is not equal to refTransBlkIdc[ xRefRound, yRef + 1 ]), the \nsample value predArray[ x, y ] is derived by: \npredArray[ x, y ] = ( ( ( yPhase < 8 )  ?  tempPred[ 0 ]  :  tempPred[ 1 ] ) + 8 ) >> 4  (G-344) \nG.8.6.3.4  Vertical interpolation process for residual prediction \nInputs to this process are: \n–  two variables mbW and mbH specifying the width and height, respectively, of a macroblock for the considered colour \ncomponent, \n–  a variable botFieldFlag specifying whether the sample array fieldPredArray contains interpolated samples for the top \nor bottom field, \n–  a variable yBorder specifying the vertical border for the sample array fieldPredArray, \n–  a variable frameMbFlag specifying whether the current macroblock is a frame or a field macroblock, \n–  an (mbW)x(mbH / ( 1 + frameMbFlag ) + 2 * yBorder) array fieldPredArray of sample values. \nOutput of this process is an (mbW)x(mbH) array predArray of interpolated sample values. \nEach sample predArray[ x, y ] with x = 0..(mbW − 1) and y = 0..(mbH − 1) is derived as follows: \n–  If frameMbFlag is equal to 1 and ( y % 2 ) is equal to botFieldFlag, the sample value predArray[ x, y ] is derived by \n582  Rec. ITU-T H.264 (06/2019) \n \npredArray[ x, y ] = fieldPredArray[ x, ( y >> 1 ) + yBorder ]  (G-345) \n–  Otherwise (frameMbFlag is equal to 0 or ( y % 2 ) is not equal to botFieldFlag), the sample value predArray[ x, y ] is \nderived by \npredArray[ x, y ] = ( fieldPredArray[ x, ( y >> frameMbFlag ) + yBorder − botFieldFlag ] + \n                                  fieldPredArray[ x, ( y >> frameMbFlag ) + yBorder − botFieldFlag + 1 ] + 1 ) >> 1  (G-346) \nG.8.7  SVC deblocking filter processes \nClause G.8.7.1 specifies the deblocking filter process for Intra_Base prediction. \nClause G.8.7.2 specifies the deblocking filter process for target representations. \nG.8.7.1  Deblocking filter process for Intra_Base prediction \nInputs to the process are: \n–  the variable currDQId, \n–  the collective term currentVars. \nOutput of this process is a modified version of currentVars. \nLet the variable refLayerDQId be equal to the value of the variable MaxRefLayerDQId of the layer representation with \nDQId equal to currDQId. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the layer representation with DQId equal to refLayerDQId. \nInside this clause, the arrays that are collectively referred to as currentVars are referred to by their names as specified in \nclause G.8.1.2.1. \nThe derivation process for quantization parameters used in the deblocking filter process as specified in clause G.8.7.3 is \ninvoked with deblockingDQId set equal to refLayerDQId, mbType, tQP , and tCoeffLevel as the inputs and the outputs \nY\nare  a  list  qpDB   specifying  luma  quantization  parameter  that  are  used  in  the  deblocking  filter  process  and,  when \nY\nChromaArrayType is not equal to 0, two lists qpDB  and qpDB  specifying chroma quantization parameters that are used \nCb Cr\nin the deblocking filter process. \nLet  disableDeblockingFilterIdc,  filterOffsetA,  and  filterOffsetB  be  equal  to  the  values  of \ndisable_inter_layer_deblocking_filter_idc, InterlayerFilterOffsetA, and InterlayerFilterOffsetB, respectively, for any slice \nof the layer representation with DQId equal to currDQId, that has no_inter_layer_pred_flag equal to 0. \nFor  the  current  macroblock  address  CurrMbAddr  proceeding  over  values  0..(PicSizeInMbs − 1),  the  macroblock \ndeblocking  filter  process  as  specified  in  clause G.8.7.4  is  invoked  with  interLayerDeblockingFlag = 1, \ndisableDeblockingFilterIdc, filterOffsetA, filterOffsetB, sliceBoundariesOnlyFlag = 0, currentVars, qpDB  and, when \nY\nChromaArrayType is not equal to 0, qpDB  and qpDB  as the inputs and the output is a modified version of currentVars. \nCb Cr\nWhen disableDeblockingFilterIdc is equal to 3 or 6, for the current macroblock address CurrMbAddr proceeding over \nvalues 0..(PicSizeInMbs − 1), the macroblock deblocking filter process as specified in clause G.8.7.4 is invoked with \ninterLayerDeblockingFlag = 1,  disableDeblockingFilterIdc,  filterOffsetA,  filterOffsetB,  sliceBoundariesOnlyFlag = 1, \ncurrentVars, qpDB  and, when ChromaArrayType is not equal to 0, qpDB  and qpDB  as the inputs and the output is a \nY Cb Cr\nmodified version of currentVars. \nG.8.7.2  Deblocking filter process for target representations \nInputs to the process are: \n–  the variable currDQId, \n–  the collective term currentVars. \nOutput of this process is a modified version of currentVars. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the process specified \nin this clause and all child processes invoked from this process are the syntax elements and derived upper-case variables \nfor the layer representation with DQId equal to currDQId. \nInside this clause, the arrays that are collectively referred to as currentVars are referred to by their names as specified in \nclause G.8.1.2.1. \n    Rec. ITU-T H.264 (06/2019)  583 \n \nThe derivation process for quantization parameters used in the deblocking filter process as specified in clause G.8.7.3 is \ninvoked with deblockingDQId set equal to currDQId, mbType, tQP , and tCoeffLevel as the inputs and the outputs are a \nY\nlist  qpDB   specifying  luma  quantization  parameter  that  are  used  in  the  deblocking  filter  process  and,  when \nY\nChromaArrayType is not equal to 0, two lists qpDB  and qpDB  specifying chroma quantization parameters that are used \nCb Cr\nin the deblocking filter process. \nFor the current macroblock address CurrMbAddr proceeding over values 0..(PicSizeInMbs − 1), the following ordered \nsteps are specified: \n1.  Let  disableDeblockingFilterIdc,  filterOffsetA,  and  filterOffsetB  be  equal  to  the  value  of \ndisable_deblocking_filter_idc, FilterOffsetA, and FilterOffsetB, respectively, for the slice with DQId equal to \n(sliceIdc[ CurrMbAddr ] & 127) and first_mb_in_slice equal to (sliceIdc[ CurrMbAddr ] >> 7). \n2.  The  macroblock  deblocking  filter  process  as  specified  in  clause G.8.7.4  is  invoked  with \ninterLayerDeblockingFlag = 0,  disableDeblockingFilterIdc,  filterOffsetA,  filterOffsetB, \nsliceBoundariesOnlyFlag = 0, currentVars, qpDB  and, when ChromaArrayType is not equal to 0, qpDB  and \nY Cb\nqpDB  as the inputs and the output is a modified version of currentVars. \nCr\nFor the current macroblock address CurrMbAddr proceeding over values 0..(PicSizeInMbs − 1), the following ordered \nsteps are specified: \n1.  Let  disableDeblockingFilterIdc,  filterOffsetA,  and  filterOffsetB  be  equal  to  the  value  of \ndisable_deblocking_filter_idc, FilterOffsetA, and FilterOffsetB, respectively, for the slice with DQId equal to \n(sliceIdc[ CurrMbAddr ] & 127) and first_mb_in_slice equal to (sliceIdc[ CurrMbAddr ] >> 7). \n2.  When disableDeblockingFilterIdc is equal to 3 or 6, the macroblock deblocking filter process as specified in \nclause G.8.7.4  is  invoked  with  interLayerDeblockingFlag = 0,  disableDeblockingFilterIdc,  filterOffsetA, \nfilterOffsetB, sliceBoundariesOnlyFlag = 1, currentVars, qpDB  and, when ChromaArrayType is not equal to 0, \nY\nqpDB  and qpDB  as inputs and the output is a modified version of currentVars. \nCb Cr\nG.8.7.3  Derivation process for quantization parameters used in the deblocking filter process \nInputs to this process are: \n–  a variable deblockingDQId, \n–  a one-dimensional array mbType with PicSizeInMbs elements specifying macroblock types for the macroblocks of \nthe current decoded or partly decoded dependency representation, \n–  a  one-dimensional  array  tQP   with  PicSizeInMbs  elements  specifying  luma  quantization  parameters  for  the \nY\nmacroblocks of the current decoded or partly decoded dependency representation, \n–  a  (PicSizeInMbs)x(256 + 2 * MbWidthC * MbHeightC)  array  tCoeffLevel  specifying  transform  coefficient  level \nvalues for the macroblocks of the current decoded or partly decoded dependency representation. \nOutputs of this process are: \n–  a one-dimensional array qpDB  with PicSizeInMbs elements specifying luma quantization parameters used in the \nY\ndeblocking filter process for the macroblocks of the current decoded or partly decoded dependency representation, \n–  when ChromaArrayType is not equal to 0, two one-dimensional arrays qpDB  and qpDB  with PicSizeInMbs \nCb Cr\nelements specifying chroma quantization parameters used in the deblocking filter process for the macroblocks of the \ncurrent decoded or partly decoded dependency representation. \nThe syntax elements and derived upper-case variables that are referred to by the process specified in this clause are the \nsyntax elements and derived upper-case variables for the layer representation with DQId equal to deblockingDQId. \nLet  tempQP  be  a  one-dimensional  array  with  PicSizeInMbs  elements.  All  elements  tempQP[ i ]  with \ni = 0..(PicSizeInMbs − 1) are set equal to tQP [ i ]. \nY\nWhen MaxTCoeffLevelPredFlag is equal to 1, the following ordered steps are specified: \n1.  Let  firstMbInSliceGroup  and  numMbsInSliceGroup  be  two  one-dimensional  arrays  with \n(num_slice_groups_minus1 + 1) elements. The array elements are derived as specified by the following pseudo \ncode. \n \nfor( iGroup = 0; iGroup <= num_slice_groups_minus1; iGroup++ )  { \n  firstMbInSliceGroup[ iGroup ] = −1 \n  numMbsInSliceGroup[ iGroup ] = 0 \n} \nfor( i = 0; i < PicSizeInMbs; i++ )  {  (G-347) \n584  Rec. ITU-T H.264 (06/2019) \n \n  if( firstMbInSliceGroup[ MbToSliceGroupMap[ i ] ]  = =  −1 ) \n    firstMbInSliceGroup[ MbToSliceGroupMap[ i ] ] = i \n  numMbsInSliceGroup[ MbToSliceGroupMap[ i ] ]++ \n} \n \n2.  The variable iGroup proceeds over the values 0..num_slice_groups_minus1. For each value of iGroup, the \nvariable lastMbAddr is set equal to firstMbInSliceGroup[ iGroup ] and the variable mbIdx proceeds over the \nvalues  1..(numMbsInSliceGroup[ iGroup ] − 1).  For  each  value  of  mbIdx,  the  following  ordered  steps  are \nspecified. \na.  The variable mbAddr is derived as specified by the following pseudo-code: \n \nmbAddr = lastMbAddr + 1 \nwhile( MbToSliceGroupMap[ mbAddr ] != MbToSliceGroupMap[ lastMbAddr ] )   (G-348) \n  mbAddr++ \n \nb.  When  mbType[ mbAddr ]  is  not  equal  to  I_16x16  and  all  elements  tCoeffLevel[ mbAddr ][ i ]  with \ni = 0..(255 + 2 * MbWidthC * MbHeightC)  are  equal  to 0,  tempQP[ mbAddr ]  is  set  equal  to \ntempQP[ lastMbAddr ]. \nc.  The variable lastMbAddr is set equal to mbAddr. \nThe macroblock address mbAddr proceeds over the values 0..(PicSizeInMbs − 1), and for each value of mbAddr, the \nfollowing ordered steps are specified: \n1.  The variable qpDB [ mbAddr ] is derived as follows: \nY\n–  If mbType[ mbAddr ] is equal to I_PCM, qpDB [ mbAddr ] is set equal to 0. \nY\n–  Otherwise  (mbType[ mbAddr ]  is  not  equal  to  I_PCM),  qpDB [ mbAddr ]  is  set  equal  to \nY\ntempQP[ mbAddr ]. \n2.  When ChromaArrayType is not equal to 0, for C being replaced by Cb and Cr, the variable qpDB [ mbAddr ] is \nC\nset equal to the value of QP  that corresponds to a value of qpDB [ mbAddr ] for QP  as specified in clause 8.5.8. \nC Y Y\nDuring  this  invocation  of  the  process  in  clause 8.5.8,  the  syntax  elements  chroma_qp_index_offset  and \nsecond_chroma_qp_index_offset of the layer representation with DQId equal to deblockingFilterDQId are used. \nG.8.7.4  Macroblock deblocking filter process \nInputs to this process are: \n–  the  variables  interLayerDeblockingFlag,  disableDeblockingFilterIdc,  filterOffsetA,  filterOffsetB,  and \nsliceBoundariesOnlyFlag, \n–  the collective term currentVars, \n–  a one-dimensional array qpDB  with PicSizeInMbs elements specifying luma quantization parameters used in the \nY\ndeblocking filter process for the macroblocks of the current decoded or partly decoded dependency representation, \n–  when ChromaArrayType is not equal to 0, two one-dimensional arrays qpDB  and qpDB  with PicSizeInMbs \nCb Cr\nelements specifying chroma quantization parameters used in the deblocking filter process for the macroblocks of the \ncurrent decoded or partly decoded dependency representation. \nOutput of this process is a modified version of currentVars. \nIn the following of this clause, the arrays that are collectively referred to as currentVars are referred to by their names as \nspecified in clause G.8.1.2.1. \nThe derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to \nmbAddrA and mbAddrB. For this invocation of the process in clause 6.4.11.1, the current macroblock is treated as field \nmacroblock  when  fieldMbFlag[ CurrMbAddr ]  is  equal  to  1,  and  it  is  treated  as  frame  macroblock  when \nfieldMbFlag[ CurrMbAddr ] is equal to 0. \nNOTE 1 – The availability status of the macroblocks mbAddrA and mbAddrB is not used inside this clause. Slice boundaries are \ndetected using the array sliceIdc. \nThe variable filterLeftLumaMbEdgeFlag is derived as follows: \n–  If any of the following conditions are true, the variable filterLeftLumaMbEdgeFlag is set equal to 0: \n    Rec. ITU-T H.264 (06/2019)  585 \n \n–  MbaffFrameFlag is equal to 0 and CurrMbAddr % PicWidthInMbs is equal to 0, \n–  MbaffFrameFlag is equal to 1 and ( CurrMbAddr >> 1 ) % PicWidthInMbs is equal to 0, \n–  disableDeblockingFilterIdc is equal to 1, \n–  disableDeblockingFilterIdc is equal to 2 or 5 and sliceIdc[ mbAddrA ] is different than sliceIdc[ CurrMbAddr ], \n–  disableDeblockingFilterIdc is equal to 3 or 6, sliceBoundariesOnlyFlag is equal to 0, and sliceIdc[ mbAddrA ] \nis different than sliceIdc[ CurrMbAddr ], \n–  disableDeblockingFilterIdc is equal to 3 or 6, sliceBoundariesOnlyFlag is equal to 1, and sliceIdc[ mbAddrA ] \nis equal to sliceIdc[ CurrMbAddr ], \n–  interLayerDeblockingFlag is equal to 1 and mbType[ CurrMbAddr ] specifies an Inter macroblock prediction \nmode. \n–  Otherwise, the variable filterLeftLumaMbEdgeFlag is set equal to 1. \nThe variable filterTopLumaMbEdgeFlag is derived as follows: \n–  If any of the following conditions are true, the variable filterTopLumaMbEdgeFlag is set equal to 0: \n–  MbaffFrameFlag is equal to 0 and CurrMbAddr is less than PicWidthInMbs, \n–  MbaffFrameFlag  is  equal  to  1,  ( CurrMbAddr >> 1 )  is  less  than  PicWidthInMbs,  and \nfieldMbFlag[ CurrMbAddr ] is equal to 1, \n–  MbaffFrameFlag is equal to 1, ( CurrMbAddr >> 1 ) is less than PicWidthInMbs, fieldMbFlag[ CurrMbAddr ] \nis equal to 0, and CurrMbAddr % 2 is equal to 0, \n–  disableDeblockingFilterIdc is equal to 1, \n–  disableDeblockingFilterIdc is equal to 2 or 5 and sliceIdc[ mbAddrB ] is different than sliceIdc[ CurrMbAddr ], \n–  disableDeblockingFilterIdc is equal to 3 or 6, sliceBoundariesOnlyFlag is equal to 0, and sliceIdc[ mbAddrB ] \nis different than sliceIdc[ CurrMbAddr ], \n–  disableDeblockingFilterIdc is equal to 3 or 6, sliceBoundariesOnlyFlag is equal to 1, and sliceIdc[ mbAddrB ] \nis equal to sliceIdc[ CurrMbAddr ], \n–  interLayerDeblockingFlag is equal to 1 and mbType[ CurrMbAddr ] specifies an Inter macroblock prediction \nmode. \n–  Otherwise, the variable filterTopLumaMbEdgeFlag is set equal to 1. \nThe variable filterInternalLumaEdgesFlag is derived as follows: \n–  If any of the following conditions are true, the variable filterInternalLumaEdgesFlag is set equal to 0: \n–  disableDeblockingFilterIdc is equal to 1, \n–  disableDeblockingFilterIdc is equal to 3 or 6 and sliceBoundariesOnlyFlag is equal to 1, \n–  interLayerDeblockingFlag is equal to 1 mbType[ CurrMbAddr ] specifies an Inter macroblock prediction mode. \n–  Otherwise the variable filterInternalLumaEdgesFlag is set equal to 1. \nThe  variables  filterLeftChromaMbEdgeFlag,  filterTopChromaMbEdgeFlag,  and  filterInternalChromaEdgesFlag  are \nderived as follows: \n–  If disableDeblockingFilterIdc is greater than 3, filterLeftChromaMbEdgeFlag, filterTopChromaMbEdgeFlag, and \nfilterInternalChromaEdgesFlag are set equal to 0. \n–  Otherwise (disableDeblockingFilterIdc is less than 4), filterLeftChromaMbEdgeFlag, filterTopChromaMbEdgeFlag, \nand filterInternalChromaEdgesFlag are set equal to filterLeftLumaMbEdgeFlag, filterTopLumaMbEdgeFlag, and \nfilterInternalLumaEdgesFlag, respectively. \nThe variable fieldMbInFrameFlag is derived as follows: \n–  If MbaffFrameFlag is equal to 1 and fieldMbFlag[ CurrMbAddr ] is equal to 1, fieldMbInFrameFlag is set equal to 1. \n–  Otherwise (MbaffFrameFlag is equal to 0 or fieldMbFlag[ CurrMbAddr ] is equal to 0), fieldMbInFrameFlag is set \nequal to 0. \n586  Rec. ITU-T H.264 (06/2019) \n \nWhen filterLeftLumaMbEdgeFlag is equal to 1, the left vertical luma edge is filtered by invoking the process specified in \nclause G.8.7.4.1  with  interLayerDeblockingFlag,  chromaEdgeFlag  set  equal  to  0,  verticalEdgeFlag  set  equal  to  1, \nfieldModeInFrameFilteringFlag set equal to fieldMbInFrameFlag, filterOffsetA, filterOffsetB, qpDB set equal to qpDB , \nY\ncurrentVars, (xE , yE ) set equal to (0, k) with k = 0..15, and cS  as the inputs and cS  as the output. \nk k L L\nWhen filterInternalLumaEdgesFlag is equal to 1, the filtering of the internal vertical luma edges is specified  by the \nfollowing ordered steps: \n1.  When cTrafo[ CurrMbAddr ] is not equal to T_8x8, the process specified in clause G.8.7.4.1 is invoked with \ninterLayerDeblockingFlag,  chromaEdgeFlag  set  equal  to  0,  verticalEdgeFlag  set  equal  to  1, \nfieldModeInFrameFilteringFlag set equal to fieldMbInFrameFlag, filterOffsetA, filterOffsetB, qpDB set equal to \nqpDB , currentVars, (xE , yE ) set equal to (4, k) with k = 0..15, and cS  as the inputs and cS  as the output. \nY k k L L\n2.  The process specified in clause G.8.7.4.1 is invoked with interLayerDeblockingFlag, chromaEdgeFlag set equal \nto  0,  verticalEdgeFlag  set  equal  to  1,  fieldModeInFrameFilteringFlag  set  equal  to  fieldMbInFrameFlag, \nfilterOffsetA, filterOffsetB, qpDB set equal to qpDB , currentVars, (xE , yE ) set equal to (8, k) with k = 0..15, \nY k k\nand cS  as the inputs and cS  as the output. \nL L\n3.  When cTrafo[ CurrMbAddr ] is not equal to T_8x8, the process specified in clause G.8.7.4.1 is invoked with \ninterLayerDeblockingFlag,  chromaEdgeFlag  set  equal  to  0,  verticalEdgeFlag  set  equal  to  1, \nfieldModeInFrameFilteringFlag set equal to fieldMbInFrameFlag, filterOffsetA, filterOffsetB, qpDB set equal to \nqpDB , currentVars, (xE , yE ) set equal to (12, k) with k = 0..15, and cS  as the inputs and cS  as the output. \nY k k L L\nWhen filterTopLumaMbEdgeFlag is equal to 1, the filtering of the top horizontal luma edge is specified as follows: \n–  If  MbaffFrameFlag  is  equal  to  1,  (CurrMbAddr % 2)  is  equal  to  0,  CurrMbAddr  is  greater  than  or  equal  to \n(2 * PicWidthInMbs),  fieldMbFlag[ CurrMbAddr ]  is  equal  to  0,  and \nfieldMbFlag[ CurrMbAddr − 2 * PicWidthInMbs + 1 ] is equal to 1, the following ordered steps are specified: \n1.  The process specified in clause G.8.7.4.1 is invoked with interLayerDeblockingFlag, chromaEdgeFlag set equal \nto 0, verticalEdgeFlag set equal to 0, fieldModeInFrameFilteringFlag set equal to 1, filterOffsetA, filterOffsetB, \nqpDB set equal to qpDB , currentVars, (xE , yE ) set equal to (k, 0) with k = 0..15, and cS  as the inputs and cS  \nY k k L L\nas the output. \n2.  The process specified in clause G.8.7.4.1 is invoked with interLayerDeblockingFlag, chromaEdgeFlag set equal \nto 0, verticalEdgeFlag set equal to 0, fieldModeInFrameFilteringFlag set equal to 1, filterOffsetA, filterOffsetB, \nqpDB set equal to qpDB , currentVars, (xE , yE ) set equal to (k, 1) with k = 0..15, and cS  as the inputs and cS  \nY k k L L\nas the output. \n–  Otherwise, the process specified in clause G.8.7.4.1 is invoked with interLayerDeblockingFlag, chromaEdgeFlag set \nequal  to  0,  verticalEdgeFlag  set  equal  to  0,  fieldModeInFrameFilteringFlag  set  equal  to  fieldMbInFrameFlag, \nfilterOffsetA, filterOffsetB, qpDB set equal to qpDB , currentVars, (xE , yE ) set equal to (k, 0) with k = 0..15, and \nY k k\ncS  as the inputs and cS  as the output. \nL L\nWhen filterInternalLumaEdgesFlag is equal to 1, the filtering of the internal horizontal luma edges is specified by the \nfollowing ordered steps: \n1.  When cTrafo[ CurrMbAddr ] is not equal to T_8x8, the process specified in clause G.8.7.4.1 is invoked with \ninterLayerDeblockingFlag,  chromaEdgeFlag  set  equal  to  0,  verticalEdgeFlag  set  equal  to  0, \nfieldModeInFrameFilteringFlag set equal to fieldMbInFrameFlag, filterOffsetA, filterOffsetB, qpDB set equal to \nqpDB , currentVars, (xE , yE ) set equal to (k, 4) with k = 0..15, and cS  as the inputs and cS  as the output. \nY k k L L\n2.  The process specified in clause G.8.7.4.1 is invoked with interLayerDeblockingFlag, chromaEdgeFlag set equal \nto  0,  verticalEdgeFlag  set  equal  to  0,  fieldModeInFrameFilteringFlag  set  equal  to  fieldMbInFrameFlag, \nfilterOffsetA, filterOffsetB, qpDB set equal to qpDB , currentVars, (xE , yE ) set equal to (k, 8) with k = 0..15, \nY k k\nand cS  as the inputs and cS  as the output. \nL L\n3.  When cTrafo[ CurrMbAddr ] is not equal to T_8x8, the process specified in clause G.8.7.4.1 is invoked with \ninterLayerDeblockingFlag,  chromaEdgeFlag  set  equal  to  0,  verticalEdgeFlag  set  equal  to  0, \nfieldModeInFrameFilteringFlag set equal to fieldMbInFrameFlag, filterOffsetA, filterOffsetB, qpDB set equal to \nqpDB , currentVars, (xE , yE ) set equal to (k, 12) with k = 0..15, and cS  as the inputs and cS  as the output. \nY k k L L\nWhen ChromaArrayType is not equal to 0, for the filtering of both chroma components with C being replaced by Cb and \nCr in qpDB  and cS , the following ordered steps are specified: \nC C\n1.  When filterLeftChromaMbEdgeFlag is equal to 1, the left vertical chroma edge is filtered by invoking the process \nspecified in clause G.8.7.4.1 with interLayerDeblockingFlag, chromaEdgeFlag set equal to 1, verticalEdgeFlag \nset equal to 1, fieldModeInFrameFilteringFlag set equal to fieldMbInFrameFlag, filterOffsetA, filterOffsetB, \n    Rec. ITU-T H.264 (06/2019)  587 \n \nqpDB set equal to qpDB , currentVars, (xE , yE ) set equal to (0, k) with k = 0..(MbHeightC − 1), and cS  as the \nC k k C\ninputs and cS  as the output. \nC\n2.  When filterInternalChromaEdgesFlag is equal to 1, the filtering of the internal vertical chroma edge is specified \nby the following ordered steps: \na.  When ChromaArrayType is not equal to 3 or cTrafo[ CurrMbAddr ] is not equal to T_8x8, the process \nspecified in clause G.8.7.4.1 is invoked with interLayerDeblockingFlag, chromaEdgeFlag set equal to 1, \nverticalEdgeFlag  set  equal  to  1,  fieldModeInFrameFilteringFlag  set  equal  to  fieldMbInFrameFlag, \nfilterOffsetA, filterOffsetB, qpDB set equal to qpDB , currentVars, (xE , yE ) set equal to (4, k) with \nC k k\nk = 0..(MbHeightC − 1), and cS  as the inputs and cS  as the output. \nC C\nb.  When  ChromaArrayType  is  equal  to 3,  the  process  specified  in  clause G.8.7.4.1  is  invoked  with \ninterLayerDeblockingFlag,  chromaEdgeFlag  set  equal  to  1,  verticalEdgeFlag  set  equal  to  1, \nfieldModeInFrameFilteringFlag set equal to fieldMbInFrameFlag, filterOffsetA, filterOffsetB, qpDB set \nequal to qpDB , currentVars, (xE , yE ) set equal to (8, k) with k = 0..(MbHeightC − 1), and cS  as the \nC k k C\ninputs and cS  as the output. \nC\nc.  When  ChromaArrayType  is  equal  to 3  and  cTrafo[ CurrMbAddr ]  is  not  equal  to  T_8x8,  the  process \nspecified in clause G.8.7.4.1 is invoked with interLayerDeblockingFlag, chromaEdgeFlag set equal to 1, \nverticalEdgeFlag  set  equal  to  1,  fieldModeInFrameFilteringFlag  set  equal  to  fieldMbInFrameFlag, \nfilterOffsetA, filterOffsetB, qpDB set equal to qpDB , currentVars, (xE , yE ) set equal to (12, k) with \nC k k\nk = 0..(MbHeightC − 1), and cS  as the inputs and cS  as the output. \nC C\n3.  When filterTopChromaMbEdgeFlag is equal to 1, the filtering of the top horizontal chroma edge is specified as \nfollows: \n–  If MbaffFrameFlag is equal to 1, (CurrMbAddr % 2) is equal to 0, CurrMbAddr is greater than or equal to \n(2 * PicWidthInMbs),  fieldMbFlag[ CurrMbAddr ]  is  equal  to  0, \nfieldMbFlag[ CurrMbAddr − 2 * PicWidthInMbs + 1 ]  is  equal  to 1,  the  following  ordered  steps  are \nspecified: \na.  The process specified in clause G.8.7.4.1 is invoked with interLayerDeblockingFlag, chromaEdgeFlag \nset  equal  to  1,  verticalEdgeFlag  set  equal  to  0,  fieldModeInFrameFilteringFlag  set  equal  to  1, \nfilterOffsetA, filterOffsetB, qpDB set equal to qpDB , currentVars, (xE , yE ) set equal to (k, 0) with \nC k k\nk = 0..(MbWidthC − 1), and cS  as the inputs and cS  as the output. \nC C\nb.  The process specified in clause G.8.7.4.1 is invoked with interLayerDeblockingFlag, chromaEdgeFlag \nset  equal  to  1,  verticalEdgeFlag  set  equal  to  0,  fieldModeInFrameFilteringFlag  set  equal  to  1, \nfilterOffsetA, filterOffsetB, qpDB set equal to qpDB , currentVars, (xE , yE ) set equal to (k, 1) with \nC k k\nk = 0..(MbWidthC − 1), and cS  as the inputs and cS  as the output. \nC C\n–  Otherwise,  the  process  specified  in  clause G.8.7.4.1  is  invoked  with  interLayerDeblockingFlag, \nchromaEdgeFlag set equal to 1, verticalEdgeFlag set equal to 0, fieldModeInFrameFilteringFlag set equal \nto fieldMbInFrameFlag, filterOffsetA, filterOffsetB, qpDB set equal to qpDB , currentVars, (xE , yE ) set \nC k k\nequal to (k, 0) with k = 0..(MbWidthC − 1), and cS  as the inputs and cS  as the output. \nC C\n4.  When  filterInternalChromaEdgesFlag  is  equal  to 1,  the  filtering  of  the  internal  horizontal  chroma  edge  is \nspecified by the following ordered steps: \na.  When ChromaArrayType is not equal to 3 or cTrafo[ CurrMbAddr ] is not equal to T_8x8, the process \nspecified in clause G.8.7.4.1 is invoked with interLayerDeblockingFlag, chromaEdgeFlag set equal to 1, \nverticalEdgeFlag  set  equal  to  0,  fieldModeInFrameFilteringFlag  set  equal  to  fieldMbInFrameFlag, \nfilterOffsetA, filterOffsetB, qpDB set equal to qpDB , currentVars, (xE , yE ) set equal to (k, 4) with \nC k k\nk = 0..(MbWidthC − 1), and cS  as the inputs and cS  as the output. \nC C\nb.  When  ChromaArrayType  is  not  equal  to 1,  the  process  specified  in  clause G.8.7.4.1  is  invoked  with \ninterLayerDeblockingFlag,  chromaEdgeFlag  set  equal  to  1,  verticalEdgeFlag  set  equal  to  0, \nfieldModeInFrameFilteringFlag set equal to fieldMbInFrameFlag, filterOffsetA, filterOffsetB, qpDB set \nequal to qpDB , currentVars, (xE , yE ) set equal to (k, 8) with k = 0..(MbWidthC − 1), and cS  as the inputs \nC k k C\nand cS  as the output. \nC\nc.  When  ChromaArrayType  is  equal  to 2,  the  process  specified  in  clause G.8.7.4.1  is  invoked  with \ninterLayerDeblockingFlag,  chromaEdgeFlag  set  equal  to  1,  verticalEdgeFlag  set  equal  to  0, \nfieldModeInFrameFilteringFlag set equal to fieldMbInFrameFlag, filterOffsetA, filterOffsetB, qpDB set \nequal to qpDB , currentVars, (xE , yE ) set equal to (k, 12) with k = 0..(MbWidthC − 1), and cS  as the \nC k k C\ninputs and cS  as the output. \nC\n588  Rec. ITU-T H.264 (06/2019) \n \nd.  When  ChromaArrayType  is  equal  to 3  and  cTrafo[ CurrMbAddr ]  is  not  equal  to  T_8x8,  the  process \nspecified in clause G.8.7.4.1 is invoked with interLayerDeblockingFlag, chromaEdgeFlag set equal to 1, \nverticalEdgeFlag  set  equal  to  0,  fieldModeInFrameFilteringFlag  set  equal  to  fieldMbInFrameFlag, \nfilterOffsetA, filterOffsetB, qpDB set equal to qpDB , currentVars, (xE , yE ) set equal to (k, 12) with \nC k k\nk = 0..(MbWidthC − 1), and cS  as the inputs and cS  as the output. \nC C\nNOTE 2 – When field mode filtering (fieldModeInFrameFilteringFlag is equal to 1) is applied across the top horizontal edges \nof a frame macroblock, this vertical filtering across the top or bottom macroblock boundary may involve some samples that \nextend across an internal block edge that is also filtered internally in frame mode. \nNOTE 3 – For example, in 4:2:0 chroma format when cTrafo[ CurrMbAddr ] is not equal to T_8x8, the following applies. 3 \nhorizontal luma edges, 1 horizontal chroma edge for Cb, and 1 horizontal chroma edge for Cr are filtered that are internal to \na macroblock. When field mode filtering (fieldModeInFrameFilteringFlag is equal to 1) is applied to the top edges of a frame \nmacroblock, 2 horizontal luma, 2 horizontal chroma edges for Cb, and 2 horizontal chroma edges for Cr between the frame \nmacroblock and the above macroblock pair are filtered using field mode filtering, for a total of up to 5 horizontal luma edges, \n3 horizontal chroma edges for Cb, and 3 horizontal chroma edges for Cr filtered that are considered to be controlled by the \nframe macroblock.  In all other cases, at most 4 horizontal luma, 2 horizontal chroma edges for Cb, and 2 horizontal chroma \nedges for Cr are filtered that are considered to be controlled by a particular macroblock. \nG.8.7.4.1  SVC filtering process for block edges \nInputs to this process are: \n–  the variable interLayerDeblockingFlag, \n–  the variable chromaEdgeFlag, \n–  the variable verticalEdgeFlag, \n–  the variable fieldModeInFrameFilteringFlag, \n–  the variables filterOffsetA and filterOffsetB, \n–  the one-dimensional array qpDB with PicSizeInMbs elements specifying quantization parameters, \n–  the collective term currentVars, \n–  a set of nE sample locations (xE , yE ), with k = 0..(nE − 1), expressed relative to the upper left corner of the \nk k\nmacroblock CurrMbAddr. The set of sample locations (xE , yE ) represent the sample locations immediately to the \nk k\nright  of  a  vertical  edge  (when  verticalEdgeFlag  is  equal  to 1)  or  immediately  below  a  horizontal  edge  (when \nverticalEdgeFlag is equal to 0), \n–  an array of samples s′. \nOutput of this process is a modified version of the array s′. \nThe variable nE is derived as follows: \n–  If chromaEdgeFlag is equal to 0, nE is set equal to 16. \n–  Otherwise  (chromaEdgeFlag  is  equal  to  1),  nE  is  set  equal  to \n( ( verticalEdgeFlag  = =  1 )  ?  MbHeightC  :  MbWidthC ). \nInside this clause, the arrays that are collectively referred to as currentVars are referred to by their names as specified in \nclause G.8.1.2.1. \nThe variable dy is set equal to (1 + fieldModeInFrameFilteringFlag). \nThe position of the upper-left luma sample of the macroblock CurrMbAddr is derived by invoking the inverse macroblock \nscanning process in clause 6.4.1 with mbAddr = CurrMbAddr as input and the output being assigned to ( xI, yI ). During \nthe process in clause 6.4.1, the current macroblock is treated as field macroblock when fieldMbFlag[ CurrMbAddr ] is \nequal to 1, and it is treated as frame macroblock when fieldMbFlag[ CurrMbAddr ] is equal to 0. \nThe variables xP and yP are derived as follows: \n–  If chromaEdgeFlag is equal to 0, xP is set equal to xI and yP is set equal to yI. \n–  Otherwise  (chromaEdgeFlag  is  equal  to  1),  xP  is  set  equal  to  (xI / SubWidthC)  and  yP  is  set  equal  to \n( ( yI + SubHeightC − 1 ) / SubHeightC ). \nFor each sample location ( xE , yE  ), k = 0..(nE − 1), the following ordered steps are specified: \nk k\n1.  The filtering process is applied to a set of eight samples across a 4x4 block horizontal or vertical edge denoted as \np and q with i = 0..3 as shown in Figure 8-11 with the edge lying between p  and q . p and q with i = 0..3 are \ni i 0 0 i i\nspecified as follows: \n    Rec. ITU-T H.264 (06/2019)  589 \n \n–  If verticalEdgeFlag is equal to 1, \nq = s′[ xP + xE  + i, yP + dy * yE  ]    (G-349) \ni k k\np = s′[ xP + xE  − i − 1, yP + dy * yE  ]    (G-350) \ni k k\n–  Otherwise (verticalEdgeFlag is equal to 0), \nq = s′[ xP + xE , yP + dy * ( yE  + i ) − (yE  % 2 ) ]  (G-351) \ni k k k\np = s′[ xP + xE , yP + dy * ( yE  − i − 1 ) − (yE  % 2 ) ]  (G-352) \ni k k k\n2.  Let  mbAddrP  and  mbAddrQ  specify  the  addresses  of  the  macroblocks  that  contain  the  samples  p   and  q , \n0 0\nrespectively. \n3.  The  process  specified  in  clause G.8.7.4.2  is  invoked  with  the  sample  values  p   and  q  (i  =  0..3), \ni i\ninterLayerDeblockingFlag,  chromaEdgeFlag,  verticalEdgeFlag,  filterOffsetA,  filterOffsetB,  qP   set  equal  to \np\nqpDB[ mbAddrP ],  qP   set  equal  to  qpDB[ mbAddrQ ],  sliceIdc,  fieldMbFlag,  mbType,  cTrafo,  predFlagL0, \nq\npredFlagL1, refIdxL0, refIdxL1, mvL0, mvL1, and rS  as inputs, and the output is assigned to the filtered result \nL\nsample values p′ and q′ with i = 0..2. \ni i\n4.  The input sample values p and q with i = 0..2 are replaced by the corresponding filtered result sample values p′ \ni i i\nand q′ with i = 0..2 inside the sample array s′ as follows: \ni\n–  If verticalEdgeFlag is equal to 1, \ns′[ xP + xE  + i, yP + dy * yE  ] = q′    (G-353) \nk k i\ns′[ xP + xE  − i − 1, yP + dy * yE  ] = p′    (G-354) \nk k i\n–  Otherwise (verticalEdgeFlag is equal to 0), \ns′[ xP + xE , yP + dy * ( yE  + i ) − ( yE  % 2 ) ] = q′   (G-355) \nk k k i\ns′[ xP + xE , yP + dy * ( yE  − i − 1 ) − ( yE  % 2 ) ] = p′   (G-356) \nk k k i\nG.8.7.4.2  SVC filtering process for a set of samples across a horizontal or vertical block edge \nInputs to this process are: \n–  the input sample values p and q with i = 0..3 of a single set of samples across an edge that is to be filtered, \ni i\n–  the variable interLayerDeblockingFlag, \n–  the variable chromaEdgeFlag, \n–  the variable verticalEdgeFlag, \n–  the variables filterOffsetA and filterOffsetB, \n–  the variables qP  and qP , \np q\n–  the arrays sliceIdc, fieldMbFlag, mbType, cTrafo, predFlagL0, predFlagL1, refIdxL0, refIdxL1, mvL0, and mvL1, \n–  an array rS  containing residual sample values. \nL\nOutputs of this process are the filtered result sample values p′ and q′ with i in the range of 0..2. \ni i\nThe content dependent boundary filtering strength variable bS is derived as follows: \n–  If chromaEdgeFlag is equal to 0, the SVC derivation process for the luma content dependent boundary filtering \nstrength specified in clause G.8.7.4.3 is invoked with p , q , interLayerDeblockingFlag, verticalEdgeFlag, sliceIdc, \n0 0\nfieldMbFlag, mbType, cTrafo, predFlagL0, predFlagL1, refIdxL0, refIdxL1, mvL0, mvL1, and rS  as inputs, and the \nL\noutput is assigned to bS. \n–  Otherwise (chromaEdgeFlag is equal to 1), the bS used for filtering a set of samples of a horizontal or vertical chroma \nedge is set equal to the value of bS for filtering the set of samples of a horizontal or vertical luma edge, respectively, \nthat contains the luma sample at location ( SubWidthC * x, SubHeightC * y ) inside the luma array of the same field, \nwhere ( x, y ) is the location of the chroma sample q  inside the chroma array for that field. \n0\nThe process specified in clause 8.7.2.2 is invoked with p , q , p , q , chromaEdgeFlag, bS, filterOffsetA, filterOffsetB, qP , \n0 0 1 1 p\nand qP  as inputs, and the output is assigned to filterSamplesFlag, indexA, , and . \nq\nDepending on the variable filterSamplesFlag, the following applies: \n590  Rec. ITU-T H.264 (06/2019) \n \n–  If filterSamplesFlag is equal to 1, the following applies: \n–  If bS is less than 4, the process specified in clause 8.7.2.3 is invoked with p and q (i = 0..2), chromaEdgeFlag, \ni i\nbS, , and indexA given as input, and the output is assigned to p′ and q′ (i = 0..2). \ni i\n–  Otherwise  (bS  is  equal  to  4),  the  process  specified  in  clause 8.7.2.4  is  invoked  with  p  and  q  (i  =  0..3), \ni i\nchromaEdgeFlag, , and  given as input, and the output is assigned to p′ and q′ (i = 0..2). \ni i\n–  Otherwise (filterSamplesFlag is equal to 0), the filtered result samples p′ and q′ (i = 0..2) are replaced by the \ni i\ncorresponding input samples p  and q: \ni i\nfor i = 0..2,    p′ = p    (G-357) \ni i\nfor i = 0..2,    q′ = q    (G-358) \ni i\nG.8.7.4.3  SVC derivation process for the luma content dependent boundary filtering strength \nInputs to this process are: \n–  the input sample values p  and q  of a single set of samples across an edge that is to be filtered, \n0 0\n–  the variable interLayerDeblockingFlag, \n–  the variable verticalEdgeFlag, \n–  the arrays sliceIdc, fieldMbFlag, mbType, cTrafo, predFlagL0, predFlagL1, refIdxL0, refIdxL1, mvL0, and mvL1, \n–  the array rS  containing residual sample values. \nL\nOutput of this process is the variable bS. \nThe following variables are derived as specified in the following: \n–  mbAddrP and mbAddrQ specify the macroblocks containing the samples p  and q , respectively. \n0 0\n–  mbPartIdxP and mbPartIdxQ specify the macroblock partitions containing the samples p  and q , respectively. \n0 0\n–  subMbPartIdxP  and  subMbPartIdxQ  specify  the  sub-macroblock  partitions  containing  the  samples  p   and  q , \n0 0\nrespectively. \n–  pFLXP and pFLXQ with X being replaced by 0 and 1 are equal to predFlagLX[ mbAddrP ][ mbPartIdxP ] and \npredFlagLX[ mbAddrQ ][ mbPartIdxQ ], respectively. \n–  refLXP  and  refLXQ  with  X  being  replaced  by  0  and  1  are  equal  to  refIdxLX[ mbAddrP ][ mbPartIdxP ]  and \nrefIdxLX[ mbAddrQ ][ mbPartIdxQ ], respectively. \n–  mvLXP and mvLXQ with X being replaced by 0 and 1 are equal to mvLX[ mbAddrP ][ mbPartIdxP ][ subMbPartP ] \nand mvLX[ mbAddrQ ][ mbPartIdxQ ][ subMbPartQ ], respectively. \n–  numMvP and numMvQ are equal to (pFL0P + pFL1P) and (pFL0Q + pFL1Q), respectively. \n–  When numMvP and numMvQ are both equal to 1, the variables refX and mvX with X being replaced by P and Q are \nderived as follows: \n–  If pFL0X is equal to 1, refX is set equal to refL0X and mvX is set equal to mvL0X. \n–  Otherwise (pFL1X is equal to 1), refX is set equal to refL1X and mvX is set equal to mvL1X. \n–  sliceX  with  X  being  replaced  by  P  and  Q  is  the  slice  with  DQId  equal  to  (sliceIdc[ mbAddrX ] & 127)  and \nfirst_mb_in_slice equal to (sliceIdc[ mbAddrX ] >> 7) \nLet the variable mixedModeEdgeFlag be derived as follows: \n–  If  MbaffFrameFlag  is  equal  to 1  and  fieldMbFlag[ mbAddrP ]  is  not  equal  to  fieldMbFlag[ mbAddrQ ], \nmixedModeEdgeFlag is set equal to 1. \n–  Otherwise, mixedModeEdgeFlag is set equal to 0. \nThe variable bS is derived as follows: \n–  If interLayerDeblockingFlag is equal to 1 and mbType[ mbAddrP ] specifies an Inter macroblock prediction mode, \nbS is set equal to 0. \nNOTE 1 – This clause is not invoked when interLayerDeblockingFlag is equal to 1 and mbType[ mbAddrQ ] \nspecifies an Inter macroblock prediction mode. \n    Rec. ITU-T H.264 (06/2019)  591 \n \n–  Otherwise,  if  SpatialResolutionChangeFlag  is  equal  to 1  and  either  or  both  mbType[ mbAddrP ]  or \nmbType[ mbAddrQ ] is equal to I_BL, the following applies: \n–  If either mbType[ mbAddrP ] or mbType[ mbAddrQ ] specifies an Intra macroblock prediction mode other than \nI_BL, the following applies: \n–  If verticalEdgeFlag is equal to 1 or both fieldMbFlag[ mbAddrP ] and fieldMbFlag[ mbAddrQ ] are equal \nto 0, bS is set equal to 4. \n–  Otherwise  (verticalEdgeFlag  is  equal  to 0  and  either  or  both  fieldMbFlag[ mbAddrP ]  or \nfieldMbFlag[ mbAddrQ ] is equal to 1), bS is set equal to 3. \n–  Otherwise, if mbType[ mbAddrP ] is equal to I_BL and mbType[ mbAddrQ ] is equal to I_BL, the following \napplies: \n–  If any of the following conditions are true, bS is set equal to 1: \n–  cTrafo[ mbAddrP ] is equal to T_8x8 and the 8x8 luma transform block coded in sliceP and associated \nwith the 8x8 luma block containing sample p  contains non-zero transform coefficient levels, \n0\n–  cTrafo[ mbAddrP ] is equal to T_4x4 and the 4x4 luma transform block coded in sliceP and associated \nwith the 4x4 luma block containing sample p  contains non-zero transform coefficient levels, \n0\n–  cTrafo[ mbAddrQ ] is equal to T_8x8 and the 8x8 luma transform block coded in sliceQ and associated \nwith the 8x8 luma block containing sample q  contains non-zero transform coefficient levels, \n0\n–  cTrafo[ mbAddrQ ] is equal to T_4x4 and the 4x4 luma transform block coded in sliceQ and associated \nwith the 4x4 luma block containing sample q  contains non-zero transform coefficient levels. \n0\nNOTE 2 – A luma transform block coded in a particular slice is considered to contain non-zero transform coefficient \nlevels, if non-zero transform coefficients are transmitted in the macroblock layer of the slice for the considered luma \ntransform block. Transform coefficient levels that are transmitted in layers that are used for inter-layer prediction \nare not taken into account. \n–  Otherwise, bS is set equal to 0. \n–  Otherwise (either mbType[ mbAddrP ] or mbType[ mbAddrQ ] specifies an Inter macroblock prediction mode), \nthe following applies: \n–  If any of the following conditions are true, bS is set equal to 2: \n–  mbType[ mbAddrP ]  specifies  an  Inter  macroblock  prediction  type,  cTrafo[ mbAddrP ]  is  equal \nto T_8x8, and the array rS  contains non-zero samples for the 8x8 luma block containing sample p , \nL 0\n–  mbType[ mbAddrP ]  specifies  an  Inter  macroblock  prediction  type,  cTrafo[ mbAddrP ]  is  equal \nto T_4x4, and the array rS  contains non-zero samples for the 4x4 luma block containing sample p , \nL 0\n–  mbType[ mbAddrQ ]  specifies  an  Inter  macroblock  prediction  type,  cTrafo[ mbAddrQ ]  is  equal \nto T_8x8, and the array rS  contains non-zero samples for the 8x8 luma block containing sample q , \nL 0\n–  mbType[ mbAddrQ ]  specifies  an  Inter  macroblock  prediction  type,  cTrafo[ mbAddrQ ]  is  equal \nto T_4x4, and the array rS  contains non-zero samples for the 4x4 luma block containing sample q . \nL 0\nNOTE 3 – The array rS  contains samples for the accumulated residual signal. Transform coefficient values of layer \nL\nrepresentations that are used for inter-layer prediction are taken into account. \n–  Otherwise, bS is set equal to 1. \n–  Otherwise, if the block edge is also a macroblock edge and any of the following conditions are true, bS is set equal \nto 4: \n–  fieldMbFlag[ mbAddrP ]  is  equal  to 0  and  fieldMbFlag[ mbAddrQ ]  is  equal  to 0  and  either  or  both \nmbType[ mbAddrP ] or mbType[ mbAddrQ ] specify an Intra macroblock prediction mode, \n–  MbaffFrameFlag is equal to 1 or field_pic_flag is equal to 1, and verticalEdgeFlag is equal to 1, and either or \nboth mbType[ mbAddrP ] or mbType[ mbAddrQ ] specify an Intra macroblock prediction mode. \n–  Otherwise, if any of the following conditions are true, bS is set equal to 3: \n–  mixedModeEdgeFlag is equal to 0 and either or both mbType[ mbAddrP ] or mbType[ mbAddrQ ] specify an \nIntra macroblock prediction mode, \n–  mixedModeEdgeFlag is equal to 1, verticalEdgeFlag is equal to 0, and either or both mbType[ mbAddrP ] or \nmbType[ mbAddrQ ] specify an Intra macroblock prediction mode. \n592  Rec. ITU-T H.264 (06/2019) \n \n–  Otherwise, if any of the following conditions are true, bS is set equal to 2: \n–  cTrafo[ mbAddrP ] is equal to T_8x8 and either the array rS  contains non-zero samples for the 8x8 luma block \nL\ncontaining sample p  or ((sliceIdc[ mbAddrP ] & 127) is equal to 0 and the 8x8 luma transform block coded in \n0\nsliceP and associated with the 8x8 luma block containing sample p  contains non-zero transform coefficient \n0\nlevels), \n–  cTrafo[ mbAddrP ] is equal to T_4x4 and either the array rS  contains non-zero samples for the 4x4 luma block \nL\ncontaining sample p  or ((sliceIdc[ mbAddrP ] & 127) is equal to 0 and the 4x4 luma transform block coded in \n0\nsliceP and associated with the 4x4 luma block containing sample p  contains non-zero transform coefficient \n0\nlevels), \n–  cTrafo[ mbAddrQ ] is equal to T_8x8 and either the array rS  contains non-zero samples for the 8x8 luma block \nL\ncontaining sample q  or ((sliceIdc[ mbAddrQ ] & 127) is equal to 0 and the 8x8 luma transform block coded in \n0\nsliceQ and associated with the 8x8 luma block containing sample q  contains non-zero transform coefficient \n0\nlevels), \n–  cTrafo[ mbAddrQ ] is equal to T_4x4 and either the array rS  contains non-zero samples for the 4x4 luma block \nL\ncontaining sample q  or ((sliceIdc[ mbAddrQ ] & 127) is equal to 0 and the 4x4 luma transform block coded in \n0\nsliceQ and associated with the 4x4 luma block containing sample q  contains non-zero transform coefficient \n0\nlevels). \nNOTE 4 – The array rS  contains samples for the accumulated residual signal. Transform coefficient values of layer \nL\nrepresentations that are used for inter-layer prediction are taken into account. \n–  Otherwise, if profile_idc is equal to 83 and any of the following conditions are true, bS is set equal to 2: \n–  cTrafo[ mbAddrP ] is equal to T_8x8 and the array sTCoeff[ mbAddrP ] contains non-zero scaled transform \ncoefficient values for the 8x8 luma transform block associated with the 8x8 luma block containing sample p , \n0\n–  cTrafo[ mbAddrP ] is equal to T_4x4 and the array sTCoeff[ mbAddrP ] contains non-zero scaled transform \ncoefficient values for the 4x4 luma transform block associated with the 4x4 luma block containing sample p , \n0\n–  cTrafo[ mbAddrQ ] is equal to T_8x8 and the array sTCoeff[ mbAddrQ ] contains non-zero scaled transform \ncoefficient values for the 8x8 luma transform block associated with the 8x8 luma block containing sample q , \n0\n–  cTrafo[ mbAddrQ ] is equal to T_4x4 and the array sTCoeff[ mbAddrQ ] contains non-zero scaled transform \ncoefficient values for the 4x4 luma transform block associated with the 4x4 luma block containing sample q . \n0\n–  Otherwise, if mixedModeEdgeFlag is equal to 1 or any of the following conditions are true, bS is set equal to 1: \n1.  numMvP is not equal to numMvQ. \n2.  numMvP and numMvQ are both equal to 1 and any of the following conditions are true: \n–  refP and refQ specify different reference pictures, \n–  the absolute difference between the horizontal or vertical components of the motion vectors mvP and mvQ \nis greater than or equal to 4 in units of quarter luma frame samples. \n3.  numRefP and numRefQ are both equal to 2 and any of the following conditions are true: \na.  refL0P and refL1P specify different reference pictures and any of the following conditions are true: \ni.  both of the following conditions are true: \n–  refL0P and refL0Q specify different reference pictures or refL1P and refL1Q specify different \nreference pictures, \n–  refL0P and refL1Q specify different reference pictures or refL1P and refL0Q specify different \nreference pictures. \nii.  refL0P and refL0Q specifies the same reference picture, refL1P and refL1Q specify the same reference \npicture, and any of the following conditions are true: \n–  the absolute difference between the horizontal or vertical components of the motion vectors \nmvL0P and mvL0Q is greater than or equal to 4 in units of quarter luma frame samples, \n–  the absolute difference between the horizontal or vertical components of the motion vectors \nmvL1P and mvL1Q is greater than or equal to 4 in units of quarter luma frame samples. \niii.  refL0P and refL1Q specifies the same reference picture, refL1P and refL0Q specify the same reference \npicture, and any of the following conditions are true: \n    Rec. ITU-T H.264 (06/2019)  593 \n \n–  the absolute difference between the horizontal or vertical components of the motion vectors \nmvL0P and mvL1Q is greater than or equal to 4 in units of quarter luma frame samples, \n–  the absolute difference between the horizontal or vertical components of the motion vectors \nmvL1P and mvL0Q is greater than or equal to 4 in units of quarter luma frame samples. \nb.  refL0P and refL1P specify the same reference picture and any of the following conditions are true: \ni.  refL0Q or refL1Q specify a different reference picture than refL0P (or refL1P). \nii.  refL0Q  and  refL1Q  specify  the  same  reference  picture  as  refL0P  (and  refL1P)  and  both  of  the \nfollowing conditions are true: \n–  the absolute difference between the horizontal or vertical components of the motion vectors \nmvL0P and mvL0Q is greater than or equal to 4 in units of quarter luma frame samples or the \nabsolute difference between the horizontal or vertical components of the motion vectors mvL1P \nand mvL1Q is greater than or equal to 4 in units of quarter luma frame samples, \n–  the absolute difference between the horizontal or vertical components of the motion vectors \nmvL0P and mvL1Q is greater than or equal to 4 in units of quarter luma frame samples or the \nabsolute difference between the horizontal or vertical components of the motion vectors mvL1P \nand mvL0Q is greater than or equal to 4 in units of quarter luma frame samples. \nNOTE 5 – The determination of whether the reference pictures used for the two macroblock/sub-macroblock partitions \nare the same or different is based only on which pictures are referenced, without regard to whether a prediction is formed \nusing an index into reference picture list 0 or an index into reference picture list 1, and also without regard to whether the \nindex position within a reference picture list is different. \nNOTE 6 – A vertical difference of 4 in units of quarter luma frame samples is a difference of 2 in units of quarter luma \nfield samples \n–  Otherwise, bS is set equal to 0. \nThe variable interProfileConformanceFlag is derived as follows: \n–  If DQId is greater than 0, interLayerDeblockingFlag is equal to 0, and any of the following conditions are true, \ninterProfileConformanceFlag is set equal to 1: \n–  profile_idc is equal to 83 and constraint_set1_flag is equal to 1, \n–  profile_idc is equal to 86 and constraint_set0_flag is equal to 1. \n–  Otherwise, interProfileConformanceFlag is set equal to 0. \nWhen interProfileConformanceFlag is equal to 1 and both mbType[ mbAddrP ] and mbType[ mbAddrQ ] specify an Inter \nmacroblock prediction mode, it is a requirement of bitstream conformance that the following constraints are obeyed: \n–  When cTrafo[ mbAddrP ] is equal to T_8x8 and the array sTCoeff[ mbAddrP ] contains at least one non-zero scaled \ntransform coefficient value for the 8x8 luma transform block associated with the 8x8 luma block containing sample \np , the bitstream shall not contain data that result in an array rS  for which all sample values are equal to 0 for the 8x8 \n0 L\nluma block containing sample p . \n0\n–  When cTrafo[ mbAddrP ] is equal to T_4x4 and the array sTCoeff[ mbAddrP ] contains at least one non-zero scaled \ntransform coefficient value for the 4x4 luma transform block associated with the 4x4 luma block containing sample \np , the bitstream shall not contain data that result in an array rS  for which all sample values are equal to 0 for the 4x4 \n0 L\nluma block containing sample p . \n0\n–  When cTrafo[ mbAddrQ ] is equal to T_8x8 and the array sTCoeff[ mbAddrQ ] contains at least one non-zero scaled \ntransform coefficient value for the 8x8 luma transform block associated with the 8x8 luma block containing sample \nq , the bitstream shall not contain data that result in an array rS  for which all sample values are equal to 0 for the 8x8 \n0 L\nluma block containing sample q . \n0\n–  When cTrafo[ mbAddrQ ] is equal to T_4x4 and the array sTCoeff[ mbAddrQ ] contains at least one non-zero scaled \ntransform coefficient value for the 4x4 luma transform block associated with the 4x4 luma block containing sample \nq , the bitstream shall not contain data that result in an array rS  for which all sample values are equal to 0 for the 4x4 \n0 L\nluma block containing sample q . \n0\nG.8.8  Specification of bitstream subsets \nClause G.8.8.1 specifies the sub-bitstream extraction process. \nClause G.8.8.2 specifies the base layer bitstream. \n594  Rec. ITU-T H.264 (06/2019) \n \nG.8.8.1  Sub-bitstream extraction process \nIt is requirement of bitstream conformance that any sub-bitstream that is the output of the process specified in this clause \nwith pIdTarget equal to any value in the range of 0 to 63, inclusive, tIdTarget equal to any value in the range of 0 to 7, \ninclusive, dIdTarget equal to any value in the range of 0 to 7, inclusive, and qIdTarget equal to any value in the range of 0 \nto 15, inclusive, shall be conforming to this Recommendation | International Standard. \nNOTE – A conforming bitstream contains one or more coded slice NAL units with priority_id equal to 0, dependency_id equal to 0, \nquality_id equal to 0, and temporal_id equal to 0. \nInputs to this process are: \n–  a variable pIdTarget (when present), \n–  a variable tIdTarget (when present), \n–  a variable dIdTarget (when present), \n–  a variable qIdTarget (when present). \nOutput of this process is a sub-bitstream. \nWhen pIdTarget is not present as input to this clause, pIdTarget is inferred to be equal to 63. \nWhen tIdTarget is not present as input to this clause, tIdTarget is inferred to be equal to 7. \nWhen dIdTarget is not present as input to this clause, dIdTarget is inferred to be equal to 7. \nWhen qIdTarget is not present as input to this clause, qIdTarget is inferred to be equal to 15. \nThe sub-bitstream is derived by applying the following operations in sequential order: \n1.  Mark all VCL NAL units and filler data NAL units for which any of the following conditions are true as \"to be \nremoved from the bitstream\": \n–  priority_id is greater than pIdTarget, \n–  temporal_id is greater than tIdTarget, \n–  dependency_id is greater than dIdTarget, \n–  dependency_id is equal to dIdTarget and quality_id is greater than qIdTarget. \n2.  Remove all access units for which all VCL NAL units are marked as \"to be removed from the bitstream\". \n3.  Remove all VCL NAL units and filler data NAL units that are marked as \"to be removed from the bitstream\". \n4.  When dIdTarget is equal to 0 and qIdTarget is equal to 0, remove the following NAL units: \n–  all NAL units with nal_unit_type equal to 14 or 15, \n–  all NAL units with nal_unit_type equal to 6 in which the first SEI message has payloadType in the range of \n24 to 35, inclusive. \n5.  Remove all NAL units with nal_unit_type equal to 6 that only contain SEI messages that are part of a scalable \nnesting SEI message with any of the following properties: \n–  sei_temporal_id is greater than tIdTarget, \n–  the  minimum  value of  ( sei_dependency_id[ i ] << 4 ) + sei_quality_id[ i ] for all i  in  the range of 0 to \nnum_layer_representations_minus1, inclusive, is greater than ( dIdTarget << 4 ) + qIdTarget. \n6.  Remove all NAL units with nal_unit_type equal to 6 that contain SEI messages with payloadType equal to 24, \n28, or 29. \nG.8.8.2  Specification of the base layer bitstream \nEach scalable bitstream that conforms to this specification shall contain a base layer bitstream that conforms to one or \nmore of the profiles specified in Annex A. This base layer bitstream is derived by invoking the sub-bitstream extraction \nprocess as specified in clause G.8.8.1 with dIdTarget being equal to 0 and qIdTarget being equal to 0 and the base layer \nbitstream being the output. \nNOTE – Although all scalable bitstreams that conform to one or more of the profiles specified in this annex contain a base layer \nbitstream that conforms to one or more of the profiles specified in Annex A, the complete scalable bitstream (prior to operation of \nthe base layer extraction process specified in this clause) may not conform to any profile specified in Annex A. \n    Rec. ITU-T H.264 (06/2019)  595 \n \nG.9  Parsing process \nInputs to this process are bits from the RBSP, a request for a value of a syntax element, and values of prior parsed syntax \nelements (if applicable). \nOutput of this process is the value of the syntax element. \nThis process is invoked for all syntax elements in the syntax tables in clause G.7.3 with descriptors equal to u(v), ue(v), \nme(v), se(v), te(v), ce(v), and ae(v). \nWhen  the  parsing  process  is  invoked  for  the  first  request  for  a  value  of  a  syntax  element  in  the  slice  data  and \nentropy_coding_mode_flag is equal to 1, the following ordered steps apply: \n1.  The initialization process as specified in clause 9.3.1 is invoked, where a slice_type equal to EI is interpreted as \nI, a slice_type equal to EP is interpreted as P, and a slice_type equal to EB is interpreted as B. \n2.  The initialization process as specified in clause G.9.3.1 is invoked. \nDepending on entropy_coding_mode_flag and the descriptor, the value of a syntax element is derived as follows: \n–  If entropy_coding_mode_flag is equal to 0, the following applies: \n1.  The parsing process for syntax elements coded as coded as ue(v), se(v), or te(v) is specified in clause 9.1. \n2.  The parsing process for the syntax element coded_block_pattern is specified in clause G.9.1. \n3.  The  parsing  process  for  syntax  elements  of  the  residual_block_cavlc( )  syntax  structure  is  specified  in \nclause G.9.2. \n–  Otherwise (entropy_coding_mode_flag is equal to 1), the value of the syntax element is derived as follows: \n–  If the syntax element is equal to base_mode_flag, motion_prediction_flag_l0, motion_prediction_flag_l1, or \nresidual_prediction_flag, the following applies: \n1.  The binarization process as specified in clause G.9.3.2 is invoked. \n2.  The decoding process flow as specified in clause G.9.3.3 is invoked. \n–  Otherwise  (the  syntax  element  is  not  equal  to  base_mode_flag,  motion_prediction_flag_l0, \nmotion_prediction_flag_l1, or residual_prediction_flag), the following applies: \n1.  The binarization process as specified in clause 9.3.2 is invoked, where a slice_type equal to EI is \ninterpreted as I, a slice_type equal to EP is interpreted as P, and a slice_type equal to EB is interpreted \nas B. \n2.  The decoding process flow as specified in clause 9.3.3 is invoked. \nNOTE – For macroblocks with base_mode_flag equal to 1, mb_type is inferred to be equal to Mb_Inferred and \nthe specifications in clause G.7.4.6 apply. \n3.  When the syntax element is equal to mb_type and the decoded value of mb_type is equal to I_PCM, \nthe arithmetic decoding engine is initialized after decoding of any pcm_alignment_zero_bit and all \npcm_sample_luma and pcm_sample_chroma data as specified in clause 9.3.1.2. \nG.9.1  Alternative parsing process for coded block pattern \nThis process is invoked for the parsing syntax elements with descriptor equal to me(v) when entropy_coding_mode_flag \nis equal to 0. \nInputs to this process are bits from the RBSP. \nOutputs of this process is a value of the syntax element coded_block_pattern. \nThe parsing process for the syntax elements begins with reading the bits starting at the current location in the bitstream up \nto and including the first non-zero bit. By counting the number of leading bits that are equal to 0 and assigning this value \nto the variable leadingZeroBits, the variable codeNum is then derived as \ncodeNum = 2leadingZeroBits − 1 + read_bits( leadingZeroBits ) \nwhere the value returned from read_bits( leadingZeroBits ) is interpreted as a binary representation of an unsigned integer \nwith most significant bit written first. \nWhen ref_layer_dq_id is greater than or equal to 0 and ( scan_idx_end − scan_idx_start ) is less than 15, codeNum is set \nequal to (codeNum − 1). \nDepending on codeNum, the following applies: \n596  Rec. ITU-T H.264 (06/2019) \n \n–  If codeNum is equal to −1, the following ordered steps are specified: \n1.  The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is \nassigned to mbAddrA and mbAddrB. \n2.  When mbAddrN is available, the variable codedBlockPatternN (with N being either A or B) is derived as follows: \n–  If mb_type for the macroblock mbAddrN is equal to P_Skip, B_Skip, or I_PCM, codedBlockPatternN is set \nequal to 0. \n–  Otherwise  (mb_type  for  the  macroblock  mbAddrN  is  not  equal  to  P_Skip,  B_Skip,  or  I_PCM), \ncodedBlockPatternN is set equal to (16 * cbpChromaN + cbpLumaN) with cbpChromaN and cbpLumaN \nrepresenting the values of CodedBlockPatternLuma and CodedBlockPatternChroma for the macroblock \nmbAddrN. \n3.  Depending on mbAddrA and mbAddrB, the following applies: \n–  If mbAddrA is available, coded_block_pattern is set equal to codedBlockPatternA. \n–  Otherwise, if mbAddrB is available, coded_block_pattern is set equal to codedBlockPatternB. \n–  Otherwise (mbAddrA and mbAddrB are not available), coded_block_pattern is set equal to 0. \n–  Otherwise (codeNum is greater than or equal to 0), the mapping process for coded block pattern as specified in \nclause 9.1.2 is invoked with codeNum as input and the output is assigned to the syntax element coded_block_pattern. \nG.9.2  Alternative CAVLC parsing process for transform coefficient levels \nThis process is invoked for the parsing syntax elements with descriptor equal to ce(v) when entropy_coding_mode_flag is \nequal to 0. \nInputs to this process are a request for a value of a syntax element, bits from slice data, a maximum number of non-zero \ntransform  coefficient  levels  maxNumCoeff,  the  luma  block  index  luma4x4BlkIdx  or  the  chroma  block  index \nchroma4x4BlkIdx, cb4x4BlkIdx or cr4x4BlkIdx of the current block of transform coefficient levels. \nOutput of this process is the list coeffLevel containing transform coefficient levels of the luma block with block index \nluma4x4BlkIdx or the chroma block with block index chroma4x4BlkIdx, cb4x4BlkIdx or cr4x4BlkIdx. \nThe process is specified in the following ordered steps: \n1.  All transform coefficient levels, with indices from 0 to maxNumCoeff − 1, in the list coeffLevel are set equal to 0. \n2.  The total number of non-zero transform coefficient levels TotalCoeff( coeff_token ) and the number of trailing \none transform coefficient levels TrailingOnes( coeff_token ) are derived by parsing coeff_token as specified by \nthe following ordered steps: \na.  The  parsing  process  of  coeff_token  as  specified  in  clause 9.2.1  is  invoked  and  the  outputs  are \nTotalCoeff( coeff_token ), TrailingOnes( coeff_token ), and nC. \nNOTE – For macroblocks with base_mode_flag equal to 1, mb_type is inferred to be equal to Mb_Inferred and \nthe specifications in clause G.7.4.6 apply. \nb.  When the CAVLC parsing process is invoked for LumaLevel4x4, LumaLevel8x8, Intra16x16ACLevel, \nChromaACLevel, CbIntra16x16ACLevel, or CrIntra16x16ACLevel and ( scan_idx_end − scan_idx_start ) is \nless than 15, nC is modified by setting it equal to Min( 7, nC ), and the additional parsing process for total \nnumber of non-zero transform coefficient levels and number of trailing ones as specified in clause G.9.2.1 is \ninvoked with nC, totalCoeffStart set equal to TotalCoeff( coeff_token ), and trailingOnesStart set equal to \nTrailingOnes( coeff_token ) as the inputs and the outputs are assigned to TotalCoeff( coeff_token ) and \nTrailingOnes( coeff_token ). \n3.  When TotalCoeff( coeff_token ) is greater than 0, the following ordered steps are specified: \na.  The non-zero transform coefficient levels are derived by parsing trailing_ones_sign_flag, level_prefix, and \nlevel_suffix as specified in clause 9.2.2. \nb.  The runs of zero transform coefficient levels before each non-zero transform coefficient level are derived by \nparsing total_zeros and run_before as specified in clause G.9.2.2. \nc.  The level and run information are combined into the list coeffLevel as specified in clause 9.2.4. \nG.9.2.1  Additional parsing process for total number of non-zero transform coefficient levels and number of trailing \nones \nInputs to this process are variables nC, totalCoeffStart, and trailingOnesStart. \n    Rec. ITU-T H.264 (06/2019)  597 \n \nOutputs of this process are variables totalCoeff and trailingOnes. \nLet  invTotalCoeff( coeffTokenIdx )  and  invTrailingOnes( coeffTokenIdx)  be  functions  that  map  the  variable \ncoeffTokenIdx to the variables nX and nY, respectively, as specified in Table G-10 for each value of the variable nC. \nA  variable  dX  is  set  equal  to  (scan_idx_end − scan_idx_start + 2).  A  variable  dY  is  set  equal  to \nMin( 4, scan_idx_end − scan_idx_start + 2 ). A variable targetCoeffTokenIdx is derived as specified by Table G-10 given \nthe variables nC, nX = totalCoeffStart, and nY = trailingOnesStart. \nThe bitstream shall not contain data that result in a value of targetCoeffTokenIdx that exceeds the range of values from 0 \nto ( dX * dY − Min( 7, ( 1 << ( dY − 1 ) ) ) ), inclusive. \nA variable coeffTokenIdx is derived as specified by the following pseudo code: \nfor( coeffTokenIdx = 0, i = 0; i <= targetCoeffTokenIdx; coeffTokenIdx++ ) \n   if( invTotalCoeff( coeffTokenIdx ) < dX  &&  invTrailingOnes( coeffTokenIdx ) < dY )  (G-359) \n      i++ \nThe variable totalCoeff is set equal to invTotalCoeff( coeffTokenIdx − 1 ) and the variable trailingOnes is set equal to \ninvTrailingOnes( coeffTokenIdx − 1 ). \nWhen the CAVLC parsing process is invoked for Intra16x16ACLevel, CbIntra16x16ACLevel, CrIntra16x16ACLevel, or \nChromaACLevel, it is a requirement of bitstream conformance that the bitstream shall not contain data that result in \ntotalCoeff being greater than (scan_idx_end − Max( 1, scan_idx_start ) + 1). \nTable G-10 – Mapping of ( nX, nY ) to coeffTokenIdx and vice versa \nnY  nX  0 <= nC < 2  2 <= nC < 4  4 <= nC < 8 \n0  0  0  0  0 \n0  1  4  7  16 \n1  1  1  1  1 \n0  2  9  11  20 \n1  2  5  5  8 \n2  2  2  2  2 \n0  3  13  15  23 \n1  3  10  8  11 \n2  3  7  9  9 \n3  3  3  3  3 \n0  4  17  19  24 \n1  4  14  12  13 \n2  4  11  13  12 \n3  4  6  4  4 \n0  5  21  22  28 \n1  5  18  16  15 \n2  5  15  17  14 \n3  5  8  6  5 \n0  6  25  23  30 \n1  6  22  20  17 \n2  6  19  21  18 \n3  6  12  10  6 \n0  7  29  27  31 \n1  7  26  24  21 \n598  Rec. ITU-T H.264 (06/2019) \n \nTable G-10 – Mapping of ( nX, nY ) to coeffTokenIdx and vice versa \nnY  nX  0 <= nC < 2  2 <= nC < 4  4 <= nC < 8 \n2  7  23  25  22 \n3  7  16  14  7 \n0  8  32  31  32 \n1  8  30  28  25 \n2  8  27  29  26 \n3  8  20  18  10 \n0  9  33  35  36 \n1  9  34  32  33 \n2  9  31  33  29 \n3  9  24  26  19 \n0  10  37  39  40 \n1  10  38  36  37 \n2  10  35  37  34 \n3  10  28  30  27 \n0  11  41  42  44 \n1  11  42  40  41 \n2  11  39  41  38 \n3  11  36  34  35 \n0  12  45  43  47 \n1  12  46  44  45 \n2  12  43  45  42 \n3  12  40  38  39 \n0  13  50  47  49 \n1  13  49  48  48 \n2  13  47  49  46 \n3  13  44  46  43 \n0  14  54  51  53 \n1  14  51  54  50 \n2  14  52  52  51 \n3  14  48  50  52 \n0  15  58  55  57 \n1  15  55  56  54 \n2  15  56  57  55 \n3  15  53  53  56 \n0  16  61  59  61 \n1  16  59  60  58 \n2  16  60  61  59 \n    Rec. ITU-T H.264 (06/2019)  599 \n \nTable G-10 – Mapping of ( nX, nY ) to coeffTokenIdx and vice versa \nnY  nX  0 <= nC < 2  2 <= nC < 4  4 <= nC < 8 \n3  16  57  58  60 \nG.9.2.2  Alternative parsing process for run information \nInputs  to  this  process  are  bits  from  slice  data  and  the  number  of  non-zero  transform  coefficient  levels \nTotalCoeff( coeff_token ). \nOutput of this process is a list of runs of zero transform coefficient levels preceding non-zero transform coefficient levels \ncalled runVal. \nThe variable maxCoeff is derived as follows: \n–  If the CAVLC parsing process is invoked for Intra16x16DCLevel, CbIntra16x16DCLevel, or CrIntra16x16DCLevel, \nmaxCoeff is set equal to 16. \n–  Otherwise,  if  the  CAVLC  parsing  process  is  invoked  for  ChromaDCLevel,  maxCoeff  is  set  equal  to \n4 * chroma_format_idc. \n–  Otherwise, if the CAVLC parsing process is invoked for LumaLevel4x4 or LumaLevel8x8, maxCoeff is set equal to \n(scan_idx_end − scan_idx_start + 1). \n–  Otherwise  (the  CAVLC  parsing  process  is  invoked  for  Intra16x16ACLevel,  CbIntra16x16ACLevel, \nCrIntra16x16ACLevel, or ChromaACLevel), maxCoeff is set equal to (scan_idx_end − Max( 1, scan_idx_start ) + 1). \nInitially, an index i is set equal to 0. \nThe variable zerosLeft is derived as follows: \n–  If the number of non-zero transform coefficient levels TotalCoeff( coeff_token ) is equal to the maximum number of \nnon-zero transform coefficient levels maxCoeff, a variable zerosLeft is set equal to 0. \n–  Otherwise (the number of non-zero transform coefficient levels TotalCoeff( coeff_token ) is less than the maximum \nnumber of non-zero transform coefficient levels maxCoeff), total_zeros is decoded and zerosLeft is set equal to its \nvalue. \nThe VLC used to decode total_zeros is derived as follows: \n–  If maxCoeff is less than or equal to 4, one of the VLCs specified in Table 9-9(a) is used with tzVlcIndex being derived \nby \ntzVlcIndex = TotalCoeff( coeff_token ) + 4 − maxCoeff  (G-360) \n–  Otherwise, if maxCoeff is greater than 4 and less than or equal to 8, one of the VLCs specified in Table 9-9(b) is used \nwith tzVlcIndex being derived by \ntzVlcIndex = TotalCoeff( coeff_token ) + 8 − maxCoeff  (G-361) \n–  Otherwise, if maxCoeff is greater than 8 and less than 15, VLCs from Tables 9-7 and 9-8 are used with tzVlcIndex \nbeing derived by \ntzVlcIndex = TotalCoeff( coeff_token ) + 16 − maxCoeff  (G-362) \n–  Otherwise (maxCoeff is greater than or equal to 15), VLCs from Tables 9-7 and 9-8 are used with tzVlcIndex equal \nto TotalCoeff( coeff_token ). \nThe following procedure is then applied iteratively (TotalCoeff( coeff_token ) − 1) times: \n1.  The variable runVal[ i ] is derived as follows: \n–  If zerosLeft is greater than zero, a value run_before is decoded based on Table 9-10 and zerosLeft. runVal[ i ] \nis set equal to run_before. \n–  Otherwise (zerosLeft is equal to 0), runVal[ i ] is set equal to 0. \n2.  The value of runVal[ i ] is subtracted from zerosLeft and the result assigned to zerosLeft. The result of the \nsubtraction shall be greater than or equal to 0. \n600  Rec. ITU-T H.264 (06/2019) \n \n3.  The index i is incremented by 1. \nFinally the value of zerosLeft is assigned to runVal[ i ]. \nG.9.3  Alternative CABAC parsing process for slice data in scalable extension \nClause G.9.3.1 specifies the initialization process for the alternative CABAC parsing process for slice data in scalable \nextension. \nClause G.9.3.2 specifies the binarization process for the alternative CABAC parsing process for slice data in scalable \nextension. \nClause G.9.3.3 specifies the decoding process flow for the alternative CABAC parsing process for slice data in scalable \nextension. \nG.9.3.1  Initialization process \nOutputs of this process are the initialized CABAC context variables indexed by ctxIdx. \nTables G-12 and G-13 contain the values of the variables n and m used in the initialization of context variables that are \nassigned  to  syntax  element  base_mode_flag,  motion_prediction_flag_l0,  motion_prediction_flag_l1,  and \nresidual_prediction_flag in clause G.7.3.4.1 and G.7.3.6. For all other syntax elements in clauses G.7.3.4.1 and G.7.3.6 the \ninitialization process of context variables as specified in clause 9.3.1 applies. \nFor each context variable, the two variables pStateIdx and valMPS are initialized. The two values assigned to pStateIdx \nand valMPS for the initialization are derived from SliceQP , which is derived in Equation 7-30. Given the two table entries \nY\n( m, n ), the initialization is specified by the following pseudo-code process: \npreCtxState = Clip3( 1, 126, ( ( m  Clip3( 0, 51, SliceQP  ) ) >> 4 ) + n ) \nY\nif( preCtxState  <=  63 )  { \n  pStateIdx = 63 − preCtxState \n  valMPS = 0 \n} else {      (G-363) \n  pStateIdx = preCtxState − 64 \n  valMPS = 1 \n} \n \nIn Table G-11, the ctxIdx for which initialization is needed for each of the slice types EI, EP, and EB are listed. Also listed \nis the table number that includes the values of m and n needed for the initialization. For EP and EB slices, the initialization \ndepends also on the value of the cabac_init_idc syntax element. Note that the syntax element names do not affect the \ninitialization process. \nTable G-11 – Association of ctxIdx and syntax elements for each slice type in the initialization process \nSlice type \n  Syntax element  Table \nEI  EP  EB \nmacroblock_layer_in_scalable_extension( )  base_mode_flag  Table G-12  1024..1026  1024..1026  1024..1026 \nmotion_prediction_flag_l0  Table G-13    1027  1027 \nmb_pred_in_scalable_extension( ) and \nsub_mb_pred_in_scalable_extension( ) \nmotion_prediction_flag_l1  Table G-13    1028  1028 \nmacroblock_layer_in_scalable_extension( )  residual_prediction_flag  Table G-13    1029..1030  1029..1030 \n \n    Rec. ITU-T H.264 (06/2019)  601 \n \nTable G-12 – Values of variables m and n for ctxIdx from 1024 to 1026 \nValue of cabac_init_idc (EP, EB slices) \nEI slices \nctxIdx  0  1  2 \nm  n  m  n  m  n  m  n \n1024  −14  138  0  75  0  75  0  75 \n1025  −22  140  2  65  2  65  2  65 \n1026  −11  99  2  59  2  59  2  59 \n \nTable G-13 – Values of variables m and n for ctxIdx from 1027 to 1030 \nValue of cabac_init_idc \nctxIdx  0  1  2 \nm  n  m  n  m  n \n1027  −6  67  −6  67  −6  67 \n1028  −6  67  −6  67  −6  67 \n1029  −23  104  −23  104  −23  104 \n1030  −35  106  −35  106  −35  106 \n \nG.9.3.2  Binarization process \nInput to this process is a request for a syntax element. \nOutput of this process is the binarization of the syntax element, maxBinIdxCtx, ctxIdxOffset, and bypassFlag. \nAssociated with each binarization or binarization part of a syntax element is a specific value of the context index offset \n(ctxIdxOffset) variable and a specific value of the maxBinIdxCtx variable as given in Table G-14. \nThe variable bypassFlag is set equal to 0. \nThe possible values of the context index ctxIdx are in the range 1024 to 1030, inclusive. The value assigned to ctxIdxOffset \nspecifies the lower value of the range of ctxIdx assigned to the corresponding binarization or binarization part of a syntax \nelement. \nTable G-14 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset \nSyntax element  Type of binarization  maxBinIdxCtx  ctxIdxOffset \nbase_mode_flag  FL, cMax=1  0  1024 \nmotion_prediction_flag_l0  FL, cMax=1  0  1027 \nmotion_prediction_flag_l1  FL, cMax=1  0  1028 \nresidual_prediction_flag  FL, cMax=1  0  1029 \nG.9.3.3  Decoding process flow \nInput to this process is a binarization of the requested syntax element, maxBinIdxCtx, bypassFlag and ctxIdxOffset as \nspecified in clause G.9.3.2. \nOutput of this process is the value of the syntax element. \nThis process specifies how each bit of a bit string is parsed for each syntax element. \n602  Rec. ITU-T H.264 (06/2019) \n \nAfter parsing each bit, the resulting bit string is compared to all bin strings of the binarization of the syntax element and \nthe following applies: \n–  If the bit string is equal to one of the bin strings, the corresponding value of the syntax element is the output. \n–  Otherwise (the bit string is not equal to one of the bin strings), the next bit is parsed. \nWhile parsing each bin, the variable binIdx is incremented by 1 starting with binIdx being set equal to 0 for the first bin. \nThe parsing of each bin is specified by the following two ordered steps: \n1.  Given binIdx, maxBinIdxCtx and ctxIdxOffset, ctxIdx is derived as specified in clause G.9.3.3.1. \n2.  Given ctxIdx, the value of the bin from the bitstream as specified in clause 9.3.3.2 is decoded. \nG.9.3.3.1  Derivation process for ctxIdx \nInputs to this process are binIdx, maxBinIdxCtx and ctxIdxOffset. \nOutput of this process is ctxIdx. \nTable G-15 shows the assignment of ctxIdx increments (ctxIdxInc) to binIdx for all ctxIdxOffset values for the syntax \nelements base_mode_flag, motion_prediction_flag_l0, motion_prediction_flag_l1, and residual_prediction_flag. \nThe ctxIdx to be used with a specific binIdx is the sum of ctxIdxOffset and ctxIdxInc, which is found in Table G-15. When \nmore than one value is listed in Table G-15 or 9-39 for a binIdx, the assignment process for ctxIdxInc for that binIdx is \nfurther specified in the clauses given in parenthesis of the corresponding table entry. \nAll entries in Table G-15 labelled with \"na\" correspond to values of binIdx that do not occur for the corresponding \nctxIdxOffset. \nTable G-15 – Assignment of ctxIdxInc to binIdx for the ctxIdxOffset values related to the syntax elements \nbase_mode_flag and residual_prediction_flag \nbinIdx \nctxIdxOffset \n0  1  2  3  4   5  >= 6 \n0,1,2 \n1024  na  na  na  na  na  na \n(clause G.9.3.3.2.1) \n1027  0  na  na  na  na  na  na \n1028  0  na  na  na  na  na  na \n0,1 \n1029  na  na  na  na  na  na \n(clause G.9.3.3.2.2) \nG.9.3.3.2  Assignment process of ctxIdxInc using neighbouring syntax elements \nClause G.9.3.3.2.1 specifies the derivation process of ctxIdxInc for the syntax element base_mode_flag. \nClause G.9.3.3.2.2 specifies the derivation process of ctxIdxInc for the syntax element residual_prediction_flag. \nG.9.3.3.2.1  Derivation process of ctxIdxInc for the syntax element base_mode_flag \nOutput of this process is ctxIdxInc. \nThe derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to \nmbAddrA and mbAddrB. \nLet the variable condTermFlagN (with N being either A or B) be derived as follows: \n–  If mbAddrN is available and base_mode_flag for the macroblock mbAddrN is equal to 1, condTermFlagN is set equal \nto 0. \n–  Otherwise  (mbAddrN  is  not  available  or  base_mode_flag  for  the  macroblock  mbAddrN  is  equal  to 0), \ncondTermFlagN is set equal to 1. \nThe variable ctxIdxInc is derived by \nctxIdxInc = condTermFlagA + condTermFlagB  (G-364) \n    Rec. ITU-T H.264 (06/2019)  603 \n \nG.9.3.3.2.2  Derivation process of ctxIdxInc for the syntax element residual_prediction_flag \nOutput of this process is ctxIdxInc. \nDepending on base_mode_flag, the following applies: \n–  If base_mode_flag is equal to 1, ctxIdxInc is set equal to 0. \n–  Otherwise (base_mode_flag is equal to 0), ctxIdxInc is set equal to 1. \nG.10  Profiles and levels \nThe specifications in Annex A apply. Additional profiles and specific values of profile_idc are specified in the following. \nThe profiles that are specified in clause G.10.1 are also referred to as the profiles specified in Annex G. \nG.10.1  Profiles \nAll constraints for picture parameter sets that are specified in clauses G.10.1.1 to G.10.1.3 are constraints for picture \nparameter sets that become the active picture parameter set or an active layer picture parameter set inside the bitstream. \nAll constraints for SVC sequence parameter sets that are specified in clauses G.10.1.1 to G.10.1.3 are constraints for SVC \nsequence parameter sets that become the active SVC sequence parameter set or an active layer SVC sequence parameter \nset inside the bitstream. All constraints for sequence parameter sets of the base layer bitstream that are specified in \nclauses G.10.1.1 to G.10.1.3 are constraints for sequence parameter sets that are activated in the base layer bitstream. \nG.10.1.1 Scalable Baseline profile \nBitstreams conforming to the Scalable Baseline profile shall obey the following constraints: \na)  The base layer bitstream as specified in clause G.8.8.2 shall obey the following constraints: \ni)  All constraints of the Baseline and Constrained Baseline profiles specified in clauses A.2.1 and A.2.1.1 \nshall be obeyed. \nii)  Sequence  parameter  sets  should  have  profile_idc  equal  to  66.  Sequence  parameter  sets  may  have \nprofile_idc equal to 77 or 88. Sequence parameter sets shall not have profile_idc equal to a value other \nthan 66, 77, or 88. \niii)  Sequence parameter sets shall have constraint_set0_flag, constraint_set1_flag, and constraint_set2_flag \nequal to 1. \nNOTE 1 – The above constraint implies that picture parameter sets must have num_slice_groups_minus1 equal to 0 and \nredundant_pic_cnt_present_flag equal to 0 and that arbitrary slice order is not allowed. \nNOTE 2 – In addition to the base layer constraints specified above in items i) through iii), the value of the syntax element \nconstrained_intra_pred_flag for picture parameter sets of the base layer stream is constrained as specified below in item l). \nb)  A list of integer values specifying layer representation identifiers is derived by invoking the process specified in \nclause G.8.1.1 with the output being the list dqIdList. The SVC sequence parameter sets that are referred to by \ncoded slice NAL units with DQId greater than 0 and DQId in the list dqIdList shall have profile_idc equal to 83 \nor (profile_idc equal to 86 and constraint_set0_flag equal to 1). \nc)  Only I, P, EI, EP, and EB slices shall be present. \nd)  SVC sequence parameter sets shall have chroma_format_idc equal to 1. \ne)  SVC sequence parameter sets shall have bit_depth_luma_minus8 equal to 0. \nf)  SVC sequence parameter sets shall have bit_depth_chroma_minus8 equal to 0. \ng)  SVC sequence parameter sets shall have separate_colour_plane_flag equal to 0. \nh)  SVC sequence parameter sets shall have qpprime_y_zero_transform_bypass_flag equal to 0. \ni)  SVC sequence parameter sets shall have frame_mbs_only_flag equal to 1. \nj)  Picture parameter sets shall have num_slice_groups_minus1 in the range of 0 to 7, inclusive. \nk)  The value of slice_group_map_type, when present in picture parameter sets, shall be equal to 2. \nl)  A list of integer values specifying layer representation identifiers is derived by invoking the process specified in \nclause G.8.1.1 with the output being the list dqIdList. The variable numDQEntries is set equal to the number of \nelements  in  the  list  dqIdList.  When  numDQEntries  is  greater  than  1,  for  any  element  dqIdList[ i ]  with \ni = 1..(numDQEntries − 1), when MaxTCoeffLevelPredFlag is equal to 0 for any layer representation with DQId \nin the set specified by dqIdList[ k ] with k = 0..i, the picture parameter set that is referenced by the coded slice \n604  Rec. ITU-T H.264 (06/2019) \n \nNAL units of the layer representation with DQId equal to dqIdList[ i ] shall have constrained_intra_pred_flag \nequal to 1. \nm)  For  each  present  layer  representation  with  dependency_id  greater  than  0,  quality_id  equal  to  0,  and \nMinNoInterLayerPredFlag equal to 0, one of the following constraints shall be obeyed. \n–  ScaledRefLayerPicWidthInSamples  is equal to RefLayerPicWidthInSamples  and \nL L\nScaledRefLayerPicHeightInSamples  is equal to RefLayerPicHeightInSamples  \nL L\n–  ScaledRefLayerPicWidthInSamples  is equal to (1.5 * RefLayerPicWidthInSamples ) and \nL L\nScaledRefLayerPicHeightInSamples  is equal to (1.5 * RefLayerPicHeightInSamples ) \nL L\n–  ScaledRefLayerPicWidthInSamples  is equal to (2 * RefLayerPicWidthInSamples ) and \nL L\nScaledRefLayerPicHeightInSamples  is equal to (2 * RefLayerPicHeightInSamples ) \nL L\nn)  For  each  present  layer  representation  with  dependency_id  greater  than  0,  quality_id  equal  to  0,  and \nMinNoInterLayerPredFlag equal to 0, all of the following constraints shall be obeyed. \n–  (ScaledRefLayerLeftOffset % 16) is equal to 0 \n–  (ScaledRefLayerTopOffset % 16) is equal to 0 \no)  The level constraints specified in clause G.10.2 shall be fulfilled. \nConformance of a bitstream to the Scalable Baseline profile is indicated by profile_idc equal to 83. \nDecoders conforming to the Scalable Baseline profile at a specific level shall be capable of decoding all bitstreams in \nwhich both of the following conditions are true: \na)  All active SVC sequence parameter sets have one of the following conditions fulfilled: \n–  profile_idc is equal to 83, \n–  profile_idc is equal to 86 and constraint_set0_flag is equal to 1, \n–  profile_idc is equal to 66 and constraint_set1_flag is equal to 1, \n–  profile_idc is equal to 77 and constraint_set0_flag is equal to 1, \n–  profile_idc is equal to 88, constraint_set0_flag is equal to 1, and constraint_set1_flag is equal to 1. \nb)  level_idc or (level_idc and constraint_set3_flag) for all active SVC sequence parameter sets represent a level less \nthan or equal to the specified level. \nG.10.1.1.1  Scalable Constrained Baseline profile \nBitstreams conforming to the Scalable Constrained Baseline profile shall obey the following constraints: \na)  The base layer bitstream as specified in clause G.8.8.2 shall obey the following constraints: \ni)  All constraints of the Baseline and Constrained Baseline profiles specified in clauses A.2.1 and A.2.1.1 \nshall be obeyed. \nii)  Sequence  parameter  sets  should  have  profile_idc  equal  to  66.  Sequence  parameter  sets  may  have \nprofile_idc equal to 77 or 88. Sequence parameter sets shall not have profile_idc equal to a value other \nthan 66, 77, or 88. \niii)  Sequence parameter sets shall have constraint_set0_flag, constraint_set1_flag, and constraint_set2_flag \nequal to 1. \nNOTE 1 – The above constraint implies that picture parameter sets must have num_slice_groups_minus1 equal \nto 0 and redundant_pic_cnt_present_flag equal to 0 and that arbitrary slice order is not allowed. \nNOTE 2 – In addition to the base layer constraints specified above in items i) through iii), the value of the syntax \nelement constrained_intra_pred_flag for picture parameter sets of the base layer stream is constrained as specified \nbelow in item m). \nb)  A list of integer values specifying layer representation identifiers is derived by invoking the process specified in \nclause G.8.1.1 with the output being the list dqIdList. The SVC sequence parameter sets that are referred to by \ncoded slice NAL units with DQId greater than 0 and DQId in the list dqIdList shall have profile_idc equal to 83 \nand  both  constraint_set1_flag  and  constraint_set5_flag  equal  to  1  or  (profile_idc  equal  to  86  and  both \nconstraint_set0_flag and constraint_set5_flag equal to 1). \nc)  Only I, P, EI, and EP slices shall be present. \nd)  SVC sequence parameter sets shall have chroma_format_idc equal to 1. \n    Rec. ITU-T H.264 (06/2019)  605 \n \ne)  SVC sequence parameter sets shall have bit_depth_luma_minus8 equal to 0. \nf)  SVC sequence parameter sets shall have bit_depth_chroma_minus8 equal to 0. \ng)  SVC sequence parameter sets shall have separate_colour_plane_flag equal to 0. \nh)  SVC sequence parameter sets shall have qpprime_y_zero_transform_bypass_flag equal to 0. \ni)  SVC sequence parameter sets shall have frame_mbs_only_flag equal to 1. \nj)  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0. \nk)  Picture parameter sets shall have num_slice_groups_minus1 equal to 0. \nl)  Arbitrary slice order is not allowed. \nm)  A list of integer values specifying layer representation identifiers is derived by invoking the process specified in \nclause G.8.1.1 with the output being the list dqIdList. The variable numDQEntries is set equal to the number of \nelements  in  the  list  dqIdList.  When  numDQEntries  is  greater  than  1,  for  any  element  dqIdList[ i ]  with \ni = 1..(numDQEntries − 1), when MaxTCoeffLevelPredFlag is equal to 0 for any layer representation with DQId \nin the set specified by dqIdList[ k ] with k = 0..i, the picture parameter set that is referenced by the coded slice \nNAL units of the layer representation with DQId equal to dqIdList[ i ] shall have constrained_intra_pred_flag \nequal to 1. \nn)  For  each  present  layer  representation  with  dependency_id  greater  than  0,  quality_id  equal  to  0,  and \nMinNoInterLayerPredFlag equal to 0, one of the following constraints shall be obeyed. \n–  ScaledRefLayerPicWidthInSamples   is  equal  to  RefLayerPicWidthInSamples   and \nL L\nScaledRefLayerPicHeightInSamples  is equal to RefLayerPicHeightInSamples  \nL L\n–  ScaledRefLayerPicWidthInSamples   is  equal  to  (1.5 * RefLayerPicWidthInSamples )  and \nL L\nScaledRefLayerPicHeightInSamples  is equal to (1.5 * RefLayerPicHeightInSamples ) \nL L\n–  ScaledRefLayerPicWidthInSamples   is  equal  to  (2 * RefLayerPicWidthInSamples )  and \nL L\nScaledRefLayerPicHeightInSamples  is equal to (2 * RefLayerPicHeightInSamples ) \nL L\no)  For  each  present  layer  representation  with  dependency_id  greater  than  0,  quality_id  equal  to  0,  and \nMinNoInterLayerPredFlag equal to 0, all of the following constraints shall be obeyed. \n–  (ScaledRefLayerLeftOffset % 16) is equal to 0 \n–  (ScaledRefLayerTopOffset % 16) is equal to 0 \np)  The level constraints specified in clause G.10.2 shall be fulfilled. \nConformance of a bitstream to the Scalable Constrained Baseline profile is indicated by constraint_set5_flag being equal \nto 1 with profile_idc equal to 83. \nDecoders conforming to the Scalable Constrained Baseline profile at a specific level shall be capable of decoding all \nbitstreams in which both of the following conditions are true: \na)  All active SVC sequence parameter sets have one of the following conditions fulfilled: \n–  profile_idc is equal to 83 and constraint_set5_flag is equal to 1, \n–  profile_idc is equal to 86, constraint_set0_flag is equal to 1, and constraint_set5_flag equal to 1, \n–  profile_idc is equal to 66 and constraint_set1_flag is equal to 1, \n–  profile_idc is equal to 77 and constraint_set0_flag is equal to 1, \n–  profile_idc is equal to 88, constraint_set0_flag is equal to 1, and constraint_set1_flag is equal to 1. \nb)  level_idc or (level_idc and constraint_set3_flag) for all active SVC sequence parameter sets represent a level less \nthan or equal to the specified level. \n606  Rec. ITU-T H.264 (06/2019) \n \nG.10.1.2 Scalable High profile \nBitstreams conforming to the Scalable High profile shall obey the following constraints: \na)  The base layer bitstream as specified in clause G.8.8.2 shall obey the following constraints: \ni)  All constraints of the High profile specified in clause A.2.4 shall be obeyed. \nii)  Sequence  parameter  sets  should  have  profile_idc  equal  to  100.  Sequence  parameter  sets  may  have \nprofile_idc equal to 66, 77, or 88 and constraint_set1_flag equal to 1. Sequence parameter sets shall not \nhave profile_idc equal to a value other than 66, 77, 88, or 100. \niii)  The syntax element direct_spatial_mv_pred_flag shall be equal to 1. \nNOTE – In addition to the base layer constraints specified above in items i) through iii), the value of the syntax element \nconstrained_intra_pred_flag for picture parameter sets of the base layer stream is constrained as specified below in item k). \nb)  A list of integer values specifying layer representation identifiers is derived by invoking the process specified in \nclause G.8.1.1 with the output being the list dqIdList. The SVC sequence parameter sets that are referred to by \ncoded slice NAL units with DQId greater than 0 and DQId in the list dqIdList shall have profile_idc equal to 86 \nor (profile_idc equal to 83 and constraint_set1_flag equal to 1). \nc)  Only I, P, B, EI, EP, and EB slices shall be present. \nd)  SVC sequence parameter sets shall have chroma_format_idc equal to 1. \ne)  SVC sequence parameter sets shall have bit_depth_luma_minus8 equal to 0. \nf)  SVC sequence parameter sets shall have bit_depth_chroma_minus8 equal to 0. \ng)  SVC sequence parameter sets shall have separate_colour_plane_flag equal to 0. \nh)  SVC sequence parameter sets shall have qpprime_y_zero_transform_bypass_flag equal to 0. \ni)  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0. \nj)  Picture parameter sets shall have num_slice_groups_minus1 equal to 0. \nk)  A list of integer values specifying layer representation identifiers is derived by invoking the process specified in \nclause G.8.1.1 with the output being the list dqIdList. The variable numDQEntries is set equal to the number of \nelements  in  the  list  dqIdList.  When  numDQEntries  is  greater  than  1,  for  any  element  dqIdList[ i ]  with \ni = 1..(numDQEntries − 1), when MaxTCoeffLevelPredFlag is equal to 0 for any layer representation with DQId \nin the set specified by dqIdList[ k ] with k = 0..i, the picture parameter set that is referenced by the coded slice \nNAL units of the layer representation with DQId equal to dqIdList[ i ] shall have constrained_intra_pred_flag \nequal to 1. \nl)  Arbitrary slice order is not allowed. \nm)  The level constraints specified in clause G.10.2 shall be fulfilled. \nConformance of a bitstream to the Scalable High profile is indicated by profile_idc equal to 86. \nDecoders conforming to the Scalable High profile at a specific level shall be capable of decoding all bitstreams in which \nboth of the following conditions are true: \na)  All active SVC sequence parameter sets have one of the following conditions fulfilled: \n–  profile_idc is equal to 86, \n–  profile_idc is equal to 83 and constraint_set1_flag is equal to 1, \n–  profile_idc is equal to 77 or 100, \n–  profile_idc is equal to 66 or 88 and constraint_set1_flag is equal to 1. \nb)  level_idc or (level_idc and constraint_set3_flag) for all active SVC sequence parameter sets represent a level less \nthan or equal to the specified level. \nG.10.1.2.1  Scalable Constrained High profile \nBitstreams conforming to the Scalable Constrained High profile shall obey the following constraints: \na)  The base layer bitstream as specified in clause G.8.8.2 shall obey the following constraints: \ni)  All constraints of the Constrained High profile specified in clause A.2.4.2 shall be obeyed. \n    Rec. ITU-T H.264 (06/2019)  607 \n \nii)  Sequence  parameter  sets  should  have  profile_idc  equal  to  100.  Sequence  parameter  sets  may  have \nprofile_idc equal to 66, 77, or 88 and constraint_set1_flag equal to 1. Sequence parameter sets shall not \nhave profile_idc equal to a value other than 66, 77, 88, or 100. \niii)  The syntax element direct_spatial_mv_pred_flag shall be equal to 1. \nNOTE – In addition to the base layer constraints specified above in items i) through iii), the value of the syntax \nelement constrained_intra_pred_flag for picture parameter sets of the base layer stream is constrained as specified \nbelow in item l). \nb)  A list of integer values specifying layer representation identifiers is derived by invoking the process specified in \nclause G.8.8.1 with the output being the list dqIdList. The SVC sequence parameter sets that are referred to by \ncoded slice NAL units with DQId greater than 0 and DQId in the list dqIdList shall have profile_idc equal to 86 \nand  constraint_set5_flag  equal  to  1  or  (profile_idc  equal  to  83  and  both  constraint_set1_flag  and \nconstraint_set5_flag equal to 1). \nc)  Only I, P, EI, and EP slices shall be present. \nd)  SVC sequence parameter sets shall have chroma_format_idc equal to 1. \ne)  SVC sequence parameter sets shall have bit_depth_luma_minus8 equal to 0. \nf)  SVC sequence parameter sets shall have bit_depth_chroma_minus8 equal to 0. \ng)  SVC sequence parameter sets shall have separate_colour_plane_flag equal to 0. \nh)  SVC sequence parameter sets shall have qpprime_y_zero_transform_bypass_flag equal to 0. \ni)  SVC sequence parameter sets shall have frame_mbs_only_flag equal to 1. \nj)  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0. \nk)  Picture parameter sets shall have num_slice_groups_minus1 equal to 0. \nl)  A list of integer values specifying layer representation identifiers is derived by invoking the process specified in \nclause G.8.8.1 with the output being the list dqIdList. The variable numDQEntries is set equal to the number of \nelements  in  the  list  dqIdList.  When  numDQEntries  is  greater  than  1,  for  any  element  dqIdList[ i ]  with \ni = 1..(numDQEntries − 1), when MaxTCoeffLevelPredFlag is equal to 0 for any layer representation with DQId \nin the set specified by dqIdList[ k ] with k = 0..i, the picture parameter set that is referenced by the coded slice \nNAL units of the layer representation with DQId equal to dqIdList[ i ] shall have constrained_intra_pred_flag \nequal to 1. \nm)  Arbitrary slice order is not allowed. \nn)  For  each  present  layer  representation  with  dependency_id  greater  than  0,  quality_id  equal  to  0,  and \nMinNoInterLayerPredFlag equal to 0, one of the following constraints shall be obeyed. \n–  ScaledRefLayerPicWidthInSamples   is  equal  to  RefLayerPicWidthInSamples   and \nL L\nScaledRefLayerPicHeightInSamples  is equal to RefLayerPicHeightInSamples  \nL L\n–  ScaledRefLayerPicWidthInSamples   is  equal  to  (1.5 * RefLayerPicWidthInSamples )  and \nL L\nScaledRefLayerPicHeightInSamples  is equal to (1.5 * RefLayerPicHeightInSamples ) \nL L\n–  ScaledRefLayerPicWidthInSamples   is  equal  to  (2 * RefLayerPicWidthInSamples )  and \nL L\nScaledRefLayerPicHeightInSamples  is equal to (2 * RefLayerPicHeightInSamples ) \nL L\no)  For  each  present  layer  representation  with  dependency_id  greater  than  0,  quality_id  equal  to  0,  and \nMinNoInterLayerPredFlag equal to 0, all of the following constraints shall be obeyed. \n–  (ScaledRefLayerLeftOffset % 16) is equal to 0 \n–  (ScaledRefLayerTopOffset % 16) is equal to 0 \np)  The level constraints specified in clause G.10.2 shall be fulfilled. \nConformance of a bitstream to the Scalable Constrained High profile is indicated by constraint_set5_flag being equal to 1 \nwith profile_idc equal to 86. \nDecoders conforming to the Scalable Constrained High profile at a specific level shall be capable of decoding all bitstreams \nin which both of the following conditions are true: \na)  All active SVC sequence parameter sets have one or more of the following conditions fulfilled: \n–  profile_idc is equal to 86 and constraint_set5_flag is equal to 1, \n608  Rec. ITU-T H.264 (06/2019) \n \n–  profile_idc is equal to 83, constraint_set1_flag is equal to 1, and constraint_set5_flag is equal to 1, \n–  (profile_idc is equal to 66 or constraint_set0_flag is equal to 1), constraint_set1_flag is equal to 1, \n–  profile_idc is equal to 77 and constraint_set0_flag is equal to 1, \n–  profile_idc is equal to 77, constraint_set4_flag is equal to 1, and constraint_set5_flag is equal to 1, \n–  profile_idc  is  equal  to  88,  constraint_set1_flag  is  equal  to  1,  constraint_set4_flag  is  equal  to  1,  and \nconstraint_set5_flag is equal to 1, \n–  profile_idc is equal to 100 and constraint_set4_flag is equal to 1, and constraint_set5_flag is equal to 1, \nb)  level_idc or (level_idc and constraint_set3_flag) for all active SVC sequence parameter sets represent a level less \nthan or equal to the specified level. \nG.10.1.3 Scalable High Intra profile \nBitstreams conforming to the Scalable High Intra profile shall obey the following constraints: \na)  The base layer bitstream as specified in clause G.8.8.2 shall obey the following constraints: \ni)  All constraints of the High profile specified in clause A.2.4 shall be obeyed. \nii)  Sequence  parameter  sets  should  have  profile_idc  equal  to  100  and  constraint_set3_flag  equal  to 1. \nSequence parameter sets may have profile_idc equal to 66, 77, or 88 and constraint_set1_flag equal to 1. \nSequence parameter sets shall not have profile_idc equal to a value other than 66, 77, 88, or 100. \nb)  A list of integer values specifying layer representation identifiers is derived by invoking the process specified in \nclause G.8.1.1 with the output being the list dqIdList. The SVC sequence parameter sets that are referred to by \ncoded slice NAL units with DQId greater than 0 and DQId in the list dqIdList shall have profile_idc equal to 86 \nand constraint_set3_flag equal to 1. \nc)  All constraints of the Scalable High profile specified in clause G.10.1.2 shall be obeyed. \nd)  All pictures shall be IDR pictures. \ne)  SVC sequence parameter sets shall have max_num_ref_frames equal to 0. \nf)  When vui_parameters_present_flag is equal to 1 and bitstream_restriction_flag is equal to 1, SVC sequence \nparameter sets shall have max_num_reorder_frames equal to 0. \ng)  When vui_parameters_present_flag is equal to 1 and bitstream_restriction_flag is equal to 1, SVC sequence \nparameter sets shall have max_dec_frame_buffering equal to 0. \nh)  Picture timing SEI messages, whether present in the bitstream (by non-VCL NAL units) or conveyed equivalently \nby other means not specified in this Recommendation | International Standard, shall have dpb_output_delay equal \nto 0. \ni)  The level constraints specified in clause G.10.2 shall be fulfilled. \nConformance of a bitstream to the Scalable High Intra profile is indicated by constraint_set3_flag being equal to 1 with \nprofile_idc equal to 86. \nDecoders conforming to the Scalable High Intra profile at a specific level shall be capable of decoding all bitstreams in \nwhich both of the following conditions are true: \na)  All active SVC sequence parameter sets have profile_idc equal to 86 or 100 and constraint_set3_flag equal to 1. \nb)  level_idc or (level_idc and constraint_set3_flag) for all active SVC sequence parameter sets represents a level \nless than or equal to the specified level. \nThe operation of the deblocking filter process for target representation as specified in clause G.8.7.2 is not required for \ndecoder conformance to the Scalable High Intra profile. \nG.10.2  Levels \nThe following is specified for expressing the constraints in this clause: \n–  Let access unit n be the n-th access unit in decoding order with the first access unit being access unit 0. \n–  Let picture n be the primary coded picture or the corresponding decoded picture of access unit n. \nThe variable fR is derived as follows: \n    Rec. ITU-T H.264 (06/2019)  609 \n \n–  If the level number is equal to 6.0, 6.1, or 6.2, fR is set equal to 1 ÷ 300. \n–  Otherwise, if picture n is a frame, fR is set equal to (1 ÷ 172). \n–  Otherwise (picture n is a field), fR is set equal to ( 1 ÷ ( 172 * 2 ) ). \nG.10.2.1 Level  limits  common  to  Scalable  Baseline,  Scalable  Constrained  Baseline,  Scalable  High,  Scalable \nConstrained High, and Scalable High Intra profiles \nThe variable dqIdMax is set equal to the maximum value of DQId for the layer representation of the access unit. \nThe variable refLayerDQId is set equal to the value of MaxRefLayerDQId for the layer representation with DQId equal to \ndqIdMax. \nA list of integer values specifying layer representation identifiers for the access unit is derived by invoking the process \nspecified in clause G.8.1.1 with the output being the list dqIdList. The variable numDQEntries is set equal to the number \nof elements in the list dqIdList. \nA variable dependentDId is derived by the following pseudo-code: \ndependentDId = 0 \nfor( i = 0; i < numDQEntries; i++ ) \n  if( ( dqIdList[ i ] % 16 )  = =  0 )   (G-365) \n    dependentDId++ \nThe variable svcPicSizeInMbs is derived as follows: \n–  If numDQEntries is less than 3, svcPicSizeInMbs is set equal to PicSizeInMbs for the layer representation with DQId \nequal to dqIdMax. \n–  Otherwise (numDQEntries is greater than 2), svcPicSizeInMbs is derived by applying the following ordered steps: \n1.  svcPicSizeInMbs is set equal to PicSizeInMbs for the layer representation with DQId equal to dqIdMax. \n2.  The variable refLayerMbs is set equal to 0. \n3.  For  each  element  dqIdList[ i ]  with  i = 2..(numDQEntries − 1),  with  refLayerPicSizeInMbs  being  the \nvariable  PicSizeInMbs  for  the  layer  representation  with  DQId  equal  to  dqIdList[ i ],  the  variable \nrefLayerMbs is modified by \nrefLayerMbs += refLayerPicSizeInMbs  (G-366) \n4.  svcPicSizeInMbs is modified by \nsvcPicSizeInMbs += ( refLayerMbs + 1 ) >> 1  (G-367) \nBitstreams conforming to the Scalable Baseline, Scalable Constrained Baseline, Scalable High, Scalable Constrained High, \nor Scalable High Intra profiles at a specific level shall obey the following constraints: \na)  The nominal removal time of access unit n with n > 0 from the CPB as specified in clause C.1.2, satisfies the \nconstraint that t ( n ) − t ( n − 1 ) is greater than or equal to Max( svcPicSizeInMbs ÷ MaxMBPS, fR ), where \nr,n r\nMaxMBPS is the value specified in Table A-1 that applies to picture n − 1 and svcPicSizeInMbs is derived for \npicture n − 1. \nb)  The difference between consecutive output times of pictures from the DPB as specified in clause C.2.2, satisfies \nthe  constraint  that  t (  n  ) >= Max( svcPicSizeInMbs ÷ MaxMBPS, fR ),  where  MaxMBPS  is  the  value \no,dpb\nspecified in Table A-1 for picture n, and svcPicSizeInMbs is derived for picture n, provided that picture n is a \npicture that is output and is not the last picture of the bitstream that is output. \nc)  PicWidthInMbs * FrameHeightInMbs <= MaxFS, where MaxFS is specified in Table A-1. PicWidthInMbs and \nFrameHeightInMbs are the derived variables for the layer representation with DQId equal to dqIdMax. \nd)  PicWidthInMbs <= Sqrt( MaxFS * 8 ), where MaxFS is specified in Table A-1 and PicWidthInMbs is the derived \nvariable for the layer representation with DQId equal to dqIdMax. \ne)  FrameHeightInMbs <= Sqrt( MaxFS * 8 ), where MaxFS is specified in Table A-1 and FrameHeightInMbs is the \nderived variable for the layer representation with DQId equal to dqIdMax. \nf)  max_dec_frame_buffering <= MaxDpbFrames,  where  MaxDpbFrames  is  equal  to \nMin( MaxDpbMbs / ( PicWidthInMbs * FrameHeightInMbs ), 16 ) and MaxDpbMbs is specified in Table A-1. \nPicWidthInMbs and FrameHeightInMbs are the derived variables for the layer representation with DQId equal \nto dqIdMax. \n610  Rec. ITU-T H.264 (06/2019) \n \ng)  The vertical motion vector component range for luma motion vectors does not exceed the range from −MaxVmvR \nto ( MaxVmvR − 0.25 ) in units of luma frame samples, where MaxVmvR is specified in Table A-1. \nh)  The horizontal motion vector component range for luma motion vectors does not exceed the following range: \n–  If the level number is less than 6.0, the specified range is from −2048 to 2047.75, inclusive, in units of luma \nsamples. \n–  Otherwise, the specified range is from −8192 to 8191.75, inclusive, in units of luma samples. \ni)  For each layer representation, the total number of motion vectors per two macroblocks mbAddrA and mbAddrB \nwith (mbAddrA + 1) equal to mbAddrB does not exceed MaxMvsPer2Mb, where MaxMvsPer2Mb is specified \nin Table A-1 given the level that is indicated in the SVC sequence parameter set that is referenced by the layer \nrepresentation. The number of motion vectors for each macroblock is the value of the variable MvCnt after the \ncompletion of the base decoding process for slices without resolution change specified in clause G.8.1.4.1 (when \nSpatialResolutionChangeFlag  is  equal  to 0)  or  after  completion  the  base  decoding  process  for  slices  with \nresolution change specified in clause G.8.1.4.2 (when SpatialResolutionChangeFlag is equal to 1). \nNOTE – Due to the constraint specified in clause G.8.8.1, the number of motion vectors for the layer representation \nwith DQId equal to 0 is additionally constrained as specified in Annex A. \nj)  The  number  of  bits  of  macroblock_layer( )  and  macroblock_layer_in_scalable_extension( )  data  for  any \nmacroblock  in  any  layer  representation  is  not  greater  than  128 + RawMbBits.  Depending  on \nentropy_coding_mode_flag, the bits of macroblock_layer( ) data are counted as follows: \n–  If entropy_coding_mode_flag is equal to 0, the number of bits of macroblock_layer( ) data is given by the \nnumber of bits in the macroblock_layer( ) syntax structure for a macroblock. \n–  Otherwise (entropy_coding_mode_flag is equal to 1), the number of bits of macroblock_layer( ) data for a \nmacroblock is given by the number of times read_bits( 1 ) is called in clauses 9.3.3.2.2 and 9.3.3.2.3 when \nparsing the macroblock_layer( ) associated with the macroblock. \nk)  The variable dependentDId specified at the beginning of this clause shall not exceed 3. \nl)  For  each  layer  representation  present  in  an  access  unit  that  has  MinNoInterLayerPredFlag  equal  to 0,  the \nfollowing applies: \n1.  The variables numILIntraPredSamples and numRefLayerILIntraPredMbs are derived as specified in \nthe derivation process for variables related to inter-layer intra prediction in clause G.8.6.2.5 with DQId \nbeing the input. \n2.  The following constraint shall be obeyed. \nnumRefLayerILIntraPredMbs * 256 <= 1.5 * numILIntraPredSamples  (G-368) \nm)  When MaxRefLayerDQId is greater than or equal to 0 for a particular layer representation, the value of level_idc \nin the SVC sequence parameter set that is referenced by the particular layer representation shall represent a level \nthat  is  greater  than  or  equal  to  the  level  that  is  represented  by  the  value  of  level_idc  or  (level_idc  and \nconstraint_set3_flag) in the SVC sequence parameter set that is referenced by the layer representation with DQId \nequal to MaxRefLayerDQId. \nTable A-1 specifies the limits for each level. A definition of all levels identified in the \"Level number\" column of Table A-1 \nis specified for the Scalable Baseline, Scalable Constrained Baseline, Scalable High, Scalable Constrained High, and \nScalable High Intra profiles. Each entry in Table A-1 indicates, for the level corresponding to the row of the table, the \nabsence or value of a limit that is imposed by the variable corresponding to the column of the table, as follows: \n–  If the table entry is marked as \"-\", no limit is imposed by the value of the variable as a requirement of bitstream \nconformance to the profile at the specified level. \n–  Otherwise, the table entry specifies the value of the variable for the associated limit that is imposed as a requirement \nof bitstream conformance to the profile at the specified level. \nIn  bitstreams  conforming  to  the  Scalable Baseline,  Scalable Constrained Baseline,  Scalable High, \nScalable Constrained High,  or  Scalable High Intra  profiles,  the  conformance  of  the  bitstream  to  a  specified  level  is \nindicated by the syntax element level_idc as follows: \n–  If level_idc is equal to 9, the indicated level is level 1b. \n–  Otherwise (level_idc is not equal to 9), level_idc is equal to a value of ten times the level number (of the indicated \nlevel) specified in Table A-1. \n    Rec. ITU-T H.264 (06/2019)  611 \n \nG.10.2.2 Profile specific level limits \nThe variable dqIdMax is set equal to the maximum value of DQId for the layer representation of the access unit. \nA list of integer values specifying layer representation identifiers for the access unit is derived by invoking the process \nspecified in clause G.8.1.1 with the output being the list dqIdList. The variable numDQEntries is set equal to the number \nof elements in the list dqIdList. \nThe variable numSVCSlices is derived as specified by the following pseudo-code: \nnumSVCSlices = 0 \nfor( i = 0; i < numDQEntries; i++ )  (G-369) \n  numSVCSlices += number of slices in layer representation with DQId equal to dqIdList[ i ] \nThe variable svcPicSizeInMbs is derived as specified in clause G.10.2.1. \nThe following constraints are specified: \na)  In bitstreams conforming to the Scalable Baseline, Scalable Constrained Baseline, Scalable High, Scalable \nConstrained High, or Scalable High Intra profiles, the removal time of access unit 0 shall satisfy the constraint \nthat  the  numSVCSlices  variable  for  picture  0  is  less  than  or  equal  to \n( Max( svcPicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * ( t ( 0 ) − t ( 0 ) ) ) ÷ SliceRate,  where  MaxMBPS \nr r,n\nand SliceRate are the values that apply to picture 0. MaxMBPS is specified in Table A-1. For Scalable Baseline \nand Scalable Constrained Baseline profiles, SliceRate is specified in Table G-16. For Scalable High, Scalable \nConstrained High, and Scalable High Intra profiles, SliceRate is specified in Table A-4. \nb)  In bitstreams conforming to the Scalable Baseline, Scalable Constrained Baseline, Scalable High, Scalable \nConstrained High, or Scalable High Intra profiles, the difference between consecutive removal times of access \nunits n and n − 1 with n > 0 shall satisfy  the constraint that the numSVCSlices variable for picture n is less than \nor equal to MaxMBPS * ( t ( n ) − t ( n − 1 ) ) ÷ SliceRate, where MaxMBPS and SliceRate are the values that \nr r\napply to picture n. MaxMBPS is specified in Table A-1. For the Scalable Baseline and Scalable Constrained \nBaseline profiles, SliceRate is specified in Table G-16. For the Scalable High, Scalable Constrained High, and \nScalable High Intra profiles, SliceRate is specified in Table A-4. \nc)  In  bitstreams  conforming  to  the  Scalable  High  profile,  SVC  sequence  parameter  sets  shall  have \ndirect_8x8_inference_flag equal to 1 for the levels specified in  Table A-4. In bitstreams conforming to the \nScalable Baseline profile, SVC sequence parameter sets shall have direct_8x8_inference_flag equal to 1. \nNOTE 1 – direct_8x8_inference_flag is not relevant to the Scalable Constrained Baseline, Scalable Constrained \nHigh, and Scalable High Intra profiles, as these profiles do not allow B or EB slice types. \nd)  In bitstreams conforming to the Scalable High or Scalable High Intra profiles, SVC sequence parameter sets shall \nhave frame_mbs_only_flag equal to 1 for the levels specified in Table A-4. \ne)  In bitstreams conforming to the Scalable High profile, for all macroblocks mbAddr and macroblock partitions \nmbPartIdx, the value of subMbType[ mbAddr ][ mbPartIdx ] that is derived as specified in clause G.8.1.5.1.1 \nshall not be equal to B_Bi_8x4, B_Bi_4x8, or B_Bi_4x4 for the levels in which MinLumaBiPredSize is shown \nas 8x8 in Table A-4. In bitstreams conforming to the Scalable Baseline profile, for all macroblocks mbAddr and \nmacroblock partitions mbPartIdx, the value of subMbType[ mbAddr ][ mbPartIdx ] that is derived as specified \nin clause G.8.1.5.1.1 shall not be equal to B_Bi_8x4, B_Bi_4x8, or B_Bi_4x4. \nNOTE 2 – The above constraint is not relevant to the Scalable Constrained Baseline, Scalable Constrained High, \nand Scalable High Intra profiles, as these profiles do not allow B or EB slice types. \nf)  In  bitstreams  conforming  to  the  Scalable  Baseline  or  Scalable  Constrained  Baseline  profiles, \n( xInt  − xInt  + 6 ) * ( yInt  − yInt  + 6 ) <= MaxSubMbRectSize in macroblocks coded with macroblock \nmax min max min\ntype equal to P_8x8, P_8x8ref0 or B_8x8 for all invocations of the process specified in clause 8.4.2.2.1 used to \ngenerate the predicted luma sample array for a single reference picture list (reference picture list 0 or reference \npicture  list  1)  for  each  8x8  sub-macroblock  with  the  macroblock  partition  index  mbPartIdx,  where \nNumSubMbPart( sub_mb_type[ mbPartIdx ] ) > 1, where MaxSubMbRectSize is specified in Table G-16 and \n–  xInt  is the minimum value of xInt  among all luma sample predictions for the sub-macroblock, \nmin L\n–  xInt  is the maximum value of xInt  among all luma sample predictions for the sub-macroblock, \nmax L\n–  yInt  is the minimum value of yInt  among all luma sample predictions for the sub-macroblock, \nmin L\n–  yInt  is the maximum value of yInt  among all luma sample predictions for the sub-macroblock. \nmax L\ng)  In bitstreams conforming to the Scalable Baseline, Scalable Constrained Baseline, Scalable High, Scalable \nConstrained  High,  or  Scalable  High  Intra  profiles,  for  the  VCL  HRD  parameters, \nBitRate[ SchedSelIdx ] <= cpbBrVclFactor * MaxBR  and  CpbSize[ SchedSelIdx ] <= \n612  Rec. ITU-T H.264 (06/2019) \n \ncpbBrVclFactor * MaxCPB  for  at  least  one  value  of  SchedSelIdx,  where  cpbBrVclFactor  is  specified  in \nTable G-17.  With  vui_ext_vcl_hrd_parameters_present_flag[ i ]  being  the  syntax  element,  in  the  SVC  VUI \nparameters extension of the active SVC sequence parameter set, that is associated with the VCL HRD parameters \nthat  are  used  for  conformance  checking  (as  specified  in  Annex C),  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are given as follows: \n–  If  vui_ext_vcl_hrd_parameters_present_flag[ i ]  is  equal  to 1,  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are given by Equations E-53 and E-54, respectively, using the syntax elements of \nthe  hrd_parameters( )  syntax  structure  that  immediately  follows \nvui_ext_vcl_hrd_parameters_present_flag[ i ]. \n–  Otherwise  (vui_ext_vcl_hrd_parameters_present_flag[ i ]  is  equal  to  0),  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are inferred as specified in clause E.2.2 for VCL HRD parameters. \nMaxBR and MaxCPB are specified in Table A-1 in units of cpbBrVclFactor bits/s and cpbBrVclFactor bits, \nrespectively. The bitstream shall satisfy these conditions for at least one value of SchedSelIdx in the range 0 to \ncpb_cnt_minus1, inclusive. \nh)  In bitstreams conforming to the Scalable Baseline, Scalable Constrained Baseline, Scalable High, Scalable \nConstrained  High,  or  Scalable  High  Intra  profiles,  for  the  NAL  HRD  parameters, \nBitRate[ SchedSelIdx ] <= cpbBrNalFactor * MaxBR  and  CpbSize[ SchedSelIdx ] <= \ncpbBrNalFactor * MaxCPB  for  at  least  one  value  of  SchedSelIdx,  where  cpbBrNalFactor  is  specified  in \nTable G-17.  With  vui_ext_nal_hrd_parameters_present_flag[ i ]  being  the  syntax  element,  in  the  SVC  VUI \nparameters extension of the active SVC sequence parameter set, that is associated with the NAL HRD parameters \nthat  are  used  for  conformance  checking  (as  specified  in  Annex C),  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are given as follows: \n–  If  vui_ext_nal_hrd_parameters_present_flag[ i ]  is  equal  to 1,  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are given by Equations E-53 and E-54, respectively, using the syntax elements of \nthe  hrd_parameters( )  syntax  structure  that  immediately  follows \nvui_ext_nal_hrd_parameters_present_flag[ i ]. \n–  Otherwise  (vui_ext_nal_hrd_parameters_present_flag[ i ]  is  equal  to  0),  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are inferred as specified in clause E.2.2 for NAL HRD parameters. \nMaxBR and MaxCPB are specified in Table A-1 in units of cpbBrNalFactor bits/s and cpbBrNalFactor bits, \nrespectively. The bitstream shall satisfy these conditions for at least one value of SchedSelIdx in the range 0 to \ncpb_cnt_minus1, inclusive. \ni)  In bitstreams conforming to the Scalable Baseline, Scalable Constrained Baseline, Scalable High, Scalable \nConstrained High, or Scalable High Intra profiles, the sum of the NumBytesInNALunit variables for access unit \n0  is  less  than  or  equal  to  384 * ( Max( svcPicSizeInMbs,  fR * MaxMBPS ) + MaxMBPS *  \n( t ( 0 ) − t ( 0 ) ) ) ÷ MinCR, where MaxMBPS and MinCR are the values specified in Table A-1 that apply to \nr r,n\npicture 0. \nj)  In bitstreams conforming to the Scalable Baseline, Scalable Constrained Baseline, Scalable High,  Scalable \nConstrained High, or Scalable High Intra profiles, the sum of the NumBytesInNALunit variables for access unit \nn with n > 0 is less than or equal to 384 * MaxMBPS * ( t ( n ) − t ( n − 1 ) ) ÷ MinCR, where MaxMBPS and \nr r\nMinCR are the values specified in Table A-1 that apply to picture n. \nk)  In bitstreams conforming to the Scalable Baseline or Scalable Constrained Baseline profile, picture parameter \nsets shall have entropy_coding_mode_flag equal to 0 and transform_8x8_mode_flag equal to 0 for level 2.1 and \nbelow. \nl)  In bitstreams conforming to  the Scalable Baseline, Scalable Constrained Baseline, Scalable High, Scalable \nConstrained High, and Scalable High Intra profiles, when PicSizeInMbs is greater than 1620 for DQId equal to \ndqIdMax, the number of macroblocks in any coded slice shall not exceed MaxFS / 4, where MaxFS is specified \nin Table A-1. \nTable A-4  specifies  limits  for  each  level  that  are  specific  to  bitstreams  conforming  to  the  Scalable  High,  Scalable \nConstrained High, and Scalable High Intra profiles. Table G-16 specifies limits for each level that are specific to bitstreams \nconforming to the Scalable Baseline and Scalable Constrained Baseline profiles. Each entry in Tables A-4 and G-16 \nindicates, for the level corresponding to the row of the table, the absence or value of a limit that is imposed by the variable \ncorresponding to the column of the table, as follows: \n–  If the table entry is marked as \"-\", no limit is imposed by the value of the variable as a requirement of bitstream \nconformance to the profile at the specified level. \n    Rec. ITU-T H.264 (06/2019)  613 \n \n–  Otherwise, the table entry specifies the value of the variable for the associated limit that is imposed as a requirement \nof bitstream conformance to the profile at the specified level. \nTable G-16 – Scalable Baseline and Scalable Constrained Baseline profile level limits \nLevel  number  SliceRate  MaxSubMbRectSize \n1  -  576 \n1b  -  576 \n1.1  -  576 \n1.2  -  576 \n1.3  -  576 \n2  -  576 \n2.1  22  576 \n2.2  22  576 \n3  22  576 \n3.1  60  1152 \n3.2  60  1152 \n4  60  1440 \n4.1  24  1440 \n4.2  24  1440 \n5  24  - \n5.1  24  - \n6  24  - \n6.1  24  - \n6.2  24  - \n \nTable G-17 – Specification of cpbBrVclFactor and cpbBrNalFactor \n \nProfile  cpbBrVclFactor cpbBrNalFactor \nScalable Baseline, \nScalable Constrained Baseline, \nScalable High,  1250  1500 \nScalable Constrained High, or \nScalable High Intra \nG.11  Byte stream format \nThe specifications in Annex B apply. \nG.12  Hypothetical reference decoder \nThe specifications in Annex C apply with substituting SVC sequence parameter set for sequence parameter set. \nG.13  Supplemental enhancement information \nThe specifications in Annex D together with the extensions and modifications specified in this clause apply. \nG.13.1  SEI payload syntax \n614  Rec. ITU-T H.264 (06/2019) \n \nG.13.1.1 Scalability information SEI message syntax \n \nscalability_info( payloadSize ) {  C  Descriptor \n  temporal_id_nesting_flag  5  u(1) \n  priority_layer_info_present_flag  5  u(1) \n  priority_id_setting_flag  5  u(1) \n  num_layers_minus1  5  ue(v) \n  for( i = 0; i <= num_layers_minus1; i++ ) {     \n    layer_id[ i ]  5  ue(v) \n    priority_id[ i ]  5  u(6) \n    discardable_flag[ i ]  5  u(1) \n    dependency_id[ i ]  5  u(3) \n    quality_id[ i ]  5  u(4) \n    temporal_id[ i ]  5  u(3) \n    sub_pic_layer_flag[ i ]  5  u(1) \n    sub_region_layer_flag[ i ]  5  u(1) \n    iroi_division_info_present_flag[ i ]  5  u(1) \n    profile_level_info_present_flag[ i ]  5  u(1) \n    bitrate_info_present_flag[ i ]  5  u(1) \n    frm_rate_info_present_flag[ i ]  5  u(1) \n    frm_size_info_present_flag[ i ]  5  u(1) \n    layer_dependency_info_present_flag[ i ]  5  u(1) \n    parameter_sets_info_present_flag[ i ]  5  u(1) \n    bitstream_restriction_info_present_flag[ i ]  5  u(1) \n    exact_inter_layer_pred_flag[ i ]  5  u(1) \n    if( sub_pic_layer_flag[ i ]  | |  iroi_division_info_present_flag[ i ] )     \n      exact_sample_value_match_flag[ i ]  5  u(1) \n    layer_conversion_flag[ i ]  5  u(1) \n    layer_output_flag[ i ]  5  u(1) \n    if( profile_level_info_present_flag[ i ] )     \n      layer_profile_level_idc[ i ]  5  u(24) \n    if( bitrate_info_present_flag[ i ] ) {     \n      avg_bitrate[ i ]  5  u(16) \n      max_bitrate_layer[ i ]  5  u(16) \n      max_bitrate_layer_representation[ i ]  5  u(16) \n      max_bitrate_calc_window[ i ]  5  u(16) \n    }     \n    if( frm_rate_info_present_flag[ i ] ) {     \n      constant_frm_rate_idc[ i ]  5  u(2) \n      avg_frm_rate[ i ]  5  u(16) \n    }     \n    if( frm_size_info_present_flag[ i ]  | |       \n      iroi_division_info_present_flag[ i ] ) { \n      frm_width_in_mbs_minus1[ i ]  5  ue(v) \n      frm_height_in_mbs_minus1[ i ]  5  ue(v) \n    }     \n    if( sub_region_layer_flag[ i ] ) {     \n      base_region_layer_id[ i ]  5  ue(v) \n    Rec. ITU-T H.264 (06/2019)  615 \n \n      dynamic_rect_flag[ i ]  5  u(1) \n      if( !dynamic_rect_flag[ i ] ) {     \n        horizontal_offset[ i ]  5  u(16) \n        vertical_offset[ i ]  5  u(16) \n        region_width[ i ]  5  u(16) \n        region_height[ i ]  5  u(16) \n      }     \n    }     \n    if( sub_pic_layer_flag[ i ] )      \n      roi_id[ i ]  5  ue(v) \n    if( iroi_division_info_present_flag[ i ] ) {     \n      iroi_grid_flag[ i ]  5  u(1) \n      if( iroi_grid_flag[ i ] ) {     \n        grid_width_in_mbs_minus1[ i ]  5  ue(v) \n        grid_height_in_mbs_minus1[ i ]  5  ue(v) \n      } else {     \n        num_rois_minus1[ i ]  5  ue(v) \n        for(j = 0; j <= num_rois_minus1[ i ]; j++ ) {     \n          first_mb_in_roi[ i ][ j ]  5  ue(v) \n          roi_width_in_mbs_minus1[ i ][ j ]  5  ue(v) \n          roi_height_in_mbs_minus1[ i ][ j ]  5  ue(v) \n        }     \n      }     \n    }     \n    if( layer_dependency_info_present_flag[ i ] ) {     \n      num_directly_dependent_layers[ i ]  5  ue(v) \n      for( j = 0; j < num_directly_dependent_layers[ i ]; j++ )     \n        directly_dependent_layer_id_delta_minus1[ i ][ j ]  5  ue(v) \n    } else     \n      layer_dependency_info_src_layer_id_delta[ i ]  5  ue(v) \n    if( parameter_sets_info_present_flag[ i ] ) {     \n      num_seq_parameter_sets[ i ]  5  ue(v) \n      for( j = 0; j < num_seq_parameter_sets[ i ]; j++ )     \n        seq_parameter_set_id_delta[ i ][ j ]  5  ue(v) \n      num_subset_seq_parameter_sets[ i ]  5  ue(v) \n      for( j = 0; j < num_subset_seq_parameter_sets[ i ]; j++ )     \n        subset_seq_parameter_set_id_delta[ i ][ j ]  5  ue(v) \n      num_pic_parameter_sets_minus1[ i ]  5  ue(v) \n      for( j = 0; j <= num_pic_parameter_sets_minus1[ i ]; j++ )     \n        pic_parameter_set_id_delta[ i ][ j ]  5  ue(v) \n    } else     \n      parameter_sets_info_src_layer_id_delta[ i ]  5  ue(v) \n    if( bitstream_restriction_info_present_flag[ i ] ) {     \n      motion_vectors_over_pic_boundaries_flag[ i ]  5  u(1) \n      max_bytes_per_pic_denom[ i ]  5  ue(v) \n      max_bits_per_mb_denom[ i ]  5  ue(v) \n      log2_max_mv_length_horizontal[ i ]  5  ue(v) \n      log2_max_mv_length_vertical[ i ]  5  ue(v) \n616  Rec. ITU-T H.264 (06/2019) \n \n      max_num_reorder_frames[ i ]  5  ue(v) \n      max_dec_frame_buffering[ i ]  5  ue(v) \n    }     \n    if( layer_conversion_flag[ i ] ) {     \n      conversion_type_idc[ i ]  5  ue(v) \n      for( j=0; j < 2; j++ ) {     \n        rewriting_info_flag[ i ][ j ]  5  u(1) \n        if( rewriting_info_flag[ i ][ j ] ) {     \n          rewriting_profile_level_idc[ i ][ j ]  5  u(24) \n          rewriting_avg_bitrate[ i ][ j ]  5  u(16) \n          rewriting_max_bitrate[ i ][ j ]  5  u(16) \n        }     \n      }     \n    }     \n  }     \n  if( priority_layer_info_present_flag ) {     \n    pr_num_dIds_minus1  5  ue(v) \n    for( i = 0; i <= pr_num_dIds_minus1; i++ ) {     \n      pr_dependency_id[ i ]  5  u(3) \n      pr_num_minus1[ i ]  5  ue(v) \n      for( j = 0; j <= pr_num_minus1[ i ]; j++ ) {     \n        pr_id[ i ][ j ]  5  ue(v) \n        pr_profile_level_idc[ i ][ j ]  5  u(24) \n        pr_avg_bitrate[ i ][ j ]  5  u(16) \n        pr_max_bitrate[ i ][ j ]  5  u(16) \n      }     \n    }     \n  }     \n  if( priority_id_setting_flag ) {     \n    PriorityIdSettingUriIdx = 0     \n    do      \n      priority_id_setting_uri[ PriorityIdSettingUriIdx ]  5  b(8) \n    while( priority_id_setting_uri[ PriorityIdSettingUriIdx++ ]  !=  0 )     \n  }     \n}     \n \nG.13.1.2 Sub-picture scalable layer SEI message syntax \n \nsub_pic_scalable_layer( payloadSize ) {  C  Descriptor \n  layer_id  5  ue(v) \n}     \n \n    Rec. ITU-T H.264 (06/2019)  617 \n \nG.13.1.3 Non-required layer representation SEI message syntax \n \nnon_required_layer_rep( payloadSize ) {  C  Descriptor \n  num_info_entries_minus1  5  ue(v) \n  for( i = 0; i <= num_info_entries_minus1; i++ ) {     \n    entry_dependency_id[ i ]  5  u(3) \n    num_non_required_layer_reps_minus1[ i ]  5  ue(v) \n    for( j = 0; j <= num_non_required_layer_reps_minus1[ i ]; j++ ) {     \n      non_required_layer_rep_dependency_id[ i ][ j ]  5  u(3) \n      non_required_layer_rep_quality_id[ i ][ j ]  5  u(4) \n    }     \n  }     \n}     \n \nG.13.1.4 Priority layer information SEI message syntax \n \npriority_layer_info( payloadSize ) {  C  Descriptor \n  pr_dependency_id  5  u(3) \n  num_priority_ids  5  u(4) \n  for( i = 0; i < num_priority_ids; i++ ) {     \n    alt_priority_id[ i ]  5  u(6) \n  }     \n}     \n \nG.13.1.5 Layers not present SEI message syntax \n \nlayers_not_present( payloadSize ) {  C  Descriptor \n  num_layers  5  ue(v) \n  for( i = 0; i < num_layers; i++ ) {     \n    layer_id[ i ]  5  ue(v) \n  }     \n}     \nG.13.1.6 Layer dependency change SEI message syntax \n \nlayer_dependency_change( payloadSize ) {  C  Descriptor \n  num_layers_minus1  5  ue(v) \n  for( i = 0; i <= num_layers_minus1; i++ ) {     \n    layer_id[ i ]  5  ue(v) \n    layer_dependency_info_present_flag[ i ]  5  u(1) \n    if( layer_dependency_info_present_flag[ i ] ) {     \n      num_directly_dependent_layers[ i ]  5  ue(v) \n      for( j = 0; j < num_directly_dependent_layers[ i ]; j++ )     \n        directly_dependent_layer_id_delta_minus1[ i ][ j ]  5  ue(v) \n    } else {     \n      layer_dependency_info_src_layer_id_delta_minus1[ i ]  5  ue(v) \n    }     \n618  Rec. ITU-T H.264 (06/2019) \n \n  }     \n}       \n \nG.13.1.7 Scalable nesting SEI message syntax \n \nscalable_nesting( payloadSize ) {  C  Descriptor \n  all_layer_representations_in_au_flag  5  u(1) \n  if( all_layer_representations_in_au_flag  = =  0) {     \n    num_layer_representations_minus1  5  ue(v) \n    for( i = 0; i <= num_layer_representations_minus1; i++ ) {     \n      sei_dependency_id[ i ]  5  u(3) \n      sei_quality_id[ i ]  5  u(4) \n    }     \n    sei_temporal_id  5  u(3) \n  }     \n  while( !byte_aligned( ) )     \n    sei_nesting_zero_bit /* equal to 0 */  5  f(1) \n  do     \n    sei_message( )  5   \n  while( more_rbsp_data( ) )     \n}     \n \nG.13.1.8 Base layer temporal HRD SEI message syntax \n \nbase_layer_temporal_hrd( payloadSize ) {  C  Descriptor \n  num_of_temporal_layers_in_base_layer_minus1  5  ue(v) \n  for( i = 0; i <= num_of_temporal_layers_in_base_layer_minus1; i++ ) {     \n    sei_temporal_id[ i ]  5  u(3) \n    sei_timing_info_present_flag[ i ]  5  u(1) \n    if( sei_timing_info_present_flag[ i ] ) {     \n      sei_num_units_in_tick[ i ]  5  u(32) \n      sei_time_scale[ i ]  5  u(32) \n      sei_fixed_frame_rate_flag[ i ]  5  u(1) \n    }     \n    sei_nal_hrd_parameters_present_flag[ i ]  5  u(1) \n    if( sei_nal_hrd_parameters_present_flag[ i ] )     \n      hrd_parameters( )  5   \n    sei_vcl_hrd_parameters_present_flag[ i ]  5  u(1) \n    if( sei_vcl_hrd_parameters_present_flag[ i ] )     \n      hrd_parameters( )  5   \n    if( sei_nal_hrd_parameters_present_flag[ i ]  | |       \n      sei_vcl_hrd_parameters_present_flag[ i ] ) \n      sei_low_delay_hrd_flag[ i ]  5  u(1) \n    sei_pic_struct_present_flag[ i ]  5  u(1) \n  }     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  619 \n \nG.13.1.9 Quality layer integrity check SEI message syntax \n \nquality_layer_integrity_check( payloadSize ) {  C  Descriptor \n  num_info_entries_minus1  5  ue(v) \n  for( i = 0; i <= num_info_entries_minus1; i++ ) {     \n    entry_dependency_id[ i ]  5  u(3) \n    quality_layer_crc[ i ]  5  u(16) \n  }     \n}     \n \nG.13.1.10  Redundant picture property SEI message syntax \n \nredundant_pic_property( payloadSize ) {  C  Descriptor \n  num_dIds_minus1  5  ue(v) \n  for( i = 0; i <= num_dIds_minus1; i++ ) {     \n    dependency_id[ i ]  5  u(3) \n    num_qIds_minus1[ i ]  5  ue(v) \n    for( j = 0; j <= num_qIds_minus1[ i ]; j++ ) {     \n      quality_id[ i ][ j ]  5  u(4) \n      num_redundant_pics_minus1[ i ][ j ]  5  ue(v) \n      for( k = 0; k <= num_redundant_pics_minus1[ i ][ j ]; k++ ) {     \n        redundant_pic_cnt_minus1[ i ][ j ][ k ]  5  ue(v) \n        pic_match_flag[ i ][ j ][ k ]  5  u(1) \n        if( !pic_match_flag[ i ][ j ][ k ]) {     \n          mb_type_match_flag[ i ][ j ][ k ]  5  u(1) \n          motion_match_flag[ i ][ j ][ k ]  5  u(1) \n          residual_match_flag[ i ][ j ][ k ]  5  u(1) \n          intra_samples_match_flag[ i ][ j ][ k ]  5  u(1) \n        }     \n      }     \n    }     \n  }     \n}     \n \nG.13.1.11  Temporal level zero dependency representation index SEI message syntax \n \ntl0_dep_rep_index( payloadSize ) {  C  Descriptor \n  tl0_dep_rep_idx  5  u(8) \n  effective_idr_pic_id  5  u(16) \n}     \n \n620  Rec. ITU-T H.264 (06/2019) \n \nG.13.1.12  Temporal level switching point SEI message syntax \n \ntl_switching_point( payloadSize ) {  C  Descriptor \n  delta_frame_num  5  se(v) \n}     \n \nG.13.2  SEI payload semantics \nThe semantics of the SEI messages with payloadType in the range of 0 to 23, inclusive, or equal to 45, 47, 137, 142, 144, \n147, 148, 149, 150, 151, 154, 155, 156, 200, or 201, which are specified in clause D.2, are extended as follows: \n–  If payloadType is equal to 3, 8, 19, 20, or 22, the following applies: \n–  If the SEI message is not included in a scalable nesting SEI message, it applies to the layer representations of the \ncurrent access unit that have dependency_id equal to 0 and quality_id equal to 0. \nThe semantics as specified in clause D.2 apply to the bitstream that would be obtained by invoking the bitstream \nextraction process as specified in clause G.8.8.1 with dIdTarget equal to 0 and qIdTarget equal to 0. All syntax \nelements and derived variables that are referred to in the semantics in clause D.2 are syntax elements and \nvariables for layer representations with dependency_id equal to 0 and quality_id equal to 0. All SEI messages \nthat are referred to in clause D.2 are SEI messages that apply to layer representations with dependency_id equal \nto 0 and quality_id equal to 0. \n–  Otherwise (the SEI message is included in a scalable nesting SEI message), the SEI message applies to all layer \nrepresentations  of  the  current  access  unit  for  which  DQId  is  equal  to  any  value  of \n( ( sei_dependency_id[ i ] << 4 ) + sei_quality_id[ i ] )  with  i  in  the  range  of  0  to \nnum_layer_representations_minus1, inclusive. \nFor each value of i in the range of 0 to num_layer_representations_minus1, inclusive, the semantics as specified \nin clause D.2 apply to the bitstream that would be obtained by invoking the bitstream extraction process as \nspecified  in  clause G.8.8.1  with  dIdTarget  equal  to  sei_dependency_id[ i ]  and  qIdTarget  equal  to \nsei_quality_id[ i ]. All syntax elements and derived variables that are referred to in the semantics in clause D.2 \nare syntax elements and variables for layer representations with dependency_id equal to sei_dependency_id[ i ] \nand quality_id equal to sei_quality_id[ i ]. All SEI messages that are referred to in clause D.2 are SEI messages \nthat apply to layer representations with dependency_id equal to sei_dependency_id[ i ] and quality_id equal to \nsei_quality_id[ i ]. \n–  Otherwise, if payloadType is equal to 2, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 23, 45, 47, 137, 142, 144, 147, \n148, 149, 150, 151, 154, 155, 156, 200, or 201, the following applies: \n–  If the SEI message is not included in a scalable nesting SEI message, it applies to the dependency representations \nof the current access unit that have dependency_id equal to 0. \nThe semantics as specified in clause D.2 apply to the bitstream that would be obtained by invoking the bitstream \nextraction process as specified in clause G.8.8.1 with dIdTarget equal to 0. All syntax elements and derived \nvariables that are referred to in the semantics in clause D.2 are syntax elements and variables for dependency \nrepresentations with dependency_id equal to 0. All SEI messages that are referred to in clause D.2 are SEI \nmessages that apply to dependency representations with dependency_id equal to 0. \n–  Otherwise (the SEI message is included in a scalable nesting SEI message), the scalable nesting SEI message \ncontaining  the  SEI  message  shall  have  all_layer_representations_in_au_flag  equal  to  1  or,  when \nall_layer_representations_in_au_flag is equal to 0, all values of sei_quality_id[ i ] present in the scalable nesting \nSEI message shall be equal to 0. The SEI message that is included in the scalable nesting SEI message applies \nto all dependency representations of the current access unit for which dependency_id is equal to any value of \nsei_dependency_id[ i ] with i in the range of 0 to num_layer_representations_minus1, inclusive. \nFor each value of i in the range of 0 to num_layer_representations_minus1, inclusive, the semantics as specified \nin clause D.2 apply to the bitstream that would be obtained by invoking the bitstream extraction process as \nspecified in clause G.8.8.1 with dIdTarget equal to sei_dependency_id[ i ]. All syntax elements and derived \nvariables that are referred to in the semantics in clause D.2 are syntax elements and variables for dependency \nrepresentations with dependency_id equal to sei_dependency_id[ i ]. All SEI messages that are referred to in \nclause D.2  are  SEI  messages  that  apply  to  dependency  representations  with  dependency_id  equal  to \nsei_dependency_id[ i ]. \n    Rec. ITU-T H.264 (06/2019)  621 \n \nWhen payloadType is equal to 10 for the SEI message that is included in a scalable nesting SEI message, the \nsemantics for sub_seq_layer_num of the sub-sequence information SEI message is modified as follows: \nsub_seq_layer_num specifies the sub-sequence layer number of the current picture. When the current \npicture resides in a sub-sequence for which the first picture in decoding order is an IDR picture, the value \nof sub_seq_layer_num shall be equal to 0. For a non-paired reference field, the value of sub_seq_layer_num \nshall be equal to 0. sub_seq_layer_num shall be in the range of 0 to 255, inclusive. \n–  Otherwise, if payloadType is equal to 0 or 1, the following applies: \n–  If the SEI message is not included in a scalable nesting SEI message, the following applies. When the SEI \nmessage and all other SEI messages with payloadType equal to 0 or 1 not included in a scalable nesting SEI \nmessage  are  used  as  the  buffering  period  and  picture  timing  SEI  messages  for  checking  the  bitstream \nconformance according to Annex C and the decoding process specified in clauses 2 to 9 is used, the bitstream \nshall be conforming to this Recommendation | International Standard. \nThe value of seq_parameter_set_id in a buffering period SEI message not included in a scalable nesting SEI \nmessage shall be equal to the value of seq_parameter_set_id in the picture parameter set that is referenced by the \nlayer representation with DQId equal to 0 of the primary coded picture in the same access unit. \n–  Otherwise (the SEI message is included in a scalable nesting SEI message), the following applies. When the SEI \nmessage and all other SEI messages with payloadType equal to 0 or 1 included in a scalable nesting SEI message \nwith identical values of sei_temporal_id, sei_dependency_id[ i ], and sei_quality_id[ i ] are used as the buffering \nperiod and picture timing SEI messages for checking the bitstream conformance according to Annex C, the \nbitstream that would be obtained by invoking the bitstream extraction process as specified in clause G.8.8.1 with \ntIdTarget  equal  to  sei_temporal_id,  dIdTarget  equal  to  sei_dependency_id[ i ],  and  qIdTarget  equal  to \nsei_quality_id[ i ] shall be conforming to this Recommendation | International Standard. \nIn  the  semantics  of  clauses D.2.1  and  D.2.3,  the  syntax  elements  num_units_in_tick,  time_scale, \nfixed_frame_rate_flag,  nal_hrd_parameters_present_flag,  vcl_hrd_parameters_present_flag, \nlow_delay_hrd_flag,  and  pic_struct_present_flag  and  the  derived  variables  NalHrdBpPresentFlag, \nVclHrdBpPresentFlag,  and  CpbDpbDelaysPresentFlag  are  substituted  with  the  syntax  elements \nvui_ext_num_units_in_tick[ i ],  vui_ext_time_scale[ i ],  vui_ext_fixed_frame_rate_flag[ i ], \nvui_ext_nal_hrd_parameters_present_flag[ i ],  vui_ext_vcl_hrd_parameters_present_flag[ i ], \nvui_ext_low_delay_hrd_flag[ i ],  and  vui_ext_pic_struct_present_flag[ i ]  and  the  derived  variables \nVuiExtNalHrdBpPresentFlag[ i ], VuiExtVclHrdBpPresentFlag[ i ], and VuiExtCpbDpbDelaysPresentFlag[ i ]. \nThe value of seq_parameter_set_id in a buffering period SEI message included in a scalable nesting SEI message \nwith  the  values  of  sei_dependency_id[ i ]  and  sei_quality_id[ i ]  shall  be  equal  to  the  value  of \nseq_parameter_set_id in the picture parameter set that is referenced by the layer representation with DQId equal \nto (( sei_dependency_id[ i ] << 4 ) + sei_quality_id[ i ]) of the primary coded picture in the same access unit. \n–  Otherwise (payloadType is equal to 4 or 5), the corresponding SEI message semantics are not extended. \nWhen an SEI message having a particular value of payloadType equal to 137 or 144, contained in a scalable nesting SEI \nmessage, and applying to a particular combination of dependency_id, quality_id, and temporal_id is present in an access \nunit, the SEI message with the particular value of payloadType applying to the particular combination of dependency_id, \nquality_id, and temporal_id shall be present a scalable nesting SEI message in the IDR access unit that is the first access \nunit of the coded video sequence. \nAll SEI messages having a particular value of payloadType equal to 137 or 144, contained in scalable nesting SEI \nmessages, and applying to a particular combination of dependency_id, quality_id, and temporal_id present in a coded video \nsequence shall have the same content. \nFor the semantics of SEI messages with payloadType in the range of 0 to 23, inclusive, or equal to 45, 47, 137, 142, 144, \n147, 148, 149, 150, 151, 154, 155, 156, 200, or 201, which are specified in clause D.2, SVC sequence parameter set is \nsubstituted for sequence parameter set; the parameters of the picture parameter set RBSP and SVC sequence parameter set \nRBSP that are in effect are specified in clause G.7.4.1.2.1. \nCoded video sequences conforming to one or more of the profiles specified in Annex G shall not include SEI NAL units \nthat contain SEI messages with payloadType in the range of 36 to 44, inclusive, or equal to 46, which are specified in \nclause H.13, or with payloadType in the range of 48 to 53, inclusive, which are specified in clause I.13. \nWhen an SEI NAL unit contains an SEI message with payloadType in the range of 24 to 35, inclusive, which are specified \nin clause G.13, it shall not contain any SEI message that has payloadType less than 24 or equal to 45, 47, 137, 142, 144, \n147, 148, 149, 150, 151, 154, 155, 156, 200, or 201 that is not included in a scalable nesting SEI message, and the first SEI \nmessage in the SEI NAL unit shall have payloadType in the range of 24 to 35, inclusive. \n622  Rec. ITU-T H.264 (06/2019) \n \nWhen an SEI NAL unit contains an SEI message with payloadType equal to 24, 28, or 29, it shall not contain any SEI \nmessage with payloadType not equal to 24, 28, or 29. \nWhen a scalable nesting SEI message (payloadType is equal to 30) is present in an SEI NAL unit, it shall be the only SEI \nmessage in the SEI NAL unit. \nThe semantics for SEI messages with payloadType in the range of 24 to 35, inclusive, are specified in the following. \nG.13.2.1 Scalability information SEI message semantics \nThe scalability information SEI message provides scalability information for subsets of the bitstream. \nIn the following specification of this clause, a VCL NAL unit of a primary coded picture is also referred to as primary \ncoded VCL NAL unit and a VCL NAL unit of a redundant coded picture is also referred to as redundant coded VCL NAL \nunit. \nA scalability information SEI message shall not be included in a scalable nesting SEI message. \nA scalability information SEI message shall not be present in access units that contain primary coded VCL NAL units with \nIdrPicFlag equal to 0. The set of access units consisting of the access unit associated with the scalability information SEI \nmessage and all succeeding access units in decoding order until, but excluding, the next access unit that does not contain \nany primary coded VCL NAL unit with IdrPicFlag equal to 0 (if present) or the end of the bitstream (otherwise) is referred \nto as the target access unit set. The scalability information SEI message applies to the target access unit set. \nThe scalability information SEI message provides information for subsets of the target access unit set. These subsets are \nreferred to as scalable layers. A scalable layer represents a set of NAL units, inside the target access unit set, that consists \nof VCL NAL units with the same values of dependency_id, quality_id, and temporal_id, as specified later in this clause, \nand associated non-VCL NAL units. When present in the target access unit set, the following NAL units are associated \nnon-VCL NAL units for a scalable layer: \n–  sequence parameter set, subset sequence parameter set, and picture parameter set NAL units that are referenced in the \nVCL NAL units of the scalable layer (via the syntax element pic_parameter_set_id), \n–  sequence parameter set extension NAL units that are associated with a sequence parameter set NAL unit referenced \nin the VCL NAL units of the scalable layer, \n–  filler data NAL units that are associated with the same values of dependency_id, quality_id, and temporal_id as the \nVCL NAL units of the scalable layer, \n–  SEI NAL units containing SEI messages, with payloadType not equal to 24, 28, or 29, that apply to subsets of the \nbitstream that contain one or more VCL NAL units of the scalable layer, \n–  access unit delimiter, end of sequence, and end of stream NAL units that are present in access units that contain VCL \nNAL units of the scalable layer, \n–  when dependency_id and quality_id are both equal to 0 in the VCL NAL units of a scalable layer, coded slice of an \nauxiliary coded picture without partitioning NAL units that are present in access units that contain VCL NAL units \nof the scalable layer. \nA scalable layer A is directly dependent on a scalable layer B when any primary coded VCL NAL unit of the scalable layer \nA references data of any VCL NAL unit of the scalable layer B through inter prediction or inter-layer prediction as specified \nin the decoding process in clause G.8, with the following exception: A scalable layer A (identified by layer_id[ a ]) is not \ndirectly  dependent  on  a  scalable  layer  B  (identified  by  layer_id[ b ])  when  dependency_id[ a ]  is  equal  to \ndependency_id[ b ], sub_pic_layer_flag[ a ] is equal to 1, and one of the following conditions is true: \n–  sub_pic_layer_flag[ b ] is equal to 0, \n–  sub_pic_layer_flag[ b ]  is  equal  to  1  and  (horizontal_offset[ a ]  is  not  equal  to  horizontal_offset[ b ], \nvertical_offset[ a ]  is  not  equal  to  vertical_offset[ b ],  region_width[ a ]  is  not  equal  to  region_width[ b ],  or \nregion_height[ a ] is not equal to region_height[ b ]). \nNOTE 1 – Sub-picture scalable layers with a particular value of dependency_id and a particular sub-picture area are only considered \nto depend on scalable layers with the same value of dependency_id when these scalable layers are associated with the same \nsub-picture area. \nA scalable layer A is indirectly dependent on a scalable layer B when the scalable layer A is not directly dependent on the \nscalable layer B but there exists a set of n (with n being greater than 0) scalable layers {C  .., C } with the following \n0, n−1\nproperties: The scalable layer A is directly dependent on the scalable layer C , each scalable layer C with i in the range of \n0 i\n0 to n − 2, inclusive, is directly dependent on the scalable layer C , and the scalable layer C  is directly dependent on \ni+1 n−1\nthe scalable layer B. \n    Rec. ITU-T H.264 (06/2019)  623 \n \nThe representation of a particular scalable layer is the set of NAL units that represents the set union of the particular \nscalable layer and all scalable layers on which the particular scalable layer directly or indirectly depends. The representation \nof a scalable layer is also referred to as scalable layer representation. In the following specification of this clause, the terms \nrepresentation of a scalable layer and scalable layer representation are also used for referring to the access unit set that can \nbe constructed from the NAL units of the scalable layer representation. A scalable layer representation can be decoded \nindependently of all NAL units that do not belong to the scalable layer representation. The decoding result of a scalable \nlayer representation is the set of decoded pictures that are obtained by decoding the access unit set of the scalable layer \nrepresentation. \nNOTE 2 – The set of access units that is formed by the representation of a scalable layer with sub_pic_layer_flag[ i ] equal to 1 does \nnot conform to this Recommendation | International Standard, since the primary coded VCL NAL units with quality_id equal to 0 \nthat belong to such a scalable layer representation do not cover all macroblocks of the layer pictures with dependency_id equal to \ndependency_id[ i ] and quality_id equal to 0. For the following specification in this clause, the decoding result for the representation \nof a scalable layer with sub_pic_layer_flag[ i ] equal to 1 is the decoding result that would be obtained for the sub-picture area (as \nspecified later in this clause) by following the decoding process in clause G.8 but ignoring the constraint that the layer representations \nwith quality_id equal to 0 of primary coded pictures must cover all macroblocks of the corresponding layer pictures. \nEach scalable layer is associated with a unique layer identifier as specified later in this clause. The representation of a \nparticular scalable layer with a particular layer identifier layerId does not include any scalable layer with a layer identifier \ngreater than layerId, but it may include scalable layers with layer identifiers less than layerId. The scalable layers on which \na particular scalable layer depends may be indicated in the scalability information SEI message as specified later in this \nclause. \nNOTE 3 – When all scalable layers for which scalability information is provided in the scalability information SEI message have \nsub_pic_layer_flag[ i ] equal to 0, the unique layer identifier values may be set equal to ( 128 * dependency_id + 8 * quality_id + \ntemporal_id ), with dependency_id, quality_id, and temporal_id being the corresponding syntax elements that are associated with \nthe VCL NAL units of a scalable layer. \ntemporal_id_nesting_flag indicates  whether inter prediction is additionally restricted for the target access  unit  set. \nDepending on the value of temporal_id_nesting_flag, the following applies: \n–  If  temporal_id_nesting_flag  is  equal  to 1,  the  scalability  information  SEI  message  indicates  that  the  following \nconstraint is obeyed for all access units sets that can be derived from the target access unit set by invoking the \nsub-bitstream extraction process as specified in clause G.8.8.1 with tIdTarget equal to any value in the range of 0 to \n7, inclusive, dIdTarget equal to any value in the range of 0 to 7, inclusive, and qIdTarget equal to any value in the \nrange of 0 to 15, inclusive, as the inputs: The values of the samples in the decoded pictures for each access unit auA \nwith temporal_id equal to tIdA and all following access units in decoding order are independent of an access unit auB \nwith temporal_id equal to tIdB and tIdB less than or equal to tIdA, when there exists an access unit auC with \ntemporal_id equal to tIdC and tIdC less than tIdB, that follows the access unit auB and precedes the access unit auA \nin decoding order. \n–  Otherwise  (temporal_id_nesting_flag  is  equal  to  0),  the  scalability  information  SEI  message  indicates  that  the \nconstraint specified for temporal_id_nesting_flag equal to 1 may or may not be obeyed. \nNOTE 4 – The syntax element temporal_id_nesting_flag is used to indicate that temporal up-switching, i.e., switching from decoding \nof up to a particular temporal_id value tIdN to decoding of up to a temporal_id value tIdM greater than tIdN, is always possible \ninside the target access unit set. \npriority_layer_info_present_flag equal to 1 specifies that characteristic information for priority layers, as specified later \nin this clause, is present in the scalability information SEI message and that priority layer information SEI messages \nassociating an alternative value for priority_id with each layer representation of the primary coded pictures in the target \naccess unit set are present. priority_layer_info_present_flag equal to 0 specifies that characteristic information for priority \nlayers is not present in the scalability information SEI message. \npriority_id_setting_flag equal to 1 specifies that syntax elements priority_id_setting_uri[ i ] are present in the scalability \ninformation SEI message and that the description of the method used to calculate the priority_id values is provided by the \nspecified  universal  resource  identifier  (URI).  priority_id_setting_flag  equal  to  0  specifies  that  syntax  elements \npriority_id_setting_uri[ i ] are not present in the scalability information SEI message. \nnum_layers_minus1 plus 1 specifies the number of scalable layers for which information is provided in the scalability \ninformation SEI message. The value of num_layers_minus1 shall be in the range of 0 to 2047, inclusive. \nlayer_id[ i ] specifies the layer identifier of the i-th scalable layer specified in the scalability information SEI message. \nlayer_id[ i ] shall be in the range of 0 to 2047, inclusive. \nFor the following specification inside this clause, the scalable layer with layer identifier equal to the current value of \nlayer_id[ i ] is referred to as the current scalable layer, and the representation of the current scalable layer is referred to as \nthe current scalable layer representation. \n624  Rec. ITU-T H.264 (06/2019) \n \npriority_id[ i ] indicates an upper bound for the priority_id values of the current scalable layer representation. All primary \ncoded VCL NAL units of the current scalable layer representation shall have a value of priority_id that is less than or equal \nto priority_id[ i ]. \ndiscardable_flag[ i ] equal to 1 indicates that all primary coded VCL NAL units of the current scalable layer have \ndiscardable_flag equal to 1. discardable_flag[ i ] equal to 0 indicates that the current scalable layer may contain one or \nmore primary coded VCL NAL units with discardable_flag equal to 0. \ndependency_id[ i ],  quality_id[ i ],  and  temporal_id[ i ]  are  equal  to  the  values  of  dependency_id,  quality_id,  and \ntemporal_id, respectively, of the VCL NAL units of the current scalable layer. All VCL NAL units of a scalable layer have \nthe same values of dependency_id, quality_id, and temporal_id. \nWhen the target access unit set does not contain any primary coded VCL NAL unit with particular values of dependency_id, \nquality_id, and temporal_id, the scalability information SEI message shall not contain information for a scalable layer with \ndependency_id[ i ], quality_id[ i ], and temporal_id[ i ] equal to the particular values of dependency_id, quality_id, and \ntemporal_id, respectively. \nNOTE 5 – When an application removes NAL units from a scalable bitstream, e.g. in order to adapt the bitstream to a transmission \nchannel or the capabilities of a receiving device, and keeps the present scalability information SEI messages, it might need to modify \nthe content of the scalability information SEI messages in order to obtain a bitstream conforming to this Recommendation | \nInternational Standard. \nsub_pic_layer_flag[ i ] specifies whether the current scalable layer represents a sub-picture scalable layer as specified \nsubsequently. Depending on sub_pic_layer_flag[ i ], the following applies: \n–  If sub_pic_layer_flag[ i ] is equal to 0, the current scalable layer does not represent a sub-picture scalable layer. The \nVCL  NAL  units  of  the  current  scalable  layer  are  all  VCL  NAL  units  of  the  target  access  unit  set  that  have \ndependency_id,  quality_id,  and  temporal_id  equal  to  dependency_id[ i ],  quality_id[ i ],  and  temporal_id[ i ], \nrespectively. \n–  Otherwise (sub_pic_layer_flag[ i ] is equal to 1), the current scalable layer represents a sub-picture scalable layer and \nis associated with a sub-picture area as specified in the following: \n(a)  The sub-picture area is a rectangular area of slice group map units inside the layer frames with dependency_id \nequal to dependency_id[ i ] and represents a proper subset of the area of the layer frames with dependency_id \nequal to dependency_id[ i ]. The sub-picture area associated with a sub-picture scalable layer does not change \ninside the target access unit set. The sub-picture area is specified by the syntax elements horizontal_offset[ i ], \nvertical_offset[ i ], region_width[ i ], and region_height[ i ] as specified later in this clause. \nNOTE 6 – The sub-picture area for a sub-picture scalable layer may additionally be indicated by the presence of sub-\npicture scalable layer SEI messages with layer_id equal to value of layer_id[ i ] for the current scalable layer. \n(b)  When a VCL NAL unit of the target access unit set has dependency_id equal to dependency_id[ i ] and contains \nany macroblock that resides inside the sub-picture area, it shall not contain any macroblock that resides outside \nof the sub-picture area. \n(c)  The VCL NAL units of the current scalable layer are the coded slice NAL units of the target access unit set that \nhave  dependency_id,  quality_id,  and  temporal_id  equal  to  dependency_id[ i ],  quality_id[ i ],  and \ntemporal_id[ i ], respectively, and for which the macroblock specified by first_mb_in_slice resides inside the \nspecified sub-picture area and the associated prefix NAL units (when present). \n(d)  For all access units sets that can be derived from the target access unit set by invoking the sub-bitstream extraction \nprocess as specified in clause G.8.8.1 with dIdTarget equal to dependency_id[ i ] and qIdTarget equal to any value \nin the range of 0 to 15, inclusive, as the inputs, the following constraint shall be obeyed: No sample value outside \nthe sub-picture area and no sample value at a fractional sample position that is derived using one or more sample \nvalues outside the sub-picture area is used, in the decoding process as specified in clause G.8, for inter prediction \nof any sample within the sub-picture area. \nWhen the target access unit set contains any primary coded VCL NAL unit with particular values of dependency_id, \nquality_id, and temporal_id, the scalability information SEI message shall contain information for a exactly one scalable \nlayer  with  dependency_id[ i ],  quality_id[ i ],  and  temporal_id[ i ]  equal  to  the  particular  values  of  dependency_id, \nquality_id, and temporal_id, respectively, and sub_pic_layer_flag[ i ] equal to 0. \nNOTE 7 – The scalability information SEI message may additionally contain information for one or more scalable layers with \ndependency_id[ i ], quality_id[ i ], and temporal_id[ i ] equal to the particular values of dependency_id, quality_id, and temporal_id, \nrespectively, and sub_pic_layer_flag[ i ] equal to 1. \nWhen sub_pic_layer_flag[ i ] is equal to 1 for the current scalable layer and the target access unit set contains any primary \ncoded VCL NAL unit that has dependency_id equal to dependency_id[ i ], resides inside the sub-picture area, and has \nparticular values of quality_id and temporal_id, with either quality_id not equal to quality_id[ i ] or temporal_id not equal \nto temporal_id[ i ], the scalability information SEI message shall also contain information for a scalable layer j with \ndependency_id[ j ]  equal  to  dependency_id[ i ],  quality_id[ j ]  and  temporal_id[ j ]  equal  to  the  particular  values  of \n    Rec. ITU-T H.264 (06/2019)  625 \n \nquality_id and temporal_id, respectively, sub_pic_layer_flag[ j ] equal to 1, and horizontal_offset[ j ], vertical_offset[ j ], \nregion_width[ j ],  and  region_height[ j ]  equal  to  horizontal_offset[ i ],  vertical_offset[ i ],  region_width[ i ],  and \nregion_height[ i ], respectively. \nThe  scalability  information  SEI  message  shall  not  contain  information  for  two  or  more  scalable  layers  with \nsub_pic_layer_flag[ i ]  equal  to  1  and  the  same  values  of  dependency_id[ i ],  quality_id[ i ],  temporal_id[ i ], \nsub_pic_layer_flag[ i ], horizontal_offset[ i ], vertical_offset[ i ], region_width[ i ], and region_height[ i ]. \nWhen the scalability information SEI message contains information for two scalable  layers  A and B (identified by \nlayer_id[ a ] and layer_id[ b ], respectively) with dependency_id[ a ] equal to dependency_id[ b ], quality_id[ a ] equal to \nquality_id[ b ], temporal_id[ a ] equal to temporal_id[ b ], sub_pic_layer_flag[ a ] equal to 1, and sub_pic_layer_flag[ b ] \nequal to 1, and the sub-picture areas associated with the scalable layers A and B overlap, the scalability information SEI \nmessage shall also contain information for a scalable layer C (identified by layer_id[ c ]) with dependency_id[ c ] equal to \ndependency_id[ b ],  quality_id[ c ]  equal  to  quality_id[ b ],  temporal_id[ c ]  equal  to  temporal_id[ b ],  and \nsub_pic_layer_flag[ c ] is equal to 1, and with the scalable layer C being associated with a sub-picture area that represents \nthe intersection of the sub-picture areas associated with the scalable layers A and B. \nsub_region_layer_flag[ i ]  equal  to  1  specifies  that  the  syntax  elements  base_region_layer_id[ i ]  and \ndynamic_rect_flag[ i ]  for  the  current  scalable  layer  are  present  in  the  scalability  information  SEI  message. \nsub_region_layer_flag[ i ]  equal  to  0  specifies  that  the  syntax  elements  base_region_layer_id[ i ]  and \ndynamic_rect_flag[ i ] for the current scalable layer are not present in the scalability information SEI message. \nWhen sub_pic_layer_flag[ i ] is equal to 1, sub_region_layer_flag[ i ] shall be equal to 1. \niroi_division_info_present_flag[ i ]  equal  to  1  specifies  that  the  layer  pictures  with  dependency_id  equal  to \ndependency_id[ i ] are divided along slice group map unit boundaries into multiple rectangular regions of interest, referred \nto as interactive regions of interest (IROIs), and that the IROI division information is explicitly signalled in the scalability \ninformation SEI message as specified later in this clause, and that the syntax elements frame_width_in_mbs_minus1[ i ] \nand frame_height_in_mbs_minus1[ i ] for the current scalable layer are present in the scalability information SEI message. \niroi_division_info_present_flag[ i ] equal to 0 specifies that the IROI division information for the current scalable layer is \nnot present in the scalability information SEI message. \nWhen sub_pic_layer_flag[ i ] is equal to 1, iroi_division_info_present_flag[ i ] shall be equal to 0. \nWhen iroi_division_info_present_flag[ i ] is equal to 1, the following is specified: \n(a)  When a primary coded VCL NAL unit of the target access unit set has dependency_id equal to dependency_id[ i ] \nand contains any macroblock that resides inside a particular IROI, it shall not contain any macroblock that resides \noutside of the particular IROI. \n(b)  For all access units sets that can be derived from the target access unit set by invoking the sub-bitstream extraction \nprocess as specified in clause G.8.8.1 with dIdTarget equal to dependency_id[ i ] and qIdTarget equal to any value \nin the range of 0 to 15, inclusive, as the inputs, the following constraint shall be obeyed: No sample value outside \na particular IROI and no sample value at a fractional sample position that is derived using one or more sample \nvalues outside the particular IROI is used, in the decoding process as specified in clause G.8, for inter prediction \nof any sample within the particular IROI. \nAll scalable layers with the same value of dependency_id[ i ] for which scalability information is present in the scalability \ninformation SEI message shall have the same value of iroi_division_info_present_flag[ i ]. \nprofile_level_info_present_flag[ i ]  equal  to  1  specifies  that  profile_idc,  constraint_set0_flag,  constraint_set1_flag, \nconstraint_set2_flag, constraint_set3_flag, constraint_set4_flag, constraint_set5_flag, reserved_zero_2bits, and level_idc \napplicable for the current scalable layer representation are indicated by the value of layer_profile_level_idc[ i ] as specified \nlater in this clause. \nWhen  profile_level_info_present_flag[ i ]  is  equal  to 0,  profile_idc,  constraint_set0_flag,  constraint_set1_flag, \nconstraint_set2_flag,  constraint_set3_flag,  constraint_set4_flag,  constraint_set5_flag,  and  level_idc  applicable  for  the \ncurrent scalable layer representation are not indicated in the scalability information SEI message. \nbitrate_info_present_flag[ i ] equal to 1 specifies that the bit rate information for the current scalable layer representation \nis present in the scalability information SEI message. bitrate_info_present_flag[ i ] equal to 0 specifies that the bit rate \ninformation for the current scalable layer representation is not present in the scalability information SEI message. \nfrm_rate_info_present_flag[ i ]  equal  to  1  specifies  that  the  frame  rate  information  for  the  current  scalable  layer \nrepresentation is present in the scalability information SEI message. frm_rate_info_present_flag[ i ] equal to 0 specifies \nthat the frame rate information for the current scalable layer representation is not present in the scalability information SEI \nmessage. \n626  Rec. ITU-T H.264 (06/2019) \n \nfrm_size_info_present_flag[ i ]  equal  to  1  specifies  that  the  frame  size  information  for  the  current  scalable  layer \nrepresentation is present in the scalability information SEI message. frm_size_info_present_flag[ i ] equal to 0 specifies \nthat the presence of the frame size information for the current scalable layer representation in the scalability information \nSEI message is specified by iroi_division_info_present_flag[ i ]. \nlayer_dependency_info_present_flag[ i ]  equal  to  1  specifies  that  one  or  more  syntax  elements \ndependent_layer_id_delta_minus1[ i ][ j ] indicating the layer dependency information for the current scalable layer are \npresent in the scalability information SEI message. layer_dependency_info_present_flag[ i ] equal to 0 specifies that, for \nthe current scalable layer, the syntax element layer_dependency_info_src_layer_id_delta[ i ] is present in the scalability \ninformation SEI message. \nparameter_sets_info_present_flag[ i ] equal to 1 specifies that the values of seq_parameter_set_id  of the sequence \nparameter sets and subset sequence parameter sets and the values of pic_parameter_set_id of the picture parameter sets \nthat are referred to in the primary coded VCL NAL units of the current scalable layer representation are present in the \nscalability information SEI message. parameter_sets_info_present_flag[ i ] equal to 0 specifies that, for the current scalable \nlayer, the syntax element parameter_sets_info_src_layer_id_delta[ i ] is present in the scalability information SEI message. \nbitstream_restriction_info_present_flag[ i ] equal to 1 specifies that the bitstream restriction information for the current \nscalable  layer  representation  is  present  in  the  scalability  information  SEI  message. \nbitstream_restriction_info_present_flag[ i ] equal to 0 specifies that the bitstream restriction information for the current \nscalable layer representation is not present in the scalability information SEI message. \nexact_inter_layer_pred_flag[ i ]  equal  to  1  indicates  that,  for  all  primary  coded  VCL  NAL  units  with \nno_inter_layer_pred_flag  equal  to  0  of  the  current  scalable  layer  representation,  the  reference  layer  representation \n(specified by the syntax elements ref_layer_dq_id) that is used for inter-layer prediction in the decoding process, as \nspecified  in  clause G.8,  is  the  same  as  the  reference  layer  representation  that  was  used  during  encoding. \nexact_inter_layer_pred_flag[ i ]  equal  to  0  indicates  that,  for  the  primary  coded  VCL  NAL  units  with \nno_inter_layer_pred_flag equal to 0 of the current scalable layer representation, the reference layer representations that are \nused for inter-layer prediction in the decoding process may or may not be the same as the reference layer representations \nthat were used during encoding. \nNOTE 8 – A mismatch between the reference layer representation that is used for inter-layer prediction in the decoding process and \nthe reference layer representation that was used during encoding may be a result of a bitstream adaption, in which one or more layer \nrepresentations that are referred to in inter-layer prediction are removed from the bitstream, any of the primary coded VCL NAL \nunits that refer to any of the removed layer representations by inter-layer prediction is not removed from the bitstream, and the value \nof the syntax elements ref_layer_dq_id in the primary coded VCL NAL units that refer to any of the removed layer representations \nis modified in order to obtain a bitstream conforming to this Recommendation | International Standard. \nexact_inter_layer_pred_flag[ i ] should be equal to 1. When the current scalable layer representation does not contain any \nprimary coded VCL NAL unit with no_inter_layer_pred_flag equal to 0, exact_inter_layer_pred_flag[ i ] shall be equal \nto 1. \nexact_sample_value_match_flag[ i ] indicates whether the values of decoded samples for decoding the representation of \nthe current sub-picture scalable layer (when sub_pic_layer_flag[ i ] is equal to 1) or any particular IROI within the current \nscalable layer representation (when iroi_division_info_present_flag[ i ] is equal to 1) are identical to the values of the same \ndecoded samples that would be obtained by decoding all layer representations, of the primary coded pictures inside the \ntarget access unit set, that have DQId less than or equal to 16 * dependency_id[ i ] + quality_id[ i ] and temporal_id less \nthan or equal to temporal_id[ i ]. \nWith picSubset being the set of the primary coded pictures of the current scalable layer representation that contain any \nVCL NAL unit with dependency_id equal to dependency_id[ i ], the following applies: \n–  If sub_pic_layer_flag[ i ] is equal to 1 (iroi_division_info_present_flag[ i ] is equal to 0), the following is specified: \n1.  Let picLRepSubset be the set of primary coded pictures that is formed by all the layer representations, of the \ntarget access unit set, that contain any primary coded VCL NAL unit present in the set of pictures picSubset. \nNOTE 9 – picSubset is a proper subset of picLRepSubset. picSubset only contains the primary coded slices of the \ncurrent  (sub-picture)  scalable  layer  representation,  picLRepSubset  contains  all  primary  coded  slices  of  the \ncorresponding layer representations (i.e. the complete layer representations that contain any slice of picSubset). \n2.  exact_sample_value_match_flag[ i ]  equal  to 1  indicates  that  the  value  of  each  decoded  sample  inside  the \nsub-picture area for decoding the picture set picSubset is identical to the value of the same decoded sample that \nwould be obtained by decoding the picture set picLRepSubset. \n3.  exact_sample_value_match_flag[ i ]  equal  to 0  indicates  that  the  value  of  any  decoded  sample  inside  the \nsub-picture area for decoding the picture set picSubset may or may not be identical to the value of the same \ndecoded sample that would be obtained by decoding the picture set picLRepSubset. \n–  Otherwise (sub_pic_layer_flag[ i ] is equal to 0 and iroi_division_info_present_flag[ i ] is equal to 1), for each \nparticular IROI, the following is specified: \n    Rec. ITU-T H.264 (06/2019)  627 \n \n1.  Let picIROISubset be the set of primary coded VCL NAL units that is obtained by removing all the VCL NAL \nunits from the set of pictures picSubset that do not cover any macroblock inside the IROI. \n2.  exact_sample_value_match_flag[ i ] equal to 1 indicates that the value of each decoded sample inside the IROI \nfor decoding the picture set picSubset is identical to the value of the same decoded sample that would be obtained \nby decoding the picture set picIROISubset. \n3.  exact_sample_value_match_flag[ i ] equal to 0 indicates that the value of any decoded sample inside the IROI \nfor decoding the picture set picSubset may or may not be identical to the value of the same decoded sample that \nwould be obtained by decoding the picture set picIROISubset. \nNOTE 10 – In the above specification, the decoding result for picIROISubset is the decoding result that would be obtained for the \nIROI by following the decoding process in clause G.8 but ignoring the constraint that the layer representations with quality_id equal \nto 0 of primary coded pictures must cover all macroblocks of the corresponding layer pictures. \nNOTE 11 – When disable_deblocking_filter_idc is equal to 1, 2, or 5 in all primary coded slices of the current scalable layer \nrepresentation that have dependency_id equal to dependency_id[ i ], exact_sample_value_match_flag should be equal to 1. \nlayer_conversion_flag[ i ] equal to 1 indicates that the representation of the current scalable layer can be converted into \nan alternative set of access units that conforms to one or more of the profiles specified in Annex A and gives exactly the \nsame decoding result as the current scalable layer representation  and that this conversion can be done  without  full \nreconstruction and re-encoding. layer_conversion_flag[ i ] equal to 0 indicates that such a conversion of the current \nscalable layer representation may or may not be possible. \nlayer_output_flag[ i ] equal to 1 indicates that the decoding result for the current scalable layer representation is intended \nfor output. layer_output_flag[ i ] equal to 0 indicates that the decoding result for the current scalable layer representation \nis not intended for output. \nNOTE 12 – The decoding result for a scalable layer representation with layer_output_flag[ i ] equal to 0 may be inappropriate for \noutput due to its low visual quality. \nlayer_profile_level_idc[ i ]  indicates  the  conformance  point  of  the  representation  of  the  current  scalable  layer. \nlayer_profile_level_idc[ i ]  is  the  exact  copy  of  the  three  bytes  comprised  of  profile_idc,  constraint_set0_flag, \nconstraint_set1_flag,  constraint_set2_flag,  constraint_set3_flag,  constraint_set4_flag,  constraint_set5_flag, \nreserved_zero_2bits and level_idc, as if these syntax elements were used to specify the profile and level conformance of \nthe representation of the current scalable layer. \nNOTE 13 – The representation of a sub-picture scalable layer (sub_pic_layer_flag[ i ] is equal to 1) does not conform to this \nRecommendation | International Standard, since the primary coded VCL NAL units with quality_id equal to 0 that belong to a sub-\npicture  scalable  layer  representation  do  not  cover  all  macroblocks  of  the  layer  pictures  with  dependency_id  equal  to \ndependency_id[ i ]  and  quality_id  equal  to  0.  For  sub-picture  scalable  layers,  the  violation  of  the  constraint  that  the  layer \nrepresentations with quality_id equal to 0 of primary coded pictures must cover all macroblocks of the corresponding layer pictures \nis ignored in the conformance point indication by layer_profile_level_idc[ i ]. \navg_bitrate[ i ] indicates the average bit rate of the representation of the current scalable layer. The average bit rate for \nthe representation of the current scalable layer in bits per second is given by BitRateBPS( avg_bitrate[ i ] ) with the function \nBitRateBPS( ) being specified by: \nBitRateBPS( x ) = ( x & ( 214 − 1 ) ) * 10( 2 + ( x >> 14 ) )  (G-370) \nThe average bit rate is derived according to the access unit removal time specified in Annex C of this Recommendation | \nInternational Standard. In the following, bTotal is the number of bits in all NAL units of the current scalable layer \nrepresentation, t  is the removal time (in seconds) of the access unit associated with the scalability information SEI \n1\nmessage, and t  is the removal time (in seconds) of the last access unit (in decoding order) of the target access unit set. \n2\nWith x specifying the value of avg_bitrate[ i ], the following applies: \n–  If t  is not equal to t , the following condition shall be true: \n1 2\n( x & ( 214 − 1 ) )  = =  Round( bTotal ÷ ( ( t  − t  ) * 10( 2 + ( x >> 14 ) ) ) )  (G-371) \n2 1\n–  Otherwise (t  is equal to t ), the following condition shall be true: \n1 2\n( x & ( 214 − 1 ) )  = =  0  (G-372) \nmax_bitrate_layer[ i ] indicates an upper bound for the bit rate of the current scalable layer in any fixed-size time window, \nspecified by max_bitrate_calc_window[ i ], of access unit removal time as specified in Annex C. The upper bound for the \nbit rate of the current scalable layer in bits per second is given by BitRateBPS( max_bitrate_layer[ i ] ) with the function \nBitRateBPS( ) being specified in Equation G-370. The bit rate values are derived according to the access unit removal time \nspecified in Annex C of this Recommendation | International Standard. In the following, t  is any point in time (in seconds), \n1\nt  is set equal to t  + max_bitrate_calc_window[ i ] ÷ 100, and bTotal is the number of bits in all NAL units of the current \n2 1\nscalable layer that belong to access units with a removal time greater than or equal to t  and less than t . With x specifying \n1 2\nthe value of max_bitrate_layer[ i ], the following condition shall be obeyed for all values of t : \n1\n628  Rec. ITU-T H.264 (06/2019) \n \n( x & ( 214 − 1 ) )  >=  bTotal ÷ ( ( t  − t  ) * 10( 2 + ( x >> 14 ) ) )  (G-373) \n2 1\nmax_bitrate_layer_representation[ i ]  indicates  an  upper  bound  for  the  bit  rate  of  the  current  scalable  layer \nrepresentation in any fixed-size time window, specified by max_bitrate_calc_window[ i ], of access unit removal time as \nspecified in Annex C. The upper bound for the bit rate of the current scalable layer representation in bits per second is \ngiven  by  BitRateBPS( max_bitrate_layer_representation[ i ] )  with  the  function  BitRateBPS( )  being  specified  in \nEquation G-370. The bit rate values are derived according to the access unit removal time specified in Annex C of this \nRecommendation |  International  Standard.  In  the  following,  t   is  any  point  in  time  (in  seconds),  t   is  set  equal  to \n1 2\nt  + max_bitrate_calc_window[ i ] ÷ 100, and bTotal is the number of bits in all NAL units of the current scalable layer \n1\nrepresentation that belong to access units with a removal time greater than or equal to t  and less than t . With x specifying \n1 2\nthe value of max_bitrate_layer_representation[ i ], the condition specified in Equation G-373 shall be obeyed. \nmax_bitrate_calc_window[ i ] specifies the size of the time window that is used for calculating the upper bounds for the \nbit rate of the current scalable layer (indicated by max_bitrate_layer[ i ]) and the bit rate of the current scalable layer \nrepresentation (indicated by max_bitrate_layer_representation[ i ]) in units of 1/100 second. \nconstant_frm_rate_idc[ i ] indicates whether the frame rate of the current scalable layer representation is constant. In the \nfollowing, a temporal segment tSeg is any set of two or more consecutive access units, in decoding order, of the current \nscalable layer representation, fTotal( tSeg ) is the number of frames, complementary field pairs, and non-paired fields in \nthe temporal segment tSeg, t ( tSeg ) is the removal time (in seconds) of the first access unit (in decoding order) of the \n1\ntemporal segment tSeg, t ( tSeg ) is the removal time (in seconds) of the last access unit (in decoding order) of the temporal \n2\nsegment tSeg, and avgFR( tSeg ) is the average frame rate in the temporal segment tSeg, which is given by: \navgFR( tSeg)  = =  Round( fTotal( tSeg ) * 256 ÷ ( t ( tSeg ) − t ( tSeg ) ) )  (G-374) \n2 1\nIf the current scalable layer representation does only contain one access unit or the value of avgFR( tSeg ) is constant over \nall temporal segments of the scalable layer representation, the frame rate is constant; otherwise, the frame rate is not \nconstant. constant_frm_rate_idc[ i ] equal to 0 indicates that the frame rate of the current scalable layer representation is \nnot constant. constant_frm_rate_idc[ i ] equal to 1 indicates that the frame rate of the current scalable layer representation \nis constant. constant_frm_rate_idc[ i ] equal to  2 indicates that the frame rate of the current scalable layer representation \nmay or may not be constant. The value of constant_frm_rate_idc[ i ] shall be in the range of 0 to 2, inclusive. \navg_frm_rate[ i ] indicates the average frame rate, in units of frames per 256 seconds, of the representation of the current \nscalable layer. With fTotal being the number of frames, complementary field pairs, and non-paired fields in the current \nscalable layer representation, t  being the removal time (in seconds) of the access unit associated with the scalability \n1\ninformation SEI message, and t  being the removal time (in seconds) of the last access unit (in decoding order) of the target \n2\naccess unit set, the following applies: \n–  If t  is not equal to t , the following condition shall be true: \n1 2\navg_frm_rate[ i ]  = =  Round( fTotal * 256 ÷ ( t  − t  ) )  (G-375) \n2 1\n–  Otherwise (t  is equal to t ), the following condition shall be true: \n1 2\navg_frm_rate[ i ]  = =  0  (G-376) \nfrm_width_in_mbs_minus1[ i ] and frm_height_in_mbs_minus1[ i ] indicate the width and height, respectively, of the \ndecoded pictures for the current scalable layer representation (when sub_pic_layer_flag[ i ] is equal to 0) or the sub-picture \narea inside the decoded pictures for the current sub-picture scalable layer (when sub_pic_layer_flag[ i ] is equal to 1). \nWhen  frame_mbs_only_flag  is  equal  to 0  for  any  primary  coded  VCL  NAL  unit  of  the  current  scalable  layer, \n( frm_height_in_mbs_minus1[ i ] + 1 ) % 2 shall be equal to 0. \nLet picSubset be the set of the primary coded pictures inside the current scalable layer representation that contain any VCL \nNAL unit with dependency_id equal to dependency_id[ i ]. For decoding the picture set picSubset, the following applies: \n–  If  sub_pic_layer_flag[ i ]  is  equal  to 0,  the  width  and  height  of  a  decoded  picture  are  equal  to \nfrm_width_in_mbs_minus1[ i ] + 1  and  ( ( frm_height_in_mbs_minus1[ i ] + 1 ) / ( 1 + field_pic_flag ) ) \nmacroblocks, respectively, with field_pic_flag being the slice header syntax element in the slices with dependency_id \nequal to dependency_id[ i ] of the corresponding primary coded picture. The width and height of the decoded pictures \nthat  are  indicated  by  frm_width_in_mbs_minus1[ i ]  and  frm_height_in_mbs_minus1[ i ],  respectively,  shall  be \nidentical  to  the  width  and  height  of  the  decoded  pictures  that  are  specified  by  the  syntax  elements \npic_width_in_mbs_minus1 and pic_height_in_map_units_minus1, respectively, of the SVC sequence parameter sets \nreferenced in the corresponding coded slice NAL units with dependency_id equal to dependency_id[ i ]. \n–  Otherwise (sub_pic_layer_flag[ i ] is equal to 1), the width and height of the sub-picture area inside a decoded picture \nare equal to frm_width_in_mbs_minus1[ i ] + 1 and ( ( frm_height_in_mbs_minus1[ i ] + 1 ) / ( 1 + field_pic_flag ) ) \nmacroblocks, respectively, with field_pic_flag being the slice header syntax element in the slices with dependency_id \nequal to dependency_id[ i ] of the corresponding primary coded picture. The sub-picture area that is indicated by \nfrm_width_in_mbs_minus1[ i ]  and  frm_height_in_mbs_minus1[ i ]  shall  be  less  than  the  area  of  the  decoded \n    Rec. ITU-T H.264 (06/2019)  629 \n \npictures, which is specified by the syntax elements pic_width_in_mbs_minus1 and pic_height_in_map_units_minus1 \nof the SVC sequence parameter sets referenced in the corresponding coded slice NAL units with dependency_id equal \nto dependency_id[ i ]. \nThe variable FrmWidthInMbs[ i ] is set equal to (frm_width_in_mbs_minus1[ i ] + 1). The variable FrmHeightInMbs[ i ] \nis  set  equal  to   frm_height_in_mbs_minus1[ i ] + 1 .  The  variable  FrmSizeInMbs[ i ]  is  set  equal  to \n(FrmWidthInMbs[ i ] * FrmHeightInMbs[ i ]). \nbase_region_layer_id[ i ] indicates the layer identifier layer_id[ b ] of the scalable layer b that represents the base region \nfor the current scalable layer as specified in the following. The value of base_region_layer_id[ i ] shall be in the range of 0 \nto 2047, inclusive. \nLet picSubset be the set of the primary coded pictures, inside the current scalable layer representation, that contain any \nVCL NAL unit with dependency_id equal to dependency_id[ i ]. Let basePicSubset be the set of the primary coded \npictures, inside the representation of the scalable layer b with layer_id[ b ] equal to base_region_layer_id[ i ], that contain \nany VCL NAL unit with dependency_id equal to dependency_id[ b ]. Depending on sub_pic_layer_flag[ i ], the following \napplies: \n–  If sub_pic_layer_flag[ i ] is equal to 0, it is indicated that the decoded pictures for the picture set picSubset represent \na subset of the areas that are represented by the decoded pictures for the picture set basePicSubset. The value of \ndependency_id[ b ] for the scalable layer b shall be less than the value of dependency_id[ i ] for the current scalable \nlayer. The area that is represented by the decoded pictures for the picture set picSubset is also referred to as the region \nrepresented by the current scalable layer and the area represented by the corresponding decoded pictures for the picture \nset basePicSubset is also referred to as the base region for the current scalable layer. \n–  Otherwise (sub_pic_layer_flag[ i ] is equal to 1), it is indicated that the sub-picture area inside the decoded pictures \nfor the picture set picSubset represents a proper subset of the areas that are represented by the decoded pictures for \nthe picture set basePicSubset. The value of dependency_id[ b ] shall be equal to the value of dependency_id[ i ] for \nthe current sub-picture scalable layer. The area that is represented by the sub-picture area inside the decoded pictures \nfor the picture set picSubset is also referred to as the region represented by the current scalable layer and the area \nrepresented by the corresponding decoded pictures for the picture set basePicSubset is also referred to as the base \nregion for the current scalable layer. \nNOTE 14 – When sub_pic_layer_flag[ i ] is equal to 1, the base region represents the area of the layer pictures  with \ndependency_id equal to dependency_id[ i ]. \nThe scalability information SEI message shall contain information for the scalable layer b with layer_id[ b ] equal to \nbase_region_layer_id[ i ], the value of sub_pic_layer_flag[ b ] for the scalable layer b shall be equal to 0, and the value of \ntemporal_id[ i ] for the scalable layer b shall be equal to the value of temporal_id[ i ] for the current scalable layer. \ndynamic_rect_flag[ i ] equal to 1 indicates that the region represented by the current scalable layer representation is a \ndynamically changing rectangular subset of the base region. dynamic_rect_flag[ i ] equal to 0 indicates that the region \nrepresented by the current scalable layer representation is a fixed rectangular subset of the base region and is specified by \nthe  syntax  elements  horizontal_offset[ i ],  vertical_offset[ i ],  region_width[ i ],  and  region_height[ i ].  When \nsub_pic_layer_flag[ i ] is equal to 1, dynamic_rect_flag[ i ] shall be equal to 0. \nhorizontal_offset[ i ], vertical_offset[ i ], region_width[ i ], and region_height[ i ] indicate the position and size of the \nregion represented by the current scalable layer in relation to its base region. \nLet picSubset be the set of the primary coded pictures, inside the current scalable layer representation, that contain any \nVCL NAL unit with dependency_id equal to dependency_id[ i ]. Let basePicSubset be the set of the primary coded \npictures, inside the representation of the scalable layer b with layer_id[ b ] equal to base_region_layer_id[ i ], that contain \nany VCL NAL unit with dependency_id equal to dependency_id[ b ]. Depending on sub_pic_layer_flag[ i ], the following \napplies: \n–  If sub_pic_layer_flag[ i ] is equal to 0, the top-left luma frame sample in the decoded pictures for picture set picSubset \ncorresponds to the luma frame sample at the luma frame sample location ( horizontal_offset[ i ], vertical_offset[ i ] ) \nin the decoded pictures for the picture set basePicSubset. The region represented by the decoded pictures for picture \nset picSubset represents an area of (region_width[ i ])x(region_height[ i ]) luma frame samples in the decoded pictures \nfor the picture set basePicSubset. When frame_mbs_only_flag is equal to 0 for any primary coded VCL NAL unit of \nthe current scalable layer, (vertical_offset[ i ] % 2) and (region_height[ i ] % 2) shall both be equal to 0. \n–  Otherwise (sub_pic_layer_flag[ i ] is equal to 1), the top-left luma frame sample of the sub-picture area in the decoded \npictures  for  picture  set  picSubset  corresponds  to  the  luma  frame  sample  at  the  luma  frame  sample  location \n( horizontal_offset[ i ], vertical_offset[ i ] ) in the decoded pictures for the picture set basePicSubset. The region \nrepresented  by  the  sub-picture  area  in  the  decoded  pictures  for  picture  set  picSubset  represents  an  area  of \n(region_width[ i ])x(region_height[ i ]) luma frame samples in the decoded pictures for the picture set basePicSubset. \n630  Rec. ITU-T H.264 (06/2019) \n \n(horizontal_offset[ i ] % 16) and (region_width[ i ] % 16) shall both be equal to 0, and depending on the values of \nframe_mbs_only_flag for the primary coded VCL NAL units of the current scalable layer, the following applies: \n–  If frame_mbs_only_flag is equal to 1 for all primary coded VCL NAL units of the current scalable layer, \n(vertical_offset[ i ] % 16) and (region_height[ i ] % 16) shall both be equal to 0. \n–  Otherwise (frame_mbs_only_flag is equal to 0 for any primary coded VCL NAL units of the current scalable \nlayer), (vertical_offset[ i ] % 32) and (region_height[ i ] % 32) shall both be equal to 0. \nWhen sub_pic_layer_flag[ i ] is equal to 1 and frm_size_info_present_flag[ i ] is equal to 1, the values of region_width[ i ] \nand region_height[ i ] shall be equal to (FrmWidthInMbs[ i ] << 4) and (FrmHeightInMbs[ i ] << 4), respectively. \nroi_id[ i ] specifies a region-of-interest identifier for the region represented by the current sub-picture scalable layer, which \nmay be used for identifying the purpose of the current sub-picture scalable layer by an application. The value of roi_id[ i ] \nshall be in the range of 0 to 63, inclusive. \nLet layerIdA and layerIdB be the layer identifiers of two scalable layers A and B, respectively, both of which having \nsub_pic_layer_flag[ i ] equal to 1, and roiIdA and roidIdB be the region-of-interest identifiers of the scalable layers A and \nB, respectively. When layerIdA is less than layerIdB, roiIdA shall not be greater than roidIdB. \niroi_grid_flag[ i ] specifies how the IROI division information is indicated for the current scalable layer. iroi_grid_flag[ i ] \nequal to 1 indicates that all IROIs for the current scalable layer are aligned on a fixed-size grid as specified in the following \nand that the syntax elements grid_width_in_mbs_minus1[ i ] and grid_width_in_mbs_minus1[ i ] for the current scalable \nlayer are present in the scalability information SEI message. iroi_grid_flag[ i ] equal to 0 indicates that the IROIs for the \ncurrent scalable layer may or may not be aligned on a fixed-size grid. \nAll scalable layers with the same value of dependency_id[ i ] for which scalability information is present in the scalability \ninformation SEI message and for which iroi_division_info_present_flag[ i ] is equal to 1 shall have the same value of \niroi_grid_flag[ i ]. \ngrid_width_in_mbs_minus1[ i ] and grid_height_in_mbs_minus1[ i ] indicate the size of the IROI grid for the current \nscalable layer. When frame_mbs_only_flag is equal to 0 for any primary coded VCL NAL unit of the current scalable \nlayer, ( grid_height_in_mbs_minus1[ i ] + 1 ) % 2 shall be equal to 0. \nThe value of grid_width_in_mbs_minus1[ i ] shall be in the range of 0 to FrmWidthInMbs[ i ] − 1, inclusive. The value of \ngrid_height_in_mbs_minus1[ i ] shall be in the range of 0 to FrmHeightInMbs[ i ] − 1, inclusive. \nLet  numX  and  numY  be  equal  to  ( FrmWidthInMbs[ i ] + grid_width_in_mbs_minus1[ i ] ) / \n( grid_width_in_mbs_minus1[ i ] + 1 )  and  ( FrmHeightInMbs[ i ] + grid_height_in_mbs_minus1[ i ] ) / \n( grid_height_in_mbs_minus1[ i ] + 1 ), respectively. \nThe  layer  pictures  with  dependency_id  equal  to  dependency_id[ i ]  are  partitioned  into  (numX * numY)  IROIs.  Let \n( xI[ k ], yI[ k ] ) be the location of the top-left luma sample of the k-th IROI relative to the top-left luma sample of the \nlayer picture and let w[ k ] and h[ k ] be the width and height, in luma samples, of the k-th IROI in the layer picture. With \nfield_pic_flag  being  the  slice  header  syntax  element  for  a  particular  layer  picture  with  dependency_id  equal  to \ndependency_id[ i ],  the  location  of  the  top-left  luma  sample  and  the  width  and  height  of  the  k-th  IROI,  with \nk = 0..(numX * numY − 1), are given by \nxI[ k ] = 16 * ( k % numX ) * ( grid_width_in_mbs_minus1[ i ] + 1 )  (G-377) \nyI[ k ] = 16 * ( k / numX ) * ( grid_height_in_mbs_minus1[ i ] + 1 ) / ( 1 + field_pic_flag )  (G-378) \nw[ k ] = Min( 16 * ( grid_width_in_mbs_minus1[ i ] + 1 ), 16 * FrmWidthInMbs[ i ] − xI[ k ] )  (G-379) \nh[ k ] = Min( 16 * ( grid_height_in_mbs_minus1[ i ] + 1 ) / ( 1 + field_pic_flag ),  \n                        16 * FrmHeightInMbs[ i ] / ( 1 + field_pic_flag ) − yI[ k ] )  (G-380) \nAll scalable layers with the same value of dependency_id[ i ] for which scalability information is present in the scalability \ninformation SEI message and for which iroi_division_info_present_flag[ i ] is equal to 1 and iroi_grid_flag[ i ] is equal to \n1 shall have the same values of grid_width_in_mbs_minus1[ i ] and grid_height_in_mbs_minus1[ i ]. \nnum_rois_minus1[ i ] plus 1 indicates the number of IROIs for the current scalable layer. \nDepending on the primary coded VCL NAL units of the current scalable layer, the following applies: \n–  If frame_mbs_only_flag is equal to 1 for all primary coded VCL NAL units of the current scalable layer, the value of \nnum_rois_minus1[ i ] shall be in the range of 0 to FrmSizeInMbs[ i ] − 1, inclusive. \n–  Otherwise (frame_mbs_only_flag is equal to 0 for any primary coded VCL NAL unit of the current scalable layer), \nthe value of num_rois_minus1[ i ] shall be in the range of 0 to FrmSizeInMbs[ i ] / 2 − 1, inclusive. \n    Rec. ITU-T H.264 (06/2019)  631 \n \nAll scalable layers with the same value of dependency_id[ i ] for which scalability information is present in the scalability \ninformation SEI message and for which iroi_division_info_present_flag[ i ] is equal to 1 and iroi_grid_flag[ i ] is equal to \n0 shall have the same value of num_rois_minus1[ i ]. \nfirst_mb_in_roi[ i ][ j ] indicates the macroblock address of the first macroblock in the j-th IROI for the current scalable \nlayer. The value of first_mb_in_roi[ i ][ j ] shall be in the range of 0 to FrmSizeInMbs[ i ] − 1, inclusive. When j is greater \nthan  0,  the  value  of  first_mb_in_roi[ i ][ j ]  shall  not  be equal  to  any  of  the  values  of  first_mb_in_roi[ i ][ k ]  with \nk = 0..(j − 1). \nThe variables firstMbY and firstMbInROIFld are derived as \nfirstMbY             = first_mb_in_roi[ i ][ j ] − ( first_mb_in_roi[ i ][ j ] % FrmWidthInMbs[ i ] )  (G-381) \nfirstMbInROIFld = ( firstMbY >> 1 ) + ( first_mb_in_roi[ i ][ j ] % FrmWidthInMbs[ i ] )  (G-382) \nWhen  frame_mbs_only_flag  is  equal  to  0  for  any  primary  coded  VCL  NAL  unit  of  the  current  scalable  layer, \n(firstMbY % 2) shall be equal to 0. \nFor each dependency representation that contains any primary coded VCL NAL unit of the current scalable layer, the \nfollowing applies: \n–  If field_pic_flag is equal to 0 and MbaffFrameFlag is equal to 0 for the dependency representation, the value of \nfirst_mb_in_roi[ i ][ j ]  shall  be  equal  to  the  syntax  element  first_mb_in_slice  in  the  slice  that  belongs  to  the \ndependency representation and covers the top-left macroblock of the j-th IROI. \n–  Otherwise (field_pic_flag is equal to 1 or MbaffFrameFlag is equal to 1 for the dependency representation), the value \nof firstMbInROIFld shall be equal to the syntax element first_mb_in_slice in the slice that belongs to the dependency \nrepresentation and covers the top-left macroblock of the j-th IROI. \nroi_width_in_mbs_minus1[ i ][ j ] and roi_height_in_mbs_minus1[ i ][ j ] specify the  size of the  j-th IROI for the \ncurrent scalable layer. When frame_mbs_only_flag is equal to 0 for any primary coded VCL NAL unit of the current \nscalable layer, ( roi_height_in_mbs_minus1[ i ][ j ] + 1 ) % 2 shall be equal to 0. \nThe  value  of  roi_width_in_mbs_minus1[ i ][ j ]  shall  be  in  the  range  of  0  to  (FrmWidthInMbs[ i ] − 1 − \n( first_mb_in_roi[ i ][ j ] % FrmWidthInMbs[ i ] )), inclusive. The value of roi_height_in_mbs_minus1[ i ][ j ] shall be in \nthe range of 0 to (FrmHeightInMbs[ i ] − 1 − ( firstMbY / FrmWidthInMbs[ i ] )), inclusive. \nWith field_pic_flag being the slice header syntax element for a particular layer picture with dependency_id equal to \ndependency_id[ i ],  the  width  and  height  of  the  j-th  IROI  in  the  layer  pictures  with  dependency_id  equal  to \ndependency_id[ i ]  are  equal  to  16 * ( roi_width_in_mbs_minus1[ i ][ j ] + 1 )  and \n16 * ( roi_height_in_mbs_minus1[ i ][ j ] + 1 ) / ( 1 + field_pic_flag ), respectively, in units of luma samples. \nAll scalable layers with the same value of dependency_id[ i ] for which scalability information is present in the scalability \ninformation SEI message and for which iroi_division_info_present_flag[ i ] is equal to 1 and iroi_grid_flag[ i ] is equal to \n0  shall  have  the  same  values  of  first_mb_in_roi[ i ][ j ],  roi_width_in_mbs_minus1[ i ][ j ],  and \nroi_height_in_mbs_minus1[ i ][ j ] with j in the range of 0 to num_rois_minus1[ i ], inclusive. \nnum_directly_dependent_layers[ i ]  specifies  the  number  of  the  syntax  elements \ndirectly_dependent_layer_id_delta_minus1[ i ][ j ]  that  are  present  for  the  current  scalable  layer.  The  value  of \nnum_directly_dependent_layers shall be in the range of 0 to 255, inclusive. \ndirectly_dependent_layer_id_delta_minus1[ i ][ j ] plus 1 indicates the difference between the value of layer_id[ i ] for \nthe current scalable layer and the layer identifier of a particular scalable layer, on which the current scalable layer directly \ndepends. The value of directly_dependent_layer_id_delta_minus1[ i ][ j ] shall be in the range of 0 to layer_id[ i ] − 1, \ninclusive. The layer identifier of the particular scalable layer, on which the current scalable layer directly depends, is equal \nto layer_id[ i ] − directly_dependent_layer_id_delta_minus1[ i ][ j ] − 1. The scalability information SEI message shall \ncontain  information  for  a  scalable  layer  b  with  layer_id[ b ]  equal  to \nlayer_id[ i ] − directly_dependent_layer_id_delta_minus1[ i ][ j ] − 1 and this information shall not contain a value of \nlayer_dependency_info_src_layer_id_delta[ i ] equal to 0. \nLet setOfDepLayers be the set union of the representations of the scalable layers b that have layer_id[ b ] equal to \nlayer_id[ i ] − directly_dependent_layer_id_delta_minus1[ i ][ j ] − 1, with j = 0..num_directly_dependent_layers[ i ] − 1. \nWhen layer_dependency_info_present_flag[ i ] is equal to 1, the set setOfDepLayers shall not contain any scalable layer, \non which the current scalable layer does not directly or indirectly depends and the current scalable layer shall not depend \non any scalable layer that is not included in the set setOfDepLayers. \nlayer_dependency_info_src_layer_id_delta[ i ] greater than 0 indicates that the current scalable layer has the same layer \ndependency  information  as  the  scalable  layer  with  layer  identifier  equal  to \nlayer_id[ i ] − layer_dependency_info_src_layer_id_delta[ i ].  layer_dependency_info_src_layer_id_delta[ i ]  equal  to 0 \nspecifies that the layer dependency information of the current scalable layer is not present in the scalability information \n632  Rec. ITU-T H.264 (06/2019) \n \nSEI message. The value of layer_dependency_info_src_layer_id_delta[ i ] shall be in the range of 0 to layer_id[ i ], \ninclusive. When layer_dependency_info_src_layer_id_delta[ i ] is greater than 0, the scalability information SEI message \nshall  contain  information  for  a  scalable  layer  b  with  layer_id[ b ]  equal  to \nlayer_id[ i ] − layer_dependency_info_src_layer_id_delta[ i ]  and  this  information  shall  not  contain  a  value  of \nlayer_dependency_info_src_layer_id_delta[ b ] equal to 0. \nWhen layer_dependency_info_present_flag[ i ] is equal to 0 and layer_dependency_info_src_layer_id_delta[ i ] is greater \nthan 0, the set of scalable layers on which the current scalable layer depends shall be identical to the set of layers on which \nthe scalable layer b with layer_id[ b ] equal to layer_id[ i ] − layer_dependency_info_src_layer_id_delta[ i ] depends. \nNOTE 15 – When layer_dependency_info_src_layer_id_delta[ i ] equal to 0 is not present for the current scalable layer, the \nrepresentation of the current scalable layer is specified by the syntax element layer_dependency_info_src_layer_id_delta[ i ] \nor  by  the  syntax  elements  directly_dependent_layer_id_delta_minus1[ i ][ j ],  with \nj = 0..num_directly_dependent_layers[ i ] − 1. \nNOTE 16 – A change for the layer dependency information may be signalled by the presence of one or more layer dependency \nchange SEI messages. When a scalability information SEI message specifies that a scalable layer A does not directly or \nindirectly depend on a scalable layer B, this relationship applies to the complete target access unit set. When a scalability \ninformation SEI message specifies that a scalable layer A does directly or indirectly depend on a scalable layer B, a following \nlayer dependency change SEI message may indicate that this dependency does not apply for a subset of the target access unit \nset. \nnum_seq_parameter_sets[ i ] indicates the number of different sequence parameter sets that are referred to by the primary \ncoded VCL NAL units of the current scalable layer representation. The value of num_seq_parameter_sets[ i ] shall be in \nthe range of 0 to 32, inclusive. \nseq_parameter_set_id_delta[ i ][ j ] indicates the smallest value of the seq_parameter_set_id of any sequence parameter \nset required for decoding the representation of the current scalable layer, if j is equal to 0. Otherwise (j is greater than 0), \nseq_parameter_set_id_delta[ i ][ j ] indicates the difference between the value of the seq_parameter_set_id of the j-th \nrequired sequence parameter set and the value of the seq_parameter_set_id of the (j − 1)-th required sequence parameter \nset for decoding the representation of the current scalable layer. The value of seq_parameter_set_id_delta[ i ][ j ] shall not \nbe greater than 31. When j is greater than 0, the value of seq_parameter_set_id_delta[ i ][ j ] shall not be equal to 0. When \nparameter_sets_info_present_flag[ i ] is equal to 1, the primary coded VCL NAL units of the current scalable layer \nrepresentation shall not refer to any sequence parameter set for which the value of seq_parameter_set_id is not indicated \nby  the  syntax  elements  seq_parameter_set_id_delta[ i ][ j ]  for  the  current  scalable  layer  and  the  syntax  elements \nseq_parameter_set_id_delta[ i ][ j ] for the current scalable layer shall not indicate any sequence parameter set that is not \nreferenced in any primary coded VCL NAL unit of the current scalable layer representation. \nnum_subset_seq_parameter_sets[ i ] indicates the number of different subset sequence parameter sets that are referred \nto  by  the  primary  coded  VCL  NAL  units  of  the  current  scalable  layer  representation.  The  value  of \nnum_subset_seq_parameter_sets[ i ] shall be in the range of 0 to 32, inclusive. \nsubset_seq_parameter_set_id_delta[ i ][ j ]  indicates  the  smallest  value  of  the  seq_parameter_set_id  of  any  subset \nsequence parameter set required for decoding the representation of the current scalable layer, if j is equal to 0. Otherwise \n(j  is  greater  than  0),  subset_seq_parameter_set_id_delta[ i ][ j ]  indicates  the  difference  between  the  value  of  the \nseq_parameter_set_id of the j-th required subset sequence parameter set and the value of the seq_parameter_set_id of the \n(j − 1)-th required subset sequence parameter set for decoding the representation of the current scalable layer. The value \nof  subset_seq_parameter_set_id_delta[ i ][ j ]  shall  not  be  greater  than  31.  When  j  is  greater  than  0,  the  value  of \nsubset_seq_parameter_set_id_delta[ i ][ j ] shall not be equal to 0. When parameter_sets_info_present_flag[ i ] is equal \nto 1, the primary coded VCL NAL units of the current scalable layer representation shall not refer to any subset sequence \nparameter  set  for  which  the  value  of  seq_parameter_set_id  is  not  indicated  by  the  syntax  elements \nsubset_seq_parameter_set_id_delta[ i ][ j ]  for  the  current  scalable  layer  and  the  syntax  elements \nsubset_seq_parameter_set_id_delta[ i ][ j ] for the current scalable layer shall not indicate any subset sequence parameter \nset that is not referenced in any primary coded VCL NAL unit of the current scalable layer representation. \nnum_pic_parameter_sets_minus1[ i ] plus 1 indicates the number of different picture parameter sets that are referred to \nby  the  primary  coded  VCL  NAL  units  of  the  current  scalable  layer  representation.  The  value  of \nnum_pic_parameter_sets_minus1[ i ] shall be in the range of 0 to 255, inclusive. \npic_parameter_set_id_delta[ i ][ j ] indicates the smallest value of the pic_parameter_set_id of any picture parameter set \nrequired for decoding the representation of the current scalable layer, if j is equal to 0. Otherwise (j is greater than 0), \npic_parameter_set_id_delta[ i ][ j ] indicates the difference between the value of the pic_parameter_set_id of the j-th \nrequired picture parameter set and the value of the pic_parameter_set_id of the (j − 1)-th required picture parameter set for \ndecoding the representation of the current scalable layer. The value of pic_parameter_set_id_delta[ i ][ j ] shall not be \ngreater than 255. When j is greater than 0, the value of pic_parameter_set_id_delta[ i ][ j ] shall not be equal to 0. When \nparameter_sets_info_present_flag[ i ] is equal to 1, the primary coded VCL NAL units of the current scalable layer \nrepresentation shall not refer to any picture parameter set for which the value of pic_parameter_set_id is not indicated by \nthe  syntax  elements  pic_parameter_set_id_delta[ i ][ j ]  for  the  current  scalable  layer  and  the  syntax  elements \n    Rec. ITU-T H.264 (06/2019)  633 \n \npic_parameter_set_id_delta[ i ][ j ] for the current scalable layer shall not indicate any picture parameter set that is not \nreferenced in any primary coded VCL NAL unit of the current scalable layer representation. \nparameter_sets_info_src_layer_id_delta[ i ] greater than 0 indicates that the values of seq_parameter_set_id of the \nsequence  parameter  sets  and  subset  sequence  parameter  sets  and  the  values  of  pic_parameter_set_id  of  the  picture \nparameter sets that are referred to by the primary coded VCL NAL units of the current scalable layer representation are the \nsame as those that are referred to by the primary coded VCL NAL units of the representation of the scalable layer b with \nthe  layer  identifier  layer_id[ b ]  equal  to  layer_id[ i ] − parameter_sets_info_src_layer_id_delta[ i ].  When \nparameter_sets_info_src_layer_id_delta[ i ]  is  greater  than 0,  the  scalability  information  SEI  message  shall  contain \ninformation for a scalable layer b with layer_id[ b ] equal to layer_id[ i ] − parameter_sets_info_src_layer_id_delta[ i ] and \nthis information shall not contain a value of parameter_sets_info_src_layer_id_delta[ b ] equal to 0. \nparameter_sets_info_src_layer_id_delta[ i ] equal to  0 indicates that the values of seq_parameter_set_id of the sequence \nparameter sets and subset sequence parameter sets and the values of pic_parameter_set_id of the picture parameter sets \nthat are referred to by the primary coded VCL NAL units of the current scalable layer representation are not indicated in \nthe scalability information SEI message. \nThe value of parameter_sets_info_src_layer_id_delta[ i ] shall be in the range of 0 to layer_id[ i ], inclusive. \nmotion_vectors_over_pic_boundaries_flag[ i ]  indicates  the  value  of  motion_vectors_over_pic_boundaries_flag,  as \nspecified in clause E.2.1, that applies to the current scalable layer representation. \nmax_bytes_per_pic_denom[ i ]  indicates  the  value  of  max_bytes_per_pic_denom,  as  specified  in  clause E.2.1,  that \napplies to the current scalable layer representation. \nmax_bits_per_mb_denom[ i ] indicates the value of max_bits_per_mb_denom, as specified in clause E.2.1, that applies \nto the current scalable layer representation. \nlog2_max_mv_length_horizontal[ i ]  and  log2_max_mv_length_vertical[ i ]  indicate  the  values  of \nlog2_max_mv_length_horizontal and log2_max_mv_length_vertical, as specified in clause E.2.1, that apply to the current \nscalable layer representation. \nNOTE 17 – The maximum absolute value of a decoded vertical or horizontal motion vector component is also constrained by profile \nand level limits as specified in Annex A and clause G.10. \nmax_num_reorder_frames[ i ] indicates the value of max_num_reorder_frames, as specified in clause E.2.1, that applies \nto the current scalable layer representation. \nmax_dec_frame_buffering[ i ] indicates the value of max_dec_frame_buffering, as specified in clause E.2.1, that applies \nto the current scalable layer representation. \nconversion_type_idc[ i ] equal to 0 indicates that tcoeff_level_prediction_flag is equal to 1 for all primary coded slices of \nthe  current  scalable  layer  representation  excluding  those  having  no_inter_layer_pred_flag  equal  to 1  and  that  the \ninformation  specified  by  the  syntax  elements  rewriting_profile_level_idc[ i ][ j ],  rewriting_avg_bitrate[ i ][ j ],  and \nrewriting_max_bitrate[ i ][ j ],  when  present,  is  correct,  though  the  method  for  converting  the  current  scalable  layer \nrepresentation into an alternative set of access units that conforms to one or more of the profiles specified in Annex A and \ngives exactly the same decoding result as the current scalable layer representation is unspecified. \nconversion_type_idc[ i ] equal to 1 indicates that the slice_header_restriction_flag in the subset sequence parameter sets \nreferred to by the primary coded VCL NAL units of the current scalable layer is equal to 1, that slice_skip_flag is equal to \n1  for  all  primary  coded  VCL  NAL  units  with  no_inter_layer_pred_flag  equal  to  0  in  the  current  scalable  layer \nrepresentation, and that the alternative set of access units obtained by applying the following operations in sequential order \nto the current scalable layer representation conforms to one or more of the profiles specified in Annex A: \n1.  For all picture parameter set NAL units referred to by NAL units with nal_unit_type equal to 1 or 5, change the \nvalue of seq_parameter_set_id to be equal to the value of seq_parameter_set_id in a subset sequence parameter \nset NAL unit with profile_idc equal to 83 or 86 that is referred to by slices with nal_unit_type equal to 20 of the \ncurrent scalable layer. \n2.  Remove all NAL units with nal_unit_type equal to 20 and slice_skip_flag equal to 1. \n3.  Remove all NAL units with nal_unit_type equal to 14. \n4.  Remove all redundant coded VCL NAL units. \n5.  In each access unit, remove all VCL NAL units with DQId less than DQIdMax, with DQIdMax being the \nmaximum value of DQId in the primary coded slices of the access unit after removing the NAL units with \nnal_unit_type equal to 20 and slice_skip_flag equal to 1. \n6.  Remove the NAL unit header SVC extension from NAL units with nal_unit_type equal to 20. \n7.  For NAL units with nal_unit_type equal to 20 and idr_flag equal to 1, set nal_unit_type equal to 5. \n634  Rec. ITU-T H.264 (06/2019) \n \n8.  For NAL units with nal_unit_type equal to 20 and idr_flag equal to 0, set nal_unit_type equal to 1. \n9.  Remove all SEI NAL units. \n10.  Remove all NAL units with nal_unit_type equal to 7. \n11.  For all NAL units with nal_unit_type equal to 15, set nal_unit_type equal to 7, remove all the syntax elements \nafter the syntax structure seq_parameter_set_data( ) and before the rbsp_trailing_bits( ) syntax structure, replace \nthe  three  bytes  starting  from  profile_idc  as  specified  by \nrewriting_profile_level_idc[ i ][ entropy_coding_mode_flag ],  when  present,  and  change  RBSP  trailing  bits \nappropriately. \nconversion_type_idc[ i ] equal to 2 indicates that slice_header_restriction_flag in the subset sequence parameter sets \nreferred to by the primary coded VCL NAL units of the current scalable layer is equal to 1, that no_inter_layer_pred_flag \nis equal to 1 in all primary coded VCL NAL units of the current scalable layer, and that the alternative set of access units \nobtained by applying the following operations in sequential order to the current scalable layer representation conforms to \none or more of the profiles specified in Annex A: \n1.  Remove all NAL units with nal_unit_type equal to 14. \n2.  Remove all redundant coded VCL NAL units. \n3.  In each access unit, remove all VCL NAL units with DQId less than DQIdMax. \n4.  Remove the NAL unit header SVC extension from NAL units with nal_unit_type equal to 20. \n5.  For NAL units with nal_unit_type equal to 20 and idr_flag equal to 1, set nal_unit_type equal to 5. \n6.  For NAL units with nal_unit_type equal to 20 and idr_flag equal to 0, set nal_unit_type equal to 1. \n7.  Remove all SEI NAL units. \n8.  Remove all NAL units with nal_unit_type equal to 7. \n9.  For all NAL units with nal_unit_type equal to 15, set nal_unit_type equal to 7, remove all the syntax elements \nafter the syntax structure seq_parameter_set_data( ) and before the rbsp_trailing_bits( ) syntax structure, replace \nthe  three  bytes  starting  from  profile_idc  as  specified  by \nrewriting_profile_level_idc[ i ][ entropy_coding_mode_flag ],  when  present,  and  change  RBSP  trailing  bits \nappropriately. \nThe value of conversion_type_idc[ i ] shall be in the range of 0 to 2, inclusive. \nFor  the  following  syntax  elements  rewriting_info_flag[ i ][ j ],  rewriting_profile_level_idc[ i ][ j ], \nrewriting_avg_bitrate[ i ][ j ],  and  rewriting_max_bitrate[ i ][ j ],  the  variable  j  specifies  the  value  of \nentropy_coding_mode_flag for all picture parameter set NAL units that are referenced in the VCL NAL units of the \nalternative set of access units obtained by converting the current scalable layer representation, with values for j equal to 0 \nor 1 indicating use of the CAVLC or CABAC entropy coding methods, respectively. \nNOTE 18 – It might be possible to convert the current scalable layer representation into two alternative sets of access units that \nconform to one or more of the profiles specified in Annex A, with one of these sets having entropy_coding_mode_flag equal to 0 \nand the other set having entropy_coding_mode_flag equal to 1 in all picture parameter set NAL units that are referenced in the VCL \nNAL units of the alternative set of access units. \nrewriting_info_flag[ i ][ j ] equal to 1 specifies that information about the alternative set of access units obtained by \nconverting  the  current  scalable  layer  representation  is  present  in  the  scalability  information  SEI  message. \nrewriting_info_flag[ i ][ j ] equal to 0 specifies that information about the alternative set of access units is not present in \nthe scalability information SEI message. When rewriting_info_flag[ i ][ j ] is equal to 1, it is asserted that the information \nsignalled  by  the  syntax  elements  rewriting_profile_level_idc[ i ][ j ],  rewriting_avg_bitrate[ i ][ j ],  and \nrewriting_max_bitrate[ i ][ j ]  is  correct,  though,  when  conversion_type_idc[ i ]  is  equal  to 0  or  the  value  of \nentropy_coding_mode_flag is modified, the method for constructing the alternative set of access units is unspecified. \nrewriting_profile_level_idc[ i ][ j ] indicates the conformance point of the alternative set of access units for the current \nscalable layer representation after conversion. rewriting_profile_level_idc[ i ] is the exact copy of the three bytes consist \nof profile_idc, constraint_set0_flag, constraint_set1_flag, constraint_set2_flag, constraint_set3_flag, constraint_set4_flag, \nconstraint_set5_flag, reserved_zero_2bits, and level_idc, as if these syntax elements were used to specify the profile and \nlevel conformance of the alternative set of access units obtained by converting the scalable layer representation. \nrewriting_avg_bitrate[ i ][ j ] indicates the average bit rate of the alternative set of access units obtained by converting \nthe representation of the current scalable layer. The average bit rate of the alternative set of access units in bits per second \nis given by BitRateBPS( rewriting_avg_bitrate[ i ][ j ] ) with the function BitRateBPS( ) being specified in Equation G-\n370. The average bit rate is derived according to the access unit removal time specified in Annex C of the Recommendation \n| International Standard. \n    Rec. ITU-T H.264 (06/2019)  635 \n \nrewriting_max_bitrate[ i ][ j ] indicates an upper bound for the bit rate of the alternative set of access units obtained by \nconverting the representation of the current scalable layer, in any one-second time window of access unit removal time as \nspecified in Annex C. The upper bound for the bit rate of the alternative set of access units in bits per second is given by \nBitRateBPS( rewriting_max_bitrate[ i ][ j ] ) with the function BitRateBPS( ) being specified in Equation G-370. \nFor the following specification, the terms priority layer, dependency layer, and priority layer representation are defined as \nfollows. A priority layer consists of the set of primary coded VCL NAL units, inside the target access unit set, that are \nassociated with a particular value of dependency_id and a value of alt_priority_id[ i ], as specified in clause G.13.2.4, that \nis less than or equal to a particular priority identifier pId and the set of associated non-VCL NAL units. A priority layer is \nassociated with a particular value of dependency_id and a particular priority layer identifier pId. When present in the target \naccess unit, the following NAL units are associated non-VCL NAL units for a priority layer: \n–  sequence parameter set, subset sequence parameter set, and picture parameter set NAL units that are referenced in the \nVCL NAL units of the priority layer (via the syntax element pic_parameter_set_id), \n–  sequence parameter set extension NAL units that are associated with a sequence parameter set NAL unit referenced \nin the VCL NAL units of the priority layer, \n–  filler data NAL units that belong to an access unit containing VCL NAL units of the priority layer and are associated \nwith the same values of dependency_id and quality_id as the VCL NAL units of the priority layer in the same access \nunit, \n–  SEI NAL units containing SEI messages, with payloadType not equal to 24, 28, or 29, that apply to subsets of the \nbitstream that contain one or more VCL NAL units of the priority layer, \n–  access unit delimiter, end of sequence, and end of stream NAL units that are present in access units that contain VCL \nNAL units of the priority layer. \nThe set of NAL units that represents the set union of all priority layers that are associated with the same value of \ndependency_id  is  referred  to  as  dependency  layer.  A  dependency  layer  is  associated  with  a  particular  value  of \ndependency_id. \nA priority layer A is directly dependent on a priority layer B when any VCL NAL unit of the priority layer A references \ndata of any VCL NAL unit of the priority layer B through inter prediction or inter-layer prediction as specified in the \ndecoding process in clause G.8. A priority layer A is indirectly dependent on a priority layer B when the priority layer A \nis not directly dependent on the priority layer B but there exists a set of n (with n being greater than 0) priority layers \n{C  .., C } with the following properties: The priority layer A is directly dependent on the priority layer C , each priority \n0, n−1 0\nlayer C with i in the range of 0 to n − 2, inclusive, is directly dependent on the priority layer C , and the priority layer \ni i+1\nC  is directly dependent on the priority layer B. \nn−1\nThe representation of a particular priority layer is the set of NAL units that represents the set union of the particular priority \nlayer and all priority layers on which the particular priority layer directly or indirectly depends. The representation of a \npriority layer is also referred to as priority layer representation. In the following specification of this clause, the terms \nrepresentation of a priority layer and priority layer representation are also used for referring to the access unit set that can \nbe constructed from the NAL units of the priority layer representation. A priority layer representation can be decoded \nindependently of all NAL units that do not belong to the priority layer representation. \npr_num_dIds_minus1 plus 1 specifies the number of dependency layers for which the  priority layer characteristic \ninformation as specified by the following syntax elements is present in the scalability information SEI message. The value \nof pr_num_dIds_minus1 shall be in the range of 0 to 7, inclusive. \npr_dependency_id[ i ]  specifies  the  value  of  dependency_id  of  the  dependency  layer  for  which  the  priority  layer \ncharacteristic  information  is  signalled  by  the  following  syntax  elements.  When  i  is  greater  than  0,  the  value  of \npr_dependency_id[ i ] shall not be equal to any of the values of pr_dependency_id[ j ] with j = 0..(i − 1). \npr_num_minus1[ i ] plus 1 specifies the number of priority layers with dependency_id equal to pr_dependency_id[ i ] for \nwhich priority layer characteristic information as specified by the following syntax elements is present in the scalability \ninformation SEI message. The value of pr_num_minus1[ i ] shall be in the range of 0 to 63, inclusive. \npr_id[ i ][ j ] specifies the priority identifier pId for a priority layer with dependency_id equal to pr_dependency_id[ i ]. \nThe value of pr_id[ i ][ j ] shall be in the range of 0 to 63, inclusive. The target access unit set shall contain one or more \nprimary  coded  VCL  NAL  units  that  are  associated  with  dependency_id  equal  to  pr_dependency_id[ i ]  and \nalt_priority_id[ i ] equal to pr_id[ i ][ j ], where the value of alt_priority_id[ i ] that is associated with a primary coded VCL \nNAL unit is specified in clause G.13.2.4. When j is greater than 0, the value of pr_id[ i ][ j ] shall not be equal to any of \nthe values of pr_id[ i ][ k ] with k = 0..(j − 1). \nFor the following specification inside the clause, the priority layer with dependency_id equal to the current value of \npr_dependency_id[ i ] and the priority layer identifier pId equal to the current value of pr_id[ i ][ j ] is referred to as the \n636  Rec. ITU-T H.264 (06/2019) \n \ncurrent  priority  layer  and  the  representation  of  the  current  priority  layer  is  referred  to  as  the  current  priority  layer \nrepresentation. \npr_profile_level_idc[ i ][ j ]  indicates  the  conformance  point  of  the  current  priority  layer  representation. \npr_profile_level_idc[ i ]  is  the  exact  copy  of  the  three  bytes  consisting  of  profile_idc,  constraint_set0_flag, \nconstraint_set1_flag,  constraint_set2_flag,  constraint_set3_flag,  constraint_set4_flag,  constraint_set5_flag, \nreserved_zero_2bits, and level_idc, as if these syntax elements were used to specify the profile and level conformance of \nthe current priority layer representation. \npr_avg_bitrate[ i ][ j ] indicates the average bit rate of the current priority layer representation. The average bit rate of the \ncurrent priority layer representation in bits per second is given by BitRateBPS( pr_avg_bitrate[ i ][ j ] ) with the function \nBitRateBPS( ) being specified in Equation G-370. The average bit rate is derived according to the access unit removal time \nspecified in Annex C of this Recommendation | International Standard. In the following, bTotal is the number of bits in all \nNAL units of the current priority layer representation, t  is the removal time (in seconds) of the access unit associated with \n1\nthe scalability information SEI message, and t  is the removal time (in seconds) of the last access unit (in decoding order) \n2\nof the target access unit set. \nWith x specifying the value of pr_avg_bitrate[ i ], the following applies: \n–  If t  is not equal to t , the condition specified in Equation G-371 shall be fulfilled. \n1 2\n–  Otherwise (t  is equal to t ), the condition specified in Equation G-372 shall be fulfilled. \n1 2\npr_max_bitrate[ i ][ j ] indicates an upper bound for  the bit rate of the  current priority layer  representation in any \none-second time window of access unit removal time as specified in Annex C. The upper bound for the bit rate of the \ncurrent priority layer representation in bits per second is given by BitRateBPS( pr_max_bitrate[ i ][ j ] ) with the function \nBitRateBPS( ) being specified in Equation G-370. The bit rate values are derived according to the access unit removal time \nspecified in Annex C of this Recommendation | International Standard. In the following, t  is any point in time (in seconds), \n1\nt  is set equal to t  + 1, and bTotal is the number of bits in all NAL units of the current priority layer representation that \n2 1\nbelong to access units with a removal time greater than or equal to t  and less than t . With x specifying the value of \n1 2\npr_max_bitrate[ i ][ j ], the condition specified in Equation G-373 shall be obeyed. \npriority_id_setting_uri[ PriorityIdSettingUriIdx ]  is  the  PriorityIdSettingUriIdx-th  byte  of  a  null-terminated  string \nencoded in UTF-8 characters, specifying the universal resource identifier (URI) of the description of the method used to \ncalculate the priority_id values in the NAL unit headers for the target access unit set. \nG.13.2.2 Sub-picture scalable layer SEI message semantics \nThe sub-picture scalable SEI message provides a mechanism for associating a slice group set indicated in a motion-\nconstrained slice group set SEI message with a sub-picture scalable layer. \nIn the following specification of this clause, the terms scalable layer, sub-picture scalable layer, and primary coded VCL \nNAL unit are used as specified in clause G.13.2.1. \nA sub-picture scalable layer SEI message shall not be succeeded, in decoding order, by a scalability information SEI \nmessage inside the same access unit. \nWhen a sub-picture scalable SEI message is present, the following applies: \n–  If the sub-picture scalable layer SEI message is included in a scalable nesting SEI message, a motion-constrained slice \ngroup set SEI message, which is also referred to as the associated motion-constrained slice group set SEI message, \nshall be present in the same scalable nesting SEI message and it shall immediately precede the sub-picture scalable \nlayer SEI message in decoding order. The scalable nesting SEI message that contains the sub-picture scalable layer \nSEI message shall contain num_layer_representations_minus1 equal to 0 and sei_quality_id[ 0 ] equal to 0. The \nvariable depId is set equal to the value of sei_dependency_id[ 0 ] that is present in the scalable nesting SEI message \ncontaining the sub-picture scalable layer SEI message. \n–  Otherwise (the sub-picture scalable layer SEI message is not included in a scalable nesting SEI  message), the \nsub-picture  scalable  layer  SEI  message  shall  be  the  first  SEI  payload  in  an  SEI  NAL  unit  and  the  NAL  unit \nimmediately preceding the SEI NAL unit containing the sub-picture scalable layer SEI message shall be an SEI NAL \nunit that contains a motion-constrained slice group set SEI message, which is also referred to as associated motion-\nconstrained slice group set SEI message, as last SEI payload. The variable depId is set equal to 0. \nThe slice group set identified by the associated motion-constrained slice group set SEI message is referred to as the \nassociated slice group set of the sub-picture scalable layer SEI message. \nThe access unit associated with the sub-picture scalable layer SEI message shall not contain any primary coded VCL NAL \nunit that has dependency_id equal to depId and IdrPicFlag equal to 0. The set of access units consisting of the access unit \nassociated with the sub-picture scalable layer SEI message and all succeeding access units in decoding order until, but \nexcluding, the next access unit that contains any primary coded VCL NAL unit with dependency_id equal to depId and \n    Rec. ITU-T H.264 (06/2019)  637 \n \nIdrPicFlag equal to 1 or that does not contain any primary coded VCL NAL units with IdrPicFlag equal to 0 (if present) or \nthe end of the bitstream (otherwise) is referred to as the target access unit set. The sub-picture scalable layer SEI message \napplies to the target access unit set. \nNOTE – The set of primary coded pictures in the target access unit set for a sub-picture scalable layer SEI message is identical to \nthe target picture set for the associated motion-constrained slice group set SEI message. \nlayer_id indicates, when the access unit containing the sub-picture scalable layer SEI message belongs to the target access \nunit set of a scalability information SEI message, the layer identifier of the sub-picture scalable layer to which the coded \nslice NAL units in the associated slice group set belong. The value of layer_id shall be in the range of 0 to 2047, inclusive. \nThe access unit containing the sub-picture scalable layer SEI message may or may not belong to the target access unit set \nof a scalability information SEI message. When the access unit containing the sub-picture scalable layer SEI message \nbelongs to the target access unit set of a scalability information SEI message, the corresponding scalability information \nSEI message may or may not contain information for a scalable layer i with layer identifier layer_id[ i ] equal to layer_id. \nWhen the access unit containing the sub-picture scalable layer SEI message belongs to the target access unit set of a \nscalability information SEI message and the corresponding scalability information SEI message contains information for \na scalable layer i with layer identifier layer_id[ i ] equal to layer_id, which is referred to as the current scalable layer in the \nfollowing, the  following applies. The information  for the current scalable layer in the scalability SEI  shall contain \nsub_pic_layer_flag[ i ] equal to 1. The sub-picture area for the current scalable layer i, which is specified by the syntax \nelements horizontal_offset[ i ], vertical_offset[ i ], region_width[ i ], and region_height[ i ] in the scalability information \nSEI message, shall be identical to the area specified by the associated slice group set. \nG.13.2.3 Non-required layer representation SEI message semantics \nThe non-required layer representation SEI message provides a mechanism for indicating which layer representations of \nthe current primary coded picture are not required for decoding dependency representations with a particular value of \ndependency_id of the current primary coded picture and succeeding primary coded pictures, in decoding order. \nThe non-required layer representation SEI message shall not be included in a scalable nesting SEI message. \nnum_info_entries_minus1  plus  1  specifies  the  number  of  dependency_id  values  for  which  non-required  layer \nrepresentations are indicated in the SEI message. The value of num_info_entries_minus1 shall be in the range of 0 to 7, \ninclusive. \nentry_dependency_id[ i ] specifies the dependency_id value for which non-required layer representations are indicated \nby the following syntax elements. The instances of entry_dependency_id[ i ] shall appear in increasing order of their \nvalues. \nThe dependency representation of the primary coded picture with dependency_id equal to entry_dependency_id[ i ] is \nreferred to as the target dependency representation. \nThe target dependency representation may or may not be present in the access unit. \nnum_non_required_layer_reps_minus1[ i ] plus 1 specifies the number of non-required layer representations for the \ntarget  dependency  representation  that  are  indicated  in  the  SEI  message.  The  value  of \nnum_non_required_layer_reps_minus1[ i ] shall be in the range of 0 to 127, inclusive. \nnon_required_layer_rep_dependency_id[ i ][ j ] indicates the value of dependency_id of the j-th non-required layer \nrepresentation for the target dependency representation. \nnon_required_layer_rep_quality_id[ i ][ j ] indicates the value of quality_id of the j-th non-required layer representation \nfor the target dependency representation. \nThe i-th non-required layer representation for the target dependency representation is the layer representation of the \nprimary coded picture that has dependency_id equal to non_required_layer_rep_dependency_id[ i ][ j ] and quality_id \nequal  to  non_required_layer_rep_quality_id[ i ][ j ].  A  non-required  layer  representation  for  the  target  dependency \nrepresentation is not required for decoding the target dependency representation and any dependency representation with \ndependency_id equal to entry_dependency_id[ i ] of primary coded pictures that follow the current primary picture in \ndecoding order. \nWhen  DependencyIdMax  is  equal  to  entry_dependency_id[ i ],  the  VCL  NAL  units  of  the  non-required  layer \nrepresentations shall not be referenced through inter or inter-layer prediction in the decoding process as specified in \nclause G.8. \nNOTE – In addition to the i-th non-required layer representation for the target dependency representation, those layer representations \nthat  have  dependency_id  equal  to  non_required_layer_rep_dependency_id[ i ][ j ]  and  quality_id  greater  than \nnon_required_layer_rep_quality_id[ i ][ j ] are also non-required layer representations for the target dependency representation. \nThe i-th non-required layer representation may or may not be present in the access unit. \n638  Rec. ITU-T H.264 (06/2019) \n \nG.13.2.4 Priority layer information SEI message semantics \nThe priority layer information SEI message provides a mechanism for signalling alternative priority_id values for VCL \nNAL units of the primary coded picture. The alternative values for priority_id indicate priority layers. \nThe priority layer information SEI message shall not be included in a scalable nesting SEI message. \npr_dependency_id  specifies  the  value  of  dependency_id  for  the  VCL  NAL  units  for  which  alternative  values  for \npriority_id are indicated. \nnum_priority_ids specifies the number of layer representations with dependency_id equal to pr_dependency_id for which \nalternative values of priority_id are indicated. \nalt_priority_id[ i ] specifies the alternative value for priority_id for the VCL NAL units of the primary coded picture that \nhave dependency_id equal to pr_dependency_id and quality_id equal to i. \nThe layer representation of the primary coded picture with dependency_id equal to pr_dependency_id and quality_id equal \nto i may or may not be present in the access unit. \nG.13.2.5 Layers not present SEI message semantics \nThe layers not present SEI message provides a mechanism for signalling that NAL units of particular scalable layers \nindicated by the preceding scalability information SEI message are not present in a particular set of access units. \nIn the following specification of this clause, the terms scalable layer and primary coded VCL NAL unit are used as specified \nin clause G.13.2.1. \nA layers not present SEI message shall not be included in a scalable nesting SEI message. \nA layers not present SEI message shall not be present in an access unit that does not belong to the target access unit set of \nany scalability information SEI message. A layers not present SEI message shall not be succeeded, in decoding order, by \na scalability information SEI message inside the same access unit. The set of access units consisting of the access unit \nassociated with the layers not present SEI message and all succeeding access units in decoding order until, but excluding, \nthe next access unit that contains a layers not present SEI message or that does not contain any primary coded VCL NAL \nunits with IdrPicFlag equal to 0 (if present), or the end of the bitstream (otherwise) is referred to as the target access unit \nset. The layers not present SEI message applies to the target access unit set. \nA layers not present SEI message refers to the most recent scalability information SEI message in decoding order. Each \nscalable layer that is referred to in this clause is a scalable layer indicated in the most recent scalability information SEI \nmessage in decoding order. Each layer identifier for a scalable layer that is referred to in this clause is a layer identifier for \na scalable layer indicated in the most recent scalability information SEI message in decoding order. \nNOTE 1 – Layers not present SEI messages do not have a cumulative effect. \nnum_layers specifies the number of syntax elements layer_id[ i ] that are present in the layers not present SEI message. \nThe value of num_layers shall be in the range of 0 to 2047, inclusive. \nlayer_id[ i ] indicates the layer identifier of a scalable layer for which no VCL NAL units are present in the target access \nunit set. The value of layer_id[ i ] shall be in the range of 0 to 2047, inclusive. The value of layer_id[ i ] shall be equal to \none of the values of layer_id[ i ] in the most recent scalability information SEI message. The target access unit set shall \nnot contain any VCL NAL unit of the scalable layer having a layer identifier equal to layer_id[ i ]. When i is greater than 0, \nthe value of layer_id[ i ] shall not be equal to any of the values of layer_id[ j ] with j = 0..(i − 1). \nNOTE 2 – When an application removes NAL units from a scalable bitstream, e.g. in order to adapt the bitstream to a transmission \nchannel or the capabilities of a receiving device, and keeps the present layers not present SEI messages, it might need to modify the \ncontent of some of the layers not present SEI messages and remove some other layers not present SEI messages in order to obtain a \nbitstream conforming to this Recommendation | International Standard. \nG.13.2.6 Layer dependency change SEI message semantics \nThe layer dependency change SEI message provides a mechanism for signalling that the interdependencies between \nparticular scalable layers indicated by the preceding scalability information SEI message are changed for a particular set \nof access units. \nIn the following specification of this clause, the terms scalable layer, representation of a scalable layer, scalable layer \nrepresentation, and primary coded VCL NAL unit are used as specified in clause G.13.2.1. \nA layer dependency change SEI message shall not be included in a scalable nesting SEI message. \nA layer dependency change SEI message shall not be present in an access unit that does not belong to the target access unit \nset of any scalability information SEI message. A layer dependency change SEI message shall not be succeeded, in \ndecoding order, by a scalability information SEI message or a layers not present SEI message inside the same access unit. \nThe set of access units consisting of the access unit associated with the layer dependency change SEI message and all \n    Rec. ITU-T H.264 (06/2019)  639 \n \nsucceeding access units in decoding order until, but excluding, the next access unit that contains a layer dependency change \nSEI message or a layers not present SEI message or that does not contain any primary coded VCL NAL units with \nIdrPicFlag equal to 0 (if present), or the end of the bitstream (otherwise) is referred to as the target access unit set. The \nlayer dependency change SEI message applies to the target access unit set. \nA layer dependency change SEI message refers to the most recent scalability information SEI message in decoding order. \nEach scalable layer that is referred to in this clause is a scalable layer indicated in the most recent scalability information \nSEI message in decoding order. Each layer identifier for a scalable layer that is referred to in this clause is a layer identifier \nfor a scalable layer indicated in the most recent scalability information SEI message in decoding order. \nNOTE 1 – Layer dependency change SEI messages do not have a cumulative effect. \nThe presence of the layer dependency change SEI message specifies the following. For a scalable layer with a layer \nidentifier equal to any value of layer_id[ i ] present in the layer dependency change SEI message, the layer dependency \nrelationship is changed for the target access unit set relative to the layer dependency relationship specified by the most \nrecent scalability information SEI message in decoding order. For a scalable layer with a layer identifier not equal to any \nvalue of layer_id[ i ] present in the layer dependency change SEI message, the layer dependency relationship remains the \nsame as the one specified in the most recent scalability information SEI message in decoding order. \nWhen, according to the layer dependency information indicated in the most recent scalability information SEI message in \ndecoding order, a scalable layer A does not directly or indirectly depend on another scalable layer B, the layer dependency \nchange SEI message shall not specify that the scalable layer A directly or indirectly depends on the scalable layer B. \nWhen a scalable layer is considered to directly or indirectly depend on another scalable layer is specified in clause G.13.2.1, \nwith the target access unit set being the target access unit set for the layer dependency change SEI message. \nnum_layers_minus1 plus 1 specifies the number of scalable layers for which a layer dependency information change \nrelative to the most recent scalability information SEI message, in decoding order, is indicated in the layer dependency \nchange SEI message. The value of num_layers_minus1 is in the range of 0 to 2047, inclusive. \nlayer_id[ i ] indicates the layer identifier of the scalable layer for which a layer dependency information change is indicated \nby the following syntax elements. The value of layer_id[ i ] shall be in the range of 0 to 2047, inclusive. The value of \nlayer_id[ i ] shall be equal to one of the values of layer_id[ i ] in the most recent scalability information SEI message. \nWhen i is greater than 0, the value of layer_id[ i ] shall not be equal to any of the values of layer_id[ j ] with j = 0..(i − 1). \nNOTE 2 – When an application removes NAL units from a scalable bitstream, e.g. in order to adapt the bitstream to a transmission \nchannel or the capabilities of a receiving device, and keeps the present layer dependency change SEI messages, it might need to \nmodify the content of some of the layer dependency change SEI messages and remove some other layer dependency change SEI \nmessages in order to obtain a bitstream conforming to this Recommendation | International Standard. \nFor  the  following  specification  of  this  clause,  the  scalable  layer  with  layer  identifier  equal  to  the  current  value  of \nlayer_id[ i ] is referred to as the current scalable layer and the representation of the current scalable layer is referred to as \ncurrent scalable layer representation. \nlayer_dependency_info_present_flag[ i ]  equal  to  1  specifies  that  one  or  more  syntax  elements \ndependent_layer_id_delta_minus1[ i ][ j ] indicating the layer dependency information for the current scalable layer are \npresent in the layer dependency change SEI message. layer_dependency_info_present_flag[ i ] equal to 0 specifies that the \nsyntax element layer_dependency_info_src_layer_id_delta_minus1[ i ] for the current scalable layer is present in the layer \ndependency change SEI message. \nnum_directly_dependent_layers[ i ]  specifies  the  number  of  the  syntax  elements \ndirectly_dependent_layer_id_delta_minus1[ i ][ j ]  that  are  present  for  the  current  scalable  layer.  The  value  of \nnum_directly_dependent_layers shall be in the range of 0 to 255, inclusive. \ndirectly_dependent_layer_id_delta_minus1[ i ][ j ] plus 1 indicates the difference between the value of layer_id[ i ] for \nthe current scalable layer and the layer identifier of a particular scalable layer, on which the current scalable layer directly \ndepends. The value of directly_dependent_layer_id_delta_minus1[ i ][ j ] shall be in the range of 0 to layer_id[ i ] − 1, \ninclusive. The layer identifier of the particular scalable layer, on which the current scalable layer directly depends, is equal \nto layer_id[ i ] − directly_dependent_layer_id_delta_minus1 − 1. The most recent scalability information SEI message in \ndecoding  order  shall  contain  information  for  a  scalable  layer b  with  layer_id[ b ]  equal  to \nlayer_id[ i ] − directly_dependent_layer_id_delta_minus1[ i ][ j ] − 1 and this information shall not contain a value of \nlayer_dependency_info_src_layer_id_delta[ i ] equal to 0. \nLet setOfDepLayers be the set union of the representations of the scalable layers b that have layer_id[ b ] equal to \nlayer_id[ i ] − directly_dependent_layer_id_delta_minus1[ i ][ j ] − 1, with j = 0..num_directly_dependent_layers[ i ] − 1. \nWhen layer_dependency_info_present_flag[ i ] is equal to 1, the set setOfDepLayers shall not contain any scalable layer, \non which the current scalable layer does not directly or indirectly depends inside the target access unit set and the current \nscalable layer shall not depend on any scalable layer, inside the target access unit set, that is not included in the set \nsetOfDepLayers. \n640  Rec. ITU-T H.264 (06/2019) \n \nlayer_dependency_info_src_layer_id_delta_minus1[ i ] indicates that the current scalable layer  has the same layer \ndependency  information  as  the  scalable  layer  with  layer  identifier  equal  to  layer_id[ i ] − \nlayer_dependency_info_src_layer_id_delta_minus1[ i ] − 1.  The  value  of \nlayer_dependency_info_src_layer_id_delta_minus1[ i ] shall be in the range of 0 to layer_id[ i ] − 1, inclusive. The most \nrecent  scalability  information  SEI  message  in  decoding  order  shall  contain  information  for  a  scalable  layer  b  with \nlayer_id[ b ] equal to layer_id[ i ] − layer_dependency_info_src_layer_id_delta_minus1[ i ] − 1 and this information shall \nnot contain a value of layer_dependency_info_src_layer_id_delta[ b ] equal to 0. \nWhen layer_dependency_info_present_flag[ i ] is equal to 0, the set of scalable layers on which the current scalable layer \ndepends inside the target access unit set shall be identical to the set of layers on which the scalable layer b with layer_id[ b ] \nequal to layer_id[ i ] − layer_dependency_info_src_layer_id_delta_minus1[ i ] − 1 depends inside the target access unit \nset. \nG.13.2.7 Scalable nesting SEI message semantics \nThe scalable nesting SEI message provides a mechanism for associating SEI messages with subsets of a bitstream. \nA scalable nesting SEI message shall contain one or more SEI messages with payloadType not equal to 30 and it shall not \ncontain any SEI message with payloadType equal to 30. An SEI message contained in a scalable nesting SEI message is \nreferred to as a nested SEI message. An SEI message not contained in a scalable nesting SEI message is referred to as a \nnon-nested  SEI  message.  The  scope  to  which  the  nested  SEI  message  applies  is  indicated  by  the  syntax  elements \nall_layer_representations_in_au_flag, num_layer_representations_minus1, sei_dependency_id[ i ], sei_quality_id[ i ], and \nsei_temporal_id, when present. \nA buffering period SEI message and an SEI message of any other type shall not be nested in the same scalable nesting SEI \nmessage. A picture timing SEI message and an SEI message of any other type shall not be nested in the same scalable \nnesting SEI message. \nall_layer_representations_in_au_flag equal to 1 specifies that the nested SEI message applies to all layer representations \nof the access unit. all_layer_representations_in_au_flag equal to 0 specifies that the scope of the nested SEI message is \nspecified  by  the  syntax  elements  num_layer_representations_minus1,  sei_dependency_id[ i ],  sei_quality_id[ i ],  and \nsei_temporal_id. \nnum_layer_representations_minus1 plus 1 specifies, when num_layer_representations_minus1 is present, the number \nof syntax element pairs sei_dependency_id[ i ] and sei_quality_id[ i ] that are present in the scalable nesting SEI message. \nWhen num_layer_representations_minus1 is not present, it shall be inferred to be equal to ( numSVCLayers − 1 ) with \nnumSVCLayers being the number of layer representations that are present in the primary coded picture of the access unit. \nThe value of num_layer_representations_minus1 shall be in the range of 0 to 127, inclusive. \nsei_dependency_id[ i ] and sei_quality_id[ i ] indicate the dependency_id and the quality_id values, respectively, of the \nlayer representations to which the nested SEI message applies. The access unit may or may not contain layer representations \nwith dependency_id equal to sei_dependency_id[ i ] and quality_id equal to sei_quality_id[ i ]. When i is greater than 0, \nthe  value  of  (16 * sei_dependency_id[ i ] + sei_quality_id[ i ])  shall  not  be  equal  to  any  of  the  values  of \n(16 * sei_dependency_id[ j ] + sei_quality_id[ j ]) with j = 0..(i − 1). \nWhen num_layer_representations_minus1 is not present, the values of sei_dependency_id[ i ] and sei_quality_id[ i ] for i \nin the range of 0 to num_layer_representations_minus1 (with num_layer_representations_minus1 being the inferred value), \ninclusive, shall be inferred as specified in the following: \n1.  Let setDQId be the set of the values DQId for all layer representations that are present in the primary coded \npicture of the access unit. \n2.  For i proceeding from 0 to num_layer_representations_minus1, inclusive, the following applies: \na.  sei_dependency_id[ i ]  and  sei_quality_id[ i ]  are  inferred  to  be  equal  to  ( minDQId >> 4 )  and \n( minDQId & 15 ), respectively, with minDQId being the smallest value (smallest value of DQId) in the \nset setDQId. \nb.  The smallest value (smallest value of DQId) of the set setDQId is removed from setDQId and thus the \nnumber of elements in the set setDQId is decreased by 1. \nsei_temporal_id indicates the temporal_id value of the bitstream subset to which the nested SEI message applies. When \nsei_temporal_id is not present, it shall be inferred to be equal to temporal_id of the access unit. \nWhen the nested SEI message is a buffering period SEI message or a picture timing SEI message (i.e., payloadType is \nequal to 0 or 1 for the nested SEI message), sei_temporal_id indicates the bitstream subset for which the nested buffering \nperiod SEI message or picture timing SEI message applies. For a buffering period SEI message or picture timing SEI \nmessage that is nested in a scalable nesting SEI message, sei_dependency_id[ i ], sei_quality_id[ i ], and sei_temporal_id \nspecify the greatest values of dependency_id, quality_id, and temporal_id, respectively, of the bitstream subsets to which \n    Rec. ITU-T H.264 (06/2019)  641 \n \nthe nested buffering period SEI message or picture timing SEI message applies. The bitstream may or may not contain \naccess units with temporal_id equal to sei_temporal_id. \nWhen the scalable nesting SEI message contains one or more  SEI messages with payloadType not equal to 0 or 1, \nsei_temporal_id shall be equal to the value of temporal_id for the access unit associated with the scalable nesting SEI \nmessage.  For  an  nested  SEI  message  with  payloadType  not  equal  to  0  or  1,  the  values  of  sei_dependency_id[ i ], \nsei_quality_id[ i ], and sei_temporal_id, present in or inferred for the associated scalable nesting SEI message, indicate the \nvalues of dependency_id, quality_id, and temporal_id, respectively, of the VCL NAL units to which the nested SEI \nmessage applies. \nsei_nesting_zero_bit shall be equal to 0. \nG.13.2.8 Base layer temporal HRD SEI message semantics \nThe base layer temporal HRD SEI message provides HRD parameters for subsets of the base layer bitstream. \nThe base layer temporal HRD SEI message shall not be included in a scalable nesting SEI message. The base layer temporal \nHRD SEI message shall not be present in access units that do not contain VCL NAL units of the primary coded picture \nwith nal_unit_type equal to 5. \nWhen present, this SEI message applies to the target access unit set that consists of the current access unit and all \nsubsequent access units in decoding order until, but excluding, the next access unit containing a NAL unit of the primary \ncoded picture with nal_unit_type equal to 5 (if present) or the end of the bitstream (otherwise). \nnum_of_temporal_layers_in_base_layer_minus1 plus 1 specifies the number of bitstream subsets inside the target \naccess unit set for which the following syntax elements are specified in the base layer temporal HRD SEI message. The \nvalue of num_of_temporal_layers_in_base_layer_minus1 shall be in the range of 0 to 7, inclusive. \nsei_temporal_id[ i ] specifies the temporal_id value of the i-th bitstream subset. When i is greater than 0, the value of \nsei_temporal_id[ i ] shall not be equal to any of the values of sei_temporal_id[ j ] with j = 0..(i − 1). \nAccess units with temporal_id equal to sei_temporal_id[ i ] may or may not be present in the target access unit set. When \naccess units with temporal_id equal to sei_temporal_id[ i ] are not present in the target access unit set, the i-th bitstream \nsubset is considered as not existing. \nWhen access units with temporal_id equal to sei_temporal_id[ i ] are present in the target access unit set, the i-th bitstream \nsubset is the bitstream subset that is obtained by invoking the bitstream extraction process as specified in clause G.8.8.1 \nfor the target access unit set with tIdTarget equal to sei_temporal_id[ i ], dIdTarget equal to 0, and qIdTarget equal to 0 as \nthe inputs. \nsei_timing_info_present_flag[ i ]  equal  to  1  specifies  that  sei_num_units_in_tick[ i ],  sei_time_scale[ i ],  and \nsei_fixed_frame_rate_flag[ i ] are present in the base layer temporal HRD SEI message. sei_timing_info_present_flag[ i ] \nequal to 0 specifies that sei_num_units_in_tick[ i ], sei_time_scale[ i ], and sei_fixed_frame_rate_flag[ i ] are not present \nin the base layer temporal HRD SEI message. \nThe following syntax elements for the i-th bitstream subset are specified using references to Annex E. For these syntax \nelements  the  same  semantics  and  constraints  as  the  ones  specified  in  Annex E  apply,  as  if  these  syntax  elements \nsei_num_units_in_tick[ i ], sei_time_scale[ i ], sei_fixed_frame_rate_flag[ i ], sei_nal_hrd_parameters_present_flag[ i ], \nsei_vcl_hrd_parameters_present_flag[ i ], sei_low_delay_hrd_flag[ i ], and sei_pic_struct_present_flag[ i ] were present \nas  num_units_in_tick,  time_scale,  fixed_frame_rate_flag,  nal_hrd_parameters_present_flag, \nvcl_hrd_parameters_present_flag, low_delay_hrd_flag, and pic_struct_present_flag, respectively, in the VUI parameters \nof the active SVC sequence parameter sets for the i−th bitstream subset. \nThe parameters for the i-th bitstream subset that are coded in the base layer temporal HRD SEI message shall be correct, \nas if these parameters are used for conformance checking (as specified in Annex C) of the i-th bitstream subset. \nsei_num_units_in_tick[ i ] indicates the value of num_units_in_tick, as specified in clause E.2.1, that applies to the i-th \nbitstream subset. \nsei_time_scale[ i ] indicates the value of time_scale, as specified in clause E.2.1, that applies to the i-th bitstream subset. \nsei_fixed_frame_rate_flag[ i ] indicates the value of fixed_frame_rate_flag, as specified in clause E.2.1, that applies to \nthe i-th bitstream subset. \nsei_nal_hrd_parameters_present_flag[ i ]  indicates  the  value  of  nal_hrd_parameters_present_flag,  as  specified  in \nclause E.2.1, that applies to the i-th bitstream subset. When sei_nal_hrd_parameters_present_flag[ i ] is equal to 1, the \nNAL  HRD  parameters  that  apply  to  the  i-th  bitstream  subset  immediately  follow  the \nsei_nal_hrd_parameters_present_flag[ i ]. \n642  Rec. ITU-T H.264 (06/2019) \n \nsei_vcl_hrd_parameters_present_flag[ i ]  indicates  the  value  of  vcl_hrd_parameters_present_flag,  as  specified  in \nclause E.2.1, that applies to the i-th bitstream subset. When sei_vcl_hrd_parameters_present_flag[ i ] is equal to 1, the \nVCL  HRD  parameters  that  apply  to  the  i-th  bitstream  subset  immediately  follow  the \nsei_vcl_hrd_parameters_present_flag[ i ]. \nsei_low_delay_hrd_flag[ i ] indicates the value of low_delay_hrd_flag, as specified in clause E.2.1, that applies to the i-\nth bitstream subset. \nsei_pic_struct_present_flag[ i ] indicates the value of pic_struct_present_flag, as specified in clause E.2.1, that applies to \nthe i-th bitstream subset. \nG.13.2.9 Quality layer integrity check SEI message semantics \nThe quality layer integrity check SEI message provides a mechanism for detecting whether VCL NAL units with quality_id \ngreater than 0 of the primary coded picture have been removed from the bitstream. \nThe quality layer integrity check SEI message shall not be included in a scalable nesting SEI message. \nnum_info_entries_minus1  plus  1  specifies  the  number  of  syntax  element  pairs  entry_dependency_id[ i ]  and \nquality_layer_crc[ i ]  that  are  present  in  the  quality  layer  integrity  check  SEI  message.  The  value  of \nnum_info_entries_minus1 shall be in the range of 0 to 7, inclusive. \nentry_dependency_id[ i ]  specifies  the  dependency_id  value  of  the  dependency  representation  for  which \nquality_layer_crc[ i ] is indicated. The instances of entry_dependency_id[ i ] shall appear in increasing order of their \nvalues.  The  dependency  representation  of  the  primary  coded  picture  that  has  dependency_id  equal  to \nentry_dependency_id[ i ] is referred to as target dependency representation. \nThe target dependency representation may or may not be present in the access unit. \nquality_layer_crc[ i ] specifies the cyclic redundancy check for all the VCL NAL units with quality_id greater than 0 in \nthe target dependency representation. \nLet crcVal be a variable that is derived as specified by the following ordered steps: \n1.  Let the variable qNalUnits[ ] be the one-dimensional array of bytes that contains a concatenation, in decoding \norder, of the bytes of the nal_unit( ) syntax structures of all VCL NAL units with quality_id greater than 0 in the \ntarget dependency representation, in decoding order. \n2.  Let the variable pLen be the sum of the NumBytesInNALunit variables of all VCL NAL units with quality_id \ngreater than 0 in the target dependency representation. \n3.  The value of crcVal is derived as specified by the following pseudo-code process: \nqNalUnits[ pLen       ] = 0 \nqNalUnits[ pLen + 1 ] = 0 \ncrcVal = 65535 \nfor( bitIdx = 0; bitIdx < ( pLen + 2 ) * 8; bitIdx++ ) {  (G-383) \n    crcMsb = ( crcVal >> 15 ) & 1 \n    bitVal = ( qNalUnits[ bitIdx >> 3 ] >> ( 7 − ( bitIdx & 7 ) ) ) & 1 \n    crcVal = ( ( ( crcVal << 1 ) + bitVal ) & 65535 ) ^ ( crcMsb * 4129 ) \n} \nWhen the target dependency representation is present in the access unit, a value of quality_layer_crc[ i ] not equal to crcVal \nindicates that one or more VCL NAL units with quality_id greater than 0 of the target dependency representation have \nbeen removed from the bitstream and that the output pictures may show undesirable visual artefacts. \nG.13.2.10  Redundant picture property SEI message semantics \nThe redundant picture property SEI message indicates properties for layer representations of redundant coded pictures. In \nthe following, a layer representation of a redundant coded picture is also referred to as redundant coded layer representation \nand a layer representation of the primary coded picture is also referred to as primary coded layer representation. \nThe redundant picture property SEI message shall not be included in a scalable nesting SEI message. \nnum_dIds_minus1 plus 1 specifies the number of dependency_id values for which properties of redundant coded layer \nrepresentations are indicated in the redundant picture property SEI message. The value of num_dIds_minus1 shall be in \nthe range of 0 to 7, inclusive. \ndependency_id[ i ] specifies the dependency_id value of the redundant coded layer representations for which properties \nare indicated by the following syntax elements. When i is greater than 0, the value of dependency_id[ i ] shall not be equal \nto any of the values of dependency_id[ j ] with j = 0..(i − 1). \n    Rec. ITU-T H.264 (06/2019)  643 \n \nnum_qIds_minus1[ i ] plus 1 specifies the number of quality_id values for which properties of redundant coded layer \nrepresentations with dependency_id equal to dependency_id[ i ] are indicated by the following syntax elements. The value \nof num_qIds_minus1[ i ] shall be in the range of 0 to 15, inclusive. \nquality_id[ i ][ j ] specifies the quality_id value of the redundant coded layer representations with dependency_id equal to \ndependency_id[ i ] for which properties are indicated by the following syntax elements. When j is greater than 0, the value \nof quality_id[ i ][ j ] shall not be equal to any of the values of quality_id[ i ][ k ] with k = 0..(j − 1). \nnum_redundant_pics_minus1[ i ][ j ]  plus  1  specifies  the  number  of  redundant  coded  layer  representations  with \ndependency_id equal to dependency_id[ i ] and quality_id equal to quality_id[ i ][ j ] for which properties are indicated by \nthe following syntax elements. The value of num_redundant_pics_minus1[ i ][ j ] shall be in the range of 0 to 127, \ninclusive. \nredundant_pic_cnt_minus1[ i ][ j ][ k ]  plus  1  specifies  the  redundant_pic_cnt  value  of  the  redundant  coded  layer \nrepresentation  with  dependency_id  equal  to  dependency_id[ i ]  and  quality_id  equal  to  quality_id[ i ][ j ]  for  which \nproperties are indicated by the following syntax elements. The value of redundant_pic_cnt_minus1[ i ][ j ][ k ] shall be in \nthe range of 0 to 126, inclusive. When k is greater than 0, the value of redundant_pic_cnt_minus1[ i ][ j ][ k ] shall not be \nequal to any of the values of redundant_pic_cnt_minus1[ i ][ j ][ m ] with m = 0..(k − 1). \nThe  redundant  coded  layer  representation  having  dependency_id  equal  to  dependency_id[ i ],  quality_id  equal  to \nquality_id[ i ][ j ], and redundant_pic_cnt equal to ( redundant_pic_cnt_minus1[ i ][ j ][ k ] + 1 ) is referred to as the target \nredundant coded layer representation. The primary coded layer representation (redundant_pic_cnt is equal to 0) having \ndependency_id equal to dependency_id[ i ] and quality_id equal to quality_id[ i ][ j ] is referred to as the target primary \ncoded layer representation. \nThe target redundant coded layer representation may or may not be present in the access unit. The target primary coded \nlayer representation may or may not be present in the access unit. \nFor the following specification, the picture that only consists of the target redundant coded layer representation and the \nprimary coded layer representations with DQId less than (dependency_id[ i ] << 4) + quality_id[ i ] is referred to as target \nredundant coded picture and the picture that only consists of the target primary coded layer representation and the primary \ncoded layer representations with DQId less than (dependency_id[ i ] << 4) + quality_id[ i ] is referred to as target primary \ncoded picture. \nFor the following specification, the arrays mbType, subMbType, predFlagL0, predFlagL1, refIdxL0, refIdxL1, mvL0, \nmvL1, rS , rS , rS , cS , cS , and cS  represent the corresponding arrays of the collective term currentVars after \nL Cb Cr L Cb Cr\ncompletion of the target macroblock decoding process as specified in clause G.8.1.5.6. \npic_match_flag[ i ][ j ][ k ] equal to 1 indicates that the target redundant coded layer representation is an exact copy of the \ntarget primary coded layer representation, with the only difference in the value of redundant_pic_cnt. \nmb_type_match_flag[ i ][ j ][ k ] equal to 1 indicates that the array mbType for the target redundant coded picture is \nidentical to the array mbType for the target primary coded picture. \nmotion_match_flag[ i ][ j ][ k ] equal to 1 indicates that, for each macroblock mbAddr in the target layer representation \nof the target primary coded picture for which the derived macroblock type mbType[ mbAddr ] represents a P or B \nmacroblock  type,  the  variables  and  arrays  mbType[ mbAddr ],  subMbType[ mbAddr ],  predFlagL0[ mbAddr ], \npredFlagL1[ mbAddr ], refIdxL0[ mbAddr ], refIdxL1[ mbAddr ], mvL0[ mbAddr ], and mvL1[ mbAddr ] for the target \nredundant coded picture are identical to the corresponding variables and arrays for the target primary coded picture. \nresidual_match_flag[ i ][ j ][ k ] equal to 1 indicates that, for each macroblock mbAddr in the target layer representation \nof the target primary coded picture for which the derived macroblock type mbType[ mbAddr ] represents a P or B \nmacroblock type, the associated reconstructed residual sample values in the arrays rS , rS , and rS  for the target \nL Cb Cr\nredundant coded picture are identical or close to the corresponding reconstructed residual sample values for the target \nprimary coded picture. \nintra_samples_match_flag[ i ][ j ][ k ]  equal  to  1  indicates  that,  for  each  macroblock  mbAddr  in  the  target  layer \nrepresentation of the target primary coded picture for which the derived macroblock type mbType[ mbAddr ] represents \nan I macroblock type, the associated reconstructed sample values in the arrays cS , cS , and cS  for the target redundant \nL Cb Cr\ncoded picture are identical or close to the corresponding reconstructed sample values for the target primary coded picture. \nG.13.2.11  Temporal level zero dependency representation index SEI message semantics \nThe temporal level zero dependency representation index SEI message provides a mechanism for detecting whether a \ndependency representation with temporal_id equal to 0 required for decoding the current access unit is available when \nNAL unit losses are expected during transport. \nLet setOfDId be a set of dependency_id values that is derived as follows: \n644  Rec. ITU-T H.264 (06/2019) \n \n–  If the temporal level zero dependency representation index SEI message is not included in a scalable nesting SEI \nmessage, setOfDId consists of exactly one value, which is equal to 0. \n–  Otherwise (the temporal level zero dependency representation index SEI message is included in a scalable nesting \nSEI  message),  setOfDId  consists  of  the  values  sei_dependency_id[ i ]  for  all  i  in  the  range  of  0  to \nnum_layer_representations_minus1, inclusive, that are present in the scalable nesting SEI message associated with \nthe temporal level zero dependency representation index SEI message. For the scalable nesting SEI message that \ncontains the temporal level zero dependency representation index SEI message, all_layer_representations_in_au_flag \nshall be equal to 1 or the value of sei_quality_id[ i ] shall be equal to 0 for all values of i in the range of 0 to \nnum_layer_representations_minus1, inclusive. \nAll dependency representations that are referred to in the following specification inside this  clause are dependency \nrepresentations of a primary coded picture. Unless specified otherwise, all dependency representation that are referred to \nin the following are dependency representations of the primary coded picture of the access unit that is associated with the \ntemporal level zero dependency representation index SEI message. \nThe dependency representations of the access unit that have dependency_id equal to any value of the set setOfDId are also \nreferred to as associated dependency representations. \nFor each value of dId in the set setOfDId, the access unit may or may not contain a dependency representation with \ndependency_id equal to dId. \ntl0_dep_rep_idx indicates the temporal level zero index for the associated dependency representations, if temporal_id is \nequal to 0. Otherwise (temporal_id is greater than 0), tl0_dep_rep_idx indicates the temporal level zero index of the \ndependency representations of the most recent access unit with temporal_id equal to 0 in decoding order that have the same \nvalue of dependency_id as any of the associated dependency representations. \nFor each value of dId in the set setOfDId, the following applies: \n–  If the dependency representation with dependency_id equal to dId contains a NAL unit with nal_unit_type equal to 5 \nor a NAL unit with nal_unit_type equal to 20 and idr_flag equal to 1, tl0_dep_rep_idx shall be equal to 0. \n–  Otherwise (the  dependency representation  with dependency_id equal to dId does not contain a NAL  unit  with \nnal_unit_type equal to 5 or a NAL unit with nal_unit_type equal to 20 and idr_flag equal to 1), the following is \nspecified: \n1.  Let prevTL0AU be the most recent access unit in decoding order that has temporal_id equal to 0 and for which \nthe primary coded picture contains a dependency representation with dependency_id equal to dId. \n2.  Let prevTL0DepRep be the dependency representation with dependency_id equal to dId of the primary coded \npicture in access unit prevTL0AU. \n3.  Let prevTL0DepRepIdx be equal to the value of tl0_dep_rep_idx that is associated with the dependency \nrepresentation  prevTL0DepRep,  as  indicated  by  a  corresponding  temporal  level  zero  dependency \nrepresentation index SEI message. \n4.  Depending on temporal_id of the current access unit, the following applies: \n–  If  temporal_id  of  the  current  access  unit  is  equal  to 0,  tl0_dep_rep_idx  shall  be  equal  to \n( prevTL0DepRepIdx + 1 ) % 256. \n–  Otherwise (temporal_id of the current access unit is greater than 0), tl0_dep_rep_idx shall be equal to \nprevTL0DepRepIdx. \nWhen the temporal level zero dependency representation index SEI message is associated with a particular dependency \nrepresentation depRepA that has dependency_id equal dIdA and IdrPicFlag equal to 0, a temporal level zero dependency \nrepresentation index SEI message shall also be associated with the previous dependency representation dIdB in decoding \norder  that  has  dependency_id  equal  to  dIdA  and  IdrPicFlag  equal  to  1  and  all  dependency  representations  with \ndependency_id equal to dIdA and temporal_id equal to 0 that follow the dependency representation dIdB and precede the \ndependency representation dIdA in decoding order. \nNOTE – For the tl0_dep_rep_idx mechanism to be effectively used, transport mechanisms should ensure that the information is \npresent in every packet that carries data for the particular values of dependency_id. \neffective_idr_pic_id indicates the latest value of idr_pic_id in decoding order present in this access unit or any preceding \naccess unit for dependency representations indicated by sei_dependency_id[ i ]. \nFor each value of dId in the set setOfDId, the following applies: \n    Rec. ITU-T H.264 (06/2019)  645 \n \n–  If the dependency representation with dependency_id equal to dId contains a NAL unit with nal_unit_type equal to 5 \nor a NAL unit with nal_unit_type equal to 20 and idr_flag equal to 1, effective_idr_pic_id shall be equal to idr_pic_id \nof the dependency representation with dependency_id equal to dId. \n–  Otherwise (the dependency representation  with dependency_id equal to dId does not contain a NAL  unit  with \nnal_unit_type equal to 5 or a NAL unit with nal_unit_type equal to 20 and idr_flag equal to 1), effective_idr_pic_id \nshall be equal to idr_pic_id of the previous dependency representation in decoding order with dependency_id equal \nto dId that contains a NAL unit with nal_unit_type equal to 5 or a NAL unit with nal_unit_type equal to 20 and \nidr_flag equal to 1. \nG.13.2.12  Temporal level switching point SEI message semantics \nThe temporal level switching point SEI message provides a mechanism for identifying temporal level switching points. If \na dependency representation is associated with a temporal level switching point SEI message, then it is a temporal level \nswitching point as specified subsequently and constrained by delta_frame_num. Otherwise, the dependency representation \nmay or may not be a temporal level switching point. \nAll  dependency  representations  that  are  referred  to  in  the  following  specification  of  this  clause  are  dependency \nrepresentations of primary coded pictures. \nIn the following, let tId be the value of temporal_id of the access unit that is associated with the temporal level switching \npoint SEI message. \nNOTE 1 – Let dId be the value of dependency_id that a bitstream adaptation process has used to generate a bitstream subset \nsubBitstreamA that contains dependency representations with dependency_id less than or equal to dId and temporal_id less than tId \nof an input bitstream (that is conforming to this Recommendation | International Standard) until the current access unit, exclusive. \nThe bitstream adaptation process can infer from a temporal level switching point SEI message whether or not the bitstream subset \ncontaining subBitstreamA and the dependency representations with dependency_id less than or equal to dId and temporal_id less \nthan  or  equal  to  tId  of  the  input  bitstream  starting  from  the  current  access  unit,  inclusive,  is  conforming  to  this \nRecommendation | International Standard. \nThe temporal level switching point SEI message shall not be present in access units with temporal_id equal to 0. \nThe temporal level switching point SEI message shall be included in a scalable nesting SEI message. For the scalable \nnesting SEI message that contains the temporal level switching point SEI message, all_layer_representations_in_au_flag \nshall  be  equal  to 1  or  the  value  of  sei_quality_id[ i ]  shall  be  equal  to  0  for  all  values  of  i  in  the  range  of  0  to \nnum_layer_representations_minus1, inclusive. \nThe following semantics apply independently to each value of sei_dependency_id[ i ] indicated by the scalable nesting SEI \nmessage containing the temporal level switching point SEI message. The current access unit, i.e., the access unit associated \nwith  the  temporal  level  switching  point  SEI  message,  may  or  may  not  contain  a  dependency  representation  with \ndependency_id equal to sei_dependency_id[ i ]. When the current access unit contains a dependency representation with \ndependency_id equal to sei_dependency_id[ i ], the following semantics apply. \nThe following semantics are specified in a way that they apply to a bitstream conforming to this Recommendation | \nInternational Standard for which DependencyIdMax for the current access unit is equal to sei_dependency_id[ i ]. \nLet  the  switch-to  dependency  representation  be  the  dependency  representation  in  the  current  access  unit  that  has \ndependency_id equal to sei_dependency_id[ i ] and let maxFrameNum be the value of MaxFrameNum for the SVC \nsequence parameter set that is the active SVC sequence parameter set for the current access unit (with DependencyIdMax \nequal to sei_dependency_id[ i ]). \ndelta_frame_num indicates the difference between the frame_num values of the switch-to dependency representation and \nthe dependency representation with dependency_id equal to sei_dependency_id[ i ] in the required access unit, as specified \nsubsequently. The value of delta_frame_num shall be in the range of  1 − maxFrameNum to maxFrameNum − 1, inclusive. \nLet currFrameNum be the frame_num value of the switch-to dependency representation. The variable requiredFrameNum \nis set equal to currFrameNum − delta_frame_num. Let lastIdrAU be the most recent access unit in decoding order that \ncontains a dependency representation with dependency_id equal to sei_dependency_id[ i ] and IdrPicFlag equal to 1. The \nbitstream shall contain an access unit that succeeds the access unit lastIdrAU and precedes the current access unit in \ndecoding order and contains a dependency representation with frame_num equal to requiredFrameNum and dependency_id \nequal to sei_dependency_id[ i ]. The most recent access unit in decoding order that contains a dependency representation \nwith frame_num equal to requiredFrameNum and dependency_id equal to sei_dependency_id[ i ] is referred to as the \nrequired access unit. The required access unit shall have a value of temporal_id that is equal to tId − 1. \nThe current access unit and all subsequent access units in decoding order for which temporal_id is less than or equal to tId \nshall  not  reference  any  of  the  following  access  units  through  inter  prediction  in  the  decoding  process  specified  in \nclause G.8: \n–  access units that precede the required access unit in decoding order and have temporal_id equal to tId − 1, \n646  Rec. ITU-T H.264 (06/2019) \n \n–  access units that precede the current access unit in decoding order and have temporal_id equal to tId. \nNOTE 2 – The set of access units consisting of the current access unit and all access units with temporal_id less than or equal to tId \nthat follow the current access unit in decoding order can be decoded when all of the following access units, which precede the current \naccess unit in decoding order, have been decoded: all access units required for decoding the required access unit (i.e., all access units \nthat are directly or indirectly referenced through inter prediction in the decoding process for the required access unit), the required \naccess unit, and all access units with temporal_id less than tId that succeed the required access unit and precede the current access \nunit in decoding order. \nG.14  Video usability information \nThe specifications in Annex E apply with substituting SVC sequence parameter set for sequence parameter set. The VUI \nparameters and the constraints specified in Annex E apply to coded video sequences for which the SVC sequence parameter \nset becomes the active SVC sequence parameter set. \nAdditionally, the following applies. \nG.14.1  SVC VUI parameters extension syntax \n \nsvc_vui_parameters_extension( ) {  C  Descriptor \n  vui_ext_num_entries_minus1  0  ue(v) \n  for( i = 0; i <= vui_ext_num_entries_minus1; i++ ) {     \n    vui_ext_dependency_id[ i ]  0  u(3) \n    vui_ext_quality_id[ i ]  0  u(4) \n    vui_ext_temporal_id[ i ]  0  u(3) \n    vui_ext_timing_info_present_flag[ i ]  0  u(1) \n    if( vui_ext_timing_info_present_flag[ i ] ) {     \n      vui_ext_num_units_in_tick[ i ]  0  u(32) \n      vui_ext_time_scale[ i ]  0  u(32) \n      vui_ext_fixed_frame_rate_flag[ i ]  0  u(1) \n    }     \n    vui_ext_nal_hrd_parameters_present_flag[ i ]  0  u(1) \n    if( vui_ext_nal_hrd_parameters_present_flag[ i ] )     \n      hrd_parameters( )  0   \n    vui_ext_vcl_hrd_parameters_present_flag[ i ]  0  u(1) \n    if( vui_ext_vcl_hrd_parameters_present_flag[ i ] )     \n      hrd_parameters( )  0   \n    if( vui_ext_nal_hrd_parameters_present_flag[ i ]  | |       \n      vui_ext_vcl_hrd_parameters_present_flag[ i ] ) \n      vui_ext_low_delay_hrd_flag[ i ]  0  u(1) \n    vui_ext_pic_struct_present_flag[ i ]   0  u(1) \n  }     \n}     \nG.14.2  SVC VUI parameters extension semantics \nThe SVC VUI parameters extension specifies timing information, HRD parameter sets, and  the presence of picture \nstructure information for subsets of coded video sequences (including the complete coded video sequences) conforming \none or more of the profiles specified in Annex G. In Annex C it is specified which of the HRD parameter sets specified in \nthe SVC VUI parameters extension are used for conformance checking. \nvui_ext_num_entries_minus1 plus 1 specifies the  number of  information entries that are present in the SVC VUI \nparameters extension syntax structure. The value of vui_ext_num_entries_minus1 shall be in the range of 0 to 1023, \ninclusive. Each information entry is associated with particular values of temporal_id, dependency_id, and quality_id and \nmay indicate timing information, NAL HRD parameters, VCL HRD parameters, and the presence of picture structure \ninformation for a particular subset of coded video sequences as specified in the following. \n    Rec. ITU-T H.264 (06/2019)  647 \n \nvui_ext_dependency_id[ i ] and vui_ext_quality_id[ i ] indicate the maximum value of DQId for the i-th subset of coded \nvideo  sequences.  The  maximum  value  of  DQId  for  the  i-th  subset  of  coded  video  sequences  is  derived  by \nvui_ext_dependency_id[ i ] + ( vui_ext_quality_id[ i ] << 4 ). \nvui_ext_temporal_id[ i ] indicates the maximum value of temporal_id for the i-th subset of coded video sequences. \nThe SVC VUI parameters extension syntax structure shall not contain two or more information entries with identical values \nof vui_ext_dependency_id[ i ], vui_ext_quality_id[ i ], and vui_ext_temporal_id[ i ]. \nThe following syntax elements apply to the coded video sequences that are obtained by the invoking the sub-bitstream \nextraction process as specified in clause G.8.8.1 with tIdTarget equal to vui_ext_temporal_id[ i ], dIdTarget equal to \nvui_ext_dependency_id[ i ], and qIdTarget equal to vui_ext_quality_id[ i ] as the inputs and the i-th subset of coded video \nsequences as the output. \nvui_ext_timing_info_present_flag[ i ] equal to 1 specifies that vui_ext_num_units_in_tick[ i ], vui_ext_time_scale[ i ], \nand vui_ext_fixed_frame_rate_flag[ i ] for the i-th subset of coded video sequences are present in the SVC VUI parameters \nextension.  vui_ext_timing_info_present_flag[ i ]  equal  to 0  specifies  that  vui_ext_num_units_in_tick[ i ], \nvui_ext_time_scale[ i ], and vui_ext_fixed_frame_rate_flag[ i ] for the i-th subset of coded video sequences are not present \nin the SVC VUI parameters extension. \nThe following syntax elements for the i-th subset of coded video sequences are specified using references to Annex E. For \nthese syntax elements the same semantics and constraints as the ones specified in Annex E apply, as if these syntax \nelements  vui_ext_num_units_in_tick[ i ],  vui_ext_time_scale[ i ],  vui_ext_fixed_frame_rate_flag[ i ], \nvui_ext_nal_hrd_parameters_present_flag[ i ],  vui_ext_vcl_hrd_parameters_present_flag[ i ], \nvui_ext_low_delay_hrd_flag[ i ],  and  vui_ext_pic_struct_present_flag[ i ]  were  present  as  the  syntax  elements \nnum_units_in_tick,  time_scale,  fixed_frame_rate_flag,  nal_hrd_parameters_present_flag, \nvcl_hrd_parameters_present_flag, low_delay_hrd_flag, and pic_struct_present_flag, respectively, in the VUI parameters \nof the active SVC sequence parameter sets for the i-th subset of coded video sequences. \nvui_ext_num_units_in_tick[ i ] specifies the value of num_units_in_tick, as specified in clause E.2.1, for the i-th subset \nof coded video sequences. \nvui_ext_time_scale[ i ] specifies the value of time_scale, as specified in clause E.2.1, for the i-th subset of coded video \nsequences. \nvui_ext_fixed_frame_rate_flag[ i ] specifies the value of fixed_frame_rate_flag, as specified in clause E.2.1, for the i-th \nsubset of coded video sequences. \nvui_ext_nal_hrd_parameters_present_flag[ i ] specifies the value of nal_hrd_parameters_present_flag, as specified in \nclause E.2.1, for the i-th subset of coded video sequences. \nWhen vui_ext_nal_hrd_parameters_present_flag[ i ] is equal to 1, NAL HRD parameters (clauses E.1.2 and E.2.2) for the \ni-th subset of coded video sequences immediately follow the flag. \nThe variable VuiExtNalHrdBpPresentFlag[ i ] is derived as follows: \n–  If any of the following is true, the value of VuiExtNalHrdBpPresentFlag[ i ] shall be set equal to 1: \n–  vui_ext_nal_hrd_parameters_present_flag[ i ] is present in the bitstream and is equal to 1, \n–  for the i-th subset of coded video sequences, the need for presence of buffering periods for NAL HRD operation \nto be present in the bitstream in buffering period SEI messages is determined by the application, by some means \nnot specified in this Recommendation | International Standard. \n–  Otherwise, the value of VuiExtNalHrdBpPresentFlag[ i ] shall be set equal to 0. \nvui_ext_vcl_hrd_parameters_present_flag[ i ] specifies the value of vcl_hrd_parameters_present_flag, as specified in \nclause E.2.1, for the i-th subset of coded video sequences. \nWhen vui_ext_vcl_hrd_parameters_present_flag[ i ] is equal to 1, VCL HRD parameters (clauses E.1.2 and E.2.2) for the \ni-th subset of coded video sequences immediately follow the flag. \nThe variable VuiExtVclHrdBpPresentFlag[ i ] is derived as follows: \n–  If any of the following is true, the value of VuiExtVclHrdBpPresentFlag[ i ] shall be set equal to 1: \n–  vui_ext_vcl_hrd_parameters_present_flag[ i ] is present in the bitstream and is equal to 1, \n–  for the i-th subset of coded video sequences, the need for presence of buffering period parameters for VCL HRD \noperation in the bitstream in buffering period SEI messages is determined by the application, by some means not \nspecified in this Recommendation | International Standard. \n–  Otherwise, the value of VuiExtVclHrdBpPresentFlag[ i ] shall be set equal to 0. \n648  Rec. ITU-T H.264 (06/2019) \n \nThe variable VuiExtCpbDpbDelaysPresentFlag[ i ] is derived as follows: \n–  If any of the following is true, the value of VuiExtCpbDpbDelaysPresentFlag[ i ] shall be set equal to 1: \n–  vui_ext_nal_hrd_parameters_present_flag[ i ] is present in the bitstream and is equal to 1, \n–  vui_ext_vcl_hrd_parameters_present_flag[ i ] is present in the bitstream and is equal to 1, \n–  for the i-th subset of coded video sequences, the need for presence of CPB and DPB output delays in the bitstream \nin  picture  timing  SEI  messages  is  determined  by  the  application,  by  some  means  not  specified  in  this \nRecommendation | International Standard. \n–  Otherwise, the value of VuiExtCpbDpbDelaysPresentFlag[ i ] shall be set equal to 0. \nvui_ext_low_delay_hrd_flag[ i ] specifies the value of low_delay_hrd_flag, as specified in clause E.2.1, for the i-th subset \nof coded video sequences. \nvui_ext_pic_struct_present_flag[ i ] specifies the value of pic_struct_present_flag, as specified in clause E.2.1, for the i-\nth subset of coded video sequences. \n    Rec. ITU-T H.264 (06/2019)  649 \n \nAnnex H \n \nMultiview video coding \n \n(This annex forms an integral part of this Recommendation | International Standard.) \nThis annex specifies multiview video coding, referred to as MVC. \nH.1  Scope \nBitstreams and decoders conforming to the profile specified in this annex are completely specified in this annex with \nreference made to clauses 2 to 9 and Annexes A to E. \nH.2  Normative references \nThe specifications in clause 2 apply. \nH.3  Definitions \nFor the purpose of this annex, the following definitions apply in addition to the definitions in clause 3. These definitions \nare either not present in clause 3 or replace definitions in clause 3. \nH.3.1  access unit: A set of NAL units that are consecutive in decoding order and contain exactly one primary coded \npicture consisting of one or more view components. In addition to the primary coded picture, an access unit may \nalso contain one or more redundant coded pictures, one auxiliary coded picture, or other NAL units not containing \nslices or slice data partitions of a coded picture. The decoding of an access unit always results in one decoded \npicture consisting of one or more decoded view components. \nH.3.2  anchor access unit: An access unit in which the primary coded picture is an anchor picture. \nH.3.3  anchor picture: A coded picture in which all slices may reference only slices within the same access unit, i.e., \ninter-view prediction may be used, but no inter prediction is used, and all following coded pictures in output order \ndo  not  use  inter  prediction  from  any  picture  prior  to  the  coded  picture  in  decoding  order.  The  value  of \nanchor_pic_flag is equal to 1 for all the prefix NAL units (when present) and all the slice extension NAL units \nthat are contained in an anchor picture. \nH.3.4  anchor view component: A view component in an anchor picture. All view components in an anchor picture are \nanchor view components. \nH.3.5  associated NAL unit: A NAL unit that immediately follows a prefix NAL unit in decoding order. \nH.3.6  base view: A view that has the minimum value of view order index in a coded video sequence. The base view can \nbe decoded independently of other views, does not use inter-view prediction, and contains VCL NAL units only \nwith nal_unit_type equal to 1, 5, or 14. The bitstream subset corresponding to the base view conforms to one or \nmore of the profiles specified in Annex A. There is only one base view in a coded video sequence. \nH.3.7  bitstream subset: A bitstream that is derived as a subset from a bitstream by discarding zero or more NAL units. \nA bitstream subset is also referred to as a sub-bitstream. \nH.3.8  coded slice MVC extension NAL unit: A coded slice NAL unit that has nal_unit_type equal to 20. \nH.3.9  decoded view component: A decoded view component is derived by decoding a view component. A decoded \nview component is either a decoded frame view component, or a decoded field view component. \nH.3.10  direct prediction: An inter prediction or inter-view prediction for a block for which no motion vector is decoded. \nTwo direct prediction modes are specified that are referred to as spatial direct prediction mode and temporal direct \nprediction mode. \nH.3.11  field view component: A view component of a field. \nH.3.12  frame view component: A view component of a frame. \nH.3.13  instantaneous  decoding  refresh  (IDR)  view  component:  A  view  component  in  an IDR  picture.  All  view \ncomponents in an IDR picture are IDR view components. IDR view components are also anchor view components, \nand inter-view prediction may be used for IDR view components that are part of a non-base view. \nH.3.14  inter-view coding: Coding of a block, macroblock, slice, or picture that uses inter-view prediction. \n650  Rec. ITU-T H.264 (06/2019) \n \nH.3.15  inter-view only reference component: A view component coded with nal_ref_idc equal to 0 and inter_view_flag \nequal to 1. An inter-view only reference component contains samples that may be used for inter-view prediction \nin the decoding process of subsequent view components in decoding order, but are not used for inter prediction \nby any view components. Inter-view only reference components are non-reference pictures. \nH.3.16  inter-view  prediction:  A  prediction  derived  from  decoded  samples  of  inter-view  reference  components  or \ninter-view only reference components for decoding another view component in the same access unit. \nH.3.17  inter-view prediction reference: A collective term for inter-view reference components or inter-view only \nreference components. \nH.3.18  inter-view reference component: A view component coded with nal_ref_idc greater than 0 and inter_view_flag \nequal  to 1.  An  inter-view  reference  component  contains  samples  that  may  be  used  for  inter  prediction  of \nsubsequent pictures in decoding order and inter-view prediction of subsequent view components in decoding \norder. Inter-view reference components are reference pictures. \nH.3.19  left view: The left part of a picture coded in a frame-packed manner with the side-by-side frame packing \narrangement type or the top part of a picture coded in a frame-packed manner with the top-bottom frame packing \narrangement type. \nH.3.20  list 0 (list 1) prediction: Inter prediction or inter-view prediction of the content of a slice using a reference index \npointing into reference picture list 0 (list 1). \nH.3.21  macroblock partition: A block of luma samples and two corresponding blocks of chroma samples resulting from \na partitioning of a macroblock for inter prediction or inter-view prediction. \nH.3.22  motion vector: A two-dimensional vector used for inter prediction or inter-view prediction that provides an offset \nfrom the coordinates in the decoded view component to the coordinates in a reference picture or inter-view only \nreference component. \nH.3.23  MVC sequence parameter set: A collective term for sequence parameter set or subset sequence parameter set. \nH.3.24  MVC sequence parameter set RBSP: A collective term for sequence parameter set RBSP or subset sequence \nparameter set RBSP. \nH.3.25  non-anchor access unit: An access unit that is not an anchor access unit. \nH.3.26  non-anchor picture: A coded picture that is not an anchor picture. \nH.3.27  non-anchor view component: A view component that is not an anchor view component. \nH.3.28  non-base view: A view that is not the base view. VCL NAL units of a non-base view have nal_unit_type equal \nto 20. Decoding of view components in a non-base view may require the use of inter-view prediction. \nH.3.29  non-reference picture: A view component coded with nal_ref_idc equal to 0. A non-reference picture is not used \nfor inter prediction in the decoding process of any other view components. \nH.3.30  operation point: An operation point is identified by a temporal_id value representing the target temporal level \nand a set of view_id values representing the target output views. One operation point is associated with a bitstream \nsubset, which consists of the target output views and all other views the target output views depend on, that is \nderived using the sub-bitstream extraction process as specified in clause H.8.5.3 with tIdTarget equal to the \ntemporal_id value and viewIdTargetList consisting of the set of view_id values as inputs. More than one operation \npoint may be associated with the same bitstream subset. When the specification states \"an operation point is \ndecoded\" it refers to the decoding of a bitstream subset corresponding to the operation point and subsequent \noutput of the target output views. \nH.3.31  picture order count: A variable that is associated with each field view component and each field of a frame view \ncomponent and has a value that is non-decreasing with increasing field position in output order in the same view \nrelative to the first output field of the previous IDR view component in decoding order in the same view or relative \nto the first output field of the previous view component, in decoding order in the same view, that contains a memory \nmanagement control operation that marks all reference pictures in the view as \"unused for reference\". \nH.3.32  prefix NAL unit: A NAL unit with nal_unit_type equal to 14 that immediately precedes in decoding order a NAL \nunit with nal_unit_type equal to 1 or 5. The NAL unit that immediately follows in decoding order the prefix NAL \nunit is referred to as the associated NAL unit. The prefix NAL unit contains data associated with the associated \nNAL unit, which are considered to be part of the associated NAL unit. \nH.3.33  reference picture: A view component coded with nal_ref_idc greater than 0. A reference picture contains samples \nthat may be used for inter prediction in the decoding process of subsequent view components in decoding order. \nA reference picture may be an inter-view reference component, in which case the samples contained in the \nreference  picture  may  also  be  used  for  inter-view  prediction  in  the  decoding  process  of  subsequent  view \n    Rec. ITU-T H.264 (06/2019)  651 \n \ncomponents in decoding order. \nH.3.34  reference picture list: A list of reference pictures and inter-view only reference components that are used for \ninter prediction or inter-view prediction of a P or B slice. For the decoding process of a P slice, there is one \nreference picture list. For the decoding process of a B slice, there are two reference picture lists. \nH.3.35  reference picture list 0: A reference picture list used for inter prediction or inter-view prediction of a P or B \nslice. All inter prediction or inter-view prediction used for P slices uses reference picture list 0. Reference picture \nlist 0 is one of two reference picture lists used for inter prediction or inter-view prediction for a B slice, with the \nother being reference picture list 1. \nH.3.36  reference picture list 1: A reference picture list used for inter prediction or inter-view prediction of a B slice. \nReference picture list 1 is one of two reference picture lists used for inter prediction or inter-view prediction for \na B slice, with the other being reference picture list 0. \nH.3.37  reference picture marking: Specifies, in the bitstream, how the decoded view components are marked for inter \nprediction or inter-view prediction. \nH.3.38  reference processing unit: A functional unit that processes an inter-view prediction reference before the inter-\nview prediction reference is used for inter-view prediction in the decoding process of subsequent view components \nin decoding order. \nH.3.39  reference view index: An index into a list of anchor view components or a list of non-anchor view components \nthat are specified in the sequence parameter set MVC extension syntax structure and can be used for inter-view \nprediction as list 0 prediction or list 1 prediction. \nH.3.40  right view: The right part of a picture coded in a frame-packed manner with the side-by-side frame packing \narrangement type or the bottom part of a picture coded in a frame-packed manner with the top-bottom frame \npacking arrangement type. \nH.3.41  sub-bitstream: A subset of a bitstream. A sub-bitstream is also referred to as a bitstream subset. \nH.3.42  subset: A subset contains only elements that are also contained in the set from which the subset is derived. The \nsubset may be identical to the set from which it is derived. \nH.3.43  subset sequence parameter set: A syntax structure containing syntax elements that apply to zero or more \nnon-base views as determined by the content of a seq_parameter_set_id syntax element found in the picture \nparameter set referred to by the pic_parameter_set_id syntax element found in each slice header of I, P, and B \nslices of a non-base view component. \nH.3.44  target output view: A view that is to be output. The target output views are either indicated by external means \nor, when not indicated by external means, the target output view is the base view. \nNOTE – The output views may be requested by a receiver and may be negotiated between the receiver and the sender. \nH.3.45  target temporal level: The target temporal level of an operation point is the greatest value of temporal_id of all \nVCL NAL units in the bitstream subset associated with the operation point. \nH.3.46  view: A sequence of view components associated with an identical value of view_id. \nH.3.47  view component: A coded representation of a view in a single access unit. When profile_idc is equal to 134, a \nview contains samples of two distinct spatially packed constituent frames that are packed into one frame using \none of the frame packing arrangement schemes as specified in clause D.2.26. \nH.3.48  view order index: An index that indicates the decoding order of view components in an access unit. \nH.4  Abbreviations \nFor the purpose of this annex, the following abbreviations apply in addition to the abbreviations in clause 4. \nMFC  Multi-resolution Frame Compatible stereo coding \nRPU  Reference Processing Unit \nH.5  Conventions \nThe specifications in clause 5 apply. \n652  Rec. ITU-T H.264 (06/2019) \n \nH.6  Source,  coded,  decoded  and  output  data  formats,  scanning  processes,  and  neighbouring \nrelationships \nThe specifications in clause 6 apply with substitution of MVC sequence parameter set for sequence parameter set. \nH.7  Syntax and semantics \nThis clause specifies syntax and semantics for coded video sequences that conform to one or more of the profiles specified \nin this annex. \nH.7.1  Method of specifying syntax in tabular form \nThe specifications in clause 7.1 apply. \nH.7.2  Specification of syntax functions, categories, and descriptors \nThe specifications in clause 7.2 apply. \nH.7.3  Syntax in tabular form \nH.7.3.1  NAL unit syntax \nThe syntax table is specified in clause 7.3.1. \nH.7.3.1.1  NAL unit header MVC extension syntax \n \nnal_unit_header_mvc_extension( ) {  C  Descriptor \n  non_idr_flag  All  u(1) \n  priority_id  All  u(6) \n  view_id  All  u(10) \n  temporal_id  All  u(3) \n  anchor_pic_flag  All  u(1) \n  inter_view_flag  All  u(1) \n  reserved_one_bit  All  u(1) \n}     \n \nH.7.3.2  Raw byte sequence payloads and RBSP trailing bits syntax \nH.7.3.2.1  Sequence parameter set RBSP syntax \nThe syntax table is specified in clause 7.3.2.1. \nH.7.3.2.1.1  Sequence parameter set data syntax \nThe syntax table is specified in clause 7.3.2.1.1. \nH.7.3.2.1.1.1 Scaling list syntax \nThe syntax table is specified in clause 7.3.2.1.1.1. \nH.7.3.2.1.2  Sequence parameter set extension RBSP syntax \nThe syntax table is specified in clause 7.3.2.1.2. \nH.7.3.2.1.3  Subset sequence parameter set RBSP syntax \nThe syntax table is specified in clause 7.3.2.1.3. \nH.7.3.2.1.4  Sequence parameter set MVC extension syntax \n    Rec. ITU-T H.264 (06/2019)  653 \n \nseq_parameter_set_mvc_extension( ) {  C  Descriptor \n  num_views_minus1  0  ue(v) \n  for( i = 0; i <= num_views_minus1; i++ )      \n    view_id[ i ]  0  ue(v) \n  for( i = 1; i <= num_views_minus1; i++ ) {     \n    num_anchor_refs_l0[ i ]  0  ue(v) \n    for( j = 0; j < num_anchor_refs_l0[ i ]; j++ )     \n      anchor_ref_l0[ i ][ j ]  0  ue(v) \n    num_anchor_refs_l1[ i ]  0  ue(v) \n    for( j = 0; j < num_anchor_refs_l1[ i ]; j++ )     \n      anchor_ref_l1[ i ][ j ]  0  ue(v) \n  }     \n  for( i = 1; i <= num_views_minus1; i++ ) {     \n    num_non_anchor_refs_l0[ i ]  0  ue(v) \n    for( j = 0; j < num_non_anchor_refs_l0[ i ]; j++ )     \n      non_anchor_ref_l0[ i ][ j ]  0  ue(v) \n    num_non_anchor_refs_l1[ i ]  0  ue(v) \n    for( j = 0; j < num_non_anchor_refs_l1[ i ]; j++ )     \n      non_anchor_ref_l1[ i ][ j ]  0  ue(v) \n  }     \n  num_level_values_signalled_minus1  0  ue(v) \n  for( i = 0; i <= num_level_values_signalled_minus1; i++ ) {     \n    level_idc[ i ]  0  u(8) \n    num_applicable_ops_minus1[ i ]  0  ue(v) \n    for( j = 0; j <= num_applicable_ops_minus1[ i ]; j++ ) {     \n      applicable_op_temporal_id[ i ][ j ]  0  u(3) \n      applicable_op_num_target_views_minus1[ i ][ j ]  0  ue(v) \n      for( k = 0; k <= applicable_op_num_target_views_minus1[ i ][ j ]; k++ )     \n        applicable_op_target_view_id[ i ][ j ][ k ]  0  ue(v) \n      applicable_op_num_views_minus1[ i ][ j ]  0  ue(v) \n    }     \n  }     \n  if( profile_idc  = =  134 ) {     \n    mfc_format_idc  0  u(6) \n    if( mfc_format_idc  = =  0  | |  mfc_format_idc  = =  1 ) {     \n      default_grid_position_flag  0  u(1) \n      if( !default_grid_position_flag ) {     \n        view0_grid_position_x  0  u(4) \n        view0_grid_position_y  0  u(4) \n        view1_grid_position_x  0  u(4) \n        view1_grid_position_y  0  u(4) \n      }     \n    }     \n    rpu_filter_enabled_flag  0  u(1) \n    if( !frame_mbs_only_flag )      \n      rpu_field_processing_flag  0  u(1) \n  }     \n}     \n654  Rec. ITU-T H.264 (06/2019) \n \n \nH.7.3.2.2  Picture parameter set RBSP syntax \nThe syntax table is specified in clause 7.3.2.2. \nH.7.3.2.3  Supplemental enhancement information RBSP syntax \nThe syntax table is specified in clause 7.3.2.3. \nH.7.3.2.3.1  Supplemental enhancement information message syntax \nThe syntax table is specified in clause 7.3.2.3.1. \nH.7.3.2.4  Access unit delimiter RBSP syntax \nThe syntax table is specified in clause 7.3.2.4. \nH.7.3.2.5  End of sequence RBSP syntax \nThe syntax table is specified in clause 7.3.2.5. \nH.7.3.2.6  End of stream RBSP syntax \nThe syntax table is specified in clause 7.3.2.6. \nH.7.3.2.7  Filler data RBSP syntax \nThe syntax table is specified in clause 7.3.2.7. \nH.7.3.2.8  Slice layer without partitioning RBSP syntax \nThe syntax table is specified in clause 7.3.2.8. \nH.7.3.2.9  Slice data partition RBSP syntax \nSlice data partition syntax is not present in coded video sequences conforming to one or more of the profiles specified in \nthis annex. \nH.7.3.2.10  RBSP slice trailing bits syntax \nThe syntax table is specified in clause 7.3.2.10. \nH.7.3.2.11  RBSP trailing bits syntax \nThe syntax table is specified in clause 7.3.2.11. \nH.7.3.2.12  Prefix NAL unit RBSP syntax \nThe syntax table is specified in clause 7.3.2.12. \nH.7.3.2.13  Slice layer extension RBSP syntax \nThe syntax table is specified in clause 7.3.2.13. \nH.7.3.3  Slice header syntax \nThe syntax table is specified in clause 7.3.3. \nH.7.3.3.1  Reference picture list modification syntax \nThe syntax table is specified in clause 7.3.3.1. \n    Rec. ITU-T H.264 (06/2019)  655 \n \nH.7.3.3.1.1  Reference picture list MVC modification syntax \n \nref_pic_list_mvc_modification( ) {  C  Descriptor \n  if( slice_type % 5  !=  2  &&  slice_type % 5  !=  4 ) {      \n    ref_pic_list_modification_flag_l0  2  u(1) \n    if( ref_pic_list_modification_flag_l0 )     \n      do {     \n        modification_of_pic_nums_idc  2  ue(v) \n        if( modification_of_pic_nums_idc  = =  0  | |     \n          modification_of_pic_nums_idc  = =  1 ) \n          abs_diff_pic_num_minus1  2  ue(v) \n        else if( modification_of_pic_nums_idc  = =  2 )     \n          long_term_pic_num  2  ue(v) \n        else if( modification_of_pic_nums_idc  = =  4  | |     \n              modification_of_pic_nums_idc  = =  5 ) \n            abs_diff_view_idx_minus1  2  ue(v) \n      } while( modification_of_pic_nums_idc  !=  3 )     \n  }     \n  if( slice_type % 5  = =  1 ) {      \n    ref_pic_list_modification_flag_l1  2  u(1) \n    if( ref_pic_list_modification_flag_l1 )     \n      do {     \n        modification_of_pic_nums_idc  2  ue(v) \n        if( modification_of_pic_nums_idc  = =  0  | |     \n          modification_of_pic_nums_idc  = =  1 ) \n          abs_diff_pic_num_minus1  2  ue(v) \n        else if( modification_of_pic_nums_idc  = =  2 )     \n          long_term_pic_num  2  ue(v) \n        else if( modification_of_pic_nums_idc  = =  4  | |     \n              modification_of_pic_nums_idc  = =  5 ) \n          abs_diff_view_idx_minus1  2  ue(v) \n      } while( modification_of_pic_nums_idc  !=  3 )     \n  }     \n}     \n \nH.7.3.3.2  Prediction weight table syntax \nThe syntax table is specified in clause 7.3.3.2. \nH.7.3.3.3  Decoded reference picture marking syntax \nThe syntax table is specified in clause 7.3.3.3. \nH.7.3.4  Slice data syntax \nThe syntax table is specified in clause 7.3.4. \nH.7.3.5  Macroblock layer syntax \nThe syntax table is specified in clause 7.3.5. \nH.7.3.5.1  Macroblock prediction syntax \nThe syntax table is specified in clause 7.3.5.1. \nH.7.3.5.2  Sub-macroblock prediction syntax \nThe syntax table is specified in clause 7.3.5.2. \n656  Rec. ITU-T H.264 (06/2019) \n \nH.7.3.5.3  Residual data syntax \nThe syntax table is specified in clause 7.3.5.3. \nH.7.3.5.3.1  Residual luma syntax \nThe syntax table is specified in clause 7.3.5.3.1. \nH.7.3.5.3.2  Residual block CAVLC syntax \nThe syntax table is specified in clause 7.3.5.3.2. \nH.7.3.5.3.3  Residual block CABAC syntax \nThe syntax table is specified in clause 7.3.5.3.3. \nH.7.4  Semantics \nSemantics associated with the syntax  structures and syntax elements within these structures (in  clause H.7.3 and in \nclause 7.3 by reference in clause H.7.3) are specified in this clause and by reference to clause 7.4. When the semantics of \na syntax element are specified using a table or a set of tables, any values that are not specified in the table(s) shall not be \npresent in the bitstream unless otherwise specified in this Recommendation | International Standard. \nH.7.4.1  NAL unit semantics \nThe  semantics  for  the  syntax  elements  in  clause H.7.3.1  are  specified  in  clause 7.4.1.  The  following  specifications \nadditionally apply. \nFor NAL units with nal_unit_type equal to 14, nal_ref_idc shall be identical to the value of nal_ref_idc for the associated \nNAL unit, which follows the NAL unit with nal_unit_type equal to 14 in decoding order. \nThe value of nal_ref_idc shall be identical for all VCL NAL units of a view component. \nH.7.4.1.1  NAL unit header MVC extension semantics \nThe syntax elements non_idr_flag, priority_id, view_id, temporal_id, anchor_pic_flag, and inter_view_flag, when present \nin a prefix NAL unit, are considered to apply to the associated NAL unit. \nnon_idr_flag equal to 0 specifies that the current access unit is an IDR access unit. \nThe value of non_idr_flag shall be the same for all VCL NAL units of an access unit. When non_idr_flag is equal to 0 for \na prefix NAL unit, the associated NAL unit shall have nal_unit_type equal to 5. When non_idr_flag is equal to 1 for a \nprefix NAL unit, the associated NAL unit shall have nal_unit_type equal to 1. \nWhen nal_unit_type is equal to 1 and the NAL unit is not immediately preceded by a NAL unit with nal_unit_type equal \nto 14, non_idr_flag shall be inferred to be equal to 1. When nal_unit_type is equal to 5 and the NAL unit is not immediately \npreceded by a NAL unit with nal_unit_type equal to 14, non_idr_flag shall be inferred to be equal to 0. \nWhen nal_ref_idc is equal to 0, the value of non_idr_flag shall be equal to 1. \nFor NAL units in which non_idr_flag is present, the variable IdrPicFlag derived in clause 7.4.1 is modified by setting it \nequal to 1 when non_idr_flag is equal to 0, and setting it equal to 0 when non_idr_flag is equal to 1. \npriority_id specifies a priority identifier for the NAL unit. A lower value of priority_id specifies a higher priority. The \nassignment of values to priority_id is constrained by the sub-bitstream extraction process as specified in clause H.8.5.3. \nWhen nal_unit_type is equal to 1 or 5 and the NAL unit is not immediately preceded by a NAL unit with nal_unit_type \nequal to 14, priority_id shall be inferred to be equal to 0. \nNOTE 1 – The syntax element priority_id is not used by the decoding process specified in this Recommendation | International \nStandard. The syntax element priority_id may be used as determined by the application within the specified constraints. \nview_id specifies a view identifier for the NAL unit. NAL units with the same value of view_id belong to the same view. \nThe assignment of values to view_id is constrained by the sub-bitstream extraction process as specified in clause H.8.5.3. \nWhen nal_unit_type is equal to 1 or 5 and the NAL unit is not immediately preceded by a NAL unit with nal_unit_type \nequal to 14, the value of view_id shall be inferred to be equal to 0. When the bitstream does contain NAL units with \nnal_unit_type equal to 1 or 5 that are not immediately preceded by a NAL unit with nal_unit_type equal to 14, it shall not \ncontain data that result in a value of view_id for a view component of any non-base view that is equal to 0. \nThe variable VOIdx, representing the view order index of the view identified by view_id, is set equal to the value of i for \nwhich the syntax element view_id[ i ] included in the referred subset sequence parameter set is equal to view_id. \ntemporal_id specifies a temporal identifier for the NAL unit. \n    Rec. ITU-T H.264 (06/2019)  657 \n \nWhen nal_unit_type is equal to 1 or 5 and the NAL unit is not immediately preceded by a NAL unit with nal_unit_type \nequal to 14, temporal_id shall be inferred to be equal to the value of temporal_id for the non-base views in the same access \nunit. \nThe value of temporal_id shall be the same for all prefix and coded slice MVC extension NAL units of an access unit. \nWhen an access unit contains any NAL unit with nal_unit_type equal to 5 or non_idr_flag equal to 0, temporal_id shall be \nequal to 0. \nThe assignment of values to temporal_id is further constrained by the sub-bitstream extraction process as specified in \nclause H.8.5.3. \nanchor_pic_flag equal to 1 specifies that the current access unit is an anchor access unit. \nWhen nal_unit_type is equal to 1 or 5 and the NAL unit is not immediately preceded by a NAL unit with nal_unit_type \nequal to 14, anchor_pic_flag shall be inferred to be equal to the value of anchor_pic_flag for the non-base views in the \nsame access unit. \nWhen non_idr_flag is equal to 0, anchor_pic_flag shall be equal to 1. \nWhen nal_ref_idc is equal to 0, the value of anchor_pic_flag shall be equal to 0. \nThe value of anchor_pic_flag shall be the same for all VCL NAL units of an access unit. \ninter_view_flag equal to 0 specifies that the current view component is not used for inter-view prediction by any other \nview component in the current access unit. inter_view_flag equal to 1 specifies that the current view component may be \nused for inter-view prediction by other view components in the current access unit. \nWhen nal_unit_type is equal to 1 or 5 and the NAL unit is not immediately preceded by a NAL unit with nal_unit_type \nequal to 14, inter_view_flag shall be inferred to be equal to 1. \nThe value of inter_view_flag shall be the same for all VCL NAL units of a view component. \nreserved_one_bit shall be equal to 1. The value 0 for reserved_one_bit may be specified by future extension of this \nRecommendation | International Standard. Decoders shall ignore the value of reserved_one_bit. \nH.7.4.1.2  Order of NAL units and association to coded pictures, access units, and video sequences \nThis clause specifies constraints on the order of NAL units in the bitstream. Any order of NAL units in the bitstream \nobeying these constraints is referred to in the text as the decoding order of NAL units. Within a NAL unit, the syntax in \nclauses 7.3, D.1, E.1, H.7.3, H.13.1, and H.14.1 specifies the decoding order of syntax elements. Decoders shall be capable \nof receiving NAL units and their syntax elements in decoding order. \nH.7.4.1.2.1  Order of MVC sequence parameter set RBSPs and picture parameter set RBSPs and their activation \nNOTE 1 – The sequence and picture parameter set mechanism decouples the transmission of infrequently changing information \nfrom the transmission of coded macroblock data. Sequence and picture parameter sets may, in some applications, be conveyed \"out-\nof-band\" using a reliable transport mechanism. \nA picture parameter set RBSP includes parameters that can be referred to by the coded slice NAL units of one or more \nview components of one or more coded pictures. \nEach picture parameter set RBSP is initially considered not active at the start of the operation of the decoding process. At \nmost one picture parameter set RBSP is considered as the active picture parameter set RBSP at any given moment during \nthe operation of the decoding process, and when any particular picture parameter set RBSP becomes the active picture \nparameter set RBSP, the previously-active picture parameter set RBSP (if any) is deactivated. \nIn addition to the active picture parameter set RBSP, zero or more picture parameter set RBSPs may be specifically active \nfor view components (with a particular value of VOIdx less than VOIdxMax) that may be referred to through inter-view \nprediction in decoding the view component with VOIdx equal to VOIdxMax. Such a picture parameter set RBSP is referred \nto as active view picture parameter set RBSP for the particular value of VOIdx. The restrictions on active picture parameter \nset RBSPs also apply to active view picture parameter set RBSPs for a particular value of VOIdx less than VOIdxMax. \nWhen a picture parameter set RBSP (with a particular value of pic_parameter_set_id) is not the active picture parameter \nset  RBSP  and  it  is  referred  to  by  a  coded  slice  NAL  unit  with  VOIdx  equal  to  VOIdxMax  (using  that  value  of \npic_parameter_set_id), it is activated. This picture parameter set RBSP is called the active picture parameter set RBSP \nuntil it is deactivated when another picture parameter set RBSP becomes the active picture parameter set RBSP. A picture \nparameter set RBSP, with that particular value of pic_parameter_set_id, shall be available to the decoding process prior to \nits activation. \nWhen a picture parameter set RBSP (with a particular value of pic_parameter_set_id) is not the active view picture \nparameter set for a particular value of VOIdx less than VOIdxMax and it is referred to by a coded slice NAL unit with the \nparticular value of VOIdx (using that value of pic_parameter_set_id), it is activated for view components with the particular \n658  Rec. ITU-T H.264 (06/2019) \n \nvalue of VOIdx. This picture parameter set RBSP is called the active view picture parameter set RBSP for the particular \nvalue of VOIdx until it is deactivated when another picture parameter set RBSP becomes the active view picture parameter \nset  RBSP  for  the  particular  value  of  VOIdx.  A  picture  parameter  set  RBSP,  with  that  particular  value  of \npic_parameter_set_id, shall be available to the decoding process prior to its activation. \nAny picture parameter set NAL unit containing the value of pic_parameter_set_id for the active picture parameter set \nRBSP for a coded picture shall have the same content as that of the active picture parameter set RBSP for this coded picture \nunless it follows the last VCL NAL unit of this coded picture and precedes the first VCL NAL unit of another coded \npicture. Any picture parameter set NAL unit containing the value of pic_parameter_set_id for the active view picture \nparameter set RBSP for a particular value of VOIdx less than VOIdxMax for a coded picture shall have the same content \nas that of the active view picture parameter set RBSP for the particular value of VOIdx for this coded picture unless it \nfollows the last VCL NAL unit of this coded picture and precedes the first VCL NAL unit of another coded picture. \nWhen a picture parameter set NAL unit with a particular value of pic_parameter_set_id is received, its content replaces \nthe content of the previous picture parameter set NAL unit, in decoding order, with the same value of pic_parameter_set_id \n(when  a  previous  picture  parameter  set  NAL  unit  with  the  same  value  of  pic_parameter_set_id  was  present  in  the \nbitstream). \nNOTE 2 – A decoder must be capable of simultaneously storing the contents of the picture parameter sets for all values of \npic_parameter_set_id. The content of the picture parameter set with a particular value of pic_parameter_set_id is overwritten when \na new picture parameter set NAL unit with the same value of pic_parameter_set_id is received. \nAn MVC sequence parameter set RBSP includes parameters that can be referred to by one or more picture parameter set \nRBSPs or one or more buffering period SEI messages. \nEach MVC sequence parameter set RBSP is initially considered not active at the start of the operation of the decoding \nprocess. At most one MVC sequence parameter set RBSP is considered as the active MVC sequence parameter set RBSP \nat any given moment during the operation of the decoding process, and when any particular MVC sequence parameter set \nRBSP becomes the active MVC sequence parameter set RBSP, the previously-active MVC sequence parameter set RBSP \n(if any) is deactivated. \nIn addition to the active MVC sequence parameter set RBSP, zero or more MVC sequence parameter set RBSPs may be \nspecifically active for view components (with a particular value of VOIdx less than VOIdxMax) that may be referred to \nthrough inter-view prediction in decoding the view component with VOIdx equal to VOIdxMax. Such an MVC sequence \nparameter set RBSP is referred to as the active view MVC sequence parameter set RBSP for the particular value of VOIdx. \nThe restrictions on active MVC sequence parameter set RBSPs also apply to active view MVC sequence parameter set \nRBSPs for a particular value of VOIdx less than VOIdxMax. \nFor the following specification, the activating buffering period SEI message is specified as follows: \n–  If VOIdxMax is equal to VOIdxMin and the access unit contains a buffering period SEI message not included in an \nMVC scalable nesting SEI message, this buffering period SEI message is the activating buffering period SEI message. \n–  Otherwise if VOIdxMax is not equal to VOIdxMin and the access unit contains a buffering period SEI message \nincluded in an MVC scalable nesting SEI message and associated with the operation point being decoded, this \nbuffering period SEI message is the activating buffering period SEI message. \n–  Otherwise, the access unit does not contain an activating buffering period SEI message. \nWhen a sequence parameter set RBSP (nal_unit_type is equal to 7) with a particular value of seq_parameter_set_id is not \nalready the active MVC sequence parameter set RBSP and it is referred to by activation of a picture parameter set RBSP \n(using that value of seq_parameter_set_id) and the picture parameter set RBSP is activated by a coded slice NAL unit with \nnal_unit_type equal to 1 or 5 (the picture parameter set  RBSP becomes  the active picture parameter set  RBSP and \nVOIdxMax is equal to VOIdxMin) and the access unit does not contain an activating buffering period SEI message, it is \nactivated. This sequence parameter set RBSP is called the active MVC sequence parameter set RBSP until it is deactivated \nwhen another MVC sequence parameter set RBSP becomes the active MVC sequence parameter set RBSP. A sequence \nparameter set RBSP, with that particular value of seq_parameter_set_id, shall be available to the decoding process prior to \nits activation. \nWhen a sequence parameter set RBSP (nal_unit_type is equal to 7) with a particular value of seq_parameter_set_id is not \nalready the active MVC sequence parameter set RBSP and it is referred to by an activating buffering period SEI message \n(using that value of seq_parameter_set_id) that is not included in an MVC scalable nesting SEI message and VOIdxMax \nis equal to VOIdxMin, it is activated. This sequence parameter set RBSP is called the active MVC sequence parameter set \nRBSP until it is deactivated when another MVC sequence parameter set RBSP becomes the active MVC sequence \nparameter set RBSP. A sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be available \nto the decoding process prior to its activation. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active MVC sequence parameter set RBSP and it is referred to by activation of a picture parameter set \n    Rec. ITU-T H.264 (06/2019)  659 \n \nRBSP (using that value of seq_parameter_set_id) and the picture parameter set RBSP is activated by a coded slice MVC \nextension NAL unit (nal_unit_type is equal to 20) with VOIdx equal to VOIdxMax (the picture parameter set RBSP \nbecomes the active picture parameter set RBSP) and the access unit does not contain an activating buffering period SEI \nmessage, it is activated. This subset sequence parameter set RBSP is called the active MVC sequence parameter set RBSP \nuntil it is deactivated when another MVC sequence parameter set RBSP becomes the active MVC sequence parameter set \nRBSP. A subset sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be available to the \ndecoding process prior to its activation. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active MVC sequence parameter set RBSP and it is referred to by an activating buffering period SEI \nmessage (using that value of seq_parameter_set_id) that is included in an MVC scalable nesting SEI message, it is \nactivated. This subset sequence parameter set RBSP is called the active MVC sequence parameter set RBSP until it is \ndeactivated when another MVC sequence parameter set RBSP becomes the active MVC sequence parameter set RBSP. A \nsubset sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be available to the decoding \nprocess prior to its activation. \nNOTE 3 – The active MVC sequence parameter set RBSP is either a sequence parameter set RBSP or a subset sequence parameter \nset RBSP. Sequence parameter set RBSPs are activated by coded slice NAL units with nal_unit_type equal to 1 or 5 or buffering \nperiod SEI messages that are not included in an MVC scalable nesting SEI message. Subset sequence parameter sets are activated \nby coded slice MVC extension NAL units (nal_unit_type equal to 20) or buffering period SEI messages that are included in an MVC \nscalable nesting SEI message. A sequence parameter set RBSP and a subset sequence parameter set RBSP may have the same value \nof seq_parameter_set_id. \nFor the following specification, the activating view buffering period SEI message for a particular value of VOIdx is \nspecified as follows: \n–  If the access unit contains one or more than one buffering period SEI message included in an MVC scalable nesting \nSEI message and associated with an operation point for which the greatest VOIdx in the associated bitstream subset \nis equal to the particular value of VOIdx, the first of these buffering period SEI messages, in decoding order, is the \nactivating view buffering period SEI message for the particular value of VOIdx. \n–  Otherwise, if the access unit contains a buffering period SEI message not included in an MVC scalable nesting SEI \nmessage, this buffering period SEI message is the activating view buffering period SEI message for the particular \nvalue of VOIdx equal to VOIdxMin. \n–  Otherwise, the access unit does not contain an activating buffering period SEI message for the particular value of \nVOIdx. \nWhen a sequence parameter set RBSP (nal_unit_type is equal to 7) with a particular value of seq_parameter_set_id is not \nalready the active view MVC sequence parameter set RBSP for VOIdx equal to VOIdxMin and VOIdxMax is greater than \nVOIdxMin and it is referred to by activation of a picture parameter set RBSP (using that value of seq_parameter_set_id) \nand the picture parameter set RBSP is activated by a coded slice NAL unit with nal_unit_type equal to 1 or 5 (the picture \nparameter set RBSP becomes the active view picture parameter set RBSP for VOIdx equal to VOIdxMin), it is activated \nfor view components with VOIdx equal to VOIdxMin. This sequence parameter set RBSP is called the active view MVC \nsequence parameter set RBSP for VOIdx equal to VOIdxMin until it is deactivated when another MVC sequence parameter \nset RBSP becomes the active view MVC sequence parameter set RBSP for VOIdx equal to VOIdxMin or when decoding \nan access unit with VOIdxMax equal to VOIdxMin, whichever is earlier. A sequence parameter set RBSP, with that \nparticular value of seq_parameter_set_id, shall be available to the decoding process prior to its activation. \nWhen a sequence parameter set RBSP (nal_unit_type is equal to 7) with a particular value of seq_parameter_set_id is not \nalready the active view MVC sequence parameter set RBSP for VOIdx equal to VOIdxMin and VOIdxMax is greater than \nVOIdxMin  and  it  is  referred  to  by  an  activating  view  buffering  period  SEI  message  (using  that  value  of \nseq_parameter_set_id) that is not included in an MVC scalable nesting SEI message, the sequence parameter set RBSP is \nactivated for view components with VOIdx equal to VOIdxMin. This sequence parameter set RBSP is called the active \nview MVC sequence parameter set RBSP for VOIdx equal to VOIdxMin until it is deactivated when another MVC \nsequence parameter set RBSP becomes the active view MVC sequence parameter set RBSP for VOIdx equal to VOIdxMin \nor when decoding an access unit with VOIdxMax equal to VOIdxMin. A sequence parameter set RBSP, with that particular \nvalue of seq_parameter_set_id, shall be available to the decoding process prior to its activation. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active view MVC sequence parameter set RBSP for a particular value of VOIdx less than VOIdxMax \nand it is referred to by activation of a picture parameter set RBSP (using that value of seq_parameter_set_id) and the picture \nparameter set RBSP is activated by a coded slice MVC extension NAL unit (nal_unit_type equal to 20) with the particular \nvalue of VOIdx (the picture parameter set RBSP becomes the active view picture parameter set RBSP for the particular \nvalue of VOIdx), it is activated for view components with the particular value of VOIdx. This subset sequence parameter \nset RBSP is called the active view MVC sequence parameter set RBSP for the particular value of VOIdx until it is \ndeactivated when another MVC sequence parameter set RBSP becomes the active view MVC sequence parameter set \nRBSP for the particular value of VOIdx or when decoding an access unit with VOIdxMax less than or equal to the particular \n660  Rec. ITU-T H.264 (06/2019) \n \nvalue of VOIdx. A subset sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be \navailable to the decoding process prior to its activation. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active view MVC sequence parameter set RBSP for a particular value of VOIdx less than VOIdxMax \nand it is referred to by an activating view buffering period SEI message (using that value of seq_parameter_set_id) that is \nincluded in an MVC scalable nesting SEI message and associated with the particular value of VOIdx, this subset sequence \nparameter set RBSP is activated for view components with the particular value of VOIdx. This subset sequence parameter \nset RBSP is called the active view MVC sequence parameter set RBSP for the particular value of VOIdx until it is \ndeactivated when another MVC sequence parameter set RBSP becomes the active view MVC sequence parameter set \nRBSP for the particular value of VOIdx or when decoding an access unit with VOIdxMax less than or equal to the particular \nvalue of VOIdx. A subset sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be \navailable to the decoding process prior to its activation. \nAn MVC sequence parameter set RBSP that includes a value of profile_idc not specified in Annex A or Annex H shall not \nbe referred to by activation of a picture parameter set RBSP as the active picture parameter set RBSP or as active view \npicture parameter set RBSP (using that value of seq_parameter_set_id) or referred to by a buffering period SEI message \n(using that value of seq_parameter_set_id). An MVC sequence parameter set RBSP including a value of profile_idc not \nspecified in Annex A or Annex H is ignored in the decoding for profiles specified in Annex A or Annex H. \nIt is a requirement of bitstream conformance that the following constraints are obeyed: \n–  For each particular value of VOIdx, all coded slice NAL units of a coded video sequence shall refer to the same value \nof seq_parameter_set_id (via the picture parameter set RBSP that is referred to by the value of pic_parameter_set_id). \n–  The value of seq_parameter_set_id in a buffering period SEI message that is not included in an MVC scalable nesting \nSEI message shall be identical to the value of seq_parameter_set_id in the picture parameter set RBSP that is referred \nto by coded slice NAL units (with nal_unit_type equal to 1 or 5) (via the value of pic_parameter_set_id) in the same \naccess unit. \n–  The value of seq_parameter_set_id in a buffering period SEI message that is included in an MVC scalable nesting \nSEI message and is associated with a particular value of VOIdx shall be identical to the value of seq_parameter_set_id \nin the picture parameter set RBSP that is referred to by coded slice NAL units with the particular value of VOIdx (via \nthe value of pic_parameter_set_id) in the same access unit. \nThe active view MVC sequence parameter set RBSPs for different values of VOIdx may be the same MVC sequence \nparameter set RBSP. The active MVC sequence parameter set RBSP and an active view MVC sequence parameter set \nRBSP for a particular value of VOIdx may be the same MVC sequence parameter set RBSP. \nWhen the active MVC sequence parameter set RBSP for a coded picture is a sequence parameter set RBSP, any sequence \nparameter set RBSP in the coded video sequence containing this coded picture and with the value of seq_parameter_set_id \nfor the active MVC sequence parameter set RBSP shall have the same content as that of the active MVC sequence \nparameter set RBSP. \nWhen the active MVC sequence parameter set RBSP for a coded picture is a subset sequence parameter set RBSP, any \nsubset sequence parameter set RBSP in the coded video sequence containing this coded picture and with the value of \nseq_parameter_set_id for the active MVC sequence parameter set RBSP shall have the same content as that of the active \nMVC sequence parameter set RBSP. \nFor each particular value of VOIdx, the following applies: \n–  When the active view MVC sequence parameter set RBSP for a coded picture is a sequence parameter set RBSP, any \nsequence parameter set RBSP in the coded video sequence containing this coded picture and with the value of \nseq_parameter_set_id for the active view MVC sequence parameter set RBSP shall have the same content as that of \nthe active view MVC sequence parameter set RBSP. \n–  When the active view MVC sequence parameter set RBSP for a coded picture is a subset sequence parameter set \nRBSP, any subset sequence parameter set RBSP in the coded video sequence containing this coded picture and with \nthe value of seq_parameter_set_id for the active view MVC sequence parameter set RBSP shall have the same content \nas that of the active view MVC sequence parameter set RBSP. \nNOTE 4 – If picture parameter set RBSPs or MVC sequence parameter set RBSPs are conveyed within the bitstream, these \nconstraints impose an order constraint on the NAL units that contain the picture parameter set RBSPs or MVC sequence parameter \nset RBSPs, respectively. Otherwise (picture parameter set RBSPs or MVC sequence parameter set RBSPs are conveyed by other \nmeans not specified in this Recommendation | International Standard), they must be available to the decoding process in a timely \nfashion such that these constraints are obeyed. \nWhen a sequence parameter set NAL unit with a particular value of seq_parameter_set_id is received, its content replaces \nthe  content  of  the  previous  sequence  parameter  set  NAL  unit,  in  decoding  order,  with  the  same  value  of \nseq_parameter_set_id (when a previous sequence parameter set NAL unit with the same value of seq_parameter_set_id \n    Rec. ITU-T H.264 (06/2019)  661 \n \nwas  present  in  the  bitstream).  When  a  subset  sequence  parameter  set  NAL  unit  with  a  particular  value  of \nseq_parameter_set_id is received, its content replaces the content of the previous subset sequence parameter set NAL unit, \nin decoding order, with the same value of seq_parameter_set_id (when a previous subset sequence parameter set NAL unit \nwith the same value of seq_parameter_set_id was present in the bitstream). \nNOTE 5 – A decoder must be capable of simultaneously storing the contents of the sequence parameter sets and subset sequence \nparameter sets for all values of seq_parameter_set_id. The content of the sequence parameter set with a particular value of \nseq_parameter_set_id is overwritten when a new sequence parameter set NAL unit with the same value of seq_parameter_set_id is \nreceived, and the content of the subset sequence parameter set with a particular value of seq_parameter_set_id is overwritten when \na new subset sequence parameter set NAL unit with the same value of seq_parameter_set_id is received. \nWhen present, a sequence parameter set extension RBSP includes parameters having a similar function to those of a \nsequence parameter set RBSP. For purposes of establishing constraints on the syntax elements of the sequence parameter \nset extension RBSP and for purposes of determining activation of a sequence parameter set extension RBSP, the sequence \nparameter set extension RBSP shall be considered part of the preceding sequence parameter set RBSP with the same value \nof seq_parameter_set_id. When a sequence parameter set RBSP is present that is not followed by a sequence parameter \nset extension RBSP with the same value of seq_parameter_set_id prior to the activation of the sequence parameter set \nRBSP, the sequence parameter set extension RBSP and its syntax elements shall be considered not present for the active \nMVC sequence parameter set RBSP. The contents of sequence parameter set extension RBSPs only apply when the base \nview, which conforms to one or more of the profiles specified in Annex A, of a coded video sequence conforming to one \nor more profiles specified in Annex H is decoded. Subset sequence parameter set RBSPs shall not be followed by a \nsequence parameter set extension RBSP. \nNOTE 6 – Sequence parameter sets extension RBSPs are not considered to be part of a subset sequence parameter set RBSP and \nsubset sequence parameter set RBSPs must not be followed by a sequence parameter set extension RBSP. \nFor view components with VOIdx equal to VOIdxMax, all constraints that are expressed on the relationship between the \nvalues of the syntax elements (and the values of variables derived from those syntax elements) in MVC sequence parameter \nsets and picture parameter sets and other syntax elements are expressions of constraints that apply only to the active MVC \nsequence parameter set and the active picture parameter set. For view components with a particular value of VOIdx less \nthan VOIdxMax, all constraints that are expressed on the relationship between the values of the syntax elements (and the \nvalues of variables derived from those syntax elements) in MVC sequence parameter sets and picture parameter sets and \nother syntax elements are expressions of constraints that apply only to the active view MVC sequence parameter set and \nthe active view picture parameter set for the particular value of VOIdx. If any MVC sequence parameter set RBSP having \nprofile_idc equal to the value of one of the profile_idc values specified in Annex A or Annex H is present that is never \nactivated in the bitstream (i.e., it never becomes the active MVC sequence parameter set or an active view MVC sequence \nparameter set), its syntax elements shall have values that would conform to the specified constraints if it were activated by \nreference in an otherwise-conforming bitstream. If any picture parameter set RBSP is present that is never activated in the \nbitstream (i.e., it never becomes the active picture parameter set or an active view picture parameter set), its syntax elements \nshall have values that would conform to the specified constraints if it were activated by reference in an otherwise-\nconforming bitstream. \nDuring operation of the decoding process (see clause H.8), for view components with VOIdx equal to VOIdxMax, the \nvalues of parameters of the active picture parameter set and the active MVC sequence parameter set shall be considered in \neffect. For view components with a particular value of VOIdx less than VOIdxMax, the values of the parameters of the \nactive view picture parameter set and the active view MVC sequence parameter set for the particular value of VOIdx shall \nbe considered in effect. For interpretation of SEI messages that apply to the entire access unit or the view component with \nVOIdx equal to VOIdxMax, the values of the parameters of the active picture parameter set and the active MVC sequence \nparameter set for the same access unit shall be considered in effect unless otherwise specified in the SEI message semantics. \nFor interpretation of SEI messages that apply to view components with a particular value of VOIdx less than VOIdxMax, \nthe values of the parameters of the active view picture parameter set and the active view MVC sequence parameter set for \nthe particular value of VOIdx for the same access unit shall be considered in effect unless otherwise specified in the SEI \nmessage semantics. \nH.7.4.1.2.2  Order of access units and association to coded video sequences \nThe specification of clause 7.4.1.2.2 applies with the following modifications. \nThe first access unit of the bitstream shall only contain coded slice NAL units with nal_unit_type equal to 5 or non_idr_flag \nequal to 0. \nThe order of NAL units and coded pictures and their association to access units is described in clause H.7.4.1.2.3. \nH.7.4.1.2.3  Order of NAL units and coded pictures and association to access units \nThe specification of clause 7.4.1.2.3 applies with the following modifications. \nNOTE – Some bitstreams that conform to one or more profiles specified in this annex do not conform to any profile specified in \nAnnex A  (prior  to  operation  of  the  base  view  extraction  process  specified  in  clause H.8.5.4).  As  specified  in  clauses 7.4.1 \nand 7.4.1.2.3, for the profiles specified in Annex A, NAL units with nal_unit_type equal to 20 are classified as non-VCL NAL units \n662  Rec. ITU-T H.264 (06/2019) \n \nthat must be preceded within each access unit by at least one NAL unit with nal_unit_type in the range of 1 to 5, inclusive. For this \nreason, any bitstream that conforms to one or more profiles specified in this annex does not conform to any profile specified in \nAnnex A when it contains any of the following: \n–  any access unit that does not contain any NAL units with nal_unit_type equal to 1 or 5, but contains one or more NAL units \nwith nal_unit_type equal to 6, 7, 8, 9, or 15; \n–  any access unit in which one or more NAL units with nal_unit_type equal to 7, 8, or 15 is present after the last NAL unit in the \naccess unit with nal_unit_type equal to 1 or 5. \nThe association of VCL NAL units to primary or redundant coded pictures is specified in clause H.7.4.1.2.5. \nThe constraints for the detection of the first VCL NAL unit of a primary coded picture are specified in clause H.7.4.1.2.4. \nThe constraint expressed in clause 7.4.1.2.3 on the order of a buffering period SEI message is replaced by the following \nconstraints. \n–  When an SEI NAL unit containing a buffering period SEI message is present, the following applies: \n–  If the buffering period SEI message is the only buffering period SEI message in the access unit and it is not \nincluded in an MVC scalable nesting SEI message, the buffering period SEI message shall be the first SEI \nmessage payload of the first SEI NAL unit in the access unit. \n–  Otherwise (the buffering period SEI message is not the only buffering period SEI message in the access unit or \nit is included in an MVC scalable nesting SEI message), the following constraints are specified: \n–  When a buffering period SEI message that is not included in an MVC scalable nesting SEI message is \npresent, this buffering period SEI message shall be the only SEI message payload of the first SEI NAL unit \nin the access unit. \n–  An MVC scalable nesting SEI message that includes a buffering period SEI message shall not include any \nother SEI messages and shall be the only SEI message inside the SEI NAL unit. \n–  All SEI NAL units that precede an SEI NAL unit that contains an MVC scalable nesting SEI message with \na buffering period SEI message as payload in an access unit shall only contain buffering period SEI \nmessages or MVC scalable nesting SEI messages with a buffering period SEI message as payload. \nEach prefix NAL unit shall be immediately followed by a NAL unit with nal_unit_type equal to 1 or 5. \nH.7.4.1.2.4  Detection of the first VCL NAL unit of a primary coded picture \nThis clause specifies constraints on VCL NAL unit syntax that are sufficient to enable the detection of the first VCL NAL \nunit of each primary coded picture. \nThe first VCL NAL unit of the primary coded picture of the current access unit, in decoding order, shall be different from \nthe last VCL NAL unit of the primary coded picture of the previous access unit, in decoding order, in one or more of the \nfollowing ways: \n–  view_id of the first VCL NAL unit of the primary coded picture of the current access unit is different from view_id \nof the last VCL NAL unit of the primary coded picture of the previous access unit, and VOIdx of the first VCL NAL \nunit of the primary coded picture of the current access unit is less than VOIdx of the last VCL NAL unit of the primary \ncoded picture of the previous access unit. \n–  view_id of the first VCL NAL unit of the primary coded picture of the current access unit is equal to view_id of the \nlast VCL NAL unit of the primary coded picture of the previous access unit, and any of the conditions specified in \nclause 7.4.1.2.4 is fulfilled. \nH.7.4.1.2.5  Order of VCL NAL units and association to coded pictures \nEach VCL NAL unit is part of a coded picture. \nLet voIdx be the value of VOIdx of any particular VCL NAL unit. The order of the VCL NAL units within a coded picture \nis constrained as follows: \n–  For all VCL NAL units following this particular VCL NAL unit, the value of VOIdx shall be greater than or equal \nto voIdx. \nFor each set of VCL NAL units within a view component, the following applies: \n–  If arbitrary slice order, as specified in Annex A or clause H.10, is allowed, coded slice NAL units of a view component \nmay have any order relative to each other. \n–  Otherwise (arbitrary slice order is not allowed), coded slice NAL units of a slice group shall not be interleaved with \ncoded slice NAL units of another slice group and the order of coded slice NAL units within a slice group shall be in \n    Rec. ITU-T H.264 (06/2019)  663 \n \nthe order of increasing macroblock address for the first macroblock of each coded slice NAL unit of the same slice \ngroup. \nNAL units having nal_unit_type equal to 12 may be present in the access unit but shall not precede the first VCL NAL \nunit of the primary coded picture within the access unit. \nNAL units having nal_unit_type equal to 0 or in the range of 24 to 31, inclusive, which are unspecified, may be present in \nthe access unit but shall not precede the first VCL NAL unit of the primary coded picture within the access unit. \nNAL units having nal_unit_type in the range of 21 to 23, inclusive, which are reserved, shall not precede the first VCL \nNAL unit of the primary coded picture within the access unit (when specified in the future by ITU-T | ISO/IEC). \nH.7.4.2  Raw byte sequence payloads and RBSP trailing bits semantics \nH.7.4.2.1  Sequence parameter set RBSP semantics \nThe semantics specified in clause 7.4.2.1 apply. \nH.7.4.2.1.1  Sequence parameter set data semantics \nFor all syntax elements other than  max_num_ref_frames, the semantics  specified in  clause 7.4.2.1.1 apply  with the \nsubstitution of MVC sequence parameter set for sequence parameter set. All constraints specified in clause 7.4.2.1.1 apply \nonly to the view components for which the MVC sequence parameter set is the active MVC sequence parameter set or the \nactive view MVC sequence parameter set as specified in clause H.7.4.1.2.1. \nFor each coded video sequence, the active MVC sequence parameter set and all active view MVC sequence parameter sets \n(if  any)  shall  have  the  same  values  of  pic_width_in_mbs_minus1,  pic_height_in_map_units_minus1,  and \nframe_mbs_only_flag. \nWhen  the  seq_parameter_set_data( )  syntax  structure  is  present  in  a  subset  sequence  parameter  set  RBSP  and \nvui_parameters_present_flag is equal to 1, timing_info_present_flag shall be equal to 0, nal_hrd_parameters_present_flag \nshall be equal to 0, vcl_hrd_parameters_present_flag shall be equal to 0, and pic_struct_present_flag shall be equal to 0. \nThe value of 1 for timing_info_present_flag, nal_hrd_parameters_present_flag, vcl_hrd_parameters_present_flag, and \npic_struct_present_flag for subset sequence parameter set RBSPs is reserved for future use by ITU-T | ISO/IEC. When \ntiming_info_present_flag is equal to 1, decoders shall ignore the values of the directly following num_units_in_tick, \ntime_scale, fixed_frame_rate_flag syntax elements. When nal_hrd_parameters_present_flag is equal to 1, decoders shall \nignore  the  value  of  the  syntax  elements  in  the  directly  following  hrd_parameters( )  syntax  structure.  When \nvcl_hrd_parameters_present_flag is equal to 1, decoders shall ignore the value of the syntax elements in the directly \nfollowing hrd_parameters( ) syntax structure. \nIf  max_num_ref_frames  is  included  in  a  sequence  parameter  set,  the  semantics  specified  in  clause 7.4.2.1.1  apply. \nOtherwise (max_num_ref_frames is included in a subset sequence parameter set), the following is specified: \nmax_num_ref_frames specifies the maximum number of short-term and long-term reference frames, complementary \nreference field pairs, and non-paired reference fields that may be used by the decoding process for inter prediction of any \nview component in the coded video sequence. max_num_ref_frames also determines the sliding window size of the sliding \nwindow operation as specified in  clause H.8.3. The value of max_num_ref_frames shall be in the range of 0 to 16, \ninclusive. \nH.7.4.2.1.1.1 Scaling list semantics \nThe semantics specified in clause 7.4.2.1.1.1 apply. \nH.7.4.2.1.2  Sequence parameter set extension RBSP semantics \nThe semantics specified in clause 7.4.2.1.2 apply. Additionally, the following applies. \nSequence parameter set extension RBSPs can only follow sequence parameter set RBSPs in decoding order. Subset \nsequence parameter set RBSPs shall not be followed by a sequence parameter set extension RBSP. The contents of \nsequence parameter set extension RBSPs only apply when the base view, which conforms to one or more of the profiles \nspecified in Annex A, of a coded video sequence conforming to one or more profiles specified in Annex H is decoded. \nH.7.4.2.1.3  Subset sequence parameter set RBSP semantics \nThe semantics specified in clause 7.4.2.1.3 apply. \nH.7.4.2.1.4  Sequence parameter set MVC extension semantics \nThe sequence parameter set MVC extension specifies inter-view dependency relationships for the coded video sequence. \nThe sequence parameter set MVC extension also specifies level values for a subset of the operation points for the coded \nvideo sequence. All sequence parameter set MVC extensions that are referred to by a coded video sequence shall be \nidentical. \n664  Rec. ITU-T H.264 (06/2019) \n \nSome views identified by view_id[ i ] may not be present in the coded video sequence. \nNOTE 1 – Some views or temporal subsets described by the sequence parameter set MVC extension may have been removed from \nthe original coded video sequence, hence may not be present in the coded video sequence. However, the information in the sequence \nparameter set MVC extension always applies to the remaining views and temporal subsets. \nnum_views_minus1 plus 1 specifies the maximum number of coded views in the coded video sequence. The value of \nnum_view_minus1 shall be in the range of 0 to 1023, inclusive. \nNOTE 2 – The actual number of views in the coded video sequence may be less than num_views_minus1 plus 1. \nview_id[ i ] specifies the view_id of the view with VOIdx equal to i. The value of view_id[ i ] shall be in the range of 0 to \n1023, inclusive. \nnum_anchor_refs_l0[ i ] specifies the number of view components for inter-view prediction in the initial reference picture \nlist RefPicList0 (which is derived as specified in clause H.8.2.1) in decoding anchor view components with VOIdx equal \nto i.  The  value  of  num_anchor_refs_l0[ i ]  shall  not  be  greater  than  Min( 15,  num_views_minus1 ).  The  value  of \nnum_anchor_refs_l0[ 0 ] shall be equal to 0. \nanchor_ref_l0[ i ][ j ] specifies the view_id of the j-th view component for inter-view prediction in the initial reference \npicture list RefPicList0 (which is derived as specified in clause H.8.2.1) in decoding anchor view components with VOIdx \nequal to i. The value of anchor_ref_l0[ i ][ j ] shall be in the range of 0 to 1023, inclusive. \nnum_anchor_refs_l1[ i ] specifies the number of view components for inter-view prediction in the initial reference picture \nlist RefPicList1 (which is derived as specified in clause H.8.2.1) in decoding anchor view components with VOIdx equal \nto i.  The  value  of  num_anchor_refs_l1[ i ]  shall  not  be  greater  than  Min( 15,  num_views_minus1 ).  The  value  of \nnum_anchor_refs_l1[ 0 ] shall be equal to 0. \nanchor_ref_l1[ i ][ j ] specifies the view_id of the j-th view component for inter-view prediction in the initial reference \npicture list RefPicList1 (which is derived as specified in clause H.8.2.1) in decoding an anchor view component with \nVOIdx equal to i. The value of anchor_ref_l1[ i ][ j ] shall be in the range of 0 to 1023, inclusive. \nnum_non_anchor_refs_l0[ i ] specifies the number of view components for inter-view prediction in the initial reference \npicture list RefPicList0 (which is derived as specified in clause H.8.2.1) in decoding non-anchor view components with \nVOIdx equal to i. The value of num_non_anchor_refs_l0[ i ] shall not be greater than Min( 15, num_views_minus1 ). The \nvalue of num_non_anchor_refs_l0[ 0 ] shall be equal to 0. \nnon_anchor_ref_l0[ i ][ j ] specifies the  view_id of the j-th view component  for inter-view prediction in  the initial \nreference  picture  list  RefPicList0  (which  is  derived  as  specified  in  clause H.8.2.1)  in  decoding  non-anchor  view \ncomponents with VOIdx equal to i. The value of non_anchor_ref_l0[ i ][ j ] shall be in the range of 0 to 1023, inclusive. \nnum_non_anchor_refs_l1[ i ] specifies the number of view components for inter-view prediction in the initial reference \npicture list RefPicList1 (which is derived as specified in clause H.8.2.1) in decoding non-anchor view components with \nVOIdx equal to i. The value of num_non_anchor_refs_l1[ i ] shall not be greater than Min( 15, num_views_minus1 ). The \nvalue of num_non_anchor_refs_l1[ 0 ] shall be equal to 0. \nnon_anchor_ref_l1[ i ][ j ] specifies the  view_id of the j-th view component  for inter-view prediction in  the initial \nreference  picture  list  RefPicList1  (which  is  derived  as  specified  in  clause H.8.2.1)  in  decoding  non-anchor  view \ncomponents with VOIdx equal to i. The value of non_anchor_ref_l1[ i ][ j ] shall be in the range of 0 to 1023, inclusive. \nFor any particular view with view_id equal to vId1 and VOIdx equal to vOIdx1 and another view with view_id equal to \nvId2 and VOIdx equal to vOIdx2, when vId2 is equal to the value of one of non_anchor_ref_l0[ vOIdx1 ][ j ] for all j in \nthe range of 0 to num_non_anchor_refs_l0[ vOIdx1 ], exclusive, or one of non_anchor_ref_l1[ vOIdx1 ][ j ] for all j in the \nrange  of 0  to  num_non_anchor_refs_l1[ vOIdx1 ],  exclusive,  vId2  shall  also  be  equal  to  the  value  of  one  of \nanchor_ref_l0[ vOIdx1 ][ j ]  for  all  j  in  the  range  of 0  to  num_anchor_refs_l0[ vOIdx1 ],  exclusive,  or  one  of \nanchor_ref_l1[ vOIdx1 ][ j ] for all j in the range of 0 to num_anchor_refs_l1[ vOIdx1 ], exclusive. \nNOTE 3 – The inter-view dependency for non-anchor view components is a subset of that for anchor view components. \nnum_level_values_signalled_minus1 plus 1 specifies the number of level values signalled for the coded video sequence. \nThe value of num_level_values_signalled_minus1 shall be in the range of 0 to 63, inclusive. \nlevel_idc[ i ] specifies the i-th level value signalled for the coded video sequence. \nnum_applicable_ops_minus1[ i ]  plus  1  specifies  the  number  of  operation  points  to  which  the  level  indicated  by \nlevel_idc[ i ] applies. The value of num_applicable_ops_minus1[ i ] shall be in the range of 0 to 1023, inclusive. \napplicable_op_temporal_id[ i ][ j ] specifies the temporal_id of the j-th operation point to which the level indicated by \nlevel_idc[ i ] applies. \napplicable_op_num_target_views_minus1[ i ][ j ]  plus  1  specifies  the  number  of  target  output  views  for  the  j-th \noperation  point  to  which  the  level  indicated  by  level_idc[ i ]  applies.  The  value  of \n    Rec. ITU-T H.264 (06/2019)  665 \n \napplicable_op_num_target_views_minus1[ i ][ j ] shall be in the range of 0 to 1023, inclusive. \napplicable_op_target_view_id[ i ][ j ][ k ] specifies the k-th target output view for the j-th operation point to which the \nlevel indicated by level_idc[ i ] applies. The value of applicable_op_target_view_id[ i ][ j ][ k ] shall be in the range of 0 \nto 1023, inclusive. \nLet maxTId be the greatest temporal_id of all NAL units in the coded video sequence, and vId be view_id of any view in \nthe  coded  video  sequence.  There  shall  be  one  set  of  applicable_op_temporal_id[ i ][ j ], \napplicable_op_num_target_views_minus1[ i ][ j ], and applicable_op_target_view_id[ i ][ j ][ k ], for any i and j and all k \nfor  the  i  and  j,  in  which  applicable_op_temporal_id[ i ][ j ]  is  equal  to  maxTId, \napplicable_op_num_target_views_minus1[ i ][ j ] is equal to 0, and applicable_op_target_view_id[ i ][ j ][ k ] is equal to \nvId. \nNOTE 4 – The above constraint ensures that the level that applies to each operation point consisting of only one target output view \nwith the greatest highest temporal_id in the coded video sequence is signalled by one of the level_idc[ i ] for all i. \nNOTE 5 – Some  operation  points  identified  by  applicable_op_temporal_id[ i ][ j ], \napplicable_op_num_target_views_minus1[ i ][ j ], and applicable_op_target_view_id[ i ][ j ][ k ], for all i, j, and k, may not be \npresent in the coded video sequence. \napplicable_op_num_views_minus1[ i ][ j ] plus 1 specifies the number of views required for decoding the target output \nviews corresponding to the j-th operation point to which the level indicated by level_idc[ i ] applies. The number of views \nspecified by applicable_op_num_views_minus1 includes the target output views and the views that the target output views \ndepend  on  as  specified  by  the  sub-bitstream  extraction  process  in  clause H.8.5  with  tIdTarget  equal  to \napplicable_op_temporal_id[ i ][ j ] and viewIdTargetList equal to the list of applicable_op_target_view_id[ i ][ j ][ k ] for \nall  k  in  the  range  of 0  to  applicable_op_num_target_views_minus1[ i ][ j ],  inclusive,  as  inputs.  The  value  of \napplicable_op_num_views_minus1[ i ][ j ] shall be in the range of 0 to 1023, inclusive. \nmfc_format_idc  specifies  the  frame  packing  arrangement  type  for  view  components  of  the  base  view  and  the \ncorresponding  frame  packing  arrangement  type  for  view  components  in  the  non-base  view.  The  semantics  of \nmfc_format_idc equal to 0 and 1 are specified by Table H-1. \nIn bitstreams conforming to this version of this Specification, the value of mfc_format_idc shall be equal to 0 or 1. Values \nof mfc_format_idc in the range of 2..63 are reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore the coded \nvideo sequence when the value of mfc_format_idc is greater than 1. \nTable H-1 – Association between frame packing arrangement type and syntax elements \nConstraints on the frame packing arrangement  Corresponding  frame  packing  arrangement \nmfc_format_idc  SEI message syntax for view components of the  type inferred for view components of the non-\nbase view  base view \nframe_packing_arrangement_type shall be equal to  frame_packing_arrangement_type equal to 4 (top-\n0 \n3 (side-by-side)  bottom) \nframe_packing_arrangement_type shall be equal to  frame_packing_arrangement_type  equal  to  3 \n1 \n4 (top-bottom)  (side-by-side) \n \ndefault_grid_position_flag equal to 0 specifies that the syntax elements view0_grid_position_x, view0_grid_position_y, \nview1_grid_position_x,  and  view1_grid_position_y  are  present.  default_grid_position_flag  equal  to  1  specifies  that \nview0_grid_position_x, view0_grid_position_y, view1_grid_position_x, and view1_grid_position_y are not present. \nview0_grid_position_x has the same semantics as specified in clause D.2.26 for the frame0_grid_position_x syntax \nelement. The value of view0_grid_position_x shall be equal to 4, 8 or 12. \nview0_grid_position_y has the same semantics as specified in clause D.2.26 for the frame0_grid_position_y syntax \nelement. The value of view0_grid_position_y shall be equal to 4, 8 or 12. \nview1_grid_position_x has the same semantics as specified in clause D.2.26 for the frame1_grid_position_x syntax \nelement. The value of view1_grid_position_x shall be equal to 4, 8 or 12. \nview1_grid_position_y has the same semantics as specified in clause D.2.26 for the frame1_grid_position_y syntax \nelement. The value of view1_grid_position_y shall be equal to 4, 8 or 12. \nWhen  default_grid_position_flag  is  equal  to  1,  the  values  of  view0_grid_position_x,  view0_grid_position_y, \nview1_grid_position_x, and view1_grid_position_y are inferred as follows: \n–  If mfc_format_idc is equal to 0, the following applies: \n–  view0_grid_position_x is inferred to be equal to 4. \n–  view0_grid_position_y is inferred to be equal to 8. \n–  view1_grid_position_x is inferred to be equal to 12. \n666  Rec. ITU-T H.264 (06/2019) \n \n–  view1_grid_position_y is inferred to be equal to 8. \n–  Otherwise (mfc_format_idc is equal to 1), the following applies: \n–  view0_grid_position_x is inferred to be equal to 8. \n–  view0_grid_position_y is inferred to be equal to 4. \n–  view1_grid_position_x is inferred to be equal to 8. \n–  view1_grid_position_y is inferred to be equal to 12. \nWhen mfc_format_idc is present, the following applies: \n–  It is a requirement of bitstream conformance that each coded view component of the base view shall be associated \nwith a frame packing arrangement SEI message for which all of the following constraints apply: \n–  frame_packing_arrangement_type is equal to the value specified by Table H-1for view components of the base \nview. \n–  quincunx_sampling_flag is equal to 0. \n–  content_interpretation_type is equal to 1. \n–  spatial_flipping_flag is equal to 0. \n–  frame0_grid_position_x,  frame0_grid_position_y,  frame1_grid_position_x,  and  frame1_grid_position_y  are \nequal to view0_grid_position_x, view0_grid_position_y, view1_grid_position_x, and view1_grid_position_y, \nrespectively. \n–  It is a requirement of bitstream conformance that no frame packing arrangement SEI message shall be associated with \nany view component of a non-base view. For each view component of a non-base view, a frame packing arrangement \nis inferred as follows: \n–  frame_packing_arrangement_type is equal to the value specified by Table H-1for the view components of the \nnon-base view. \n–  quincunx_sampling_flag is equal to 0. \n–  content_interpretation_type is equal to 1. \n–  spatial_flipping_flag is equal to 0. \nNOTE 6 – These constraints also apply to cases where a coded view component would be associated with a frame packing \narrangement SEI message that is present in an access unit that is earlier in decoding order than the access unit containing the coded \nview component. \nrpu_filter_enabled_flag equal to 1 specifies that a downsampling filter process and an upsampling filter process are used \nto generate each colour component of an inter-view prediction reference. rpu_filter_enabled_flag equal to 0 specifies that \nall sample values for each colour component of an inter-view prediction reference are set equal to 128. \nrpu_field_processing_flag equal to 0 specifies that each inter-view prediction reference with field_pic_flag equal to 0 is \nprocessed as a frame when processed by the RPU. rpu_field_processing_flag equal to 1 specifies that each inter-view \nprediction reference with field_pic_flag equal to 0 is processed as two fields when processed by the RPU. When not \npresent, the value of rpu_field_processing_flag is inferred to be equal to 0. \nH.7.4.2.2  Picture parameter set RBSP semantics \nThe semantics specified in clause 7.4.2.2 apply with substituting MVC sequence parameter set for sequence parameter set. \nAll constraints specified in clause 7.4.2.2 apply only to the view components for which the picture parameter set is the \nactive picture parameter set or the active view picture parameter set as specified in clause H.7.4.1.2.1. \nweighted_bipred_idc has the same semantics as specified in clause 7.4.2.2 with the following modification. \nWhen there is at least one inter-view prediction reference, which belongs to the same access unit as the current view \ncomponent, in RefPicList0 or RefPicList1, weighted_bipred_idc shall not be equal to 2. \nH.7.4.2.3  Supplemental enhancement information RBSP semantics \nThe semantics specified in clause 7.4.2.3 apply. \nH.7.4.2.3.1  Supplemental enhancement information message semantics \nThe semantics specified in clause 7.4.2.3.1 apply. \nH.7.4.2.4  Access unit delimiter RBSP semantics \nThe semantics specified in clause 7.4.2.4 apply. \n    Rec. ITU-T H.264 (06/2019)  667 \n \nNOTE – The value of primary_pic_type applies to the slice_type values in all slice headers of the primary coded picture, including \nthe slice_type syntax elements in all NAL units with nal_unit_type equal to 1, 5, or 20. NAL units with nal_unit_type equal to 2 are \nnot present in bitstreams conforming to any of the profiles specified in this annex. \nH.7.4.2.5  End of sequence RBSP semantics \nThe semantics specified in clause 7.4.2.5 apply. \nH.7.4.2.6  End of stream RBSP semantics \nThe semantics specified in clause 7.4.2.6 apply. \nH.7.4.2.7  Filler data RBSP semantics \nThe semantics specified in clause 7.4.2.7 apply with the following addition. \nFiller data NAL units shall be considered to contain the syntax elements priority_id, view_id, and temporal_id with values \nthat are inferred as follows: \n1.  Let prevMvcNalUnit be the most recent NAL unit in decoding order that has nal_unit_type equal to 14 or 20. \nNOTE – The most recent NAL unit in decoding order with nal_unit_type equal to 14 or 20 always belongs to the same access \nunit as the filler data NAL unit. \n2.  The values of priority_id, view_id, and temporal_id for the filler data NAL unit are inferred to be equal to the \nvalues of priority_id, view_id, and temporal_id, respectively, of the NAL unit prevMvcNalUnit. \nH.7.4.2.8  Slice layer without partitioning RBSP semantics \nThe semantics specified in clause 7.4.2.8 apply. \nH.7.4.2.9  Slice data partition RBSP semantics \nSlice data partition syntax is not present in bitstreams conforming to one or more of the profiles specified in Annex H. \nH.7.4.2.10  RBSP slice trailing bits semantics \nThe semantics specified in clause 7.4.2.10 apply with the following modifications. \nLet NumBytesInVclNALunits be the sum of the values of NumBytesInNALunit for all VCL NAL units of a  view \ncomponent and let BinCountsInNALunits be the number of times that the parsing process function DecodeBin( ), specified \nin  clause 9.3.3.2,  is  invoked  to  decode  the  contents  of  all  VCL  NAL  units  of  the  view  component.  When \nentropy_coding_mode_flag is equal to 1, it is a requirement of bitstream conformance that BinCountsInNALunits shall \nnot exceed ( 32 ÷ 3 ) * NumBytesInVclNALunits + ( RawMbBits * PicSizeInMbs ) ÷ 32. \nNOTE – The constraint on the maximum number of bins resulting from decoding the contents of the slice layer NAL units of a view \ncomponent  can  be  met  by  inserting  a  number  of  cabac_zero_word  syntax  elements  to  increase  the  value  of \nNumBytesInVclNALunits. Each cabac_zero_word is represented in a NAL unit by the three-byte sequence 0x000003 (as a result of \nthe  constraints  on  NAL  unit  contents  that  result  in  requiring  inclusion  of  an  emulation_prevention_three_byte  for  each \ncabac_zero_word). \nH.7.4.2.11  RBSP trailing bits semantics \nThe semantics specified in clause 7.4.2.11 apply. \nH.7.4.2.12  Prefix NAL unit RBSP semantics \nThe semantics specified in clause 7.4.2.12 apply. \nH.7.4.2.13  Slice layer extension RBSP semantics \nThe semantics specified in clause 7.4.2.13 apply. \nH.7.4.3  Slice header semantics \nThe semantics specified in clause 7.4.3 apply with the following modifications. \nAll constraints specified in clause 7.4.3 apply only to the view components with the same value of VOIdx. \nThe value of the following MVC sequence parameter set syntax elements shall be the same across all coded slice NAL \nunits of an access unit: chroma_format_idc. \nThe value of the following slice header syntax elements shall be the same across all coded slice NAL units of an access \nunit: field_pic_flag and bottom_field_flag. \nframe_num is used as an identifier for view components and is represented by log2_max_frame_num_minus4 + 4 bits in \nthe bitstream. \n668  Rec. ITU-T H.264 (06/2019) \n \nframe_num is constrained as specified in clause 7.4.3 where this constraint applies to view components with view_id equal \nto the current value of view_id. \ndirect_spatial_mv_pred_flag has the same semantics as specified in clause 7.4.3 with the following modification. \nWhen RefPicList1[ 0 ] is an inter-view reference component or an inter-view only reference component, which belongs to \nthe same access unit as the current view component, direct_spatial_mv_pred_flag shall be equal to 1. \nnum_ref_idx_l0_active_minus1 has the same semantics as specified in clause 7.4.3 with the following modification. \nThe range of num_ref_idx_l0_active_minus1 is specified as follows: \n–  If num_views_minus1 is equal to 1, the following applies: \n–  If field_pic_flag is equal to 0, num_ref_idx_l0_active_minus1 shall be in the range of 0 to 7, inclusive. When \nMbaffFrameFlag is equal to 1, num_ref_idx_l0_active_minus1 is the maximum index value for the decoding of \nframe macroblocks and 2 * num_ref_idx_l0_active_minus1 + 1 is the maximum index value for the decoding of \nfield macroblocks. \n–  Otherwise (field_pic_flag is equal to 1), num_ref_idx_l0_active_minus1 shall be in the range of 0 to 15, inclusive. \n–  Otherwise (num_views_minus1 is greater than 1), the following applies: \n–  If field_pic_flag is equal to 0, num_ref_idx_l0_active_minus1 shall be in the range of 0 to 15, inclusive. When \nMbaffFrameFlag is equal to 1, num_ref_idx_l0_active_minus1 is the maximum index value for the decoding of \nframe macroblocks and 2 * num_ref_idx_l0_active_minus1 + 1 is the maximum index value for the decoding of \nfield macroblocks. \n–  Otherwise (field_pic_flag is equal to 1), num_ref_idx_l0_active_minus1 shall be in the range of 0 to 31, inclusive. \nnum_ref_idx_l1_active_minus1 has the same semantics as specified in clause 7.4.3 with the following modification. \nThe  range  of  num_ref_idx_l1_active_minus1  is  constrained  as  specified  in  the  semantics  for \nnum_ref_idx_l0_active_minus1 in this clause with l0 and list 0 replaced by l1 and list 1, respectively. \nH.7.4.3.1  Reference picture list modification semantics \nThe semantics specified in clause 7.4.3.1 apply with the following modifications. \nref_pic_list_modification_flag_l0 equal to 1 specifies that the syntax element modification_of_pic_nums_idc is present \nfor specifying reference picture list 0. ref_pic_list_modification_flag_l0 equal to 0 specifies that this syntax element is not \npresent. \nWhen ref_pic_list_modification_flag_l0 is equal to 1, the number of times that modification_of_pic_nums_idc is not equal \nto 3 following ref_pic_list_modification_flag_l0 shall not exceed num_ref_idx_l0_active_minus1 + 1. \nWhen  RefPicList0[ num_ref_idx_l0_active_minus1 ]  in  the  initial  reference  picture  list  produced  as  specified  in \nclause H.8.2.1  is  equal  to  \"no  reference  picture\",  ref_pic_list_modification_flag_l0  shall  be  equal  to 1  and \nmodification_of_pic_nums_idc shall not be equal to 3 until RefPicList0[ num_ref_idx_l0_active_minus1 ] in the modified \nlist produced as specified in clause H.8.2.2 is not equal to \"no reference picture\". \nref_pic_list_modification_flag_l1 equal to 1 specifies that the syntax element modification_of_pic_nums_idc is present \nfor specifying reference picture list 1. ref_pic_list_modification_flag_l1 equal to 0 specifies that this syntax element is not \npresent. \nWhen ref_pic_list_modification_flag_l1 is equal to 1, the number of times that modification_of_pic_nums_idc is not equal \nto 3 following ref_pic_list_modification_flag_l1 shall not exceed num_ref_idx_l1_active_minus1 + 1. \nWhen decoding a slice with slice_type equal to 1 or 6 and RefPicList1[ num_ref_idx_l1_active_minus1 ] in the initial \nreference  picture  list  produced  as  specified  in  clause H.8.2.1  is  equal  to  \"no  reference  picture\", \nref_pic_list_modification_flag_l1 shall be equal to 1 and modification_of_pic_nums_idc shall not be equal to 3 until \nRefPicList1[ num_ref_idx_l1_active_minus1 ] in the modified list produced as specified in clause H.8.2.2 is not equal to \n\"no reference picture\". \nH.7.4.3.1.1  Reference picture list MVC modification semantics \nThe semantics specified in clause 7.4.3.1 apply with the following modified semantics of modification_of_pic_nums_idc. \nIn addition, the semantics of abs_diff_view_idx_minus1 specified below apply. \nmodification_of_pic_nums_idc  together  with  abs_diff_pic_num_minus1,  long_term_pic_num,  or \nabs_diff_view_idx_minus1  specifies  which  of  the  reference  pictures  or  inter-view  only  reference  components  are \nre-mapped.  The  values  of  modification_of_pic_nums_idc  are  specified  in  Table H-2.  The  value  of  the  first \nmodification_of_pic_nums_idc  that  follows  immediately  after  ref_pic_list_modification_flag_l0  or \n    Rec. ITU-T H.264 (06/2019)  669 \n \nref_pic_list_modification_flag_l1 shall not be equal to 3. \nTable H-2 – modification_of_pic_nums_idc operations for modification of reference picture lists \nmodification_of_pic_nums_idc  Modification specified \n0  abs_diff_pic_num_minus1 is present and corresponds to a difference to subtract from \na picture number prediction value \n1  abs_diff_pic_num_minus1 is present and corresponds to a difference to add to a picture \nnumber prediction value \n2  long_term_pic_num  is  present  and  specifies  the  long-term  picture  number  for  a \nreference picture \n3  End loop for modification of the initial reference picture list \n4  abs_diff_view_idx_minus1 is present and corresponds to a difference to subtract from \na prediction value of the reference view index \n5  abs_diff_view_idx_minus1  is  present  and  corresponds  to  a  difference  to  add  to  a \nprediction value of the reference view index \n \nabs_diff_view_idx_minus1 plus 1 specifies the absolute difference between the reference view index to put to the current \nindex in the reference picture list and the prediction value of the reference view index. \nLet currVOIdx be the VOIdx of the current view component, and let intViewIdx be the reference view index of the target \ninter-view prediction reference to put to the current index in RefPicListX (X is 0 or 1). Depending on whether the current \nview component is an anchor view component, the following applies: \n–  If the current view component is an anchor view component, the view_id of the target inter-view prediction reference \nis equal to anchor_ref_lX[ currVOIdx ][ intViewIdx ]. For anchor view components with VOIdx equal to currVOIdx, \nabs_diff_view_idx_minus1 shall be in the range of 0 to Max(0, num_anchor_refs_lX[ currVOIdx ] − 1 ), inclusive. \n–  Otherwise (the current view component is not an anchor view component), the view_id of the target inter-view \nprediction reference is equal to non_anchor_ref_lX[ currVOIdx ][ intViewIdx ]. For non-anchor view components \nwith  VOIdx  equal  to  currVOIdx,  abs_diff_view_idx_minus1  shall  be  in  the  range  of 0  to  Max(0, \nnum_non_anchor_refs_lX[ currVOIdx ] − 1), inclusive. \nThe allowed values of abs_diff_view_idx_minus1 are further restricted as specified in clause H.8.2.2.3. \nH.7.4.3.2  Prediction weight table semantics \nThe semantics specified in clause 7.4.3.2 apply. \nH.7.4.3.3  Decoded reference picture marking semantics \nThe semantics specified in clause 7.4.3.3 apply to each view independently, with \"sequence parameter set\" being replaced \nby \"MVC sequence parameter set\", and \"primary coded picture\" being replaced by \"view component of the primary coded \npicture\". \nH.7.4.4  Slice data semantics \nThe semantics specified in clause 7.4.4 apply. \nH.7.4.5  Macroblock layer semantics \nThe semantics specified in clause 7.4.5 apply. \nH.7.4.5.1  Macroblock prediction semantics \nThe semantics specified in clause 7.4.5.1 apply. \nH.7.4.5.2  Sub-macroblock prediction semantics \nThe semantics specified in clause 7.4.5.2 apply. \nH.7.4.5.3  Residual data semantics \nThe semantics specified in clause 7.4.5.3 apply. \n670  Rec. ITU-T H.264 (06/2019) \n \nH.7.4.5.3.1  Residual luma semantics \nThe semantics specified in clause 7.4.5.3.1 apply. \nH.7.4.5.3.2  Residual block CAVLC semantics \nThe semantics specified in clause 7.4.5.3.2 apply. \nH.7.4.5.3.3  Residual block CABAC semantics \nThe semantics specified in clause 7.4.5.3.3 apply. \nH.8  MVC decoding process \nThis clause specifies the decoding process for an access unit of a coded video sequence conforming to one or more of the \nprofiles specified in Annex H. Specifically, this clause specifies how the decoded picture with multiple view components \nis derived from syntax elements and global variables that are derived from NAL units in an access unit when the decoder \nis decoding the operation point identified by the target temporal level and the target output views. \nThe decoding process is specified such that all decoders shall produce numerically identical results for the target output \nviews. Any decoding process that produces identical results for the target output views to the process described here \nconforms to the decoding process requirements of this Recommendation | International Standard. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the decoding process \nspecified in this clause and all child processes invoked from the process specified in this clause are the syntax elements \nand derived upper-case variables for the current access unit. \nThe target output views are either specified by external means not specified in this Specification, or, when not specified \nby external means, there shall be one target output view which is the base view. Let OutputVOIdxList be the list of VOIdx \nvalues, in increasing order of VOIdx, of all the target output views in one access unit. The list OutputVOIdxList shall not \nchange within a coded video sequence. \nAll sub-bitstreams that can be derived using the sub-bitstream extraction process with pIdTarget equal to any value in the \nrange of 0 to 63, inclusive, tIdTarget equal to any value in the range of 0 to 7, inclusive, viewIdTargetList consisting of \nany one or more viewIdTarget's identifying the views in the bitstream as inputs as specified in clause H.8.5 shall result in \na set of coded video sequences, with each coded video sequence conforming to one or more of the profiles specified in \nAnnex A and Annex H. \nLet vOIdxList be a list of integer values specifying the VOIdx values of the view components of the access unit. The \nvariable VOIdxMax is set equal to the maximum value of the entries in the list vOIdxList, and the variable vOIdxMin is \nset to the minimum value of the entries in the list vOIdxList. VOIdxMax shall be the same for all access units within a \ncoded video sequence. vOIdxMin shall be the same for all anchor access units within a coded video sequence. When the \ncurrent access unit is an anchor access unit, the variable VOIdxMin is set to vOIdxMin. \nThe multiview video decoding process specified in this clause is repeatedly invoked for each view component with VOIdx \nfrom vOIdxMin to VOIdxMax, inclusive, which is present in the list vOIdxList, in increasing order of VOIdx. \nOutputs of the multiview video decoding process are decoded samples of the current primary coded picture including all \ndecoded view components. \nFor each view component, the specifications in clause 8 apply, with the decoding processes for picture order count, \nreference picture lists construction and decoded reference picture marking being modified in clauses H.8.1, H.8.2 and \nH.8.3,  respectively.  The  MVC  inter  prediction  and  inter-view  prediction  process  is  specified  in  clause H.8.4.  The \nspecification  of  bitstream  subsets  is  specified  in  clause H.8.5.  Additionally,  when  mfc_format_idc  is  present,  the \nrecommended enhanced-resolution picture reconstruction process is as described in clause H.8.6. \nH.8.1  MVC decoding process for picture order count \nThe process specified in this clause is invoked for a particular view with view order index VOIdx. The specifications in \nclause 8.2.1 apply independently for each view, with \"picture\" being replaced by \"view component\", \"frame\" being \nreplaced by \"frame view component\", and \"field\" being replaced by \"field view component\". \nThe following constraints shall be obeyed: \n–  When the view components of an access  unit have field_pic_flag equal to 0 or (field_pic_flag equal to 1 and \nbottom_field_flag equal to 0), it is a requirement of bitstream conformance that the bitstream shall not contain data \nthat result in different values of TopFieldOrderCnt for the view components of the access unit. \n–  When the view components of an access  unit have field_pic_flag equal to 0 or (field_pic_flag equal to 1 and \nbottom_field_flag equal to 1), it is a requirement of bitstream conformance that the bitstream shall not contain data \nthat result in different values of BottomFieldOrderCnt for the view components of the access unit. \n    Rec. ITU-T H.264 (06/2019)  671 \n \nH.8.2  MVC decoding process for reference picture lists construction \nThis process is invoked at the beginning of the decoding process for each P, SP or B slice. \nDuring the invocation of this process, when clauses 8.2.4.1 and 8.2.4.2 are invoked, only the reference pictures having the \nsame value of view_id as the current slice are considered. All clauses of clause 8 are invoked with \"picture\" being replaced \nby \"view component\", \"frame\" being replaced by \"frame view component\", and \"field\" being replaced by \"field view \ncomponent\". \nDecoded reference pictures are marked as \"used for short-term reference\" or \"used for long-term reference\" as specified in \nclause H.8.3. Short-term reference pictures are identified by the values of frame_num. Long-term reference pictures are \nassigned a long-term frame index as specified in clause H.8.3. \nIn addition to reference pictures marked as \"used for short-term reference\" or \"used for long-term reference\", inter-view \nreference components and inter-view only reference components of the current access unit may also be included in a \nreference picture list. Inter-view reference components and inter-view only reference components are identified by the \nvalue of view_id. \nClause 8.2.4.1 is invoked to specify \n–  the assignment of variables FrameNum, FrameNumWrap, and PicNum to each of the short-term reference pictures, \nand \n–  the assignment of variable LongTermPicNum to each of the long-term reference pictures. \nReference pictures and, when present, inter-view only reference components, are addressed through reference indices as \nspecified in clause 8.2.4.1. A reference index is an index into a reference picture list. When decoding a P or SP slice, there \nis a single reference picture list RefPicList0. When decoding a B slice, there is a second independent reference picture list \nRefPicList1 in addition to RefPicList0. \nAt the beginning of the decoding process for each slice, reference picture list RefPicList0, and for B slices RefPicList1, \nare derived as specified by the following ordered steps: \n1.  Depending on non_idr_flag, the following applies: \n–  If non_idr_flag is equal to 1, the initial reference picture list RefPicList0 and for B slices RefPicList1 are \nderived as specified in clause 8.2.4.2. \n–  Otherwise  (non_idr_flag  is  equal  to  0),  all  (num_ref_idx_l0_active_minus1 + 1)  entries  of  the  initial \nreference  picture  list  RefPicList0  are  set  equal  to  \"no  reference  picture\"  and,  for  B  slices,  all \n(num_ref_idx_l1_active_minus1 + 1) entries of the initial reference picture list RefPicList1 are set equal to \n\"no reference picture\". \n2.  Inter-view reference components or inter-view only reference components are appended to the initial reference \npicture list RefPicList0 and for B slices RefPicList1 as specified in clause H.8.2.1. \n3.  When  ref_pic_list_modification_flag_l0  is  equal  to 1  or,  when  decoding  a  B  slice, \nref_pic_list_modification_flag_l1 is equal to 1, the reference picture list RefPicList0 and for B slices RefPicList1 \nare modified as specified in clause H.8.2.2. \nNOTE – The modification process for reference picture lists specified in clause H.8.2.2 allows the contents of RefPicList0 \nand for B slices RefPicList1 to be modified in a flexible fashion. In particular, it is possible for a reference picture that is \ncurrently marked \"used for reference\" to be inserted into RefPicList0 and for B slices RefPicList1 even when the reference \npicture is not in the initial reference picture list derived as specified in clauses 8.2.4.2 and H.8.2.1. \nThe number of entries in the modified reference picture list RefPicList0 is num_ref_idx_l0_active_minus1 + 1, and for B \nslices the number of entries in the modified reference picture list RefPicList1 is num_ref_idx_l1_active_minus1 + 1. A \nreference picture or inter-view only reference component may appear at more than one index in the modified reference \npicture lists RefPicList0 or RefPicList1. \nDuring  the  invocation  of  the  process  specified  in  clause H.8.2.1,  an  inter-view  prediction  reference  appended  to \nRefPicListX (with X being 0 or 1) may not exist. However, an inter-view prediction reference that does not exist shall not \nbe in the modified RefPicListX after the invocation of the process specified in clause H.8.2.2. \nWhen anchor_pic_flag is equal to 1, the bitstream shall not contain data that result in any entry of the reference picture list \nRefPicList0 or, for B slices, any entry of the reference picture list RefPicList1 that does not represent a view component \nof the current access unit. \n672  Rec. ITU-T H.264 (06/2019) \n \nH.8.2.1  Initialization process for reference picture list for inter-view prediction references \nInputs to this process are a reference picture list RefPicListX (with X being 0 or 1), inter_view_flag and view dependency \ninformation that has been decoded from the seq_parameter_set_mvc_extension( ). \nThe output of this process is a possibly modified reference picture list RefPicListX, which is still referred to as the initial \nreference picture list RefPicListX. \nWith i being the value of VOIdx for the current slice, inter-view reference components and inter-view only reference \ncomponents (the corresponding NAL units have inter_view_flag equal to 1) are appended to the reference picture list as \nspecified in the following. \n–  If  the  current  slice  has  anchor_pic_flag  equal  to 1,  for  each  value  of  reference  view  index j  from 0  to \nnum_anchor_refs_lX[ i ] − 1, inclusive, in ascending order of j, the inter-view prediction reference with view_id equal \nto anchor_ref_lX[ i ][ j ] from the same access unit as the current slice is appended to RefPicListX. \n–  Otherwise (the current slice has anchor_pic_flag equal to 0), for each value of reference view index j from 0 to \nnum_non_anchor_refs_lX[ i ] − 1, inclusive, in ascending order of j, the inter-view prediction reference with view_id \nequal to non_anchor_ref_lX[ i ][ j ] from the same access unit as the current slice is appended to RefPicListX. \nNOTE 1 – View components with inter_view_flag equal to 0 are not appended to the reference picture list. \nNOTE 2 – When a NAL unit with nal_unit_type equal to 1 or 5 is not immediately preceded by a NAL unit with nal_unit_type \nequal to 14, the value of inter_view_flag is inferred to be equal to 1. Encoders that do not encode a prefix NAL unit before each \nNAL unit with nal_unit_type equal to 1 or 5 and devices that remove prefix NAL units from a bitstream should take into \nconsideration this inferred value to avoid potential mismatches in the reference picture lists between the encoder and decoder. \nInter-view reference components and inter-view only reference components are appended to the reference picture list \nstarting from the first entry position of \"no reference picture\" in the initial reference picture list RefPicListX or starting \nfrom the entry position num_ref_idx_lX_active_minus1+1 of the initial reference picture list RefPicListX, whichever is \nthe earliest position. \nWhen  the  number  of  entries  in  the  initial  reference  picture  list  RefPicListX  is  greater  than \n(num_ref_idx_lX_active_minus1 + 1), the extra entries past position num_ref_idx_lX_active_minus1 are discarded from \nthe initial reference picture list RefPicListX. \nH.8.2.2  Modification process for reference picture lists \nInput  to  this  process  is  reference  picture  list  RefPicList0  and,  when  decoding  a  B  slice,  also  reference  picture  list \nRefPicList1. \nOutputs of this process are a possibly modified reference picture list RefPicList0 and, when decoding a B slice, also a \npossibly modified reference picture list RefPicList1. \nWhen ref_pic_list_modification_flag_l0 is equal to 1, the following ordered steps are specified: \n1.  Let refIdxL0 be an index into the reference picture list RefPicList0. It is initially set equal to 0. \n2.  The corresponding syntax elements modification_of_pic_nums_idc are processed in the order they occur in the \nbitstream. For each of these syntax elements, the following applies: \n–  If modification_of_pic_nums_idc is equal to 0 or equal to 1, the process specified in clause H.8.2.2.1 is invoked \nwith RefPicList0 and refIdxL0 given as input, and the output is assigned to RefPicList0 and refIdxL0. \n–  Otherwise, if modification_of_pic_nums_idc is equal to 2, the process specified in clause H.8.2.2.2 is invoked \nwith RefPicList0 and refIdxL0 given as input, and the output is assigned to RefPicList0 and refIdxL0. \n–  Otherwise, if modification_of_pic_nums_idc is equal to 4 or equal to 5, the process specified in clause H.8.2.2.3 \nis invoked with RefPicList0 and refIdxL0 given as input, and the output is assigned to RefPicList0 and refIdxL0. \n–  Otherwise (modification_of_pic_nums_idc is equal to 3), the modification process for reference picture list \nRefPicList0 is finished. \nWhen ref_pic_list_modification_flag_l1 is equal to 1, the following ordered steps are specified: \n1.  Let refIdxL1 be an index into the reference picture list RefPicList1. It is initially set equal to 0. \n2.  The corresponding syntax elements modification_of_pic_nums_idc are processed in the order they occur in the \nbitstream. For each of these syntax elements, the following applies: \n–  If modification_of_pic_nums_idc is equal to 0 or equal to 1, the process specified in clause H.8.2.2.1 is invoked \nwith RefPicList1 and refIdxL1 given as input, and the output is assigned to RefPicList1 and refIdxL1. \n    Rec. ITU-T H.264 (06/2019)  673 \n \n–  Otherwise, if modification_of_pic_nums_idc is equal to 2, the process specified in clause H.8.2.2.2 is invoked \nwith RefPicList1 and refIdxL1 given as input, and the output is assigned to RefPicList1 and refIdxL1. \n–  Otherwise, if modification_of_pic_nums_idc is equal to 4 or equal to 5, the process specified in clause H.8.2.2.3 \nis invoked with RefPicList1 and refIdxL1 given as input, and the output is assigned to RefPicList1 and refIdxL1. \n–  Otherwise (modification_of_pic_nums_idc is equal to 3), the modification process for reference picture list \nRefPicList1 is finished. \nH.8.2.2.1  Modification process of reference picture lists for short-term reference pictures for inter prediction \nInputs to this process are an index refIdxLX and a reference picture list RefPicListX (with X being 0 or 1). \nOutputs of this process are an incremented index refIdxLX and a modified reference picture list RefPicListX. \nThe variable picNumLXNoWrap is derived as follows: \n–  If modification_of_pic_nums_idc is equal to 0, \nif( picNumLXPred − ( abs_diff_pic_num_minus1 + 1 ) < 0 ) \n  picNumLXNoWrap = picNumLXPred − ( abs_diff_pic_num_minus1 + 1 ) + MaxPicNum  (H-1) \nelse \n  picNumLXNoWrap = picNumLXPred − ( abs_diff_pic_num_minus1 + 1 ) \n–  Otherwise (modification_of_pic_nums_idc is equal to 1), \nif( picNumLXPred + ( abs_diff_pic_num_minus1 + 1 )  >=  MaxPicNum ) \n  picNumLXNoWrap = picNumLXPred + ( abs_diff_pic_num_minus1 + 1 ) − MaxPicNum  (H-2) \nelse \n  picNumLXNoWrap = picNumLXPred + ( abs_diff_pic_num_minus1 + 1 ) \npicNumLXPred is the prediction value for the variable picNumLXNoWrap. When the process specified in this clause is \ninvoked the first time for a slice (that is, for the first occurrence of modification_of_pic_nums_idc equal to 0 or 1 in the \nref_pic_list_modification( ) syntax), picNumL0Pred and picNumL1Pred are initially set equal to CurrPicNum. After each \nassignment of picNumLXNoWrap, the value of picNumLXNoWrap is assigned to picNumLXPred. \nThe variable picNumLX is derived as specified by the following pseudo-code: \nif( picNumLXNoWrap > CurrPicNum ) \n  picNumLX = picNumLXNoWrap − MaxPicNum  (H-3) \nelse \n  picNumLX = picNumLXNoWrap \npicNumLX shall be equal to the PicNum of a reference picture that is marked as \"used for short-term reference\" and shall \nnot be equal to the PicNum of a short-term reference picture that is marked as \"non-existing\". \nThe following procedure is conducted to place the picture with short-term picture number picNumLX into the index \nposition refIdxLX, shift the position of any other remaining pictures to later in the list, and increment the value of refIdxLX: \nfor( cIdx = num_ref_idx_lX_active_minus1 + 1; cIdx > refIdxLX; cIdx−− ) \n \n  RefPicListX[ cIdx ] = RefPicListX[ cIdx − 1] \nRefPicListX[ refIdxLX++ ] = short-term reference picture with PicNum equal to picNumLX \nnIdx = refIdxLX \nfor( cIdx = refIdxLX; cIdx <= num_ref_idx_lX_active_minus1 + 1; cIdx++ )   (H-4) \n  if( PicNumF( RefPicListX[ cIdx ] ) != picNumLX  | |  viewID(RefPicListX[ cIdx ] ) != currViewID ) \n    RefPicListX[ nIdx++ ] = RefPicListX[ cIdx ] \nIn the above, the function viewID(refpic) returns the view_id of the reference picture refpic, the variable currViewID is \nequal to the view_id of the current slice, and the function PicNumF( RefPicListX[ cIdx ] ) is derived as follows: \n–  If  the  reference  picture  RefPicListX[ cIdx ]  is  marked  as  \"used  for  short-term  reference\", \nPicNumF( RefPicListX[ cIdx ] ) is the PicNum of the picture RefPicListX[ cIdx ]. \n–  Otherwise  (the  reference  picture  RefPicListX[ cIdx ]  is  not  marked  as  \"used  for  short-term  reference\"), \nPicNumF( RefPicListX[ cIdx ] ) is equal to MaxPicNum. \nNOTE 1 – The value of picNumLX can never be equal to MaxPicNum. \nNOTE 2 – Within this pseudo-code procedure, the length of the list RefPicListX is temporarily made one element longer than the \nlength needed for the final list. After the execution of this procedure, only elements 0 through num_ref_idx_lX_active_minus1 of \nthe list need to be retained. \n674  Rec. ITU-T H.264 (06/2019) \n \nH.8.2.2.2  Modification process of reference picture lists for long-term reference pictures for inter prediction \nInputs to this process are an index refIdxLX (with X being 0 or 1) and reference picture list RefPicListX. \nOutputs of this process are an incremented index refIdxLX and a modified reference picture list RefPicListX. \nThe following procedure is conducted to place the picture with long-term picture number long_term_pic_num into the \nindex position refIdxLX, shift the position of any other remaining pictures to later in the list, and increment the value of \nrefIdxLX: \nfor( cIdx = num_ref_idx_lX_active_minus1 + 1; cIdx > refIdxLX; cIdx−− ) \n \n  RefPicListX[ cIdx ] = RefPicListX[ cIdx − 1] \nRefPicListX[ refIdxLX++ ] = long-term reference picture with LongTermPicNum equal to long_term_pic_num \nnIdx = refIdxLX \nfor( cIdx = refIdxLX; cIdx <= num_ref_idx_lX_active_minus1 + 1; cIdx++ )  (H-5) \n  if( LongTermPicNumF( RefPicListX[ cIdx ] ) != long_term_pic_num | | \n       viewID(RefPicListX[ cIdx ] ) != currViewID ) \n    RefPicListX[ nIdx++ ] = RefPicListX[ cIdx ] \nIn the above, the function viewID(refpic) returns the view_id of the reference picture refpic, the variable currViewID is \nequal to the view_id of the current slice, and the function LongTermPicNumF( RefPicListX[ cIdx ] ) is derived as follows: \n–  If  the  reference  picture  RefPicListX[ cIdx ]  is  marked  as  \"used  for  long-term  reference\", \nLongTermPicNumF( RefPicListX[ cIdx ] ) is the LongTermPicNum of the picture RefPicListX[ cIdx ]. \n–  Otherwise  (the  reference  picture  RefPicListX[ cIdx ]  is  not  marked  as  \"used  for  long-term  reference\"), \nLongTermPicNumF( RefPicListX[ cIdx ] ) is equal to 2 * ( MaxLongTermFrameIdx + 1 ). \nNOTE 1 – The value of long_term_pic_num can never be equal to 2 * ( MaxLongTermFrameIdx + 1 ). \nNOTE 2 – Within this pseudo-code procedure, the length of the list RefPicListX is temporarily made one element longer than the \nlength needed for the final list. After the execution of this procedure, only elements 0 through num_ref_idx_lX_active_minus1 of \nthe list need to be retained. \nH.8.2.2.3  Modification process for reference picture lists for inter-view prediction references \nInputs to this process are reference picture list RefPicListX (with X being 0 or 1) and an index refIdxLX into this list. \nOutputs of this process are a modified reference picture list RefPicListX (with X being 0 or 1) and an incremented index \nrefIdxLX. \nLet currVOIdx be the variable VOIdx of the current slice. The variable maxViewIdx is derived as follows: \n–  If the current slice has anchor_pic_flag equal to 1, maxViewIdx is set equal to num_anchor_refs_lX[ currVOIdx ] − 1. \n–  Otherwise  (the  current  slice  has  anchor_pic_flag  equal  to 0),  maxViewIdx  is  set  equal  to \nnum_non_anchor_refs_lX[ currVOIdx ] − 1. \nThe variable picViewIdxLX is derived as follows: \n–  If modification_of_pic_nums_idc is equal to 4, \nif( picViewIdxLXPred − ( abs_diff_view_idx_minus1 + 1 ) < 0 ) \npicViewIdxLX = picViewIdxLXPred − ( abs_diff_view_idx_minus1 + 1 ) + maxViewIdx + 1  (H-6) \nelse \npicViewIdxLX = picViewIdxLXPred − ( abs_diff_view_idx_minus1 + 1 ) \n–  Otherwise (modification_of_pic_nums_idc is equal to 5), \nif( picViewIdxLXPred + ( abs_diff_view_idx_minus1 + 1 ) >= maxViewIdx + 1 ) \npicViewIdxLX = picViewIdxLXPred + ( abs_diff_view_idx_minus1 + 1 ) − ( maxViewIdx + 1 )  (H-7) \nelse \npicViewIdxLX = picViewIdxLXPred + ( abs_diff_view_idx_minus1 + 1 ) \npicViewIdxLXPred is the prediction value for the variable picViewIdxLX. When the process specified in this clause is \ninvoked the first time for a slice (that is, for the first occurrence of modification_of_pic_nums_idc equal to 4 or 5 in the \nref_pic_list_modification( ) syntax), picViewIdxL0Pred and picViewIdxL1Pred are initially set equal to −1. After each \nassignment of picViewIdxLX, the value of picViewIdxLX is assigned to picViewIdxLXPred. \nThe bitstream shall not contain data that result in picViewIdxLX less than 0 or picViewIdxLX greater than maxViewIdx. \nThe variable targetViewID is derived as follows: \n–  If the current slice has anchor_pic_flag equal to 1, \n    Rec. ITU-T H.264 (06/2019)  675 \n \ntargetViewID = anchor_refs_lX[ currVOIdx ][ picViewIdxLX ]  (H-8) \n–  Otherwise (the current slice has anchor_pic_flag equal to 0), \ntargetViewID = non_anchor_refs_lX[ currVOIdx ][ picViewIdxLX ]  (H-9) \nThe following procedure is conducted to place the inter-view prediction reference with reference view index equal to \npicViewIdxLX into the index position refIdxLX and shift the position of any other remaining pictures to later in the list: \nfor( cIdx = num_ref_idx_lX_active_minus1 + 1; cIdx > refIdxLX; cIdx−− ) \n \n  RefPicListX[ cIdx ] = RefPicListX[ cIdx − 1] \nRefPicListX[ refIdxLX++ ] = inter-view prediction reference with view_id equal to targetViewID \nnIdx = refIdxLX \nfor( cIdx = refIdxLX; cIdx <= num_ref_idx_lX_active_minus1 + 1; cIdx++ )   (H-10) \n  if( viewID(RefPicListX[ cIdx ]) != targetViewID | | PictureOrderCnt(RefPicListX[ cIdx ]) != currPOC ) \n    RefPicListX[ nIdx++ ] = RefPicListX[ cIdx ] \nIn the above, the function viewID(refpic) returns the view_id of the reference picture refpic, the variable currViewID is \nequal to the view_id of the current slice, and the variable currPOC is equal to PicOrderCnt( ) of the current slice. \nH.8.3  MVC decoded reference picture marking process \nThe process specified in this clause is invoked for a particular view with view order index VOIdx. The specifications in \nclause 8.2.5  apply  with  \"picture\"  being  replaced  by  \"view  component\",  \"frame\"  being  replaced  by  \"frame  view \ncomponent\", and \"field\" being replaced by \"field view component\". During the invocation of the process for a particular \nview, only view components of the particular view are considered. The marking of view components of other views is not \nchanged. \nNOTE – A view component of a picture may have a different marking status than other view components of the same picture. \nH.8.4  MVC inter prediction and inter-view prediction process \nFor both inter-prediction and inter-view prediction, the specifications in clause 8.4 apply. For the invocation of the MVC \ninter prediction and inter-view prediction process as specified in this clause, the inter-view reference components and inter-\nview only reference components that are included in the reference picture lists are considered as not being marked as \"used \nfor short-term reference\" or \"used for long-term reference\". \nNOTE – This implies that when RefPicList1[ 0 ] represents an inter-view reference component or an inter-view only reference \ncomponent, the variable colZeroFlag in clause 8.4.1.2.2 is always derived to be equal to 0. \nWhen  mfc_format_idc  is  present,  the  additional  processing  for  an  inter-view  prediction  reference  as  specified  in \nclause H.8.4.1 is invoked before the inter-view prediction reference is used for inter-view prediction. \nH.8.4.1  Additional processing for an inter-view prediction reference \nThis process is invoked when mfc_format_idc is present to modify each colour component array of an inter-view prediction \nreference used in decoding view components of the non-base view. When rpu_filter_enabled_flag is equal to 1, the \nmodification  process  consists  of  a  one-dimensional  downsampling  filtering  process  followed  by  a  one-dimensional \nupsampling filtering process. The modification process converts an inter-view prediction reference from the frame packing \narrangement format of the view components in the base view to the frame packing arrangement format of  the view \ncomponents in the non-base view. When rpu_filter_enabled_flag is equal to 0, all sample values for each colour component \nof an inter-view prediction reference are set equal to 128. \nInputs of this process are: \n–  two variables refW and refH specifying the width and height, respectively, of the inter-view prediction reference \npicture sample array, \n–  a (refW)x(refH) inter-view prediction reference picture sample array refPicture for either the luma or a chroma \ncomponent. \nOutput of this process is a (refW)x(refH) modified inter-view prediction reference picture sample array RpuPicture for \neither the luma or a chroma component. \nThe input sample array refPicture corresponds to a decoded sample array S , S  or S , respectively, for each colour \nL Cb Cr\ncomponent derived in clause 8.7 for a decoded frame or complementary field pair or field of a decoded frame from the \nbase view. \nThe output sample array RpuPicture corresponds to a decoded sample array S , S  or S , respectively, for each colour \nL Cb Cr\ncomponent derived in clause 8.7 for a previously-decoded reference frame or complementary reference field pair or field \nof a reference frame. \n676  Rec. ITU-T H.264 (06/2019) \n \nDepending on the value of rpu_field_processing_flag, the following applies: \n–  If rpu_field_processing_flag is equal to 1, the inter-view prediction reference picture refPicture is a field, the modified \ninter-view prediction reference picture RpuPicture is a field, and the inter-view prediction reference modification is \napplied to the individual inter-view prediction reference fields separately. \n–  Otherwise (rpu_field_processing_flag is equal to 0), the inter-view prediction reference picture refPicture is a frame, \nthe modified inter-view prediction reference picture RpuPicture is a frame, and the inter-view prediction reference \nmodification is applied to the inter-view prediction reference frame. \nThe mathematical function Clip1( ) is defined with Clip1( ) being substituted with Clip1 ( ) for the luma component and \nY\nClip1( ) being substituted with Clip1 ( ) for the chroma components, respectively. \nC\nThe variables refW and refH are derived as follows: \n–  For the luma component, refW is set equal to PicWidthInSamples  and refH is set equal to PicHeightInSamples . \nL L\n–  For the chroma components, refW is set equal to PicWidthInSamples  and refH is set equal to PicHeightInSamples . \nC C\nThe variables subW and subH are derived as follows: \n–  For the luma component, subW is set equal to SubWidthC and subH is set equal to SubHeightC. \n–  For the chroma components, subW is set equal to 1 and subH is set equal to 1. \nThe variable view0OffsetX is derived as follows: \n–  If view0_grid_position_x is equal to 4 or 8, view0OffsetX is set equal to 0, \n–  Otherwise (view0_grid_position_x is equal to 12), view0OffsetX is set equal to 1. \nThe variable view1OffsetX is derived as follows: \n–  If view1_grid_position_x is equal to 4 or 8, view1OffsetX is set equal to 0, \n–  Otherwise (view1_grid_position_x is equal to 12), view1OffsetX is set equal to 1. \nThe variable view0OffsetY is derived as follows: \n–  If view0_grid_position_y is equal to 4 or 8, view0OffsetY is set equal to 0, \n–  Otherwise (view0_grid_position_y is equal to 12), view0OffsetY is set equal to 1. \nThe variable view1OffsetY is derived as follows: \n–  If view1_grid_position_y is equal to 4 or 8, view1OffsetY is set equal to 0, \n–  Otherwise (view1_grid_position_y is equal to 12), view1OffsetY is set equal to 1. \nThe variable RpuW specifying the width of an active area of the reference picture is derived as specified by the following \nordered steps: \n1.  leftOffset = frame_crop_left_offset* subW \n2.  rightOffset = frame_crop_right_offset * subW \n3.  RpuW = refW − leftOffset − rightOffset  (H-11) \nThe variable RpuH specifying the height of an active area of the reference picture is derived as specified by the following \nordered steps: \n1.  topOffset = frame_crop_top_offset * subH * ( 2 − frame_mbs_only_flag ) \n2.  botOffset = frame_crop_bottom_offset * subH * ( 2 − frame_mbs_only_flag ) \n3.  if ( rpu_field_processing_flag ) \ntopOffset = topOffset  >>  1, botOffset = botOffset  >>  1 \n4.  RpuH = refH − topOffset − botOffset  (H-12) \nThe variable SbsV is set equal to RpuW  >>  1. In the side-by-side arrangement, the view boundary position between the \nleft and right views is set equal to SbsV + leftOffset. \nThe variable TabV is set equal to RpuH  >>  1. In the top-bottom arrangement, the view boundary position between the \nleft and right views is set equal to TabV + topOffset. \n    Rec. ITU-T H.264 (06/2019)  677 \n \nThe filtered samples of picture sample array rpuPicture[ x, y ], with x = 0..refW − 1 and y = 0..refH − 1, are derived as \nfollows: \n–  If rpu_filter_enabled_flag is equal to 0, the following applies: \nRpuPicture[ x, y ] = 128 with x = 0..refW − 1 and y = 0..refH − 1  (H-13) \n–  Otherwise (rpu_filter_enabled_flag is equal to 1), the following applies: \nLet tempPicture[ x, y ] be a (SbsV)x(TabV) array of samples with x = 0..SbsV − 1 and y = 0..TabV − 1. \n–  If  mfc_format_idc  is  equal  to  0,  let  tempRefPic[ x, y ]  be  a  (SbsV)x(RpuH)  array  of  samples  with \nx = 0..SbsV − 1 and y = 0..RpuH − 1, and tempRpuPic[ x, y ] be a (RpuW)x(TabV) array of samples with \nx = 0..RpuW − 1 and y = 0..TabV − 1. \n–  Otherwise (mfc_format_idc is equal to 1), let tempRefPic[ x, y ]  be a (RpuW)x(TabV) array of samples \nwith x = 0..RpuW − 1 and y = 0..TabV − 1, and tempRpuPic[ x, y ] be a (SbsV)x(RpuH) array of samples \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1. \nThe filtered samples of picture sample array RpuPicture[ x, y ] with x = leftOffset..RpuW − 1 + leftOffset and \ny = topOffset..RpuH − 1 + topOffset are derived as specified by the following ordered steps: \n–  If mfc_format_idc is equal to 0, the following applies: \n1.  RpuPicture[ x, y ] with x = leftOffset.. RpuW − 1 + leftOffset and y = topOffset..TabV − 1 + topOffset \nis derived from the input of the array refPicture[ x, y ] with x = leftOffset..SbsV − 1 + leftOffset and \ny = topOffset..RpuH − 1 + topOffset as specified by the following ordered steps: \na.  tempRefPic[ x, y ] = refPicture[ x + leftOffset , y + topOffset ] \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1  (H-14) \nb.  Apply the following one-dimensional downsampling process: \ntempPicture[ x, y ] = \n     Clip1( ( 4 * tempRefPic[ x, Clip3( 0, 2 * y − 2, RpuH − 1 ) ] + \n      7 * tempRefPic[ x, Clip3( 0, 2 * y − 1, RpuH − 1 ) ] + \n     10 * tempRefPic[ x, Clip3( 0, 2 * y, RpuH − 1 ) ] + \n      7 * tempRefPic[ x, Clip3( 0, 2 * y + 1, RpuH − 1 ) ] + \n     4 * tempRefPic[ x, Clip3( 0, 2 * y + 2, RpuH − 1 ) ] + 32 )  >>  6 )  (H-15) \nwith x = 0..SbsV − 1 and y = 0..TabV − 1 \nc.  Apply the following one-dimensional upsampling process: \ngMin = − 2 − View0OffsetX  (H-16) \ntempRpuPic[ 2 * x + view0OffsetX, y ] = tempPicture[ x, y ]  (H-17) \ntempRpuPic[ 2 * x + ( 1 − view0OffsetX ), y ] = \n      Clip1( ( 3 * tempPicture[ Clip3( 0, x + gMin, SbsV − 1 ), y ] − \n      17 * tempPicture[ Clip3( 0, x + gMin + 1, SbsV − 1 ), y ] + \n      78 * tempPicture[ Clip3( 0, x + gMin + 2, SbsV − 1 ), y ] + \n      78 * tempPicture[ Clip3( 0, x + gMin + 3, SbsV − 1 ), y ] − \n      17 * tempPicture[ Clip3( 0, x + gMin + 4, SbsV − 1 ), y ] + \n      3 * tempPicture[ Clip3( 0, x + gMin + 5, SbsV − 1 ), y ] + 64)  >>  7 )  (H-18) \nwith x = 0..SbsV − 1 and y = 0..TabV − 1 \nd.  RpuPicture[ x + leftOffset, y + topOffset ] = tempRpuPic[ x, y ] \nwith x = 0..RpuW − 1 and y = 0..TabV − 1  (H-19) \n2.  RpuPicture[ x, y ]  with  x  =  leftOffset..RpuW − 1 + leftOffset  and \ny = TabV + topOffset..RpuH − 1 + topOffset is derived from the input of the array refPicture[ x, y ] with \nx = SbsV + leftOffset..RpuW − 1 + leftOffset and y = topOffset..RpuH − 1 + topOffset as specified by \nthe following ordered steps: \na.  tempRefPic[ x, y ] = refPicture[ x + SbsV + leftOffset , y + topOffset ] \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1  (H-20) \nb.  Apply the following one-dimensional downsampling process: \n678  Rec. ITU-T H.264 (06/2019) \n \ntempPicture[ x, y ] = \n      Clip1( ( 4 * tempRefPic[ x, Clip3( 0, 2 * y − 2, RpuH − 1 ) ] + \n      7 * tempRefPic[ x, Clip3( 0, 2 * y − 1, RpuH − 1 ) ] + \n      10 * tempRefPic[ x, Clip3( 0,  2 * y, RpuH − 1 ) ] + \n      7 * tempRefPic[ x, Clip3( 0,  2 * y + 1, RpuH − 1 ) ] + \n      4 * tempRefPic[ x, Clip3( 0,  2 * y + 2, RpuH − 1 ) ] + 32 )  >>  6 )  (H-21) \nwith x = 0..SbsV − 1 and y = 0..TabV − 1 \nc.  Apply the following one-dimensional upsampling process: \ngMin = − 2 − View1OffsetX  (H-22) \ntempRpuPic[ 2 * x + view1OffsetX, y ] = tempPicture[ x, y ]  (H-23) \ntempRpuPic[ 2 * x + ( 1 − view1OffsetX ), y ] = \n      Clip1( ( 3 * tempPicture[ Clip3( 0, x + gMin, SbsV − 1 ), y ] − \n      17 * tempPicture[ Clip3( 0, x + gMin + 1, SbsV − 1 ), y ] + \n      78 * tempPicture[ Clip3( 0, x + gMin + 2, SbsV − 1 ), y ] + \n      78 * tempPicture[ Clip3( 0, x + gMin + 3, SbsV − 1 ), y ] − \n      17 * tempPicture[ Clip3( 0, x + gMin + 4, SbsV − 1 ), y ] + \n      3 * tempPicture[ Clip3( 0, x + gMin + 5, SbsV − 1 ), y ] + 64)  >>  7 )  (H-24) \nwith x = 0..SbsV − 1 and y = 0..TabV − 1 \nd.  RpuPicture[ x + leftOffset, y + TabV + topOffset ] = tempRpuPic[ x, y ] \nwith x = 0..RpuW − 1 and y = 0..TabV − 1  (H-25) \n–  Otherwise ( mfc_format_idc is equal to 1), the following applies: \n1.  RpuPicture[ x, y ] with x = leftOffset..SbsV − 1 + leftOffset and y = topOffset..RpuH − 1 + topOffset is \nderived from the input of the array refPicture[ x, y ] with x = leftOffset..RpuW − 1 + leftOffset and \ny = topOffset..TabV − 1 + topOffset as specified by the following ordered steps: \na.  tempRefPic[ x, y ] = refPicture[ x + leftOffset, y + topOffset ] \nwith x = 0..RpuW − 1 and y = 0..TabV − 1  (H-26) \nb.  Apply the following one-dimensional downsampling process: \ntempPicture[ x, y ] = \n      Clip1( ( 4 * tempRefPic[ Clip3( 0, 2 * x − 2, RpuW − 1 ), y ] + \n      7 * tempRefPic[ Clip3( 0, 2 * x − 1, RpuW − 1 ), y ] + \n      10 * tempRefPic[ Clip3( 0, 2 * x, RpuW − 1 ), y ] + \n      7 * tempRefPic[ Clip3( 0, 2 * x + 1, RpuW − 1 ), y ] + \n      4 * tempRefPic[ Clip3( 0, 2 * x + 2, RpuW − 1 ), y ] + 32 )  >>  6 )   (H-27) \nwith x = 0..SbsV − 1 and y = 0..TabV − 1 \nc.  Apply the following one-dimensional upsampling process: \ngMin = − 2 − View0OffsetY  (H-28) \ntempRpuPic[ x, 2 * y + view0OffsetY ] = tempPicture[ x, y ]  (H-29) \ntempRpuPic[ x, 2 * y + ( 1 − view0OffsetY ) ] =    \n    Clip1( ( 3 * tempPicture[ x, Clip3( 0, y + gMin, TabV − 1 ) ] − \n      17 * tempPicture[ x, Clip3( 0, y + gMin + 1, TabV − 1 ) ] +    \n      78 * tempPicture[ x, Clip3( 0, y + gMin + 2, TabV − 1 ) ] + \n      78 * tempPicture[ x, Clip3( 0, y + gMin + 3, TabV − 1 ) ] −    \n      17 * tempPicture[ x, Clip3( 0, y + gMin + 4, TabV − 1 ) ] + \n      3 * tempPicture[ x, Clip3( 0, y + gMin + 5, TabV − 1 ) ] + 64 )  >>  7 )  (H-30) \nwith x = 0..SbsV − 1 and y = 0..TabV − 1 \nd.  RpuPicture[ x + leftOffset, y + topOffset ] = tempRpuPic[ x, y ] \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1  (H-31) \n2.  RpuPicture[ x, y ]  with  x  =  SbsV + leftOffset..RpuW − 1 + leftOffset  and \ny = topOffset..RpuH − 1 + topOffset  is  derived  from  the  input  of  the  array  refPicture[ x, y ]  with \n    Rec. ITU-T H.264 (06/2019)  679 \n \nx = leftOffset..RpuW − 1 + leftOffset and y = TabV + topOffset..RpuH − 1 + topOffset as specified by \nthe following ordered steps: \na.  tempRefPic[ x, y ] = refPicture[ x + leftOffset, y + topOffset + TabV ] \nwith x = 0..RpuW − 1 and y = 0..TabV − 1  (H-32) \nb.  Apply the following one-dimensional downsampling process: \ntempPicture[ x, y ] = \n      Clip1( ( 4 * tempRefPic[ Clip3( 0, 2 * x − 2, RpuW − 1 ), y ] + \n      7 * tempRefPic[ Clip3( 0, 2 * x − 1, RpuW − 1 ), y ] + \n      10 * tempRefPic[ Clip3( 0, 2 * x, RpuW − 1 ), y ] + \n      7 * tempRefPic[ Clip3( 0, 2 * x + 1, RpuW − 1 ), y ] + \n      4 * tempRefPic[ Clip3( 0, 2 * x + 2, RpuW − 1 ), y ] + 32 )  >>  6 )  (H-33) \nwith x = 0..SbsV − 1 and y = 0..TabV − 1 \nc.  Apply the following one-dimensional upsampling process: \ngMin = − 2 − View1OffsetY  (H-34) \ntempRpuPic[ x, 2 * y + view1OffsetY ] = tempPicture[ x, y ]  (H-35) \ntempRpuPic[ x, 2 * y + ( 1 − view1OffsetY ) ] ] = \n      Clip1( ( 3 * tempPicture[ x, Clip3( 0, y + gMin, TabV − 1 ) ] − \n      17 * tempPicture[ x, Clip3( 0, y + gMin + 1, TabV − 1 ) ] + \n      78 * tempPicture[ x, Clip3( 0, y + gMin + 2, TabV − 1 ) ] + \n      78 * tempPicture[ x, Clip3( 0, y + gMin + 3, TabV − 1 ) ] − \n      17 * tempPicture[ x, Clip3( 0, y + gMin + 4, TabV − 1 ) ] + \n      3 * tempPicture[ x, Clip3( 0, y + gMin + 5, TabV − 1 ) ] + 64 )  >>  7 )  (H-36) \nwith x = 0..SbsV − 1 and y = 0..TabV − 1 \nd.  RpuPicture[ x + SbsV + leftOffset, y + topOffset ] = tempRpuPic[ x, y ] \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1  (H-37) \nThe padded filtered samples of picture sample array RpuPicture[ x, y ] outside frame cropping rectangle with \nx = 0..leftOffset − 1 or x = RpuW + leftOffset..refW − 1 or y = 0..topOffset − 1 or y = RpuH + topOffset..refH − 1 \nare derived as specified by the following ordered steps: \n1.  RpuPicture[ x, y ] = RpuPicture[ leftOffset, y ] \nwith x = 0.. leftOffset − 1 and y = topOffset..RpuH − 1+ topOffset  (H-38) \n2.  RpuPicture[ x, y ] = RpuPicture[ RpuW − 1 + leftOffset, y ] \nwith x = RpuW+ leftOffset..refW − 1 and y = topOffest..RpuH − 1+ topOffset  (H-39) \n3.  RpuPicture[ x, y ] = RpuPicture[ x, topOffset ] \nwith x =  0..refW − 1 and y = 0..topOffset − 1  (H-40) \n4.  RpuPicture[ x, y ] = RpuPicture[ x, RpuH − 1 + topOffset] \nwith x =  0..refW − 1 and y = RpuH+ topOffset..refH − 1  (H-41) \nNOTE – If each view component in the base view is a side-by-side frame packing arrangement picture, the inter-view reference \npicture is first vertically downsampled and then horizontally upsampled in a conversion to the top-bottom format. Otherwise (each \nview component in the base view is a top-bottom frame packing arrangement picture), the inter-view reference picture is first \nhorizontally downsampled and then vertically upsampled in a conversion to the side-by-side format. \nH.8.5  Specification of bitstream subsets \nClauses H.8.5.1  and  H.8.5.2  specify  the  processes  for  deriving  required  anchor  and  non-anchor  view  components, \nrespectively, that are used in the sub-bitstream extraction process. Clause H.8.5.3 specifies the sub-bitstream extraction \nprocess. Clause H.8.5.4 specifies the base view bitstream subset. Clause H.8.5.5 gives an informative example for creation \nof a base view in case the original base view in the input bitstream to the bitstream extraction process is not included in \nthe output bitstream subset. \nH.8.5.1  Derivation process for required anchor view components \nThis process is recursively invoked to derive the set of required anchor view components for a specified view. \n680  Rec. ITU-T H.264 (06/2019) \n \nInput to this process is a variable viewId, representing a view with view_id equal to viewId, with its corresponding view \norder index denoted by vOIdx. \nOutputs of this process are a possibly updated VOIdxList, and additional invocations of the derivation process based on \nthe inter-view dependency for anchor view components in the view with view_id equal to viewId as specified in the \nsequence parameter set MVC extension. \nThe following ordered steps are specified: \n1.  When vOIdx is not already included in VOIdxList, add vOIdx to VOIdxList. \n2.  Depending on num_anchor_refs_l0[ vOIdx ] and num_anchor_refs_l1[ vOIdx ], the following applies: \n–  If  both  num_anchor_refs_l0[ vOIdx ]  and  num_anchor_refs_l1[ vOIdx ]  are  equal  to 0,  terminate  this \nprocess. \n–  Otherwise (num_anchor_refs_l0[ vOIdx ] or num_anchor_refs_l1[ vOIdx ] is not equal to 0), the following \nordered steps are specified: \na.  When num_anchor_refs_l0[ vOIdx ] is not equal to 0, invoke the process specified in clause H.8.5.1 for \neach  viewId  equal  to  anchor_ref_l0[ vOIdx ][ i ]  for  all  i  in  the  range  of 0  to \nnum_anchor_refs_l0[ vOIdx ] − 1, inclusive, in ascending order of i. \nb.  When num_anchor_refs_l1[ vOIdx ] is not equal to 0, invoke the process specified in clause H.8.5.1 for \neach  viewId  equal  to  anchor_ref_l1[ vOIdx ][ i ]  for  all  i  in  the  range  of 0  to \nnum_anchor_refs_l1[ vOIdx ] − 1, inclusive, in ascending order of i. \nH.8.5.2  Derivation process for required non-anchor view components \nThis process is recursively invoked to derive the set of required non-anchor view components for a specified view. \nInput to this process is a variable viewId, representing a view with view_id equal to viewId, with its corresponding view \norder index denoted by vOIdx. \nOutputs of this process are a possibly updated VOIdxList, and additional invocations of the derivation process based on \nthe inter-view dependency for non-anchor view components in the view with view_id equal to viewId as specified in the \nsequence parameter set MVC extension. \nThe following ordered steps are specified: \n1.  When vOIdx is not already included in VOIdxList, add vOIdx to VOIdxList. \n2.  Depending on num_non_anchor_refs_l0[ vOIdx ] and num_non_anchor_refs_l1[ vOIdx ], the following applies: \n–  If both num_non_anchor_refs_l0[ vOIdx ] and num_non_anchor_refs_l1[ vOIdx ] are equal to 0, terminate \nthis process. \n–  Otherwise  (num_non_anchor_refs_l0[ vOIdx ]  or  num_non_anchor_l1[ vOIdx ]  is  not  equal  to 0),  the \nfollowing ordered steps are specified: \na.  When  num_non_anchor_refs_l0[ vOIdx ]  is  not  equal  to 0,  invoke  the  process  specified  in \nclause H.8.5.2 for each viewId equal to non_anchor_ref_l0[ vOIdx ][ i ] for all i in the range of 0 to \nnum_non_anchor_l0[ vOIdx ] − 1, inclusive, in ascending order of i. \nb.  When  num_non_anchor_refs_l1[ vOIdx ]  is  not  equal  to 0,  invoke  the  process  specified  in \nclause H.8.5.2 for each viewId equal to non_anchor_ref_l1[ vOIdx ][ i ] for all i in the range of 0 to \nnum_non_anchor_l1[ vOIdx ] − 1, inclusive, in ascending order of i. \nH.8.5.3  Sub-bitstream extraction process \nIt is requirement of bitstream conformance that any sub-bitstream that is the output of the process specified in this clause \nwith pIdTarget equal to any value in the range of 0 to 63, inclusive, tIdTarget equal to any value in the range of 0 to 7, \ninclusive, viewIdTargetList consisting of any one or more values of viewIdTarget identifying the views in the bitstream, \nshall be conforming to this Recommendation | International Standard. \nNOTE 1 – A conforming bitstream contains one or more coded slice NAL units with priority_id equal to 0 and temporal_id equal \nto 0. \nNOTE 2 – It is possible that not all operation points of sub-bitstreams resulting from the sub-bitstream extraction process have an \napplicable level_idc or level_idc[ i ]. In this case, each coded video sequence in a sub-bitstream must still conform to one or more \nof the profiles specified in Annex A and Annex H, but may not satisfy the level constraints specified in clauses A.3 and H.10.2, \nrespectively. \n    Rec. ITU-T H.264 (06/2019)  681 \n \nInputs to this process are: \n–  a variable pIdTarget (when present), \n–  a variable tIdTarget (when present), \n–  a list viewIdTargetList consisting of one or more values of viewIdTarget (when present). \nOutputs of this process are a sub-bitstream and a list of VOIdx values VOIdxList. \nWhen pIdTarget is not present as input to this clause, pIdTarget is inferred to be equal to 63. \nWhen tIdTarget is not present as input to this clause, tIdTarget is inferred to be equal to 7. \nWhen  viewIdTargetList is not present as input to this  clause, there shall be one  value of viewIdTarget inferred in \nviewIdTargetList and the value of viewIdTarget is inferred to be equal to view_id of the base view. \nThe sub-bitstream is derived by applying the following operations in sequential order: \n1.  Let VOIdxList be empty and minVOIdx be the VOIdx value of the base view. \n2.  For each value of viewIdTarget included in viewIdTargetList, invoke the process specified in clause H.8.5.1 with \nthe value of viewIdTarget as input. \n3.  For each value of viewIdTarget included in viewIdTargetList, invoke the process specified in clause H.8.5.2 with \nthe value of viewIdTarget as input. \n4.  Mark all VCL NAL units and filler data NAL units for which any of the following conditions are true as \"to be \nremoved from the bitstream\": \n–  priority_id is greater than pIdTarget, \n–  temporal_id is greater than tIdTarget, \n–  view_id is not in the viewIdTargetList. \n5.  Remove all access units for which all VCL NAL units are marked as \"to be removed from the bitstream\". \n6.  Remove all VCL NAL units and filler data NAL units that are marked as \"to be removed from the bitstream\". \n7.  When VOIdxList contains only one value of VOIdx that is equal to minVOIdx, remove the following NAL units: \n–  all NAL units with nal_unit_type equal to 14 or 15, \n–  all NAL units with nal_unit_type equal to 6 in which the first SEI message has payloadType in the range \nof 36 to 44, inclusive, or equal to 46. \nNOTE 3 – When VOIdxList contains only one value of VOIdx equal to minVOIdx, the sub-bitstream contains only the base \nview or only a temporal subset of the base view. \n8.  Let maxTId be the maximum temporal_id of all the remaining VCL NAL units. Remove all NAL units with \nnal_unit_type equal to 6 that only contain SEI messages that are part of an MVC scalable nesting SEI message \nwith any of the following properties: \n–  operation_point_flag  is  equal  to 0  and  all_view_components_in_au_flag  is  equal  to 0  and  none  of \nsei_view_id[ i ] for all i in the range of 0 to num_view_components_minus1, inclusive, corresponds to a \nVOIdx value included in VOIdxList, \n–  operation_point_flag is equal to 1 and either sei_op_temporal_id is greater than  maxTId  or the list of \nsei_op_view_id[ i ] for all i in the range of 0 to num_view_components_op_minus1, inclusive, is not a subset \nof  viewIdTargetList  (i.e.,  it  is  not  true  that  sei_op_view_id[ i ]  for  any  i  in  the  range  of 0  to \nnum_view_components_op_minus1, inclusive, is equal to a value in viewIdTargetList). \n9.  Remove each view scalability information SEI message and each operation point not present SEI message, when \npresent. \n10.  When VOIdxList does not contain a value of VOIdx equal to minVOIdx, the view with VOIdx equal to the \nminimum VOIdx value included in VOIdxList is converted to the base view of the extracted sub-bitstream. An \ninformative procedure that outlines key processing steps to create a base view is described in clause H.8.5.5. \nNOTE 4 – When VOIdxList does not contain a value of VOIdx equal to minVOIdx, the resulting sub-bitstream \naccording to the operation steps 1-9 above does not contain a base view that conforms to one or more profiles specified \nin Annex A. In this case, by this operation step, the remaining view with the new minimum VOIdx value is converted \nto be the new base view that conforms to one or more profiles specified in Annex A. \n682  Rec. ITU-T H.264 (06/2019) \n \nH.8.5.4  Specification of the base view bitstream \nA bitstream that conforms to one or more profiles as specified in Annex H shall contain a base view bitstream that conforms \nto one or more of the profiles specified in Annex A. This base view bitstream is derived by invoking the sub-bitstream \nextraction process as specified in clause H.8.5.3 with no input and the base view bitstream being the output. \nNOTE – Although all multiview bitstreams that conform to one or more of the profiles specified in this annex contain a base view \nbitstream that conforms to one or more of the profiles specified in Annex A, the complete multiview bitstream (prior to operation of \nthe base view extraction process specified in this clause) may not conform to any profile specified in Annex A. \nH.8.5.5  Creation of a base view during sub-bitstream extraction (informative) \nAccording to the sub-bitstream extraction process specified in clause H.8.5.3, the resulting sub-bitstream shall contain a \nbase view. When the resulting bitstream does not contain a base view, the following procedure may be used to create a \nbase view during sub-bitstream extraction. \nWhen VOIdxList does not contain a value of VOIdx equal to minVOIdx, let newBaseViewId be equal to the view_id for \nwhich the VOIdx value is equal to the minimum VOIdx value included in VOIdxList, and apply the following operations \nin sequential order: \n1.  Remove all NAL units with nal_unit_type equal to 7. \n2.  For all subset sequence parameter set NAL units (with nal_unit_type equal to 15) that are referred to by at least \none  remaining  VCL  NAL  unit  with  view_id  equal  to  newBaseViewId,  apply  the  following  operations  in \nsequential order: \na.  Set nal_unit_type to 7. \nb.  Set profile_idc to 100. \nc.  Set  level_idc  to  level_idc[ i ],  with  i  equal  to  the  value  that  for  one  value  of  j  in  the  range  of 0  to \nnum_applicable_ops_minus1[ i ],  inclusive,  applicable_op_temporal_id[ i ][ j ]  is  equal  to  maxTId, \napplicable_op_num_target_views_minus1[ i ][ j ]  is  equal  to 0,  and \napplicable_op_target_view_id[ i ][ j ][ k ] for k equal to 0 is equal to newBaseViewId. \nd.  Remove all the syntax elements after the syntax structure seq_parameter_set_data( ) and before the syntax \nstructure rbsp_trailing_bits( ), and change RBSP trailing bits appropriately. \n3.  Remove all SEI NAL units (with nal_unit_type equal to 6) for which the first contained SEI message has \npayloadType in the range of 0 to 23, inclusive. \n4.  For each SEI NAL unit (with nal_unit_type equal to 6) containing an MVC scalable nesting SEI message, the \nfollowing operations are applied in sequential order: \na.  When none of the following properties is true for the MVC scalable nesting SEI message, the SEI NAL unit \nis removed: \n–  operation_point_flag is equal to 0 and all_view_components_in_au_flag is equal to 1, \n–  operation_point_flag is equal to 0, all_view_components_in_au_flag is equal to 0, and at least one of \nthe values of sei_view_id[ i ] for all i in the range of 0 to num_view_components_minus1, inclusive, is \nequal to the value of one of the viewIdTarget's in viewIdTargetList, \n–  operation_point_flag is equal to 1, sei_op_temporal_id is equal to or less than maxtIdT, and the list of \nsei_op_view_id[ i ] for all i in the range of 0 to num_view_components_op_minus1, inclusive, is a \nsubset  of  viewIdTargetList  (i.e.,  it  is  true  that  sei_op_view_id[ i ]  for  any  i  in  the  range  of 0  to \nnum_view_components_op_minus1, inclusive, is equal to a value in viewIdTargetList). \nb.  When the SEI NAL unit is not removed, the following applies: \n–  If VOIdxList contains only one VOIdx value, the SEI NAL unit is replaced by an SEI NAL unit \ncontaining only the original nested SEI message not as part of an MVC scalable nesting SEI message. \n–  Otherwise (VOIdxList contains more than one VOIdx value), when any of the following properties is \ntrue for the MVC scalable nesting SEI message, a new SEI NAL unit containing only the nested SEI \nmessage not as part of an MVC scalable nesting SEI message is generated and inserted immediately \nbefore the original SEI NAL unit in decoding order: \n–  operation_point_flag is equal to 0 and all_view_components_in_au_flag is equal to 1, \n–  operation_point_flag is equal to 0, all_view_components_in_au_flag is equal to 0, and for the \nvalues of sei_view_id[ i ] for all i in the range of 0 to num_view_components_minus1, inclusive, \n    Rec. ITU-T H.264 (06/2019)  683 \n \none is equal to newBaseViewId, and at least another one is equal to the value of one of the \nviewIdTarget's in viewIdTargetList. \n5.  When VOIdxList contains only one value of VOIdx, remove the following NAL units: \n–  all NAL units with nal_unit_type equal to 15, \n–  all NAL units with nal_unit_type equal to 6 in which the first SEI message has payloadType in the range \nof 36 to 44, inclusive. \n6.  For each NAL unit nalUnit with nal_unit_type equal to 20 and view_id equal to newBaseViewId, the following \noperations are applied in sequential order: \na.  Depending on non_idr_flag, the following applies: \n–  If non_idr_flag is equal to 0, set nal_unit_type equal to 5. \n–  Otherwise (non_idr_flag is equal to 1), set nal_unit_type equal to 1. \nb.  When VOIdxList contains more than one VOIdx value, generate a prefix NAL unit with the same NAL unit \nheader (including NAL unit header MVC extension) as the NAL unit nalUnit, except that nal_unit_type is \nset to 14 and priority_id may be changed, and insert the prefix NAL unit immediately before the NAL unit \nnalUnit in decoding order. After the last application of this operation, at least one of all the inserted prefix \nNAL units by the applications of this operation shall have priority_id equal to 0. \nc.  Remove the NAL unit header MVC extension of nalUnit. \nH.8.6  MFC enhanced resolution picture reconstruction \nThis clause does not form an integral part of this Recommendation | International Standard. \nThis informative clause describes a process for reconstructing the enhanced resolution stereo views from the coded video \nsequences conforming to the MFC High profile. The process is applied to each colour component independently. \nInputs of this process are: \n–  a (refW)x(refH) modified inter-view prediction reference picture sample array RpuPicture derived in clause H.8.4.1, \n–  a (RpuW)x(RpuH) cropped decoded picture sample array decBasePicture for a luma or a chroma component of the \nbase view component with VOIdx equal to 0, \n–  a (RpuW)x(RpuH) cropped decoded picture sample array decEnhPicture for a luma or a chroma component of the \nview component with VOIdx equal to 1. \nOutputs of this process are: \n–  a (RpuW)x(RpuH) enhanced resolution picture sample array leftPicture for a luma or a chroma component of the left \nview, \n–  a (RpuW)x(RpuH) enhanced resolution picture sample array rightPicture for a luma or a chroma component of the \nright view. \nThe  input  sample  array  decBasePicture  is  the  output  cropped  picture  of  the  decoded  sample  arrays  S ,  S   or  S  \nL Cb Cr\nrespectively for each colour component derived in clause 8.7 for a decoded frame or complementary field pair or field of \na decoded frame from a base view. The input sample array decEnhPicture is the output cropped picture of the decoded \nsample  arrays  S ,  S   or  S   respectively  for  each  colour  component  derived  in  clause 8.7  for  a decoded  frame  or \nL Cb Cr\ncomplementary field pair or field of a decoded frame of a non- base view. \nDepending on the value of rpu_field_processing_flag, the following applies: \n–  If rpu_field_processing_flag is equal to 1, the modified inter-view prediction reference picture RpuPicture is a field, \nthe  cropped  decoded  view  component  of  the  base  view,  decBasePicture,  is  a  field,  the  cropped  decoded  view \ncomponent of the non-base view, decEnhPicture, is a field, the enhanced resolution left view picture leftPicture is a \nfield,  the  enhanced  resolution  right  view  picture  rightPicture  is  a  field,  and  the  enhanced  resolution  picture \nreconstruction is applied to the individual fields separately. \n–  Otherwise (rpu_field_processing_flag is equal to 0), the modified inter-view prediction reference picture RpuPicture \nis a frame, the cropped decoded view component of the base view, decBasePicture, is a frame, the cropped decoded \nview component of the non-base view, decEnhPicture, is a frame, the enhanced resolution left view picture leftPicture \nis a frame, the enhanced resolution right view picture rightPicture is a frame, and the enhanced resolution picture \nreconstruction is applied to the frame. \n684  Rec. ITU-T H.264 (06/2019) \n \nThe mathematical function Clip1( ) is defined with Clip1( ) being substituted with Clip1 ( ) for the luma component and \nY\nClip1( ) being substituted with Clip1 ( ) for the chroma components, respectively. \nC\nThe  variable  tVal  is  set  equal  to  ( 1  <<  ( BitDepth  − 1 ) )  for  the  luma  component  and  tVal  is  set  equal  to \nY\n( 1  <<  ( BitDepth  − 1 ) ) for a chroma component, respectively. \nC\nLet upBasePic[ x, y ] be an (RpuW)x(RpuH) array of samples with x = 0..RpuW − 1 and y = 0..RpuH − 1. \nLet resPicture[ x, y ] be an (RpuW)x(RpuH) array of samples with x = 0..RpuW − 1 and y = 0..RpuH − 1. \nLet upResPic[ x, y ] be an (RpuW)x(RpuH) array of samples with x = 0..RpuW − 1 and y = 0..RpuH − 1. \n–  If mfc_format_idc is equal to 0, let tempDecBasePic[ x, y ] be a (SbsV)x(RpuH) array of samples with x = 0..SbsV − 1 \nand y = 0..RpuH − 1, tempDecEnhPic[ x, y ] be a (RpuW)x(TabV) array of samples with x = 0..RpuW − 1 and \ny = 0..TabV − 1,  and  tempRpuPic[ x, y ]  be  a  (RpuW)x(TabV)  array  of  samples  with  x  =  0..RpuW − 1  and \ny = 0..TabV − 1. \n–  Otherwise (mfc_format_idc is equal to 1), let tempDecBasePic[ x, y ] be a (RpuW)x(TabV) array of samples with \nx = 0..RpuW − 1  and  y  =  0..TabV − 1,  tempDecEnhPic[ x, y ]  be  a  (SbsV)x(RpuH)  array  of  samples  with \nx = 0..SbsV − 1  and  y  =  0..RpuH − 1,  and  tempRpuPic[ x, y ]  be  a  (SbsV)x(RpuH)  array  of  samples  with \nx = 0..SbsV − 1 and y = 0..RpuH − 1. \nThe  samples  of  enhanced  resolution  picture  sample  array  for  the  left  view  leftPicture[ x, y ]  and  the  right  view \nrightPicture[ x, y ] with x = 0..RpuW − 1 and y = 0..RpuH − 1 are derived as follows: \n–  If mfc_format_idc is equal to 0, the following applies: \n1.  leftPicture[ x, y ]  with  x  =  0..RpuW − 1  and  y  =  0..RpuH − 1  is  derived  from  the  input  of  the  arrays \ndecBasePicture[ x, y ] with x = 0..SbsV − 1 and y = 0..RpuH − 1, decEnhPicture[ x, y ] with x = 0..RpuW − 1 and \ny  =  0..TabV − 1  and  RpuPicture[ x, y ]  with  x  =  leftOffset..RpuW − 1 + leftOffset  and \ny = topOffset..TabV − 1 + topOffset as specified by the following ordered steps: \na.  tempDecBasePic[ x, y ] = decBasePicture[ x, y ]  (H-42) \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1 \nb.  tempDecEnhPic[ x, y ] = decEnhPicture[ x, y ]  (H-43) \nwith x = 0..RpuW − 1 and y = 0..TabV − 1 \nc.  tempRpuPic[ x, y ] = RpuPicture[ x + leftOffset, y + topOffset ]  (H-44) \nwith x = 0..RpuW− 1 and y = 0..TabV − 1 \nd.  Apply the following one-dimensional upsampling process: \ngMin = − 2 − View0OffsetX  (H-45) \nupBasePic[ 2 * x + view0OffsetX, y ] = tempDecBasePic[ x, y ]  (H-46) \nupBasePic[ 2 * x + ( 1 − view0OffsetX ), y ] = \n      Clip1( ( 3 * tempDecBasePic[ Clip3( 0, x + gMin, SbsV − 1 ), y ] − \n      17 * tempDecBasePic[ Clip3( 0, x + gMin + 1, SbsV − 1 ), y ] + \n      78 * tempDecBasePic[ Clip3( 0, x + gMin + 2, SbsV − 1 ), y ] + \n      78 * tempDecBasePic[ Clip3( 0, x + gMin + 3, SbsV − 1 ), y ] − \n      17 * tempDecBasePic[ Clip3( 0, x + gMin + 4, SbsV − 1 ), y ] + \n      3 * tempDecBasePic[ Clip3( 0, x + gMin + 5, SbsV − 1 ), y ] + 64 )  >>  7 )  (H-47) \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1 \ne.  resPicture[ x, y ] = Clip3( − tVal, tVal − 1, ( tempDecEnhPic[ x, y ] − tempRpuPic[ x, y ] ) )  (H-48) \nwith x = 0..RpuW − 1 and y = 0..TabV − 1 \nf.  Apply the following one-dimensional upsampling process: \nupResPic[ x, 2 * y] = resPicture[ x, y ]  (H-49) \nupResPic[ x, 2 * y + 1 ] = \n      Clip3( − tVal, tVal − 1, ( 3 * resPicture[ x, Clip3( 0,y − 2, TabV − 1 ) ] − \n      17 * resPicture[ x, Clip3( 0,y − 1, TabV − 1 ) ] + \n      78 * resPicture[ x, Clip3( 0, y, TabV − 1 ) ] + \n      78 * resPicture[ x, Clip3( 0, y + 1, TabV − 1 ) ] − \n    Rec. ITU-T H.264 (06/2019)  685 \n \n      17 * resPicture[ x, Clip3( 0,y + 2, TabV − 1 ) ] + \n      3 * resPicture[ x, Clip3( 0, y + 3, TabV − 1 ) ] + 64 )  >>  7 ) )  (H-50) \nwith x = 0..RpuW − 1 and y = 0..TabV − 1 \ng.  leftPicture[ x, y ] = Clip1( upBasePic[ x, y ] + upResPic[ x, y ] )  (H-51) \nwith x = 0..RpuW − 1 and y = 0..RpuH − 1 \n2.  rightPicture[ x, y ]  with  x  =  0..RpuW − 1  and  y  =  0..RpuH − 1  is  derived  from  the  input  of  the  arrays \ndecBasePicture[ x, y ]  with  x  =  SbsV..RpuW − 1  and  y  =  0..RpuH − 1,  decEnhPicture[ x, y ]  with \nx = 0..RpuW − 1 and y = TabV..RpuH − 1 and RpuPicture[ x, y ] with x = leftOffset..RpuW − 1 + leftOffset and \ny = TabV + topOffset..RpuH − 1 + topOffset as specified by the following ordered steps: \na.  tempDecBasePic[ x, y ] = decBasePicture[ x + SbsV, y ]  (H-52) \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1 \nb.  tempDecEnhPic[ x, y ] = decEnhPicture[ x, y + TabV ]  (H-53) \nwith x = 0..RpuW − 1 and y = 0..TabV − 1 \nc.  tempRpuPic[ x, y ] = RpuPicture[ x + leftOffset, y + TabV + topOffset ]  (H-54) \nwith x = 0..RpuW− 1 and y = 0..TabV − 1 \nd.  Apply the following one-dimensional upsampling process: \ngMin = − 2 − View1OffsetX,  (H-55) \nupBasePic[ 2 * x + view1OffsetX, y ] = tempDecBasePic[ x, y ],  (H-56) \nupBasePic[ 2 * x + ( 1 − view1OffsetX ), y ] = \n      Clip1( ( 3 * tempDecBasePic[ Clip3( 0, x + gMin, SbsV − 1 ), y ] − \n      17 * tempDecBasePic[ Clip3( 0, x + gMin + 1, SbsV − 1 ), y ] + \n      78 * tempDecBasePic[ Clip3( 0, x + gMin + 2, SbsV − 1 ), y ] + \n      78 * tempDecBasePic[ Clip3( 0, x + gMin + 3, SbsV − 1 ), y ] − \n      17 * tempDecBasePic[ Clip3( 0, x + gMin + 4, SbsV − 1 ), y ] + \n      3 * tempDecBasePic[ Clip3( 0, x + gMin + 5, SbsV − 1 ), y ] + 64 )  >>  7 )  (H-57) \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1 \ne.  resPicture[ x, y ] = Clip3( − tVal, tVal − 1, ( tempDecEnhPic[ x, y ] − tempRpuPic[ x, y ] ) )  (H-58) \nwith x = 0..RpuW − 1 and y = 0..TabV − 1 \nf.  Apply the following one-dimensional upsampling process: \nupResPic[ x, 2 * y] = resPicture[ x, y ]  (H-59) \nupResPic[ x, 2 * y + 1 ] = \n      Clip3( − tVal, tVal − 1, ( 3 * resPicture[ x, Clip3( 0,y − 2, TabV − 1 ) ] − \n      17 * resPicture[ x, Clip3( 0, y − 1, TabV − 1 ) ] + \n      78 * resPicture[ x, Clip3( 0, y, TabV − 1 ) ] + \n      78 * resPicture[ x, Clip3( 0, y + 1, TabV − 1 ) ] − \n      17 * resPicture[ x, Clip3( 0,  y + 2, TabV − 1 ) ] + \n      3 * resPicture[ x, Clip3( 0, y + 3, TabV − 1 ) ] + 64 )  >>  7 ) )  (H-60) \nwith x = 0..RpuW − 1 and y = 0..TabV − 1 \ng.  rightPicture[ x, y ] = Clip1( upBasePic[ x, y ] + upResPic[ x, y ] )  (H-61) \nwith x = 0..RpuW − 1 and y = 0..RpuH − 1 \n–  Otherwise ( mfc_format_idc is equal to 1 ), the following applies: \n1.  leftPicture[ x, y ]  with  x  =  0..RpuW − 1  and  y  =  0..RpuH − 1  is  derived  from  the  input  of  the  arrays \ndecBasePicture[ x, y ] with x = 0..RpuW − 1 and y = 0..TabV − 1, decEnhPicture[ x, y ] with x = 0..SbsV − 1 and \ny  =  0..RpuH − 1  and  RpuPicture[ x, y ]  with  x  =  leftOffset..SbsV − 1 + leftOffset  and \ny = topOffset..RpuH − 1 + topOffset as specified by the following ordered steps: \na.  tempDecBasePic[ x, y ] = decBasePicture[ x, y ]  (H-62) \nwith x = 0..RpuW − 1 and y = 0..TabV − 1 \n686  Rec. ITU-T H.264 (06/2019) \n \nb.  tempDecEnhPic[ x, y ] = decEnhPicture[ x, y ]  (H-63) \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1 \nc.  tempRpuPic[ x, y ] = RpuPicture[ x + leftOffset, y + topOffset ]  (H-64) \nwith x = 0..SbsV− 1 and y = 0..RpuH − 1 \nd.  Apply the following one-dimensional upsampling process: \ngMin = − 2 − View0OffsetY  (H-65) \nupBasePic[ x, 2 * y + view0OffsetY ] = tempDecBasePic[ x, y ]  (H-66) \nupBasePic[ x , 2 * y + ( 1 − view0OffsetY ) ] = \n      Clip1( ( 3 * tempDecBasePic[ x, Clip3( 0, y + gMin, TabV − 1 ) ] − \n      17 * tempDecBasePic[ x, Clip3( 0, y + gMin + 1, TabV − 1 ) ] + \n      78 * tempDecBasePic[ x, Clip3( 0, y + gMin + 2, TabV − 1 ) ] + \n      78 * tempDecBasePic[ x, Clip3( 0, y + gMin + 3, TabV − 1 ) ] − \n      17 * tempDecBasePic[ x, Clip3( 0, y + gMin + 4, TabV − 1 ) ] + \n      3 * tempDecBasePic[ x, Clip3( 0, y + gMin + 5, TabV − 1 ) ] + 64 )  >>  7 )  (H-67) \nwith x = 0..RpuW − 1 and y = 0..TabV − 1 \ne.  resPicture[ x, y ] = Clip3( − tVal, tVal − 1, ( tempDecEnhPic[ x, y ] − tempRpuPic[ x, y ] ) )  (H-68) \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1 \nf.  Apply the following one-dimensional upsampling process: \nupResPic[ 2 * x, y ] = resPicture[ x, y ]  (H-69) \nupResPic[ 2 * x + 1, y ] = \n      Clip3(− tVal, tVal − 1, ( 3 * resPicture[ Clip3( 0, x − 2, TabV − 1 ), y ] − \n      17 * resPicture[ Clip3( 0, x − 1, SbsV − 1 ), y ] + \n      78* resPicture[ Clip3( 0, x, SbsV − 1 ), y ] + \n      78* resPicture[ Clip3( 0, x + 1, SbsV − 1 ), y ] − \n      17 * resPicture[ Clip3( 0, x + 2, SbsV − 1 ), y ] + \n      3* resPicture[ Clip3( 0, x + 3, SbsV − 1 ), y ] + 64 )  >>  7 ) )  (H-70) \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1 \ng.  leftPicture[ x, y ] = Clip1( upBasePic[ x, y ] + upResPic[ x, y ] )  (H-71) \nwith x = 0..RpuW − 1 and y = 0..RpuH − 1 \n2.  rightPicture[ x, y ]  with  x  =  0..RpuW − 1  and  y  =  0..RpuH − 1  is  derived  from  the  input  of  the  arrays \ndecBasePicture[ x, y ]  with  x  =  0..RpuW − 1  and  y  =  TabV..RpuH − 1,  decEnhPicture[ x, y ]  with \nx = SbsV..RpuW − 1  and  y  =  0..RpuH − 1  and  RpuPicture[ x, y ]  with \nx = SbsV + leftOffset..RpuW − 1 + leftOffset  and  y  =  topOffset..RpuH − 1 + topOffset  as  specified  by  the \nfollowing ordered steps: \na.  tempDecBasePic[ x, y ] = decBasePicture[ x, y + TabV ]  (H-72) \nwith x = 0..RpuW − 1 and y = 0..TabV − 1 \nb.  tempDecEnhPic[ x, y ] = decEnhPicture[ x + SbsV, y ]  (H-73) \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1 \nc.  tempRpuPic[ x, y ] = RpuPicture[ x + SbsV + leftOffset, y + topOffset ]  (H-74) \nwith x = 0..SbsV− 1 and y = 0..RpuH − 1 \nd.  Apply the following one-dimensional upsampling process: \ngMin = − 2 − View1OffsetY  (H-75) \nupBasePic[ x, 2 * y + view1OffsetY ] = tempDecBasePic[ x, y ]  (H-76) \nupBasePic[ x , 2 * y + ( 1 − view1OffsetY ) ] = \n      Clip1( ( 3 * tempDecBasePic[ x, Clip3( 0, y + gMin, TabV − 1 ) ] − \n      17 * tempDecBasePic[ x, Clip3( 0, y + gMin + 1, TabV − 1 ) ] + \n      78 * tempDecBasePic[ x, Clip3( 0, y + gMin + 2, TabV − 1 ) ] + \n    Rec. ITU-T H.264 (06/2019)  687 \n \n      78 * tempDecBasePic[ x, Clip3( 0, y + gMin + 3, TabV − 1 ) ] − \n      17 * tempDecBasePic[ x, Clip3( 0, y + gMin + 4, TabV − 1 ) ] + \n      3 * tempDecBasePic[ x, Clip3( 0, y + gMin + 5, TabV − 1 ) ] + 64 )  >>  7 )  (H-77) \nwith x = 0..RpuW − 1 and y = 0..TabV − 1 \ne.  resPicture[ x, y ] = Clip3( − tVal, tVal − 1, ( tempDecEnhPic[ x, y ] − tempRpuPic[ x, y ] ) )  (H-78) \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1 \nf.  Apply the following one-dimensional upsampling process: \nupResPic[ 2 * x, y ] = resPicture[ x, y ]  (H-79) \nupResPic[ 2 * x + 1, y ] =  \n      Clip3(− tVal, tVal − 1, ( 3 * resPicture[ Clip3( 0, x − 2, SbsV − 1 ), y ] − \n      17 * resPicture[ Clip3( 0, x − 1, SbsV − 1 ), y ] + \n      78* resPicture[ Clip3( 0, x, SbsV − 1 ), y ] + \n      78* resPicture[ Clip3( 0, x + 1, SbsV − 1 ), y ] − \n      17 * resPicture[ Clip3( 0, x + 2, SbsV − 1 ), y ] + \n      3* resPicture[ Clip3( 0, x + 3, SbsV − 1 ), y ] + 64 )  >>  7 ) )  (H-80) \nwith x = 0..SbsV − 1 and y = 0..RpuH − 1 \ng.  rightPicture[ x, y ] = Clip1( upBasePic[ x, y ] + upResPic[ x, y ] )  (H-81) \nwith x = 0..RpuW − 1 and y = 0..RpuH − 1 \nH.9  Parsing process \nThe specifications in clause 9 apply. \nH.10  Profiles and levels \nThe specifications in Annex A apply. Additional profiles and specific values of profile_idc are specified in the following. \nThe profiles that are specified in clause H.10.1 are also referred to as the profiles specified in Annex H. \nH.10.1  Profiles \nAll constraints for picture parameter sets that are specified in the following are constraints for picture parameter sets that \nbecome the active picture parameter set or an active view picture parameter set inside the bitstream. All constraints for \nMVC sequence parameter sets that are specified in the following are constraints for MVC sequence parameter sets that \nbecome the active MVC sequence parameter set or an active view MVC sequence parameter set inside the bitstream. \nH.10.1.1 Multiview High profile \nBitstreams conforming to the Multiview High profile shall obey the following constraints: \n–  The base view bitstream as specified in clause H.8.5.4 shall obey all constraints of the Progressive High profile \nspecified in clause A.2.4.1 and all active sequence parameter sets shall fulfil one or more of the following conditions: \n–  profile_idc is equal to 100 or 77 and constraint_set4_flag is equal to 1, \n–  (profile_idc is equal to 66 or constraint_set0_flag is equal to 1) and constraint_set1_flag is equal to 1, \n–  profile_idc is equal to 77 and constraint_set0_flag is equal to 1, \n–  profile_idc is equal to 88, constraint_set1_flag is equal to 1, and constraint_set4_flag is equal to 1. \n–  Only I, P, and B slice types may be present. \n–  NAL unit streams shall not contain nal_unit_type values in the range of 2 to 4, inclusive. \n–  MVC sequence parameter sets shall have frame_mbs_only_flag equal to 1. \n–  Arbitrary slice order is not allowed. \n–  Picture parameter sets shall have num_slice_groups_minus1 equal to 0 only. \n–  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0 only. \n–  MVC sequence parameter sets shall have chroma_format_idc in the range of 0 to 1 inclusive. \n–  MVC sequence parameter sets shall have bit_depth_luma_minus8 equal to 0 only. \n–  MVC sequence parameter sets shall have bit_depth_chroma_minus8 equal to 0 only. \n688  Rec. ITU-T H.264 (06/2019) \n \n–  MVC sequence parameter sets shall have qpprime_y_zero_transform_bypass_flag equal to 0 only. \n–  The level constraints specified for the Multiview High profile in clause H.10.2 shall be fulfilled. \nConformance of a bitstream to the Multiview High profile is indicated by profile_idc being equal to 118. \nDecoders conforming to the Multiview High profile at a specific level shall be capable of decoding all bitstreams in which \nboth of the following conditions are true: \na)  All active MVC sequence parameter sets have one or more of the following conditions fulfilled: \n–  profile_idc is equal to 118, \n–  profile_idc is equal to 100 or 77 and constraint_set4_flag is equal to 1, \n–  profile_idc is equal to 88, constraint_set1_flag is equal to 1, and constraint_set4_flag is equal to 1, \n–  profile_idc is equal to 77 and constraint_set0_flag is equal to 1, \n–  (profile_idc is equal to 66 or constraint_set0_flag is equal to 1) and constraint_set1_flag is equal to 1. \nb)  All active MVC sequence parameter sets have one or more of the following conditions fulfilled: \n–  level_idc or (level_idc and constraint_set3_flag) represent a level less than or equal to the specific level, \n–  level_idc[ i ] or (level_idc[ i ] and constraint_set3_flag) represent a level less than or equal to the specific level. \nH.10.1.2 Stereo High profile \nBitstreams conforming to the Stereo High profile shall obey the following constraints: \n–  The base view bitstream as specified in clause H.8.5.4 shall obey all constraints of the High profile specified in \nclause A.2.4 and all active sequence parameter sets shall fulfil one of the following conditions: \n–  profile_idc is equal to 77 or constraint_set1_flag is equal to 1, \n–  profile_idc is equal to 100. \n–  Only I, P, and B slice types may be present. \n–  NAL unit streams shall not contain nal_unit_type values in the range of 2 to 4, inclusive. \n–  Arbitrary slice order is not allowed. \n–  Picture parameter sets shall have num_slice_groups_minus1 equal to 0 only. \n–  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0 only. \n–  MVC sequence parameter sets shall have chroma_format_idc in the range of 0 to 1 inclusive. \n–  MVC sequence parameter sets shall have bit_depth_luma_minus8 equal to 0 only. \n–  MVC sequence parameter sets shall have bit_depth_chroma_minus8 equal to 0 only. \n–  MVC sequence parameter sets shall have qpprime_y_zero_transform_bypass_flag equal to 0 only. \n–  When num_views_minus1 is present in an MVC sequence parameter set, its value shall be less than 2. \n–  For each access unit, the value of level_idc for all active view MVC sequence parameter set RBSPs shall be the same \nas the value of level_idc for the active MVC sequence parameter set RBSP. \n–  The level constraints specified for the Stereo High profile in clause H.10.2 shall be fulfilled. \nConformance of a bitstream to the Stereo High profile is indicated by profile_idc being equal to 128. \nDecoders conforming to the Stereo High profile at a specific level shall be capable of decoding all bitstreams in which \nboth of the following conditions are true: \na)  All active MVC sequence parameter sets have one or more of the following conditions fulfilled: \n–  profile_idc is equal to 128, \n–  profile_idc is equal to 118 and constraint_set5_flag is equal to 1, \n–  profile_idc is equal to 100, \n–  profile_idc is equal to 77 or constraint_set1_flag is equal to 1. \nb)  All active MVC sequence parameter sets have one or more of the following conditions fulfilled: \n–  level_idc or (level_idc and constraint_set3_flag) represent a level less than or equal to the specific level, \n    Rec. ITU-T H.264 (06/2019)  689 \n \n–  level_idc[ i ] or (level_idc[ i ] and constraint_set3_flag) represent a level less than or equal to the specific level. \nH.10.1.3 MFC High profile \nBitstreams conforming to the MFC High profile shall obey the following constraints: \n–  The base view bitstream as specified in clause H.8.5.4 shall obey all constraints of the High profile specified in \nclause A.2.4 and all active sequence parameter sets shall fulfil one of the following conditions: \n–  profile_idc is equal to 77 or constraint_set1_flag is equal to 1, \n–  profile_idc is equal to 100. \n–  Only I, P, and B slice types may be present. \n–  NAL unit streams shall not contain nal_unit_type values in the range of 2 to 4, inclusive. \n–  Arbitrary slice order is not allowed. \n–  Picture parameter sets shall have num_slice_groups_minus1 equal to 0 only. \n–  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0 only. \n–  MVC sequence parameter sets shall have chroma_format_idc in the range of 0 to 1 inclusive. \n–  MVC sequence parameter sets shall have bit_depth_luma_minus8 equal to 0 only. \n–  MVC sequence parameter sets shall have bit_depth_chroma_minus8 equal to 0 only. \n–  MVC sequence parameter sets shall have qpprime_y_zero_transform_bypass_flag equal to 0 only. \n–  When num_views_minus1 is present in an MVC sequence parameter set, its value shall be less than 2. \n–  For each access unit, the value of level_idc for all active view MVC sequence parameter set RBSPs shall be the same \nas the value of level_idc for the active MVC sequence parameter set RBSP. \n–  The level constraints specified for the MFC High profile in clause H.10.2 shall be fulfilled. \nConformance of a bitstream to the MFC High profile is indicated by profile_idc being equal to 134. \nDecoders conforming to the MFC High profile at a specific level shall be capable of decoding all bitstreams in which both \nof the following conditions are true: \na)  All active MVC sequence parameter sets have one or more of the following conditions fulfilled: \n–  profile_idc is equal to 134, \n–  profile_idc is equal to 128, \n–  profile_idc is equal to 118 and constraint_set5_flag is equal to 1, \n–  profile_idc is equal to 100, \n–  profile_idc is equal to 77 or constraint_set1_flag is equal to 1. \nb)  All active MVC sequence parameter sets have one or more of the following conditions fulfilled: \n–  level_idc or (level_idc and constraint_set3_flag) represent a level less than or equal to the specific level, \n–  level_idc[ i ] or (level_idc[ i ] and constraint_set3_flag) represent a level less than or equal to the specific level. \nH.10.2  Levels \nThe following is specified for expressing the constraints in this clause: \n–  Let access unit n be the n-th access unit in decoding order with the first access unit being access unit 0. \n–  Let picture n be the primary coded picture or the corresponding decoded picture of access unit n. \nLet the variable fR be derived as follows: \n–  If the level number is equal to 6.0, 6.1, or 6.2, fR is set equal to 1 ÷ 300. \n–  Otherwise, if picture n is a frame, fR is set equal to 1 ÷ 172. \n–  Otherwise (picture n is a field), fR is set equal to 1 ÷ (172 * 2). \nThe value of mvcScaleFactor is set equal to 2. \n690  Rec. ITU-T H.264 (06/2019) \n \nThe value of NumViews is set equal to applicable_op_num_views_minus1[ i ][ j ] plus 1, which indicates the number of \nviews required for decoding the target output views corresponding to the j-th operation point for level_idc[ i ] as signalled \nin the subset sequence parameter set. \nH.10.2.1 Level limits common to Multiview High, Stereo High, and MFC High profiles \nBitstreams conforming to the Multiview High profile at a specified level shall obey the following constraints: \na)  The nominal removal time of access unit n (with n > 0) from the CPB as specified in clause C.1.2, satisfies the \nconstraint  that  t ( n ) − t ( n − 1 )  is  greater  than  or  equal \nr,n r\nto Max( NumViews * PicSizeInMbs ÷ ( mvcScaleFactor * MaxMBPS ), fR ),  where  MaxMBPS  is  the  value \nspecified in Table A-1 that applies to picture n − 1, and PicSizeInMbs is the number of macroblocks in a single \nview component of picture n − 1. \nb)  The difference between consecutive output times of pictures from the DPB as specified in clause C.2.2, satisfies \nthe  constraint  that  t ( n ) >= Max( NumViews * PicSizeInMbs ÷ ( mvcScaleFactor * MaxMBPS ),  fR ), \no,dpb\nwhere  MaxMBPS  is  the  value  specified  in  Table A-1  for  picture  n,  and  PicSizeInMbs  is  the  number  of \nmacroblocks of a single view component of picture n, provided that picture n is a picture that is output and is not \nthe last picture of the bitstream that is output. \nc)  PicWidthInMbs * FrameHeightInMbs <= MaxFS, where MaxFS is specified in Table A-1. \nd)  PicWidthInMbs <= Sqrt( MaxFS * 8 ), where MaxFS is specified in Table A-1. \ne)  FrameHeightInMbs <= Sqrt( MaxFS * 8 ), where MaxFS is specified in Table A-1. \nf)  max_dec_frame_buffering <= MaxDpbFrames,  where  MaxDpbFrames  is  equal  to \nMin( mvcScaleFactor * MaxDpbMbs / ( PicWidthInMbs * FrameHeightInMbs ), \nMax( 1, Ceil( log2( NumViews ) ) ) * 16 ) and MaxDpbMbs is specified in Table A-1. \ng)  The vertical motion vector component range for luma motion vectors does not exceed the range from −MaxVmvR \nto ( MaxVmvR − 0.25 ) in units of luma frame samples, where MaxVmvR is specified in Table A-1. \nh)  The horizontal motion vector component range for luma motion vectors does not exceed the following range: \n–  If the level number is less than 6.0, the specified range is from −2048 to 2047.75, inclusive, in units of luma \nsamples. \n–  Otherwise, the specified range is from −8192 to 8191.75, inclusive, in units of luma samples. \ni)  Let setOf2Mb be the set of unsorted pairs of macroblocks that contains the unsorted pairs of macroblocks \n(mbA, mbB) of a coded video sequence for which any of the following conditions are true: \n–  mbA and mbB are macroblocks that belong to the same slice and are consecutive in decoding order, \n–  separate_colour_plane_flag is equal to 0, mbA is the last macroblock (in decoding order) of a slice, and \nmbB is the first macroblock (in decoding order) of the next slice in decoding order, \n–  separate_colour_plane_flag is equal to 1, mbA is the last macroblock (in decoding order) of a slice with a \nparticular value of colour_plane_id, and mbB is the first macroblock (in decoding order) of the next slice \nwith the same value of colour_plane_id in decoding order. \nNOTE 1 – In the two above conditions, the macroblocks mbA and mbB can belong to different pictures. \nFor each unsorted pair of macroblocks (mbA, mbB) of the set setOf2Mb, the total number of motion vectors \n(given by the sum of the number of motion vectors for macroblock mbA and the number of motion vectors for \nmacroblock mbB) does not exceed MaxMvsPer2Mb, where MaxMvsPer2Mb is specified in  Table A-1. The \nnumber of motion vectors for each macroblock is the value of the variable MvCnt after the completion of the intra \nor inter prediction process for the macroblock. \nNOTE 2 – When separate_colour_plane_flag is equal to 0, the constraint specifies that the total number of motion \nvectors  for  two  consecutive  macroblocks  in  decoding  order  must  not  exceed  MaxMvsPer2Mb.  When \nseparate_colour_plane_flag is equal to 1, the constraint specifies that the total number of motion vectors for two \nconsecutive  macroblocks  with  the  same  value  of  colour_plane_id  in  decoding  order  must  not  exceed \nMaxMvsPer2Mb. For macroblocks that are consecutive in decoding order but are associated with a different value \nof colour_plane_id, no constraint for the total number of motion vectors is specified. \nj)  The number of bits of macroblock_layer( ) data for any macroblock is not greater than 128 + RawMbBits. \nDepending on entropy_coding_mode_flag, the bits of macroblock_layer( ) data are counted as follows: \n–  If entropy_coding_mode_flag is equal to 0, the number of bits of macroblock_layer( ) data is given by the \nnumber of bits in the macroblock_layer( ) syntax structure for a macroblock. \n    Rec. ITU-T H.264 (06/2019)  691 \n \n–  Otherwise (entropy_coding_mode_flag is equal to 1), the number of bits of macroblock_layer( ) data for a \nmacroblock is given by the number of times read_bits( 1 ) is called in clauses 9.3.3.2.2 and 9.3.3.2.3 when \nparsing the macroblock_layer( ) associated with the macroblock. \nk)  The removal time of access unit 0 shall satisfy the constraint that the number of slices in picture 0 is less than or \nequal  to  mvcScaleFactor * ( Max( PicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * ( t ( 0 ) − t ( 0 ) ) ) ÷ \nr r,n\nSliceRate, where MaxMBPS and SliceRate are the values specified in Tables A-1 and A-4, respectively, that \napply to picture 0 and PicSizeInMbs is the number of macroblocks in a single view component of picture 0. \nl)  The removal time of access unit 0 shall satisfy the constraint that the number of slices in each view component of \npicture  0  is  less  than  or  equal  to  ( Max( PicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * \n( t ( 0 ) − t ( 0 ) ) ) ÷ SliceRate, where MaxMBPS and SliceRate are the values specified in Tables A-1 and A-4, \nr r,n\nrespectively, that apply to picture 0 and PicSizeInMbs is the number of macroblocks in a single view component \nof picture 0. \nm)  The difference between consecutive removal times of access units n and n − 1 with n > 0 shall satisfy the constraint \nthat  the  number  of  slices  in  picture  n  is  less  than  or  equal  to \nmvcScaleFactor * MaxMBPS * ( t ( n ) − t ( n − 1 ) ) ÷ SliceRate,  where  SliceRate  is  the  value  specified  in \nr r\nTable A-4 that applies to picture n. \nn)  The difference between consecutive removal times of access units n and n − 1 with n > 0 shall satisfy the constraint \nthat  the  number  of  slices  in  each  view  component  of  picture  n  is  less  than  or  equal  to \nMaxMBPS * ( t ( n ) − t ( n − 1 ) ) ÷ SliceRate, where SliceRate is the value specified in Table A-4 that applies to \nr r\npicture n. \no)  MVC  sequence  parameter  sets  shall  have  direct_8x8_inference_flag  equal  to 1  for  the  levels  specified  in \nTable A-4. \np)  The value of sub_mb_type[ mbPartIdx ] with mbPartIdx = 0..3 in B macroblocks with mb_type equal to B_8x8 \nshall not be equal to B_Bi_8x4, B_Bi_4x8, or B_Bi_4x4 for the levels in which MinLumaBiPredSize is shown \nas 8x8 in Table A-4. \nq)  For  the  VCL  HRD  parameters,  BitRate[ SchedSelIdx ] <= cpbBrVclFactor * MaxBR  and \nCpbSize[ SchedSelIdx ] <= cpbBrVclFactor *MaxCPB  for  at  least  one  value  of  SchedSelIdx,  where \ncpbBrVclFactor is equal to 1250. With vui_mvc_vcl_hrd_parameters_present_flag[ i ] being the syntax element, \nin the MVC VUI parameters extension of the active MVC sequence parameter set, that is associated with the VCL \nHRD parameters that are used for conformance checking (as specified in Annex C), BitRate[ SchedSelIdx ] and \nCpbSize[ SchedSelIdx ] are given as follows: \n–  If  vui_mvc_vcl_hrd_parameters_present_flag  equal  to 1,  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are given by Equations E-53 and E-54, respectively, using the syntax elements of \nthe  hrd_parameters( )  syntax  structure  that  immediately  follows \nvui_mvc_vcl_hrd_parameters_present_flag. \n–  Otherwise  (vui_mvc_vcl_hrd_parameters_present_flag  equal  to  0),  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are inferred as specified in clause E.2.2 for VCL HRD parameters. \nMaxBR and MaxCPB are specified in Table A-1 in units of cpbBrVclFactor bits/s and cpbBrVclFactor bits, \nrespectively. The bitstream shall satisfy these conditions for at least one value of SchedSelIdx in the range 0 to \ncpb_cnt_minus1, inclusive. \nr)  For  the  NAL  HRD  parameters,  BitRate[ SchedSelIdx ] <= cpbBrNalFactor * MaxBR  and \nCpbSize[ SchedSelIdx ] <= cpbBrNalFactor *MaxCPB  for  at  least  one  value  of  SchedSelIdx,  where \ncpbBrNalFactor is equal to 1500. With vui_mvc_nal_hrd_parameters_present_flag[ i ] being the syntax element, \nin the MVC VUI parameters extension of the active MVC sequence parameter set, that is associated with the \nNAL HRD parameters that are used for conformance checking (as specified in Annex C), BitRate[ SchedSelIdx ] \nand CpbSize[ SchedSelIdx ] are given as follows: \n–  If  vui_mvc_nal_hrd_parameters_present_flag  equal  to 1,  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are given by Equations E-53 and E-54, respectively, using the syntax elements of \nthe  hrd_parameters( )  syntax  structure  that  immediately  follows \nvui_mvc_nal_hrd_parameters_present_flag. \n–  Otherwise  (vui_mvc_nal_hrd_parameters_present_flag  equal  to  0),  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are inferred as specified in clause E.2.2 for NAL HRD parameters. \nMaxBR and MaxCPB are specified in Table A-1 in units of cpbBrNalFactor bits/s and cpbBrNalFactor bits, \nrespectively. The bitstream shall satisfy these conditions for at least one value of SchedSelIdx in the range 0 to \ncpb_cnt_minus1, inclusive. \n692  Rec. ITU-T H.264 (06/2019) \n \ns)  The  sum  of  the  NumBytesInNALunit  variables  for  access  unit  0  is  less  than  or  equal  to \n384 * mvcScaleFactor * ( Max( PicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * ( t ( 0 ) − t ( 0 ) ) ) ÷ MinCR, \nr r,n\nwhere MaxMBPS and MinCR are the values specified in Table A-1 that apply to picture 0 and PicSizeInMbs is \nthe number of macroblocks in a single view component of picture 0. \nt)  The sum of the NumBytesInNALunit variables for the VCL NAL units of each view component of access unit 0 \nis  less  than  or  equal  to  384 * ( Max( PicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * ( t ( 0 ) − t ( 0 ) ) ) ÷ \nr r,n\nMinCR,  where  MaxMBPS  and  MinCR  are  the  values  specified  in  Table A-1  that  apply  to  picture  0  and \nPicSizeInMbs is the number of macroblocks in a single view component of picture 0. \nu)  The  sum  of  the  NumBytesInNALunit  variables  for  access  unit n  with  n  >  0  is  less  than  or  equal  to \n384 * mvcScaleFactor * MaxMBPS * ( t ( n ) − t ( n − 1 ) ) ÷ MinCR,  where  MaxMBPS  and  MinCR  are  the \nr r\nvalues specified in Table A-1 that apply to picture n. \nv)  The sum of the NumBytesInNALunit variables for the VCL NAL units of each view component of access unit n \nwith n > 0 is less than or equal to 384 * MaxMBPS * ( t ( n ) − t ( n − 1 ) ) ÷ MinCR, where MaxMBPS and \nr r\nMinCR are the values specified in Table A-1 that apply to picture n. \nw)  When PicSizeInMbs is greater than 1620, the number of macroblocks in any coded slice shall not exceed MaxFS \n/ 4, where MaxFS is specified in Table A-1. \nx)  max_num_ref_frames shall be less than or equal to MaxDpbFrames / mvcScaleFactor for each view component, \nwhere MaxDpbFrames is specified in item f). \nTable A-1 specifies the limits for each level. A definition of all levels identified in the \"Level number\" column of Table A-1 \nis specified for the Multiview High, Stereo High, and MFC High profiles. Table A-4 specifies limits for each level that are \nspecific to bitstreams conforming to the Multiview High, Stereo High, and MFC High profiles. Each entry in Tables A-1 \nand A-4 indicates, for the level corresponding to the row of the table, the absence or value of a limit that is imposed by the \nvariable corresponding to the column of the table, as follows: \n–  If the table entry is marked as \"-\", no limit is imposed by the value of the variable as a requirement of bitstream \nconformance to the profile at the specified level. \n–  Otherwise, the table entry specifies the value of the variable for the associated limit that is imposed as a requirement \nof bitstream conformance to the profile at the specified level. \nFor coded video sequences conforming to the Multiview High, Stereo High, or MFC High profile, the level_idc value is \nspecified as follows: \n–  If level_idc is not equal to 0, level_idc indicates the level that applies to the coded video sequence operating with all \nthe views being target output views. \nNOTE 3 – A level_idc value that is not equal to zero may indicate a higher level than necessary to decode the coded video \nsequence operating with all the views being target output views. This may occur when a subset of views or temporal subsets \nare removed from a coded video sequence according to the sub-bitstream extraction process specified in clause H.8.5.3, and \nthe level_idc value is not updated accordingly. \n–  Otherwise (level_idc is equal to 0), the level that applies to the coded video sequence operating with all the views \nbeing target output views is unspecified. \nNOTE 4 – When profile_idc is equal to 118, 128, or 134 and level_idc is equal to 0, there may exist a level indicated by \nlevel_idc[ i ] that is applicable to the coded video sequence operating with all the views being target output views. This may \noccur when a subset of views or temporal subsets are removed from a coded video sequence according to the sub-bitstream \nextraction process specified in clause H.8.5.3, and a particular value of level_idc[ i ] corresponds to the resulting coded video \nsequence. \nIn bitstreams conforming to the Multiview High, Stereo High, or MFC High profiles, the conformance of the bitstream to \na specified level is indicated by the syntax element level_idc or level_idc[ i ] as follows: \n–  If level_idc or level_idc[ i ] is equal to 9, the indicated level is level 1b. \n–  Otherwise (level_idc or level_idc[ i ] is not equal to 9), level_idc or level_idc[ i ] is equal to a value of ten times the \nlevel number (of the indicated level) specified in Table A-1. \nH.10.2.2 Profile specific level limits \na)  In bitstreams conforming to the Stereo High or MFC High profile, MVC sequence parameter sets shall have \nframe_mbs_only_flag equal to 1 for the levels specified in Table A-4. \nH.11  Byte stream format \nThe specifications in Annex B apply. \n    Rec. ITU-T H.264 (06/2019)  693 \n \nH.12  MVC hypothetical reference decoder \nThe specifications in Annex C apply with substituting MVC sequence parameter set for sequence parameter set. \nH.13  MVC SEI messages \nThe specifications in Annex D together with the extensions and modifications specified in this clause apply. \nH.13.1  SEI message syntax \nH.13.1.1 Parallel decoding information SEI message syntax \n \nparallel_decoding_info( payloadSize ) {  C  Descriptor \n  seq_parameter_set_id  5  ue(v) \n  for( i = 1; i <= num_views_minus1; i++ ) {     \n    if( anchor_pic_flag ) {     \n      for( j = 0; j <= num_anchor_refs_l0[ i ]; j++ )      \n        pdi_init_delay_anchor_minus2_l0[ i ][ j ]  5  ue(v) \n      for( j = 0; j <= num_anchor_refs_l1[ i ]; j++ )      \n        pdi_init_delay_anchor_minus2_l1[ i ][ j ]  5  ue(v) \n    }     \n    else {     \n      for( j = 0; j <= num_non_anchor_refs_l0[ i ]; j++ )      \n        pdi_init_delay_non_anchor_minus2_l0[ i ][ j ]  5  ue(v) \n      for( j = 0; j <= num_non_anchor_refs_l1[ i ]; j++ )      \n        pdi_init_delay_non_anchor_minus2_l1[ i ][ j ]  5  ue(v) \n    }     \n  }     \n}     \n \nH.13.1.2 MVC scalable nesting SEI message syntax \n \nmvc_scalable_nesting( payloadSize ) {  C  Descriptor \n  operation_point_flag  5  u(1) \n  if( !operation_point_flag ) {     \n    all_view_components_in_au_flag  5  u(1) \n    if( !all_view_components_in_au_flag ) {     \n      num_view_components_minus1  5  ue(v) \n      for( i = 0; i <= num_view_components_minus1; i++ )     \n        sei_view_id[ i ]  5  u(10) \n    }     \n  } else {     \n    num_view_components_op_minus1  5  ue(v) \n    for( i = 0; i <= num_view_components_op_minus1; i++ )     \n      sei_op_view_id[ i ]  5  u(10) \n    sei_op_temporal_id  5  u(3) \n  }     \n  while( !byte_aligned( ) )     \n    sei_nesting_zero_bit /* equal to 0 */  5  f(1) \n  sei_message( )  5   \n}     \n694  Rec. ITU-T H.264 (06/2019) \n \n \nH.13.1.3  View scalability information SEI message syntax \n \nview_scalability_info( payloadSize ) {  C  Descriptor \n  num_operation_points_minus1  5  ue(v) \n  for( i = 0; i <= num_operation_points_minus1; i++ ) {     \n    operation_point_id[ i ]  5  ue(v) \n    priority_id[ i ]  5  u(5) \n    temporal_id[ i ]  5  u(3) \n    num_target_output_views_minus1[ i ]  5  ue(v) \n    for( j = 0; j <= num_target_output_views_minus1[ i ]; j++ )      \n      view_id[ i ][ j ]  5  ue(v) \n    profile_level_info_present_flag[ i ]  5  u(1) \n    bitrate_info_present_flag[ i ]  5  u(1) \n    frm_rate_info_present_flag[ i ]  5  u(1) \n    if( !num_target_output_views_minus1[ i ] )      \n      view_dependency_info_present_flag[ i ]  5  u(1) \n    parameter_sets_info_present_flag[ i ]  5  u(1) \n    bitstream_restriction_info_present_flag[ i ]  5  u(1) \n    if( profile_level_info_present_flag[ i ] )     \n      op_profile_level_idc[ i ]   5  u(24) \n    if( bitrate_info_present_flag[ i ] ) {     \n      avg_bitrate[ i ]  5  u(16) \n      max_bitrate[ i ]  5  u(16) \n      max_bitrate_calc_window[ i ]  5  u(16) \n    }     \n    if( frm_rate_info_present_flag[ i ] ) {     \n      constant_frm_rate_idc[ i ]  5  u(2) \n      avg_frm_rate[ i ]  5  u(16) \n    }     \n    if( view_dependency_info_present_flag[ i ] ) {     \n      num_directly_dependent_views[ i ]  5  ue(v) \n      for( j = 0; j < num_directly_dependent_views[ i ]; j++ )     \n        directly_dependent_view_id[ i ][ j ]  5  ue(v) \n    } else     \n      view_dependency_info_src_op_id[ i ]  5  ue(v) \n    if( parameter_sets_info_present_flag[ i ] ) {     \n      num_seq_parameter_sets[ i ]  5  ue(v) \n      for( j = 0; j < num_seq_parameter_sets[ i ]; j++ )     \n        seq_parameter_set_id_delta[ i ][ j ]  5  ue(v) \n      num_subset_seq_parameter_sets[ i ]  5  ue(v) \n      for( j = 0; j < num_subset_seq_parameter_sets[ i ]; j++ )     \n        subset_seq_parameter_set_id_delta[ i ][ j ]  5  ue(v) \n      num_pic_parameter_sets_minus1[ i ]  5  ue(v) \n      for( j = 0; j <= num_pic_parameter_sets_minus1[ i ]; j++ )     \n        pic_parameter_set_id_delta[ i ][ j ]  5  ue(v) \n    } else     \n    Rec. ITU-T H.264 (06/2019)  695 \n \n      parameter_sets_info_src_op_id[ i ]  5  ue(v) \n    if( bitstream_restriction_info_present_flag[ i ] ) {     \n      motion_vectors_over_pic_boundaries_flag[ i ]  5  u(1) \n      max_bytes_per_pic_denom[ i ]  5  ue(v) \n      max_bits_per_mb_denom[ i ]  5  ue(v) \n      log2_max_mv_length_horizontal[ i ]  5  ue(v) \n      log2_max_mv_length_vertical[ i ]  5  ue(v) \n      max_num_reorder_frames[ i ]  5  ue(v) \n      max_dec_frame_buffering[ i ]  5  ue(v) \n    }     \n  }     \n}     \n \nH.13.1.4  Multiview scene information SEI message syntax \n \nmultiview_scene_info( payloadSize ) {  C  Descriptor \n  max_disparity  5  ue(v) \n}     \n \nH.13.1.5  Multiview acquisition information SEI message syntax \n \nmultiview_acquisition_info( payloadSize ) {  C  Descriptor \n  num_views_minus1    ue(v) \n  intrinsic_param_flag  5  u(1) \n  extrinsic_param_flag  5  u(1) \n  if( instrinsic_param_flag ) {     \n    intrinsic_params_equal  5  u(1) \n    prec_focal_length  5  ue(v) \n    prec_principal_point  5  ue(v) \n    prec_skew_factor  5  ue(v) \n    if( intrinsic_params_equal )      \n      num_of_param_sets = 1     \n    else      \n      num_of_param_sets = num_views_minus1 + 1     \n    for( i = 0; i < num_of_param_sets; i++ ) {     \n      sign_focal_length_x[ i ]  5  u(1) \n      exponent_focal_length_x[ i ]  5  u(6) \n      mantissa_focal_length_x[ i ]   5  u(v) \n      sign_focal_length_y[ i ]  5  u(1) \n      exponent_focal_length_y[ i ]  5  u(6) \n      mantissa_focal_length_y[ i ]  5  u(v) \n      sign_principal_point_x[ i ]  5  u(1) \n      exponent_principal_point_x[ i ]  5  u(6) \n      mantissa_principal_point_x[ i ]  5  u(v) \n      sign_principal_point_y[ i ]  5  u(1) \n      exponent_principal_point_y[ i ]  5  u(6) \n      mantissa_principal_point_y[ i ]   5  u(v) \n696  Rec. ITU-T H.264 (06/2019) \n \n      sign_skew_factor[ i ]  5  u(1) \n      exponent_skew_factor[ i ]  5  u(6) \n      mantissa_skew_factor[ i ]  5  u(v) \n    }     \n  }     \n  if( extrinsic_param_flag ) {     \n    prec_rotation_param  5  ue(v) \n    prec_translation_param  5  ue(v) \n    for( i = 0; i <= num_views_minus1; i++ ) {     \n      for( j = 1; j <= 3; j++ ) { /* row */     \n        for( k = 1; k <= 3; k++ ) { /* column */     \n          sign_r[ i ][ j ][ k ]  5  u(1) \n          exponent_r[ i ][ j ][ k ]  5  u(6) \n          mantissa_r[ i ][ j ][ k ]  5  u(v) \n        }     \n        sign_t[ i ][ j ]  5  u(1) \n        exponent_t[ i ][ j ]  5  u(6) \n        mantissa_t[ i ][ j ]  5  u(v) \n      }     \n    }     \n  }     \n}     \n \nH.13.1.6 Non-required view component SEI message syntax \n \nnon_required_view_component( payloadSize ) {  C  Descriptor \n  num_info_entries_minus1  5  ue(v) \n  for( i = 0; i <= num_info_entries_minus1; i++ ) {     \n    view_order_index[ i ]  5  ue(v) \n    num_non_required_view_components_minus1[ i ]  5  ue(v) \n    for( j = 0; j <= num_non_required_view_components_minus1[ i ]; j++ )      \n      index_delta_minus1[ i ][ j ]  5  ue(v) \n  }     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  697 \n \nH.13.1.7 View dependency change SEI message syntax \n \nview_dependency_change( payloadSize ) {  C  Descriptor \n  seq_parameter_set_id  5  ue(v) \n  anchor_update_flag  5  u(1) \n  non_anchor_update_flag  5  u(1) \n  if( anchor_update_flag )     \n    for( i = 1; i <= num_views_minus1; i++ ) {     \n      for( j = 0; j < num_anchor_refs_l0[ i ]; j++ )     \n        anchor_ref_l0_flag[ i ][ j ]  5  u(1) \n      for( j = 0; j < num_anchor_refs_l1[ i ]; j++ )     \n        anchor_ref_l1_flag[ i ][ j ]  5  u(1) \n    }     \n  if( non_anchor_update_flag )     \n    for( i = 1; i <= num_views_minus1; i++ ) {     \n      for( j = 0; j < num_non_anchor_refs_l0[ i ]; j++ )     \n        non_anchor_ref_l0_flag[ i ][ j ]  5  u(1) \n      for( j = 0; j < num_non_anchor_refs_l1[ i ]; j++ )     \n        non_anchor_ref_l1_flag[ i ][ j ]  5  u(1) \n    }     \n}     \n \nH.13.1.8 Operation point not present SEI message syntax \n \noperation_point_not_present( payloadSize ) {  C  Descriptor \n  num_operation_points  5  ue(v) \n  for( k = 0; k < num_operation_points; k++ )      \n    operation_point_not_present_id[ k ]  5  ue(v) \n}     \n \nH.13.1.9 Base view temporal HRD SEI message syntax \n \nbase_view_temporal_hrd( payloadSize ) {  C  Descriptor \n  num_of_temporal_layers_in_base_view_minus1  5  ue(v) \n  for( i = 0; i <= num_of_temporal_layers_in_base_view_minus1; i++ ) {     \n    sei_mvc_temporal_id[ i ]  5  u(3) \n    sei_mvc_timing_info_present_flag[ i ]  5  u(1) \n    if( sei_mvc_timing_info_present_flag[ i ] ) {     \n      sei_mvc_num_units_in_tick[ i ]  5  u(32) \n      sei_mvc_time_scale[ i ]  5  u(32) \n      sei_mvc_fixed_frame_rate_flag[ i ]  5  u(1) \n    }     \n    sei_mvc_nal_hrd_parameters_present_flag[ i ]  5  u(1) \n    if( sei_mvc_nal_hrd_parameters_present_flag[ i ] )     \n      hrd_parameters( )  5   \n    sei_mvc_vcl_hrd_parameters_present_flag[ i ]  5  u(1) \n    if( sei_mvc_vcl_hrd_parameters_present_flag[ i ] )     \n698  Rec. ITU-T H.264 (06/2019) \n \n      hrd_parameters( )  5   \n    if( sei_mvc_nal_hrd_parameters_present_flag[ i ]  | |       \n      sei_mvc_vcl_hrd_parameters_present_flag[ i ] ) \n      sei_mvc_low_delay_hrd_flag[ i ]  5  u(1) \n    sei_mvc_pic_struct_present_flag[ i ]  5  u(1) \n  }     \n}     \n \nH.13.1.10  Multiview view position SEI message syntax \n \nmultiview_view_position( payloadSize ) {  C  Descriptor \n  num_views_minus1  5  ue(v) \n  for( i = 0; i <= num_views_minus1; i++ )     \n    view_position[ i ]  5  ue(v) \n  multiview_view_position_extension_flag  5  u(1) \n}     \n \nH.13.2  SEI message semantics \nDepending on payloadType, the corresponding SEI message semantics are extended as follows: \n–  If payloadType is equal to 2, 3, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 45, 47, 137, 142, 144, \n147, 148, 149, 150, 151, 154, 155, 156, 200, or 201, the following applies: \n–  If the SEI message is not included in an MVC scalable nesting SEI message, it applies to the view component of \nthe current access unit with VOIdx equal to VOIdxMin. \n–  Otherwise (the SEI message is included in an MVC scalable nesting SEI message), it applies to all view \ncomponents of the current access unit when all_view_components_in_au_flag is equal to 1, or it applies to all \nview components of the current access unit with view_id equal to sei_view_id[ i ] for any i in the range of 0 to \nnum_view_components_minus1,  inclusive,  when  all_view_components_in_au_flag  is  equal  to 0.  When \npayloadType is equal to 10 for the SEI message that is included in an MVC scalable nesting SEI message, the \nsemantics for sub_seq_layer_num of the sub-sequence information SEI message is modified as follows: \nsub_seq_layer_num specifies the sub-sequence layer number of the current picture. When the current \npicture resides in a sub-sequence for which the first picture in decoding order is an IDR picture, the value \nof sub_seq_layer_num shall be equal to 0. For a non-paired reference field, the value of sub_seq_layer_num \nshall be equal to 0. sub_seq_layer_num shall be in the range of 0 to 255, inclusive. \n–  Otherwise, if payloadType is equal to 0 or 1, the following applies: \n–  If the SEI message is not included in an MVC scalable nesting SEI message, the following applies. When the \nSEI message and all other SEI messages with payloadType equal to 0 or 1 not included in an MVC scalable \nnesting SEI message are used as the buffering period and picture timing SEI messages for checking the bitstream \nconformance according to Annex C and the decoding process specified in clauses 2 to 9 is used, the bitstream \nshall be conforming to this Recommendation | International Standard. \n–  Otherwise (the SEI message is included in an MVC scalable nesting SEI message), the following applies. When \nthe SEI message and all other SEI messages with payloadType equal to 0 or 1 included in an MVC scalable \nnesting SEI message with identical values of sei_op_temporal_id and sei_op_view_id[ i ] for all i in the range \nof 0 to num_view_components_op_minus1, inclusive, are used as the buffering period and picture timing SEI \nmessages for checking the bitstream conformance according to Annex C, the bitstream that would be obtained \nby  invoking  the  bitstream  extraction  process  as  specified  in  clause H.8.3  with  tIdTarget  equal  to \nsei_op_temporal_id  and  viewIdTargetList  equal  to  sei_op_view_id[ i ]  for  all  i  in  the  range  of 0  to \nnum_view_components_op_minus1,  inclusive,  shall  be  conforming  to  this  Recommendation | \nInternational Standard. \nIn  the  semantics  of  clauses D.2.1  and  D.2.3,  the  syntax  elements  num_units_in_tick,  time_scale, \nfixed_frame_rate_flag,  nal_hrd_parameters_present_flag,  vcl_hrd_parameters_present_flag, \nlow_delay_hrd_flag,  and  pic_struct_present_flag  and  the  derived  variables  NalHrdBpPresentFlag, \n    Rec. ITU-T H.264 (06/2019)  699 \n \nVclHrdBpPresentFlag,  and  CpbDpbDelaysPresentFlag  are  substituted  with  the  syntax  elements \nvui_mvc_num_units_in_tick[ i ],  vui_mvc_time_scale[ i ],  vui_mvc_fixed_frame_rate_flag[ i ], \nvui_mvc_nal_hrd_parameters_present_flag[ i ],  vui_mvc_vcl_hrd_parameters_present_flag[ i ], \nvui_mvc_low_delay_hrd_flag[ i ],  and  vui_mvc_pic_struct_present_flag[ i ]  and  the  derived  variables \nVuiMvcNalHrdBpPresentFlag[ i ],  VuiMvcVclHrdBpPresentFlag[ i ],  and \nVuiMvcCpbDpbDelaysPresentFlag[ i ]. \nThe values of seq_parameter_set_id's in all buffering period SEI messages included in MVC scalable nesting \nSEI messages and associated with operation points for which the greatest VOIdx values in the associated \nbitstream subsets are identical shall be identical. \n–  Otherwise (all remaining payloadType values), the corresponding SEI message semantics are not extended. \nWhen an SEI message having a particular value of payloadType equal to 137 or 144, contained in an MVC scalable nesting \nSEI message, and applying to a particular combination of a list of view_id and a temporal_id is present in an access unit, \nthe SEI message with the particular value of payloadType applying to the particular combination of a list of view_id and \na temporal_id shall be present an MVC scalable nesting SEI message in the IDR access unit that is the first access unit of \nthe coded video sequence. \nAll SEI messages having a particular value of payloadType equal to 137 or 144, contained in MVC scalable nesting SEI \nmessages, and applying to a particular combination of a list of view_id and a temporal_id present in a coded video sequence \nshall have the same content. \nFor the semantics of SEI messages with payloadType in the range of 0 to 23, inclusive, or equal to 45, 47, 137, 142, 144, \n147, 148, 149, 150, 151, 154, 155, 156, 200, or 201, which are specified in clause D.2, MVC sequence parameter set is \nsubstituted for sequence parameter set; the parameters of MVC sequence parameter set RBSP and picture parameter set \nRBSP that are in effect are specified in clauses H.7.4.2.1 and H.7.4.2.2, respectively. \nCoded video sequences conforming to one or more of the profiles specified in Annex H shall not include SEI NAL units \nthat contain SEI messages with payloadType in the range of 24 to 35, inclusive, which are specified in clause G.13. \nWhen an SEI NAL unit contains an SEI message with payloadType in the range of 36 to 44, inclusive, or equal to 46, \nwhich are specified in clause H.13, it shall not contain any SEI messages with payloadType less than 36 or equal to 45, 47, \n137, 142, 144, 147, 148, 149, 150, 151, 154, 155, 156, 200, or 201, and the first SEI message in the SEI NAL unit shall \nhave payloadType in the range of 36 to 44, inclusive, or equal to 46. \nWhen an MVC scalable nesting SEI message (payloadType equal to 37) or a view scalability information SEI message \n(payloadType equal to 38) or an operation point not present SEI message (payloadType equal to 43) is present in an SEI \nNAL unit, it shall be the only SEI message in the SEI NAL unit. \nH.13.2.1 Parallel decoding information SEI message semantics \nThe parallel decoding information SEI message may be associated with any access unit. The information signalled in the \nSEI message applies to all the access units from the access unit the SEI message is associated with to the next access unit, \nin decoding order, containing an SEI message of the same type, exclusively, or to the end of the coded video sequence, \nwhichever is earlier in decoding order. \nSome view components for which the parallel decoding information is signalled in a parallel decoding information SEI \nmessage may not be present in the coded video sequence. \nseq_parameter_set_id specifies a subset sequence parameter set that contains the inter-view dependency relationship \ninformation.  The  value  of  seq_parameter_set_id  shall  be  equal  to  the  value  of  seq_parameter_set_id  in  the  picture \nparameter set referenced by a view component of the primary coded picture of the access unit containing the parallel \ndecoding information SEI message. The value of seq_parameter_set_id shall be in the range of 0 to 31, inclusive. \nNOTE 1 – The inter-view dependency relationship is signalled in the sequence parameter set MVC extension, which is identical \nfor all subset sequence parameter sets that may be activated during the decoding process for the coded video sequence. \npdi_init_delay_anchor_minus2_l0[ i ][ j ] specifies the unavailable reference area in the view component with view_id \nequal to anchor_ref_l0[ i ][ j ] that shall not be used for inter-view reference by the coded anchor view component with \nview_id equal to view_id[ i ], where anchor_ref_l0[ i ][ j ] and view_id[ i ] are both from the MVC sequence parameter set \nthat has a sequence parameter set identifier equal to the syntax element seq_parameter_set_id contained in the current SEI \nmessage.  The  unavailable  reference  area  is  a  rectangular  area  with  coordinates \n( 0, (CurrMbAddr / PicWidthInMbs + pdi_init_delay_anchor_minus2_l0[ i ][ j ] + 2  ) * 16  )  as  the  top  left  corner  and \n( PicWidthInSamples, PicHeightInSamples ) as the bottom right corner. When decoding the coded view component with \nview_id equal to view_id[ i ], samples from the unavailable reference area from the view component with view_id equal \nto  anchor_ref_l0[ i ][ j ]  shall  not  be  referred  to  by  the  inter-view  prediction  process.  The  value  of \npdi_init_delay_anchor_minus2_l0[ i ][ j ] shall be in the range of 0 to PicHeightInMbs − 2, inclusive. \n700  Rec. ITU-T H.264 (06/2019) \n \npdi_init_delay_anchor_minus2_l1[ i ][ j ] specifies the unavailable reference area in the view component with view_id \nequal to anchor_ref_l1[ i ][ j ] that shall not be used for inter-view reference by the coded anchor view component with \nview_id equal to view_id[ i ], where anchor_ref_lX[ i ][ j ] and view_id[ i ] are both from the MVC sequence parameter \nset that has a sequence parameter set identifier equal to the syntax element seq_parameter_set_id contained in the current \nSEI  message.  The  unavailable  reference  area  is  a  rectangular  area  with  coordinates \n( 0, ( CurrMbAddr / PicWidthInMbs + pdi_init_delay_anchor_minus2_l1[i ][ j ] + 2) * 16  )  as  the  top  left  corner  and \n( PicWidthInSamples, PicHeightInSamples ) as the bottom right corner. When decoding the coded view component with \nview_id equal to view_id[ i ], samples from the unavailable reference area from the view component with view_id equal \nto  anchor_ref_l1[ i ][ j ]  shall  not  be  referred  to  by  the  inter-view  prediction  process.  The  value  of \npdi_init_delay_anchor_minus2_l1[ i ][ j ] shall be in the range of 0 to PicHeightInMbs − 2, inclusive. \npdi_init_delay_non_anchor_minus2_l0[ i ][ j ] specifies the unavailable reference area in the view component with \nview_id equal to non_anchor_ref_l0[ i ][ j ] that shall not be used for inter-view reference by the coded non-anchor view \ncomponent with view_id equal to view_id[ i ], where non_anchor_ref_l0[ i ][ j ] and view_id[ i ] are both from the MVC \nsequence parameter set that has a sequence parameter set identifier equal to the syntax element seq_parameter_set_id \ncontained  in  the  current  SEI  message.  The  unavailable  reference  area  is  a  rectangular  area  with  coordinates \n( 0, (CurrMbAddr / PicWidthInMbs + pdi_init_delay_non_anchor_minus2_l0[ i ][ j ] + 2) * 16 ) as the top left corner and \n( PicWidthInSamples, PicHeightInSamples ) as the bottom right corner. When decoding the coded view component with \nview_id equal to view_id[ i ], samples from the unavailable reference area from the view component with view_id equal \nto  non_anchor_ref_l0[ i ][ j ]  shall  not  be  referred  to  by  the  inter-view  prediction  process.  The  value  of \npdi_init_delay_non_anchor_minus2_l0[ i ][ j ] shall be in the range of 0 to PicHeightInMbs − 2, inclusive. \npdi_init_delay_non_anchor_minus2_l1[ i ][ j ] specifies the unavailable reference area in the view component with \nview_id equal to non_anchor_ref_l1[ i ][ j ] that shall not be used for inter-view reference by the coded anchor view \ncomponent with view_id equal to view_id[ i ], where non_anchor_ref_lX[ i ][ j ] and view_id[ i ] are both from the MVC \nsequence parameter set that has a sequence parameter set identifier equal to the syntax element seq_parameter_set_id \ncontained  in  the  current  SEI  message.  The  unavailable  reference  area  is  a  rectangular  area  with  coordinates \n( 0, (CurrMbAddr / PicWidthInMbs + pdi_init_delay_non_anchor_minus2_l1[i ][ j ] + 2) * 16 ) as the top left corner and \n( PicWidthInSamples, PicHeightInSamples ) as the bottom right corner. When decoding the coded view component with \nview_id equal to view_id[ i ], samples from the unavailable reference area from the view component with view_id equal \nto  non_anchor_ref_l1[ i ][ j ]  shall  not  be  referred  to  by  the  inter-view  prediction  process.  The  value  of \npdi_init_delay_non_anchor_minus2_l1[ i ][ j ] shall be in the range of 0 to PicHeightInMbs − 2, inclusive. \nH.13.2.2 MVC scalable nesting SEI message semantics \nAn MVC nesting SEI message shall contain one and only one SEI message of payloadType less than or equal to 23, which \nis referred to as the nested SEI message. The scope to which the nested SEI message applies is indicated by the syntax \nelements operation_point_flag, all_view_components_in_au_flag, num_view_components_minus1, sei_view_id[ i ] for \nall i, num_view_components_op_minus1, sei_op_view_id[ i ] for all i, and sei_op_temporal_id. \nSome view components to which the nested SEI message applies may not be present in the access unit containing the MVC \nscalable nesting SEI message. \noperation_point_flag  equal to 1  specifies  that  the  nested  SEI  message  applies  to  the  current  access  unit  when  the \nassociated  operation  point  identified  by  sei_op_temporal_id  and  sei_op_view_id[ i ]  for  all  i  in  the  range  of 0  to \nnum_view_components_op_minus1, inclusive, is decoded. operation_point_flag equal to 0 specifies that the nested SEI \nmessage applies to the view components identified by all_view_components_in_au_flag, num_view_components_minus1, \nand sei_view_id[ i ] for all i in the range of 0 to num_view_components_minus1, inclusive, regardless of which operation \npoint is decoded. \nIf the nested SEI message has payloadType equal to 0 or 1, operation_point_flag shall be equal to 1. Otherwise (the nested \nSEI message has payloadType not equal to 0 or 1), operation_point_flag shall be equal to 0. \nall_view_components_in_au_flag equal to 1 specifies that the nested SEI message applies to all view components of the \naccess unit. all_view_components_in_au_flag equal to 0 specifies that the applicable scope of the nested SEI message is \nsignalled  by  the  syntax  elements  num_view_components_minus1  and  sei_view_id[ i ]  for  all  i  in  the  range  of 0  to \nnum_view_components_minus1, inclusive. \nnum_view_components_minus1 plus 1 specifies the number of view components to which the nested SEI message \napplies  when  operation_point_flag  is  equal  to 0  and  all_view_components_in_au_flag  is  equal  to 0.  The  value  of \nnum_view_components_minus1 shall be in the range of 0 to 1023, inclusive. \nsei_view_id[ i ]  specifies  the  view_id  of  the  i-th  view  component  to  which  the  nested  SEI  message  applies  when \noperation_point_flag is equal to 0 and all_view_components_in_au_flag is equal to 0. \nnum_view_components_op_minus1 plus 1 specifies the number of view components of the operation point to which the \nnested SEI message applies when operation_point_flag is equal to 1. The value of num_view_components_op_minus1 \nshall be in the range of 0 to 1023, inclusive. \n    Rec. ITU-T H.264 (06/2019)  701 \n \nsei_op_view_id[ i ] specifies the view_id of the i-th view component to which the nested SEI message applies when \noperation_point_flag is equal to 1. \nsei_op_temporal_id specifies the maximum temporal_id of the bitstream subset to which the nested SEI message applies \nwhen operation_point_flag is equal to 1. \nsei_nesting_zero_bit is equal to 0. \nH.13.2.3 View scalability information SEI message semantics \nWhen present, this SEI message shall be associated with an IDR access unit. The semantics of the message are valid for \nthe current coded video sequence. A view scalability information SEI message contains view and scalability information \nfor a subset of the operation points in the coded video sequence. Each operation point is associated with an operation point \nidentifier. The sub-bitstream for an operation point is referred to as the operation point representation or the representation \nof the operation point. Information such as bit rate and frame rate, among others, are signalled for the representations of \nthe subset of the operation points. \nNOTE 1 – Any operation point for which view and scalability information is signalled in a view scalability information SEI message \n(i.e. identified by a value of operation_point_id[ i ]) must be present in the coded video sequence. When an application keeps a \nview scalability information SEI message in a sub-bitstream extracted according to the process specified in clause H.8.5.3, and \nafter the extraction any operation point for which view and scalability information is signalled in the original SEI message becomes \nnot present in the coded video sequence, the application must change the content of the view scalability information SEI message \nto fulfil the condition stated by the first sentence in this note. \nnum_operation_points_minus1 plus 1 specifies the number of operation points that are present in the coded video \nsequence and for which the view scalability information is signalled by the following syntax elements. The value of \nnum_operation_points_minus1 shall be in the range of 0 to 1023, inclusive. \nThe  bitstream  subset  corresponding  to  an  operation  point  is  defined  as  the  operation  point  representation  or  the \nrepresentation of the operation point. The representation of the operation point identified by operation_point_id[ i ] is the \noutput of the sub-bitstream extraction process specified in clause H.8.5.3 with tIdTarget equal to temporal_id[ i ] and \nviewIdTargetList  consisting  of  view_id[ i ][ j ]  for  all  j  in  the  range  of 0  to  num_target_output_views_minus1[ i ], \ninclusive, as the inputs. \noperation_point_id[ i ] specifies the identifier of the operation point. Each operation point is associated with a unique \noperation point identifier. The value of operation_point_id[ i ] shall be in the range of 0 to 65535, inclusive. \nIn the following semantics in this clause, the operation point with identifier equal to operation_point_id[ i ] is referred to \nas the current operation point. \npriority_id[ i ] and temporal_id[ i ] specify the maximum value of priority_id and temporal_id, respectively, of the NAL \nunits in the representation of the current operation point. \nnum_target_output_views_minus1[ i ] plus 1 specifies the number of target output views for the current operation point. \nThe value of num_target_output_views_minus1[ i ] shall be in the range of 0 to 1023, inclusive. \nview_id[ i ][ j ]  specifies  the  identifier  of  the  j-th  target  output  view  for  the  current  operation  point.  The  value  of \nview_id[ i ][ j ] shall be in the range of 0 to 1023, inclusive. \nprofile_level_info_present_flag[ i ] equal to 1 specifies that the profile and level information for the representation of the \ncurrent operation point is present in the SEI message. profile_level_info_present_flag[ i ] equal to 0 specifies that the \nprofile and level information for the current operation point is not present in the SEI message. \nbitrate_info_present_flag[ i ] equal to 1 specifies  that the bitrate information for the current operation point is present in \nthe SEI message. bitrate_info_present_flag[ i ] equal to 0 specifies that the bitrate information for the current operation \npoint is not present in the SEI message. \nfrm_rate_info_present_flag[ i ] equal to 1 specifies that the frame rate information for the current operation point is \npresent in the SEI message. frm_rate_info_present_flag[ i ] equal to 0 specifies that the frame rate information for the \ncurrent operation point is not present in the SEI message. \nview_dependency_info_present_flag[ i ] equal to 1 specifies that information on the views the target output view of the \ncurrent operation point directly depends on is present in the SEI message. View A is directly dependent on view point B if \nthere is at least one view component of view A using a view component of view B for inter-view prediction reference. \nview_dependency_info_present_flag[ i ] equal to 0 specifies that view_dependency_info_src_op_id[ i ] is present in the \nSEI message. When not present, view_dependency_info_present_flag[ i ] shall be inferred to be equal to 0. \n702  Rec. ITU-T H.264 (06/2019) \n \nNOTE 2 – The inter-view dependency relationship signalled in sequence parameter set MVC extension is an upper bound, in the \nsense that whenever view A may depend on view B at any access unit, it is specified as view A depends on view B. Therefore, the \ndependency relationship is indicated by sequence parameter set MVC extension when view A depends on view B at only one of all \naccess units in the coded video sequence, or even when view A actually does not depend on view B at any access unit but when \ngenerating the sequence parameter set MVC extension the encoder thought view A might depend on view B. The dependency \nrelationship signalled here can be more refined. For example, when view A depends on view B at access units with temporal_id \nequal to 0 but not at other access units, this can be indicated through the view dependency information signalled in this SEI message \nfor operation points with view A as the target output view and with different maximum values of temporal_id. \nparameter_sets_info_present_flag[ i ]  equal  to 1  specifies  that  the  values  of  seq_parameter_set_id  of  the  sequence \nparameter sets and subset sequence parameter sets and the values of pic_parameter_set_id of the picture parameter sets \nthat are referred to by the VCL NAL units of the representation of the current operation point are present in the SEI \nmessage. parameter_sets_info_present_flag[ i ] equal to 0 specifies that parameter_sets_info_src_op_id[ i ] is present in \nthe SEI message. \nbitstream_restriction_info_present_flag[ i ]  equal  to 1  specifies  that  the  bitstream  restriction  information  for  the \nrepresentation of the current operation point is present in the SEI message. bitstream_restriction_info_present_flag[ i ] \nequal to 0 specifies that the bitstream restriction information for the representation of the current operation point is not \npresent in the SEI message. \nop_profile_level_idc[ i ] specifies the profile and level compliancy of the representation of the current operation point. \nop_profile_level_idc[ i ]  is  the  exact  copy  of  the  three  bytes  comprised  of  profile_idc,  constraint_set0_flag, \nconstraint_set1_flag,  constraint_set2_flag,  constraint_set3_flag,  constraint_set4_flag,  constraint_set5_flag, \nreserved_zero_2bits, and level_idc, if these syntax elements were used to specify the profile and level compliancy of the \nrepresentation of the current operation point as specified in Annexes A and H. \navg_bitrate[ i ] specifies the average bit rate of the representation of the current operation point. The average bit rate for \nthe representation of the current operation point in bits per second is given by BitRateBPS( avg_bitrate[ i ] ) with the \nfunction BitRateBPS( ) being specified by the following equation. \nBitRateBPS( x ) = ( x & ( 214 − 1 ) ) * 10( 2 + ( x >> 14 ) )  (H-82) \nAll NAL units of the representation of the current operation point are taken into account in the calculation. The average \nbit rate is derived according to the access unit removal time specified in Annex C. In the following, bTotal is the number \nof bits in all NAL units of the representation of the current operation point in the current coded video sequence. t  is the \n1\nremoval time (in seconds) of the current access unit, and t  is the removal time (in seconds) of the last access unit (in \n2\ndecoding order) of the current coded video sequence. \nWith x specifying the value of avg_bitrate[ i ], the following applies: \n–  If t  is not equal to t , the following condition shall be true. \n1 2\n( x & ( 214 − 1 ) ) = = Round( bTotal ÷ ( ( t  − t  ) * 10( 2 + ( x >> 14 ) ) ) )  (H-83) \n2 1\n–  Otherwise (t  is equal to t ), the following condition shall be true. \n1 2\n( x & ( 214 − 1 ) ) = = 0  (H-84) \nmax_bitrate[ i ]  specifies  the  maximum  bit  rate  of  the  representation  of  the  current  operation  point,  given  by \nBitRateBPS( max_bitrate_layer_representation[ i ] ), in bits per second, with the function BitRateBPS( ) being specified \nin Equation H-82. The maximum bit rate of the representation of the current operation point is calculated based on a time \nwindow specified by max_bitrate_calc_window[ i ]. \nmax_bitrate_calc_window[ i ]  specifies  the  length  of  the  time  window,  in  units  of  1/100  second,  based  on  which \nmax_bitrate[ i ] is calculated. \nconstant_frm_rate_idc[ i ] specifies whether the frame rate of the representation of the current operation point is constant. \nIf  the  value  of  avg_frm_rate  as  specified  below  is  constant  whichever  a  temporal  section  of  the  operation  point \nrepresentation  is  used  for  the  calculation,  the  frame  rate  is  constant,  otherwise  the  frame  rate  is  non-constant. \nconstant_frm_rate_idc[ i ] equal to 0 specifies that the frame rate is not constant, constant_frm_rate_idc[ i ] equal to 1 \nspecifies that the frame rate is constant, and constant_frm_rate_idc[ i ] equal to 2 specifies that the frame rate may be or \nmay not be constant. The value of constant_frm_rate_idc[ i ] shall be in the range of 0 to 2, inclusive. \navg_frm_rate[ i ] specifies the average frame rate, in units of frames per 256 seconds, of the representation of the current \noperation point. The semantics of avg_frm_rate[ i ] is identical to the semantics of average_frame_rate in sub-sequence \nlayer characteristics SEI message when accurate_statistics_flag is equal to 1, except that herein the set of NAL units in the \nrange of sub-sequence layers is replaced by the set of NAL units of the representation of the current operation point. \n    Rec. ITU-T H.264 (06/2019)  703 \n \nnum_directly_dependent_views[ i ] specifies the number of views that the target output view of the current operation \npoint  is  directly  dependent  on  within  the  representation  of  the  current  operation  point.  The  value  of \nnum_directly_dependent_views[ i ] shall be in the range of 0 to 16, inclusive. \ndirectly_dependent_view_id[ i ][ j ] specifies the view_id of the j-th view that the target output view of the current \noperation  point  is  directly  dependent  on  within  the  representation  of  the  current  operation  point.  The  value  of \ndirectly_dependent_view_id[ i ][ j ] shall be in the range of 0 to 1023, inclusive. \nview_dependency_info_src_op_id[ i ] specifies that the views the target output view of the current operation point \ndirectly depends on within the representation of the current operation point are the same as the views the target output view \nof  the  operation  point  with  identifier  equal  to  view_dependency_info_src_op_id[ i ]  directly  depends  on  within  the \nrepresentation  of  the  operation  point  with  identifier  equal  to  view_dependency_info_src_op_id[ i ],  if \nview_dependency_info_src_op_id[ i ]  is  not  equal  to  operation_point_id[ i ].  Otherwise \n(view_dependency_info_src_op_id[ i ] is equal to operation_point_id[ i ]), information on the views the target output view \nof  the  current  operation  point  directly  depends  on  is  not  present  in  the  SEI  message.  The  value  of \nview_dependency_info_src_op_id[ i ] shall be in the range of 0 to 65535, inclusive. \nnum_seq_parameter_sets[ i ] specifies the number of different sequence parameter sets that are referred to by the VCL \nNAL units of the representation of the current operation point. The value of num_seq_parameter_sets[ i ] shall be in the \nrange of 0 to 32, inclusive. \nseq_parameter_set_id_delta[ i ][ j ] specifies the smallest value of the seq_parameter_set_id of all sequence parameter \nsets required for decoding the representation of the current operation point, if j is equal to 0. Otherwise (j is greater than 0), \nseq_parameter_set_id_delta[ i ][ j ] specifies the difference between the value of the seq_parameter_set_id of the j-th \nrequired sequence parameter set and the value of the seq_parameter_set_id of the (j−1)-th required sequence parameter set \nfor decoding the representation of the current operation point. The sequence parameter sets are logically ordered in \nascending order of the value of seq_parameter_set_id. The value of seq_parameter_set_id_delta[ i ][ j ] shall be in the \nrange of 0 to 31, inclusive. \nnum_subset_seq_parameter_sets[ i ] specifies the number of different subset sequence parameter sets that are referred \nto  by  the  VCL  NAL  units  of  the  representation  of  the  current  operation  point.  The  value  of \nnum_subset_seq_parameter_sets[ i ] shall be in the range of 0 to 32, inclusive. \nsubset_seq_parameter_set_id_delta[ i ][ j ]  specifies  the  smallest  value  of  the  seq_parameter_set_id  of  all  subset \nsequence parameter sets required for decoding the representation of the current operation point, if j is equal to 0. Otherwise \n(j  is  greater  than 0),  subset_seq_parameter_set_id_delta[ i ][ j ]  specifies  the  difference  between  the  value  of  the \nseq_parameter_set_id of the j-th required subset sequence parameter set and the value of the seq_parameter_set_id of the \n(j−1)-th required subset sequence parameter set for decoding the representation of the current operation point. The subset \nsequence parameter sets are logically ordered in ascending order of the value of seq_parameter_set_id. The value of \nsubset_seq_parameter_set_id_delta[ i ][ j ] shall be in the range of 0 to 31, inclusive. \nnum_pic_parameter_sets_minus1[ i ] plus 1 specifies the number of different picture parameter sets that are referred to \nby  the  VCL  NAL  units  of  the  representation  of  the  current  operation  point.  The  value  of \nnum_pic_parameter_sets_minus1[ i ] shall be in the range of 0 to 255, inclusive. \npic_parameter_set_id_delta[ i ][ j ] specifies the smallest value of the pic_parameter_set_id of all picture parameter sets \nrequired for decoding the representation of the current operation point, if j is equal to 0. Otherwise (j is greater than 0), \npic_parameter_set_id_delta[ i ][ j ] specifies the difference between the value of the pic_parameter_set_id of the j-th \nrequired picture parameter set and the value of the pic_parameter_set_id of the (j−1)-th required picture parameter set for \ndecoding the representation of the current operation point. The picture parameter sets are logically ordered in ascending \norder of the value of pic_parameter_set_id. The value of pic_parameter_set_id_delta[ i ][ j ] shall be in the range of 0 \nto 255, inclusive. \nparameter_sets_info_src_op_id[ i ] specifies that the values of seq_parameter_set_id of the sequence parameter sets and \nsubset sequence parameter sets and the values of pic_parameter_set_id of the picture parameter sets that are referred to by \nthe VCL NAL units of the representation of the current operation point are the same as those for the representation of the \noperation point with identifier equal to parameter_sets_info_src_op_id[ i ], if parameter_sets_info_src_op_id[ i ] is not \nequal  to  operation_point_id[ i ].  Otherwise  (parameter_sets_info_src_op_id[ i ]  is  equal  to  operation_point_id[ i ]), \nparameter_sets_info_src_op_id[ i ] specifies that the values of seq_parameter_set_id of the sequence parameter sets and \nsubset sequence parameter sets and the values of pic_parameter_set_id of the picture parameter sets that are referred to by \nthe VCL NAL units of the representation of the current operation point are not present in the SEI message. The value of \nparameter_sets_info_src_op_id[ i ] shall be in the range of 0 to 65535, inclusive. \nmotion_vectors_over_pic_boundaries_flag[ i ]  specifies  the  value  of  motion_vectors_over_pic_boundaries_flag,  as \nspecified  in  clause E.2.1,  for  the  current  operation  point  representation.  When  the \nmotion_vectors_over_pic_boundaries_flag[ i ] syntax element is not present, motion_vectors_over_pic_boundaries_flag \nvalue for the current operation point representation shall be inferred to be equal to 1. \n704  Rec. ITU-T H.264 (06/2019) \n \nmax_bytes_per_pic_denom[ i ]  specifies  the  max_bytes_per_pic_denom  value,  as  specified  in  clause E.2.1,  for  the \ncurrent operation point representation. When the max_bytes_per_pic_denom[ i ] syntax element is not present, the value \nof max_bytes_per_pic_denom for the current operation point representation shall be inferred to be equal to 2. The value \nof max_bytes_per_pic_denom[ i ] shall be in the range of 0 to 16, inclusive. \nmax_bits_per_mb_denom[ i ] specifies the max_bits_per_mb_denom value, as specified in clause E.2.1, for the current \noperation  point  representation.  When  the  max_bits_per_mb_denom[ i ]  is  not  present,  the  value  of \nmax_bits_per_mb_denom for the current operation point representation shall be inferred to be equal to 1. The value of \nmax_bits_per_mb_denom[ i ] shall be in the range of 0 to 16, inclusive. \nlog2_max_mv_length_horizontal[ i ]  and  log2_max_mv_length_vertical[ i ]  specify  the  values  of \nlog2_max_mv_length_horizontal and log2_max_mv_length_vertical, as specified in clause E.2.1, for the current operation \npoint  representation.  When  log2_max_mv_length_horizontal[ i ]  is  not  present,  the  values  of \nlog2_max_mv_length_horizontal and log2_max_mv_length_vertical for the current operation point representation shall \nbe inferred to be equal to 16. The value of log2_max_mv_length_horizontal[ i ] shall be in the range of 0 to 16, inclusive. \nThe value of log2_max_mv_length_vertical[ i ] shall be in the range of 0 to 16, inclusive. \nNOTE 3 – The maximum absolute value of a decoded vertical or horizontal motion vector component is also constrained by profile \nand level limits as specified in Annex A or clause H.10.2. \nmax_num_reorder_frames[ i ] specifies the value of max_num_reorder_frames, as specified in clause E.2.1, for the \ncurrent  operation  point  representation.  The  value  of  max_num_reorder_frames[ i ]  shall  be  in  the  range  of 0  to 16, \ninclusive. When the max_num_reorder_frames[ i ] syntax element is not present, the value of max_num_reorder_frames \nfor the current operation point representation shall be inferred to be equal to 16. \nmax_dec_frame_buffering[ i ] specifies the value of max_dec_frame_buffering, as specified in clause E.2.1, for the \ncurrent  operation  point  representation.  The  value  of  max_dec_frame_buffering[ i ]  shall  be  in  the  range  of 0  to \nMaxDpbFrames (as specified in  clauses A.3.1, A.3.2, or H.10.2), inclusive. When the max_dec_frame_buffering[ i ] \nsyntax element is not present, the value of max_dec_frame_buffering for the current operation point representation shall \nbe inferred to be equal to MaxDpbFrames. \nH.13.2.4 Multiview scene information SEI message semantics \nThe multiview scene information SEI message indicates the maximum disparity among multiple view components in an \naccess unit. The maximum disparity could be used for processing the decoded view components prior to rendering on a \n3D display. When present, the multiview scene information SEI message shall be associated with an IDR access unit. The \ninformation signalled in the SEI message applies to the coded video sequence. \nThe actual maximum disparity value may be less than the one signalled in the multiview scene information SEI message, \ndue to that some views in the coded video sequence may have been removed from the original bitstream to produce an \nextracted sub-bitstream according to the process specified in clause H.8.5.3. \nmax_disparity specifies the maximum disparity, in units of luma samples, between spatially adjacent view components \namong the total set of view components in an access unit. The value of max_disparity shall be in the range of 0 to 1023, \ninclusive. \nNOTE – The maximum disparity depends on the baseline distance between spatially adjacent views and the spatial resolution of \neach view. Therefore, if either the number of views or spatial resolution is changed, the maximum disparity should also be changed \naccordingly. \nH.13.2.5 Multiview acquisition information SEI message semantics \nThe  multiview  acquisition  information  SEI  message  specifies  various  parameters  of  the  acquisition  environment. \nSpecifically, intrinsic and extrinsic camera parameters are specified. These parameters could be used for processing the \ndecoded view components prior to rendering on a 3D display. When present as a non-nested SEI message, the multiview \nacquisition information SEI message shall be associated with an IDR access unit. The information signalled in the \nmultiview acquisition information SEI message applies to the coded video sequence. \nThe multiview acquisition information SEI message may be nested in an MVCD scalable nesting SEI message to indicate \nparameters of the acquisition environment of texture and depth views. When present as a nested SEI message, the multiview \nacquisition information SEI message is recommended be associated with an IDR access unit and may be associated with \nany access unit. When present as a nested SEI message, the information indicated in the SEI message applies from the \naccess unit associated with the SEI message to the next access unit, in decoding order, containing an SEI message of the \nsame type, exclusive, or to the end of the coded video sequence, whichever is earlier in decoding order. \nSome of the views for which the multiview acquisition information is included in a multiview acquisition information SEI \nmessage may not be present in the coded video sequence. \nThe extrinsic camera parameters are specified according to a right-handed coordinate system, where the upper left corner \nof the image is the origin, i.e., the (0, 0) coordinate, with the other corners of the image having non-negative coordinates. \n    Rec. ITU-T H.264 (06/2019)  705 \n \nWith these specifications, a 3-dimensional world point, wP=[x y z] is mapped to a 2-dimensional camera point, cP[ i ] = \n[u v 1], for the i-th camera according to: \ns * cP[ i ] = A[ i ] * R−1[ i ] * ( wP − T[ i ] )  (H-85) \nwhere A[ i ] denotes the intrinsic camera parameter matrix, R−1[ i ] denotes the inverse of the rotation matrix R[ i ], T[ i ] \ndenotes the translation vector, and s (a scalar value) is an arbitrary scale factor chosen to make the third coordinate of \ncP[ i ] equal to 1. The elements of A[ i ], R[ i ], T[ i ] are determined according to the syntax elements signalled in this SEI \nmessage and as specified below. \nnum_views_minus1 shall be equal to the value of the syntax element num_views_minus1 in the active MVC sequence \nparameter set for the coded video sequence when the SEI message is not nested. When the SEI message is nested in an \nMVCD scalable nesting SEI message, num_views_minus1 shall be equal to the value of num_view_components_minus1 \nof the containing MVCD scalable nesting SEI message. The value of num_views_minus1 shall be in the range of 0 to 1023, \ninclusive. \nWhen the SEI message is not nested, the loop index i in the subsequent syntax elements indicates the view order index \nderived from the active MVC sequence parameter set. When the SEI message is nested in an MVCD scalable nesting SEI \nmessage, the loop index i in the subsequent syntax elements indicates the view with view_id equal to sei_view_id[ i ] of \nthe containing MVCD scalable nesting SEI message. \nintrinsic_param_flag equal to 1 indicates the presence of intrinsic camera parameters. intrinsic_param_flag equal to 0 \nindicates the absence of intrinsic camera parameters. \nextrinsic_param_flag equal to 1 indicates the presence of extrinsic camera parameters. extrinsic_param_flag equal to 0 \nindicates the absence of extrinsic camera parameters. \nintrinsic_params_equal equal to 1 indicates that the intrinsic camera parameters are equal for all cameras and only one \nset of intrinsic camera parameters are present.  intrinsic_params_equal equal to 0 indicates that the intrinsic camera \nparameters are different for each camera and that a set of intrinsic camera parameters are present for each camera. \nprec_focal_length  specifies  the  exponent  of  the  maximum  allowable  truncation  error  for  focal_length_x[ i ]  and \nfocal_length_y[ i ] as given by 2−prec_focal_length. The value of prec_focal_length shall be in the range of 0 to 31, inclusive. \nprec_principal_point specifies the exponent of the maximum allowable truncation error for principal_point_x[ i ] and \nprincipal_point_y[ i ] as given by 2−prec_principal_point. The value of prec_principal_point shall be in the range of 0 to 31, \ninclusive. \nprec_skew_factor  specifies  the  exponent  of  the  maximum  allowable  truncation  error  for  skew  factor  as  given  by \n2 prec_skew_factor. The value of prec_skew_factor shall be in the range of 0 to 31, inclusive. \nsign_focal_length_x[ i ] equal to 0 indicates that the sign of the focal length of the i-th camera in the horizontal direction \nis positive. sign_focal_length_x[ i ] equal to 1 indicates that the sign is negative. \nexponent_focal_length_x[ i ] specifies the exponent part of the focal length of the i-th camera in the horizontal direction. \nThe value of exponent_focal_length_x[ i ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved for future \nuse by ITU-T | ISO/IEC. Decoders shall treat the value 63 as indicating an unspecified focal length. \nmantissa_focal_length_x[ i ] specifies the mantissa part of the focal length of the i-th camera in the horizontal direction. \nThe length of the mantissa_focal_length_x[ i ] syntax element is variable and determined as follows: \n–  If exponent_focal_length_x[ i ] = = 0, the length is Max( 0, prec_focal_length − 30 ). \n–  Otherwise  (0  <  exponent_focal_length_x[ i ]  <  63),  the  length  is  Max( 0,  exponent_focal_length_x[ i ] + \nprec_focal_length − 31 ). \nsign_focal_length_y[ i ] equal to 0 indicates that the sign of the focal length of the i-th camera in the vertical direction is \npositive. sign_focal_length_y[ i ] equal to 1 indicates that the sign is negative. \nexponent_focal_length_y[ i ] specifies the exponent part of the focal length of the i-th camera in the vertical direction. \nThe value of exponent_focal_length_y[ i ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved for future \nuse by ITU-T | ISO/IEC. Decoders shall treat the value 63 as indicating an unspecified focal length. \nmantissa_focal_length_y[ i ] specifies the mantissa part of the focal length of the i-th camera in the vertical direction. The \nlength of the mantissa_focal_length_y[ i ] syntax element is variable and determined as follows: \n–  If exponent_focal_length_y[ i ] = = 0, the length is Max( 0, prec_focal_length − 30 ). \n–  Otherwise  (0  <  exponent_focal_length_y[ i ]  <  63),  the  length  is  Max( 0,  exponent_focal_length_y[ i ] + \nprec_focal_length − 31 ). \nsign_principal_point_x[ i ] equal to 0 indicates that the sign of the principal point of the i-th camera in the horizontal \n706  Rec. ITU-T H.264 (06/2019) \n \ndirection is positive. sign_principal_point_x[ i ] equal to 1 indicates that the sign is negative. \nexponent_principal_point_x[ i ] specifies the exponent part of the principal point of the i-th camera in the horizontal \ndirection. The value of exponent_principal_point_x[ i ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved \nfor future use by ITU-T | ISO/IEC. Decoders shall treat the value 63 as indicating an unspecified principal point. \nmantissa_principal_point_x[ i ] specifies the mantissa part of the principal point of the i-th camera in the horizontal \ndirection. The length of the mantissa_principal_point_x[ i ] syntax element in units of bits is variable and is determined as \nfollows: \n–  If exponent_principal_point_x[ i ] = = 0, the length is Max( 0, prec_principal_point − 30 ). \n–  Otherwise  (0  <  exponent_principal_point_x[ i ]  <  63),  the  length  is  Max( 0,  exponent_principal_point_x[ i ] + \nprec_principal_point − 31 ). \nsign_principal_point_y[ i ] equal to 0 indicates that the sign of the principal point of the i-th camera in the vertical \ndirection is positive. sign_principal_point_y[ i ] equal to 1 indicates that the sign is negative. \nexponent_principal_point_y[ i ] specifies the exponent part of the principal point of the i-th camera in the vertical \ndirection. The value of exponent_principal_point_y[ i ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved \nfor future use by ITU-T | ISO/IEC. Decoders shall treat the value 63 as indicating an unspecified principal point. \nmantissa_principal_point_y[ i ] specifies the  mantissa part of the principal point of the i-th camera in the vertical \ndirection. The length of the mantissa_principal_point_y[ i ] syntax element in units of bits is variable and is determined as \nfollows: \n–  If exponent_principal_point_y[ i ] = = 0, the length is Max( 0, prec_principal_point − 30 ). \n–  Otherwise  (0  <  exponent_principal_point_y[ i ]  <  63),  the  length  is  Max( 0,  exponent_principal_point_y[ i ] + \nprec_principal_point − 31 ). \nsign_skew_factor[ i ]  equal  to  0  indicates  that  the  sign  of  the  skew  factor  of  the  i-th  camera  is  positive. \nsign_skew_factor[ i ] equal to 1 indicates that the sign is negative. \nexponent_skew_factor[ i ]  specifies  the  exponent  part  of  the  skew  factor  of  the  i-th  camera.  The  value  of \nexponent_skew_factor[ i ]  shall  be  in  the  range  of 0  to 62,  inclusive.  The  value  63  is  reserved  for  future  use  by \nITU-T | ISO/IEC. Decoders shall treat the value 63 as indicating an unspecified skew factor. \nmantissa_skew_factor[ i ]  specifies  the  mantissa  part  of  the  skew  factor  of  the  i-th  camera.  The  length  of  the \nmantissa_skew_factor[ i ] syntax element is variable and determined as follows: \n–  If exponent_skew_factor[ i ] = = 0, the length is Max( 0, prec_skew_factor − 30 ). \n–  Otherwise  (0  <  exponent_skew_factor[ i ]  <  63),  the  length  is  Max( 0,  exponent_skew_factor[ i ] + \nprec_skew_factor − 31 ). \nThe intrinsic matrix A[ i ] for i-th camera is represented by \nfocalLengthX[i] skewFactor[i] principalP ointX[ i]\n   (H-86) \n0 focalLengthY[ i] principalP ointY[i]\n \n 0 0 1 \n \nprec_rotation_param specifies the exponent of the maximum allowable truncation error for r[ i ][ j ][ k ] as given by \n2−prec_rotation_param. The value of prec_rotation_param shall be in the range of 0 to 31, inclusive. \nprec_translation_param specifies the exponent of the maximum allowable truncation error for t[ i ][ j ] as given by \n2−prec_translation_param. The value of prec_ translation_param shall be in the range of 0 to 31, inclusive. \nsign_r[ i ][ j ][ k ] equal to 0 indicates that the sign of (j, k) component of the rotation matrix for the i-th camera is positive. \nsign_r[ i ][ j ][ k ] equal to 1 indicates that the sign is negative. \nexponent_r[ i ][ j ][ k ] specifies the exponent part of (j, k) component of the rotation matrix for the i-th camera. The value \nof  exponent_r[ i ][ j ][ k ]  shall  be  in  the  range  of 0  to 62,  inclusive.  The  value  63  is  reserved  for  future  use  by \nITU-T | ISO/IEC. Decoders shall treat the value 63 as indicating an unspecified rotation matrix. \nmantissa_r[ i ][ j ][ k ] specifies the mantissa part of (j, k) component of the rotation matrix for the i-th camera. The length \nof the mantissa_r[ i ][ j ][ k ] syntax element in units of bits is variable and determined as follows: \n–  If exponent_r[ i ] = = 0, the length is Max( 0, prec_rotation_param − 30 ). \n–  Otherwise (0 < exponent_r[ i ] < 63), the length is Max( 0, exponent_r[ i ] + prec_rotation_param − 31 ). \n    Rec. ITU-T H.264 (06/2019)  707 \n \nThe rotation matrix R[ i ] for i-th camera is represented as follows: \nrE[i][0][0] rE[i][0][1] rE[i][0][2]\n   (H-87) \nrE[ i ][ 1 ][ 0 ] rE[i][1][1] rE[i][1][2]\n \nrE[ i ][ 2 ][ 0 ] rE[i][2][1] rE[i][2][2]\n \nsign_t[ i ][ j ] equal to 0 indicates that the sign of the j-th component of the translation vector for the i-th camera is positive. \nsign_t[ i ][ j ] equal to 1 indicates that the sign is negative. \nexponent_t[ i ][ j ] specifies the exponent part of the j-th component of the translation vector for the i-th camera. The value \nof exponent_t[ i ][ j ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved for future use by ITU-T | ISO/IEC. \nDecoders shall treat the value 63 as indicating an unspecified translation vector. \nmantissa_t[ i ][ j ] specifies the mantissa part of the j-th component of the translation vector for the i-th camera. The length \nv of the mantissa_t[ i ][ j ] syntax element in units of bits is variable and is determined as follows: \n–  If exponent_t[ i ] = = 0, the length v = Max( 0, prec_translation_param − 30 ). \n–  Otherwise (0 < exponent_t[ i ] < 63), the length v = Max( 0, exponent_t[ i ] + prec_translation_param − 31 ). \nThe translation vector T[ i ] for the i-th camera is represented by: \ntE[ i ][ 0 ]\n       (H-88) \ntE[ i ][ 1 ]\n \ntE[ i ][ 2 ]\n \nThe association between the camera parameter variables and corresponding syntax elements is specified by Table H-3. \nEach component of the intrinsic and rotation matrices and the translation vector is obtained from the variables specified in \nTable H-3 as the variable x computed as follows: \n–  If 0 < e < 63, x = ( −1 )s * 2( e − 31 ) * ( 1 + n ÷ 2v ). \n–  Otherwise (e is equal to 0), x = ( −1 )s * 2−( 30 + v ) * n. \nNOTE – The above specification is similar to that found in IEC 60559:1989, Binary floating-point arithmetic for microprocessor \nsystems. \nTable H-3 – Association between camera parameter variables and syntax elements. \nx  s  e  n \nfocalLengthX[ i ]  sign_focal_length_x[ i ]  exponent_focal_length_x[ i ]  mantissa_focal_length_x[ i ] \nfocalLengthY[ i ]  sign_focal_length_y[ i ]  exponent_focal_length_y[ i ]  mantissa_focal_length_y[ i ] \nprincipalPointX[ i ]  sign_principal_point_x[ i ]  exponent_principal_point_x[ i ]  mantissa_principal_point_x[ i ] \nprincipalPointY[ i ]  sign_principal_point_y[ i ]  exponent_principal_point_y[ i ]  mantissa_principal_point_y[ i ] \nskewFactor[ i ]  sign_skew_factor[ i ]  exponent_skew_factor[ i ]  mantissa_skew_factor[ i ] \nrE[ i ][ j ][ k ]  sign_r[ i ][ j ][ k ]  exponent_r[ i ][ j ][ k ]  mantissa_r[ i ][ j ][ k ] \ntE[ i ][ j ]  sign_t[ i ][ j ]  exponent_t[ i ][ j ]  mantissa_t[ i ][ j ] \n \nH.13.2.6 Non-required view component SEI message semantics \nThis SEI message indicates non-required view components within the associated access unit. A view component is a non-\nrequired view component for a target view component if it is not needed for decoding the target view component and \nsubsequent view components with the same view_id in decoding order within the coded video sequence. \nSome of the view components indicated by view_order_index[ i ] or index_delta_minus1[ i ][ j ] may not be present in the \nassociated access unit. \nnum_info_entries_minus1  plus 1  specifies  the  number  of  target  view  components  for  which  non-required  view \ncomponents are indicated. The value of num_info_entries_minus1 shall be in the range of 0 to num_views_minus1 − 1, \ninclusive. \nview_order_index[ i ] specifies the view order index of the i-th target view component for which non-required view \ncomponents are indicated. The i-th target view component has view_id equal to view_id[ view_order_index[ i ] ]. The \nvalue of view_order_index[ i ] shall be in the range of 1 to num_views_minus1, inclusive. \nnum_non_required_view_components_minus1[ i ] plus 1 specifies the number of non-required view components for \n708  Rec. ITU-T H.264 (06/2019) \n \nthe i-th target view component. The value of num_non_required_view_components_minus1[ i ] shall be in the range of 0 \nto view_order_index[ i ] − 1, inclusive. \nindex_delta_minus1[ i ][ j ] plus 1 specifies the difference between the view order index of the i-th target view component \nand the view order index of the j-th non-required view component for the i-th target view component. The view order index \nof  the  j-th  non-required  view  component  for  the  i-th  target  view  component  is \nview_order_index[ i ] − index_delta_minus1[ i ][ j ] − 1. The value of index_delta_minus1[ i ][ j ] shall be in the range \nof 0 to view_order_index[ i ] − 1, inclusive. \nH.13.2.7 View dependency change SEI message semantics \nThis SEI message indicates that the view dependency information changes starting with the current access unit containing \nthe SEI message and is always interpreted with respect to the active MVC sequence parameter set. When present, the view \ndependency change SEI message applies to the target access unit set that consists of the current access unit and all the \nsubsequent access units, in decoding order, until the next view dependency change SEI message or the end of the coded \nvideo sequence, whichever is earlier in decoding order. \nIf, according to the view dependency information indicated in the active MVC sequence parameter set, view component \nA does not directly or indirectly depend on view component B and vice versa, the view dependency change SEI message \nshall not specify view dependency relationship between view components A and B. \nNOTE 1 – The dependent views for any view are always a subset of those indicated by the active MVC sequence parameter set. \nNOTE 2 – View dependency change SEI messages do not have a cumulative effect. \nSome of the views indicated by the following syntax elements may not be present in the target access unit set. \nseq_parameter_set_id specifies a subset sequence parameter set that contains the inter-view dependency relationship \ninformation.  The  value  of  seq_parameter_set_id  shall  be  equal  to  the  value  of  seq_parameter_set_id  in  the  picture \nparameter set referenced by a view component of the primary coded picture of the access  unit containing the view \ndependency change SEI message. The value of seq_parameter_set_id shall be in the range of 0 to 31, inclusive. \nanchor_update_flag equal to 1 indicates that there are updates for the dependencies for anchor view components relative \nto the dependencies defined in the active MVC sequence parameter set. anchor_update_flag equal to 0 indicates that there \nis no change for the dependencies for anchor view components relative to the dependencies defined in the active MVC \nsequence parameter set. \nnon_anchor_update_flag equal to 1 indicates that there are updates for the dependencies for non-anchor view components \nrelative to the dependencies defined in the active MVC sequence parameter set. non_anchor_update_flag equal to 0 \nindicates that there is no change for the dependencies for non-anchor view components relative to the dependencies defined \nin the active MVC sequence parameter set. \nanchor_ref_l0_flag[ i ][ j ] equal to 0 indicates that the j-th inter-view prediction reference in the initial reference picture \nlist RefPicList0 (which is derived as specified in clause H.8.2.1) for any anchor view component with view order index \nequal  to i  will  not  be  present  in  the  final  RefPicList0  after  reference  picture  list  modification  for  the  anchor  view \ncomponent.  anchor_ref_l0_flag[ i ][ j ]  equal  to 1  indicates  that  the  j-th  inter-view  prediction  reference  in  the  initial \nreference picture list RefPicList0 for at least one anchor view component with view order index equal to i will be present \nin the final RefPicList0 after reference picture list modification for the anchor view component. \nanchor_ref_l1_flag[ i ][ j ] equal to 0 indicates that the j-th inter-view prediction reference in the initial reference picture \nlist RefPicList1 (which is derived as specified in clause H.8.2.1) for any anchor view component with view order index \nequal  to i  will  not  be  present  in  the  final  RefPicList1  after  reference  picture  list  modification  for  the  anchor  view \ncomponent.  anchor_ref_l1_flag[ i ][ j ]  equal  to 1  indicates  that  the  j-th  inter-view  prediction  reference  in  the  initial \nreference picture list RefPicList1 for at least one anchor view component with view order index equal to i will be present \nin the final RefPicList1 after reference picture list modification for the anchor view component. \nnon_anchor_ref_l0_flag[ i ][ j ] equal to 0 indicates that the j-th inter-view prediction reference in the initial reference \npicture list RefPicList0 (which is derived as specified in clause H.8.2.1) for any non-anchor view component with view \norder index equal to i will not be present in the final RefPicList0 after reference picture list modification for the non-anchor \nview component. non-anchor_ref_l0_flag[ i ][ j ] equal to 1 indicates that the j-th inter-view prediction reference in the \ninitial reference picture list RefPicList0 for at least one non-anchor view component with view order index equal to i will \nbe present in the final RefPicList0 after reference picture list modification for the non-anchor view component. \nnon_anchor_ref_l1_flag[ i ][ j ] equal to 0 indicates that the j-th inter-view prediction reference in the initial reference \npicture list RefPicList1 (which is derived as specified in clause H.8.2.1) for any non-anchor view component with view \norder index equal to i will not be present in the final RefPicList1 after reference picture list modification for the non-anchor \nview component. non-anchor_ref_l1_flag[ i ][ j ] equal to 1 indicates that the j-th inter-view prediction reference in the \ninitial reference picture list RefPicList1 for at least one non-anchor view component with view order index equal to i will \nbe present in the final RefPicList1 after reference picture list modification for the non-anchor view component. \n    Rec. ITU-T H.264 (06/2019)  709 \n \nH.13.2.8 Operation point not present SEI message semantics \nThis SEI message indicates operation points that are not present in the bitstream starting with the current access unit, and \nis interpreted with respect to the previous view scalability information SEI message in decoding order. The message \nremains effective until the next SEI message of the same type or the end of the coded video sequence, whichever is earlier \nin decoding order. \nNOTE 1– Operation point not present SEI messages do not have a cumulative effect. \nNOTE 2 – Any operation point identified by a value of operation_point_id[ i ] in the previous view scalability information SEI \nmessage, in decoding order, and not identified by a value of operation_point_not_present_id[ k ] must be present in the coded video \nsequence. Therefore, when an application keeps an operation point not present SEI message in a sub-bitstream extracted according \nto the process specified in clause H.8.5.3, the application may need to change the content of the operation point not present SEI \nmessage according to the semantics. \nnum_operation_points specifies the number of operation points that are indicated not to be present by the SEI message. \nnum_operation_points equal to 0 indicates that all operation points indicated by the view scalability information SEI \nmessage  are  present.  The  value  of  num_operation_points  shall  be  in  the  range  of 0  to  the  value  of \nnum_operation_points_minus1 in the previous view scalability information SEI message in decoding order, inclusive. \noperation_point_not_present_id[ k ] identifies an operation point that is not present. operation_point_not_present_id[ k ] \nshall be equal to the value of one of the operation_point_id[ i ] syntax elements of the previous view scalability information \nSEI message in decoding order. The value of operation_point_not_present_id[ k ] shall be in the range of 0 to 65535, \ninclusive. \nH.13.2.9 Base view temporal HRD SEI message semantics \nWhen present, this SEI message shall be associated with an IDR access unit. The SEI message applies to the coded video \nsequence. Some temporal subsets identified by sei_mvc_temporal_id[ i ] may not be present in the coded video sequence. \nnum_of_temporal_layers_in_base_view_minus1 plus 1 specifies the number of temporal bitstream subsets in the coded \nvideo  sequence  for  which  the  following  syntax  elements  apply.  The  value  of \nnum_of_temporal_layers_in_base_view_minus1 shall be in the range of 0 to 7, inclusive. \nsei_mvc_temporal_id[ i ] specifies the temporal_id value of the i-th temporal bitstream subset. \nLet the i-th bitstream subset for the coded video sequence that is obtained by invoking the sub-bitstream extraction process \nas specified in clause H.8.5.3 with tIdTarget equal to sei_mvc_temporal_id[ i ] as input. \nsei_mvc_timing_info_present_flag[ i ] equal to 1 specifies that sei_mvc_num_units_in_tick[ i ], sei_mvc_time_scale[ i ], \nand  sei_mvc_fixed_frame_rate_flag[ i ]  are  present  in  the  base  view  temporal  HRD  SEI  message. \nsei_mvc_timing_info_present_flag[ i ] equal to 0 specifies that sei_mvc_num_units_in_tick[ i ], sei_mvc_time_scale[ i ], \nand sei_mvc_fixed_frame_rate_flag[ i ] are not present in the base view temporal HRD SEI message. \nThe following syntax elements for the i-th bitstream subset are specified using references to Annex E. For these syntax \nelements  the  same  semantics  and  constraints  as  the  ones  specified  in  Annex E  apply,  as  if  these  syntax  elements \nsei_mvc_num_units_in_tick[ i ],  sei_mvc_time_scale[ i ],  sei_mvc_fixed_frame_rate_flag[ i ], \nsei_mvc_nal_hrd_parameters_present_flag[ i ],  sei_mvc_vcl_hrd_parameters_present_flag[ i ], \nsei_mvc_low_delay_hrd_flag[ i ],  and  sei_mvc_pic_struct_present_flag[ i ]  were  present  as  num_units_in_tick, \ntime_scale,  fixed_frame_rate_flag,  nal_hrd_parameters_present_flag,  vcl_hrd_parameters_present_flag, \nlow_delay_hrd_flag,  and  pic_struct_present_flag,  respectively,  in  the  VUI  parameters  of  the  active  MVC  sequence \nparameter sets for the i-th bitstream subset. \nThe parameters for the i-th bitstream subset that are coded in the base view temporal HRD SEI message shall be correct, \nas if these parameters are used for conformance checking (as specified in Annex C) of the i-th bitstream subset. \nsei_mvc_num_units_in_tick[ i ] indicates the value of num_units_in_tick, as specified in clause E.2.1, that applies to the \ni-th bitstream subset. \nsei_mvc_time_scale[ i ] indicates the value of time_scale, as specified in clause E.2.1, that applies to the i-th bitstream \nsubset. \nsei_mvc_fixed_frame_rate_flag[ i ] indicates the value of fixed_frame_rate_flag, as specified in clause E.2.1, that applies \nto the i-th bitstream subset. \nsei_mvc_nal_hrd_parameters_present_flag[ i ] indicates the value of nal_hrd_parameters_present_flag, as specified in \nclause E.2.1, that applies to the i-th bitstream subset. When sei_mvc_nal_hrd_parameters_present_flag[ i ] is equal to 1, \nthe  NAL  HRD  parameters  that  apply  to  the  i-th  bitstream  subset  immediately  follow  the \nsei_mvc_nal_hrd_parameters_present_flag[ i ]. \nsei_mvc_vcl_hrd_parameters_present_flag[ i ] indicates the value of vcl_hrd_parameters_present_flag, as specified in \nclause E.2.1, that applies to the i-th bitstream subset. When sei_mvc_vcl_hrd_parameters_present_flag[ i ] is equal to 1, \n710  Rec. ITU-T H.264 (06/2019) \n \nthe  VCL  HRD  parameters  that  apply  to  the  i-th  bitstream  subset  immediately  follow  the \nsei_mvc_vcl_hrd_parameters_present_flag[ i ]. \nsei_mvc_low_delay_hrd_flag[ i ] indicates the value of low_delay_hrd_flag, as specified in clause E.2.1, that applies to \nthe i-th bitstream subset. \nsei_mvc_pic_struct_present_flag[ i ] indicates the value of pic_struct_present_flag, as specified in clause E.2.1, that \napplies to the i-th bitstream subset. \nH.13.2.10  Multiview view position SEI message semantics \nThe multiview view position SEI message specifies the relative view position along a single horizontal axis of view \ncomponents within a coded video sequence. When present, the multiview view position SEI message shall be associated \nwith an IDR access unit. The information signalled in this SEI message applies to the entire coded video sequence. \nnum_views_minus1 shall be equal to the value of the syntax element num_views_minus1 in the active MVC sequence \nparameter set for the coded video sequence. The value of num_views_minus1 shall be in the range of 0 to 1023, inclusive. \nview_position[ i ] indicates the order of the view with VOIdx equal to i among all the views from left to right for the \npurpose of display, with the order for the left-most view being equal to 0 and the value of the order increasing by 1 for \nnext view from left to right. The value of view_position[ i ] shall be in the range of 0 to 1023, inclusive. \nmultiview_view_position_extension_flag equal to 0 indicates that no additional data follows within the multiview view \nposition SEI message. The value of multiview_view_position_extension_flag shall be equal to 0. The value of 1 for \nmultiview_view_position_extension_flag is reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore all data that \nfollows the value of 1 for multiview_view_position_extension_flag in a multiview view position SEI message. \nH.14  Video usability information \nThe specifications in Annex E apply with substituting MVC sequence parameter set for sequence parameter set. \nWith maxVOIdx being the maximum value of view order index for the views that reference the MVC sequence parameter \nset containing the vui_parameters( ) syntax structure, the VUI parameters and the constraints specified in Annex E apply \nto all views with a value of view order index that is less than or equal to maxVOIdx. \nAdditionally, the following applies. \nH.14.1  MVC VUI parameters extension syntax \n \nmvc_vui_parameters_extension( ) {  C  Descriptor \n  vui_mvc_num_ops_minus1  0  ue(v) \n  for( i = 0; i <= vui_mvc_num_ops_minus1; i++ ) {     \n    vui_mvc_temporal_id[ i ]  0  u(3) \n    vui_mvc_num_target_output_views_minus1[ i ]  5  ue(v) \n    for( j = 0; j <= vui_mvc_num_target_output_views_minus1[ i ]; j++ )      \n      vui_mvc_view_id[ i ][ j ]  5  ue(v) \n    vui_mvc_timing_info_present_flag[ i ]  0  u(1) \n    if( vui_mvc_timing_info_present_flag[ i ] ) {     \n      vui_mvc_num_units_in_tick[ i ]  0  u(32) \n      vui_mvc_time_scale[ i ]  0  u(32) \n      vui_mvc_fixed_frame_rate_flag[ i ]  0  u(1) \n    }     \n    vui_mvc_nal_hrd_parameters_present_flag[ i ]  0  u(1) \n    if( vui_mvc_nal_hrd_parameters_present_flag[ i ] )     \n      hrd_parameters( )  0   \n    vui_mvc_vcl_hrd_parameters_present_flag[ i ]  0  u(1) \n    if( vui_mvc_vcl_hrd_parameters_present_flag[ i ] )     \n      hrd_parameters( )  0   \n    if( vui_mvc_nal_hrd_parameters_present_flag[ i ]  | |       \n      vui_mvc_vcl_hrd_parameters_present_flag[ i ] ) \n      vui_mvc_low_delay_hrd_flag[ i ]  0  u(1) \n    Rec. ITU-T H.264 (06/2019)  711 \n \n    vui_mvc_pic_struct_present_flag[ i ]   0  u(1) \n  }     \n}     \n \nH.14.2  MVC VUI parameters extension semantics \nThe MVC VUI parameters extension specifies VUI parameters that apply to one or more operation points for the coded \nvideo sequence. In Annex C it is specified which of the HRD parameter sets specified in the MVC VUI parameters extension are used \nfor conformance checking. All MVC VUI parameters extensions that are referred to by a coded video sequence shall be \nidentical. \nSome views identified by vui_mvc_view_id[ i ][ j ] may not be present in the coded video sequence. Some temporal subsets \nidentified by vui_mvc_temporal_id[ i ] may not be present in the coded video sequence. \nvui_mvc_num_ops_minus1 plus 1 specifies the number of operation points for which timing information, NAL HRD \nparameters,  VCL  HRD  parameters,  and  the  pic_struct_present_flag  may  be  present.  The  value  of \nvui_mvc_num_ops_minus1 shall be in the range of 0 to 1023, inclusive. \nvui_mvc_temporal_id[ i ] indicates the maximum value of temporal_id for all VCL NAL units in the representation of \nthe i-th operation point. \nvui_mvc_num_target_output_views_minus1[ i ]  plus  one  specifies  the  number  of  target  output  views  for  the  i-th \noperation point. The value of vui_mvc_num_target_output_views_minus1[ i ] shall be in the range of 0 to 1023, inclusive. \nvui_mvc_view_id[ i ][ j ]  indicates  the  j-th  target  output  view  in  the  i-th  operation  point.  The  value  of \nvui_mvc_view_id[ i ] shall be in the range of 0 to 1023, inclusive. \nThe following syntax elements apply to the coded video sequence that is obtained by the sub-bitstream extraction process \nas  specified  in  clause H.8.5.3  with  tIdTarget  equal  to  vui_mvc_temporal_id[ i ]  and  viewIdTargetList  containing \nvui_mvc_view_id[ i ][ j ] for all j in the range of 0 to vui_mvc_num_target_output_views_minus1[ i ], inclusive, as the \ninputs and the i-th sub-bitstream as the output. \nvui_mvc_timing_info_present_flag[ i ]  equal  to  1  specifies  that  vui_mvc_num_units_in_tick[ i ], \nvui_mvc_time_scale[ i ], and vui_mvc_fixed_frame_rate_flag[ i ] for the i-th sub-bitstream are present in the MVC VUI \nparameters extension. vui_mvc_timing_info_present_flag[ i ] equal to 0 specifies that vui_mvc_num_units_in_tick[ i ], \nvui_mvc_time_scale[ i ], and vui_mvc_fixed_frame_rate_flag[ i ] for the i-th sub-bitstream are not present in the MVC \nVUI parameters extension. \nThe following syntax elements for the i-th sub-bitstream are specified using references to Annex E. For these syntax \nelements  the  same  semantics  and  constraints  as  the  ones  specified  in  Annex E  apply,  as  if  these  syntax  elements \nvui_mvc_num_units_in_tick[ i ],  vui_mvc_time_scale[ i ],  vui_mvc_fixed_frame_rate_flag[ i ], \nvui_mvc_nal_hrd_parameters_present_flag[ i ],  vui_mvc_vcl_hrd_parameters_present_flag[ i ], \nvui_mvc_low_delay_hrd_flag[ i ],  and  vui_mvc_pic_struct_present_flag[ i ]  were  present  as  the  syntax  elements \nnum_units_in_tick,  time_scale,  fixed_frame_rate_flag,  nal_hrd_parameters_present_flag, \nvcl_hrd_parameters_present_flag, low_delay_hrd_flag, and pic_struct_present_flag, respectively, in the VUI parameters \nof the active MVC sequence parameter sets for the i-th sub-bitstream. \nvui_mvc_num_units_in_tick[ i ] specifies the value of num_units_in_tick, as specified in clause E.2.1, for the i-th sub-\nbitstream. \nvui_mvc_time_scale[ i ] specifies the value of time_scale, as specified in clause E.2.1, for the i-th sub-bitstream. \nvui_mvc_fixed_frame_rate_flag[ i ] specifies the value of fixed_frame_rate_flag, as specified in clause E.2.1, for the i-\nth sub-bitstream. \nvui_mvc_nal_hrd_parameters_present_flag[ i ] specifies the value of nal_hrd_parameters_present_flag, as specified in \nclause E.2.1, for the i-th sub-bitstream. \nWhen vui_mvc_nal_hrd_parameters_present_flag[ i ] is equal to 1, NAL HRD parameters (clauses E.1.2 and E.2.2) for \nthe i-th sub-bitstream immediately follow the flag. \nThe variable VuiMvcNalHrdBpPresentFlag[ i ] is derived as follows: \n–  If any of the following is true, the value of VuiMvcNalHrdBpPresentFlag[ i ] shall be set equal to 1: \n–  vui_mvc_nal_hrd_parameters_present_flag[ i ] is present in the bitstream and is equal to 1, \n712  Rec. ITU-T H.264 (06/2019) \n \n–  for the i-th sub-bitstream, the need for presence of buffering periods for NAL HRD operation to be present in \nthe bitstream in buffering period SEI messages is determined by the application, by some means not specified in \nthis Recommendation | International Standard. \n–  Otherwise, the value of VuiMvcNalHrdBpPresentFlag[ i ] shall be set equal to 0. \nvui_mvc_vcl_hrd_parameters_present_flag[ i ] specifies the value of vcl_hrd_parameters_present_flag, as specified in \nclause E.2.1, for the i-th sub-bitstream. \nWhen vui_mvc_vcl_hrd_parameters_present_flag[ i ] is equal to 1, VCL HRD parameters (clauses E.1.2 and E.2.2) for \nthe i-th sub-bitstream immediately follow the flag. \nThe variable VuiMvcVclHrdBpPresentFlag[ i ] is derived as follows: \n–  If any of the following is true, the value of VuiMvcVclHrdBpPresentFlag[ i ] shall be set equal to 1: \n–  vui_mvc_vcl_hrd_parameters_present_flag[ i ] is present in the bitstream and is equal to 1, \n–  for the i-th sub-bitstream, the need for presence of buffering period parameters for VCL HRD operation in the \nbitstream in buffering period SEI messages is determined by the application, by some means not specified in this \nRecommendation | International Standard. \n–  Otherwise, the value of VuiMvcVclHrdBpPresentFlag[ i ] shall be set equal to 0. \nThe variable VuiMvcCpbDpbDelaysPresentFlag[ i ] is derived as follows: \n–  If any of the following is true, the value of VuiMvcCpbDpbDelaysPresentFlag[ i ] shall be set equal to 1: \n–  vui_mvc_nal_hrd_parameters_present_flag[ i ] is present in the bitstream and is equal to 1, \n–  vui_mvc_vcl_hrd_parameters_present_flag[ i ] is present in the bitstream and is equal to 1, \n–  for the i-th sub-bitstream, the need for presence of CPB and DPB output delays in the bitstream in picture timing \nSEI  messages  is  determined  by  the  application,  by  some  means  not  specified  in  this  Recommendation  | \nInternational Standard. \n–  Otherwise, the value of VuiMvcCpbDpbDelaysPresentFlag[ i ] shall be set equal to 0. \nvui_mvc_low_delay_hrd_flag[ i ] specifies the value of low_delay_hrd_flag, as specified in clause E.2.1, for the i-th sub-\nbitstream. \nvui_mvc_pic_struct_present_flag[ i ] specifies the value of pic_struct_present_flag, as specified in clause E.2.1, for the \ni-th sub-bitstream. \n \n   \n    Rec. ITU-T H.264 (06/2019)  713 \n \nAnnex I \n \nMultiview and depth video coding \n \n(This annex forms an integral part of this Recommendation | International Standard.) \nThis annex specifies multiview video coding with depth information, referred to as MVCD. \nI.1  Scope \nBitstreams and decoders conforming to the profile specified in this annex are completely specified in this annex with \nreference made to clauses 2 to 9 and Annexes A to H. \nI.2  Normative references \nThe specifications in clause 2 apply. \nI.3  Definitions \nFor the purpose of this annex, the following definitions apply in addition to the definitions in clause H.3. These definitions \nare either not present in clause H.3 or replace definitions in clause H.3. \nI.3.1  depth field view: A depth view component of a field. \nI.3.2  depth frame view: A depth view component of a frame. \nI.3.3  depth view: A sequence of depth view components associated with an identical value of view_id. \nI.3.4  depth view component: A coded representation of the depth of a view in a single access unit. \nI.3.5  inter-view only reference component: A view component, texture view component, or depth view component \ncoded with  nal_ref_idc equal to 0 and inter_view_flag equal to 1. An inter-view only  reference component \ncontains  samples  that  may  be  used  for  inter-view  prediction  in  the  decoding  process  of  subsequent  view \ncomponents in decoding order, but are not used for inter prediction by any view components. Inter-view only \nreference components are non-reference pictures. \nI.3.6  inter-view reference component: A view component, texture view component, or depth view component coded \nwith nal_ref_idc greater than 0 and inter_view_flag equal to 1. An inter-view reference component contains \nsamples that may be used for inter prediction of subsequent pictures in decoding order and inter-view prediction \nof subsequent view components in decoding order. Inter-view reference components are reference pictures. \nI.3.7  MVCD operation point: An operation point for which each target output view includes a texture view or a depth \nview or both a texture view and a depth view. \nI.3.8  MVCD sequence parameter set: A collective term for sequence parameter set or subset sequence parameter \nset. \nI.3.9  MVCD sequence parameter set RBSP: A collective term for sequence parameter set RBSP or subset sequence \nparameter set RBSP. \nI.3.10  reference picture: A view component, texture view component, or depth view component coded with nal_ref_idc \ngreater than 0. A reference picture contains samples that may be used for inter prediction in the decoding process \nof subsequent view components in decoding order. A reference picture may be an inter-view reference component, \nin which case the samples contained in the reference picture may also be used for inter-view prediction in the \ndecoding process of subsequent view components in decoding order. \nI.3.11  stereoscopic texture bitstream: A bitstream containing two texture views and conforming to one of the profiles \nspecified in Annex H. \nI.3.12  texture field view component: A texture view component of a field. \nI.3.13  texture frame view component: A texture view component of a frame. \nI.3.14  texture view: A sequence of texture view components associated with an identical value of view_id. \nI.3.15  texture view component: A coded representation of the texture of a view in a single access unit. \nI.3.16  view: A texture view and a depth view with the same value of view_id, unless explicitly limited to either texture \n714  Rec. ITU-T H.264 (06/2019) \n \nview or depth view. \nI.3.17  view component: A coded representation of a view in a single access unit. A view component may consist of a \ntexture view component and a depth view component. \nI.3.18  view component pair: A texture view component and a depth view component of the same view within the same \naccess unit. \nI.4  Abbreviations \nThe specifications in clause 4 apply. \nI.5  Conventions \nThe specifications in clause 5 apply. \nI.6  Source,  coded,  decoded  and  output  data  formats,  scanning  processes,  and  neighbouring \nrelationships \nThe specifications in clause 6 apply with substitution of MVCD sequence parameter set for sequence parameter set. \nI.7  Syntax and semantics \nThis clause specifies syntax and semantics for coded video sequences that conform to one or more of the profiles specified \nin this annex. \nI.7.1  Method of specifying syntax in tabular form \nThe specifications in clause H.7.1 apply. \nI.7.2  Specification of syntax functions, categories, and descriptors \nThe specifications in clause H.7.2 apply. \nI.7.3  Syntax in tabular form \nI.7.3.1  NAL unit syntax \nThe syntax table is specified in clause H.7.3.1. \nI.7.3.1.1  NAL unit header MVC extension syntax \nThe syntax table is specified in clause H.7.3.1.1. \nI.7.3.2  Raw byte sequence payloads and RBSP trailing bits syntax \nI.7.3.2.1  Sequence parameter set RBSP syntax \nThe syntax table is specified in clause H.7.3.2.1. \nI.7.3.2.1.1  Sequence parameter set data syntax \nThe syntax table is specified in clause H.7.3.2.1.1. \nI.7.3.2.1.1.1  Scaling list syntax \nThe syntax table is specified in clause H.7.3.2.1.1.1. \nI.7.3.2.1.2  Sequence parameter set extension RBSP syntax \nThe syntax table is specified in clause H.7.3.2.1.2. \nI.7.3.2.1.3  Subset sequence parameter set RBSP syntax \nThe syntax table is specified in clause H.7.3.2.1.3. \nI.7.3.2.1.4  Sequence parameter set MVC extension syntax \nThe syntax table is specified in clause H.7.3.2.1.4. \n    Rec. ITU-T H.264 (06/2019)  715 \n \nI.7.3.2.1.5  Sequence parameter set MVCD extension syntax \n \nseq_parameter_set_mvcd_extension( ) {  C  Descriptor \n  num_views_minus1  0  ue(v) \n  for( i = 0, NumDepthViews = 0; i <= num_views_minus1; i++ ) {     \n    view_id[ i ]  0  ue(v) \n    depth_view_present_flag[ i ]  0  u(1) \n    DepthViewId[ NumDepthViews ] = view_id[ i ]     \n    NumDepthViews += depth_view_present_flag[ i ]     \n    texture_view_present_flag[ i ]  0  u(1) \n  }     \n  for( i = 1; i <= num_views_minus1; i++ )     \n    if( depth_view_present_flag[ i ] ) {     \n      num_anchor_refs_l0[ i ]  0  ue(v) \n      for( j = 0; j < num_anchor_refs_l0[ i ]; j++ )     \n        anchor_ref_l0[ i ][ j ]  0  ue(v) \n      num_anchor_refs_l1[ i ]  0  ue(v) \n      for( j = 0; j < num_anchor_refs_l1[ i ]; j++ )     \n        anchor_ref_l1[ i ][ j ]  0  ue(v) \n    }     \n  for( i = 1; i <= num_views_minus1; i++ )     \n    if( depth_view_present_flag[ i ] ) {     \n      num_non_anchor_refs_l0[ i ]  0  ue(v) \n      for( j = 0; j < num_non_anchor_refs_l0[ i ]; j++ )     \n        non_anchor_ref_l0[ i ][ j ]  0  ue(v) \n      num_non_anchor_refs_l1[ i ]  0  ue(v) \n      for( j = 0; j < num_non_anchor_refs_l1[ i ]; j++ )     \n        non_anchor_ref_l1[ i ][ j ]  0  ue(v) \n    }     \n  num_level_values_signalled_minus1  0  ue(v) \n  for( i = 0; i <= num_level_values_signalled_minus1; i++ ) {     \n    level_idc[ i ]  0  u(8) \n    num_applicable_ops_minus1[ i ]  0  ue(v) \n    for( j = 0; j <= num_applicable_ops_minus1[ i ]; j++ ) {     \n      applicable_op_temporal_id[ i ][ j ]  0  u(3) \n      applicable_op_num_target_views_minus1[ i ][ j ]  0  ue(v) \n      for( k = 0; k <= applicable_op_num_target_views_minus1[ i ][ j ];     \n        k++ ) { \n        applicable_op_target_view_id[ i ][ j ][ k ]  0  ue(v) \n        applicable_op_depth_flag[ i ][ j ][ k ]  0  u(1) \n        applicable_op_texture_flag[ i ][ j ][ k ]  0  u(1) \n      }     \n      applicable_op_num_texture_views_minus1[ i ][ j ]  0  ue(v) \n      applicable_op_num_depth_views[ i ][ j ]  0  ue(v) \n    }     \n  }     \n  mvcd_vui_parameters_present_flag  0  u(1) \n  if( mvcd_vui_parameters_present_flag  = =  1 )     \n    mvcd_vui_parameters_extension( )     \n  texture_vui_parameters_present_flag  0  u(1) \n  if( texture_vui_parameters_present_flag  = =  1 )     \n    mvc_vui_parameters_extension( )  0   \n}     \n \n716  Rec. ITU-T H.264 (06/2019) \n \nI.7.3.2.2  Picture parameter set RBSP syntax \nThe syntax table is specified in clause H.7.3.2.2. \nI.7.3.2.3  Supplemental enhancement information RBSP syntax \nThe syntax table is specified in clause H.7.3.2.3. \nI.7.3.2.3.1  Supplemental enhancement information message syntax \nThe syntax table is specified in clause H.7.3.2.3.1. \nI.7.3.2.4  Access unit delimiter RBSP syntax \nThe syntax table is specified in clause H.7.3.2.4. \nI.7.3.2.5  End of sequence RBSP syntax \nThe syntax table is specified in clause H.7.3.2.5. \nI.7.3.2.6  End of stream RBSP syntax \nThe syntax table is specified in clause H.7.3.2.6. \nI.7.3.2.7  Filler data RBSP syntax \nThe syntax table is specified in clause H.7.3.2.7. \nI.7.3.2.8  Slice layer without partitioning RBSP syntax \nThe syntax table is specified in clause H.7.3.2.8. \nI.7.3.2.9  Slice data partition RBSP syntax \nSlice data partition syntax is not present in coded video sequences conforming to one or more of the profiles specified in \nthis annex. \nI.7.3.2.10  RBSP slice trailing bits syntax \nThe syntax table is specified in clause H.7.3.2.10. \nI.7.3.2.11  RBSP trailing bits syntax \nThe syntax table is specified in clause H.7.3.2.11. \nI.7.3.2.12  Prefix NAL unit RBSP syntax \nThe syntax table is specified in clause H.7.3.2.12. \nI.7.3.2.13  Slice layer extension RBSP syntax \nThe syntax table is specified in clause H.7.3.2.13. \nI.7.3.3  Slice header syntax \nThe syntax table is specified in clause H.7.3.3. \nI.7.3.3.1  Reference picture list modification syntax \nThe syntax table is specified in clause H.7.3.3.1. \nI.7.3.3.1.1  Reference picture list MVC modification syntax \nThe syntax table is specified in clause H.7.3.3.1.1 \nI.7.3.3.2  Prediction weight table syntax \nThe syntax table is specified in clause H.7.3.3.2. \nI.7.3.3.3  Decoded reference picture marking syntax \nThe syntax table is specified in clause H.7.3.3.3. \nI.7.3.4  Slice data syntax \nThe syntax table is specified in clause H.7.3.4. \nI.7.3.5  Macroblock layer syntax \nThe syntax table is specified in clause H.7.3.5. \n    Rec. ITU-T H.264 (06/2019)  717 \n \nI.7.3.5.1  Macroblock prediction syntax \nThe syntax table is specified in clause H.7.3.5.1. \nI.7.3.5.2  Sub-macroblock prediction syntax \nThe syntax table is specified in clause H.7.3.5.2. \nI.7.3.5.3  Residual data syntax \nThe syntax table is specified in clause H.7.3.5.3. \nI.7.3.5.3.1  Residual luma syntax \nThe syntax table is specified in clause H.7.3.5.3.1. \nI.7.3.5.3.2  Residual block CAVLC syntax \nThe syntax table is specified in clause H.7.3.5.3.2. \nI.7.3.5.3.3  Residual block CABAC syntax \nThe syntax table is specified in clause H.7.3.5.3.3. \nI.7.4  Semantics \nSemantics  associated  with  the  syntax  structures  and  syntax  elements  within  these  structures  (in  clause I.7.3  and  in \nclause H.7.3 by reference in clause I.7.3) are specified in this clause and by reference to clause I.7.4. When the semantics \nof a syntax element are specified using a table or a set of tables, any values that are not specified in the table(s) shall not \nbe present in the bitstream unless otherwise specified in this Recommendation | International Standard. \nI.7.4.1  NAL unit semantics \nThe semantics for the syntax elements in clause I.7.3.1 are specified in clause H.7.4.1. \nI.7.4.1.1  NAL unit header MVC extension semantics \nThe semantics for the syntax elements in clause I.7.3.1.1 are specified in clause H.7.4.1.1. \nI.7.4.1.2  Order of NAL units and association to coded pictures, access units, and video sequences \nThis clause specifies constraints on the order of NAL units in the bitstream. Any order of NAL units in the bitstream \nobeying these constraints is referred to in the text as the decoding order of NAL units. Within a NAL unit, the syntax in \nclauses 7.3, D.1, E.1, H.7.3, H.13.1, H.14.1, I.13.1 and I.14.1 specifies the decoding order of syntax elements. Decoders \nshall be capable of receiving NAL units and their syntax elements in decoding order. \nI.7.4.1.2.1  Order of MVCD sequence parameter set RBSPs and picture parameter set RBSPs and their activation \nNOTE 1 – The sequence and picture parameter set mechanism decouples the transmission of infrequently changing information \nfrom the transmission of coded macroblock data. Sequence and picture parameter sets may, in some applications, be conveyed \"out-\nof-band\" using a reliable transport mechanism. \nA picture parameter set RBSP includes parameters that can be referred to by the coded slice NAL units of one or more \ntexture view or depth view components of one or more coded pictures. \nEach picture parameter set RBSP is initially considered not active at the start of the operation of the decoding process. At \nmost one picture parameter set RBSP is considered as the active picture parameter set RBSP at any given moment during \nthe operation of the decoding process, and when any particular picture parameter set RBSP becomes the active picture \nparameter set RBSP, the previously-active picture parameter set RBSP (if any) is deactivated. \nIn addition to the active picture parameter set RBSP, zero or more picture parameter set RBSPs may be specifically active \nfor texture view components (with a particular value of VOIdx less than or equal to VOIdxMax) that belong to the target \noutput views or that may be referred to through inter-view prediction in decoding texture view components belonging to \nthe target output views. Such a picture parameter set RBSP is referred to as the active texture picture parameter set RBSP \nfor the particular value of VOIdx. The restrictions on active picture parameter set RBSPs also apply to active texture picture \nparameter set RBSPs for a particular value of VOIdx. \nFurthermore, zero or more picture parameter set RBSPs may be specifically active for depth view components (with a \nparticular value of VOIdx less than VOIdxMax) that belong to the target output views or that may be referred to through \ninter-view prediction in decoding depth view components belonging to the target output views. Such a picture parameter \nset RBSP is referred to as the active depth picture parameter set RBSP for the particular value of VOIdx. The restrictions \non active picture parameter set RBSPs also apply to active depth picture parameter set RBSPs for a particular value of \nVOIdx less than VOIdxMax. \n718  Rec. ITU-T H.264 (06/2019) \n \nWhen a picture parameter set RBSP (with a particular value of pic_parameter_set_id) is not the active picture parameter \nset RBSP and it is referred to by a coded slice NAL unit belonging to a depth view component (i.e., with nal_unit_type \nequal to 21) and with VOIdx equal to VOIdxMax (using that value of pic_parameter_set_id), it is activated. This picture \nparameter set RBSP is called the active picture parameter set RBSP until it is deactivated when another picture parameter \nset RBSP becomes the active picture parameter set RBSP. A picture parameter set RBSP, with that particular value of \npic_parameter_set_id, shall be available to the decoding process prior to its activation. \nWhen a picture parameter set RBSP (with a particular value of pic_parameter_set_id) is not the active depth picture \nparameter set for a particular value of VOIdx less than VOIdxMax and it is referred to by a coded slice NAL unit belonging \nto a depth view component (i.e., with nal_unit_type equal to 21) and with the particular value of VOIdx (using that value \nof pic_parameter_set_id), it is activated for view components with the particular value of VOIdx. This picture parameter \nset RBSP is called the active depth picture parameter set RBSP for the particular value of VOIdx until it is deactivated \nwhen another picture parameter set RBSP becomes the active depth picture parameter set RBSP for the particular value of \nVOIdx. A picture parameter set RBSP, with that particular value of pic_parameter_set_id, shall be available to the decoding \nprocess prior to its activation. \nWhen a picture parameter set RBSP (with a particular value of pic_parameter_set_id) is not the active texture picture \nparameter set for a particular value of VOIdx less than or equal to VOIdxMax and it is referred to by a coded slice NAL \nunit belonging to a texture view component (i.e., with nal_unit_type equal to 1, 5 or 20) and with the particular value of \nVOIdx (using that value of pic_parameter_set_id), it is activated for texture view components with the particular value of \nVOIdx. This picture parameter set RBSP is called the active texture picture parameter set RBSP for the particular value of \nVOIdx until it is deactivated when another picture parameter set RBSP becomes the active texture picture parameter set \nRBSP for the particular value of VOIdx. A picture parameter set RBSP, with that particular value of pic_parameter_set_id, \nshall be available to the decoding process prior to its activation. \nAny picture parameter set NAL unit containing the value of pic_parameter_set_id for the active picture parameter set \nRBSP for a coded picture shall have the same content as that of the active picture parameter set RBSP for this coded picture \nunless it follows the last VCL NAL unit of this coded picture and precedes the first VCL NAL unit of another coded \npicture. Any picture parameter set NAL unit containing the value of pic_parameter_set_id for the active depth picture \nparameter set RBSP for a particular value of VOIdx less than VOIdxMax for a coded picture shall have the same content \nas that of the active view picture parameter set RBSP for the particular value of VOIdx for this coded picture unless it \nfollows the last VCL NAL unit of this coded picture and precedes the first VCL NAL unit of another coded picture. Any \npicture parameter set NAL unit containing the value of pic_parameter_set_id for the active texture picture parameter set \nRBSP for a particular value of VOIdx for a coded picture shall have the same content as that of the active texture picture \nparameter set RBSP for the particular value of VOIdx for this coded picture unless it follows the last VCL NAL unit of \nthis coded picture and precedes the first VCL NAL unit of another coded picture. \nAn MVCD sequence parameter set RBSP includes parameters that can be referred to by one or more picture parameter set \nRBSPs or one or more buffering period SEI messages. \nEach MVCD sequence parameter set RBSP is initially considered not active at the start of the operation of the decoding \nprocess. At most one MVCD sequence parameter set RBSP is considered as the active MVCD sequence parameter set \nRBSP at any given moment during the operation of the decoding process, and when any particular MVCD sequence \nparameter set RBSP becomes the active MVCD sequence parameter set RBSP, the previously-active MVCD sequence \nparameter set RBSP (if any) is deactivated. \nIn addition to the active MVCD sequence parameter set RBSP, zero or more MVCD sequence parameter set RBSPs may \nbe specifically active for view components (with a particular value of VOIdx less than VOIdxMax) that belong to the target \noutput views or that may be referred to through inter-view prediction in decoding view components belonging to the target \noutput views. Such an MVCD sequence parameter set RBSP is referred to as the active view MVCD sequence parameter \nset RBSP for the particular value of VOIdx. The restrictions on active MVCD sequence parameter set RBSPs also apply \nto active view MVCD sequence parameter set RBSPs for a particular value of VOIdx less than VOIdxMax. \nFurthermore, zero or more MVCD sequence parameter set RBSPs may be specifically active for texture view components \n(with a particular value of VOIdx less than or equal to VOIdxMax) that belong to the target output views or that may be \nreferred to through inter-view prediction in decoding texture view components belonging to the target output views. Such \nan MVCD sequence parameter set RBSP is referred to as the active texture MVCD sequence parameter set RBSP for the \nparticular value of VOIdx. The restrictions on active MVCD sequence parameter set RBSPs also apply to active texture \nMVCD sequence parameter set RBSPs for a particular value of VOIdx. \nFor the following specification, the activating buffering period SEI message is specified as follows. \n–  If VOIdxMax is equal to VOIdxMin and the access unit contains a buffering period SEI message not included in an \nMVC scalable nesting SEI message and not included in an MVCD scalable nesting SEI message, this buffering period \nSEI message is the activating buffering period SEI message. \n    Rec. ITU-T H.264 (06/2019)  719 \n \n–  Otherwise if VOIdxMax is not equal to VOIdxMin and the access unit contains a buffering period SEI message \nincluded in an MVCD scalable nesting SEI message and associated with the operation point being decoded, this \nbuffering period SEI message is the activating buffering period SEI message. \n–  Otherwise, the access unit does not contain an activating buffering period SEI message. \nWhen a sequence parameter set RBSP (nal_unit_type is equal to 7) with a particular value of seq_parameter_set_id is not \nalready the active MVCD sequence parameter set RBSP and it is referred to by activation of a picture parameter set RBSP \n(using that value of seq_parameter_set_id) and the picture parameter set RBSP is activated by a coded slice NAL unit with \nnal_unit_type equal to 1 or 5 (the picture parameter set  RBSP becomes  the active picture parameter set  RBSP and \nVOIdxMax is equal to VOIdxMin and there is no depth view component in any access unit) and the access unit does not \ncontain an activating buffering period SEI message, it is activated. This sequence parameter set RBSP is called the active \nMVCD sequence parameter set RBSP until it is deactivated when another MVCD sequence parameter set RBSP becomes \nthe  active  MVCD  sequence  parameter  set  RBSP.  A  sequence  parameter  set  RBSP,  with  that  particular  value  of \nseq_parameter_set_id, shall be available to the decoding process prior to its activation. \nWhen a sequence parameter set RBSP (nal_unit_type is equal to 7) with a particular value of seq_parameter_set_id is not \nalready the active MVCD sequence parameter set RBSP and it is referred to by an activating buffering period SEI message \n(using that value of seq_parameter_set_id) that is not included in an MVCD scalable nesting SEI message and VOIdxMax \nis equal to VOIdxMin and there is no depth view component in the access unit, it is activated. This sequence parameter set \nRBSP is called the active MVCD sequence parameter set RBSP until it is deactivated when another MVCD sequence \nparameter set RBSP becomes the active MVCD sequence parameter set RBSP. A sequence parameter set RBSP, with that \nparticular value of seq_parameter_set_id, shall be available to the decoding process prior to its activation. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active MVCD sequence parameter set RBSP and it is referred to by activation of a picture parameter set \nRBSP (using that value of seq_parameter_set_id) and the picture parameter set RBSP is activated by a coded slice depth \nextension NAL unit with nal_unit_type equal to 21 and with VOIdx equal to VOIdxMax (the picture parameter set RBSP \nbecomes the active picture parameter set RBSP) and the access unit does not contain an activating buffering period SEI \nmessage, it is activated. This subset sequence parameter set RBSP is called the active MVCD sequence parameter set \nRBSP until it is deactivated when another MVCD sequence parameter set RBSP becomes the active MVCD sequence \nparameter set RBSP. A subset sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be \navailable to the decoding process prior to its activation. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active MVCD sequence parameter set RBSP and it is referred to by an activating buffering period SEI \nmessage (using that value of seq_parameter_set_id) that is included in an MVCD scalable nesting SEI message, it is \nactivated. This subset sequence parameter set RBSP is called the active MVCD sequence parameter set RBSP until it is \ndeactivated when another MVCD sequence parameter set RBSP becomes the active MVCD sequence parameter set RBSP. \nA subset sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be available to the \ndecoding process prior to its activation. \nNOTE 2 – The active MVCD sequence parameter set RBSP is either a sequence parameter set RBSP or a subset sequence parameter \nset RBSP. Sequence parameter set RBSPs are activated by coded slice NAL units with nal_unit_type equal to 1 or 5 or buffering \nperiod SEI messages that are not included in an MVC scalable nesting SEI message or an MVCD scalable nesting SEI message. \nSubset sequence parameter sets are activated by coded slice depth extension NAL units (nal_unit_type equal to 21) or buffering \nperiod SEI messages that are included in an MVCD scalable nesting SEI message. A sequence parameter set RBSP and a subset \nsequence parameter set RBSP may have the same value of seq_parameter_set_id. \nFor the following specification, the activating texture buffering period SEI message for a particular value of VOIdx is \nspecified as follows. \n–  If the access unit contains one or more than one buffering period SEI message included in an MVC scalable nesting \nSEI message and associated with an operation point for which the greatest VOIdx in the associated bitstream subset \nis equal to the particular value of VOIdx, the first of these buffering period SEI messages, in decoding order, is the \nactivating texture buffering period SEI message for the particular value of VOIdx. \n–  Otherwise, if the access unit contains a buffering period SEI message not included in an MVC scalable nesting SEI \nmessage or an MVCD scalable nesting SEI message, this buffering period SEI message is the activating texture \nbuffering period SEI message for the particular value of VOIdx equal to VOIdxMin. \n–  Otherwise, the access unit does not contain an activating texture buffering period SEI message for the particular value \nof VOIdx. \nWhen a sequence parameter set RBSP (nal_unit_type is equal to 7) with a particular value of seq_parameter_set_id is not \nalready the active texture MVCD sequence parameter set RBSP for VOIdx equal to VOIdxMin and it is referred to by \nactivation of a picture parameter set RBSP (using that value of seq_parameter_set_id) and the picture parameter set RBSP \nis activated by a coded slice NAL unit with nal_unit_type equal to 1 or 5 (the picture parameter set RBSP becomes the \nactive texture picture parameter set RBSP for VOIdx equal to VOIdxMin), it is activated for texture view components with \n720  Rec. ITU-T H.264 (06/2019) \n \nVOIdx equal to VOIdxMin. This sequence parameter set RBSP is called the active texture MVCD sequence parameter set \nRBSP for VOIdx equal to VOIdxMin until it is deactivated when another MVCD sequence parameter set RBSP becomes \nthe active texture MVCD sequence parameter set RBSP for VOIdx equal to VOIdxMin. A sequence parameter set RBSP, \nwith that particular value of seq_parameter_set_id, shall be available to the decoding process prior to its activation. \nWhen a sequence parameter set RBSP (nal_unit_type is equal to 7) with a particular value of seq_parameter_set_id is not \nalready the active texture MVCD sequence parameter set RBSP for VOIdx equal to VOIdxMin and it is referred to by an \nactivating texture buffering period SEI message (using that value of seq_parameter_set_id) that is not included in an MVC \nscalable nesting SEI message or an MVCD scalable nesting SEI message, the sequence parameter set RBSP is activated \nfor texture view components with VOIdx equal to VOIdxMin. This sequence parameter set RBSP is called the active \ntexture MVCD sequence parameter set RBSP for VOIdx equal to VOIdxMin until it is deactivated when another MVCD \nsequence parameter set RBSP becomes the active texture MVCD sequence parameter set RBSP for VOIdx equal to. A \nsequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be available to the decoding \nprocess prior to its activation. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active texture MVCD sequence parameter set RBSP for a particular value of VOIdx less than or equal to \nVOIdxMax and it is referred to by activation of a picture parameter set RBSP (using that value of seq_parameter_set_id) \nand the picture parameter set RBSP is activated by a coded slice MVC extension NAL unit (nal_unit_type equal to 20) \nwith the particular value of VOIdx (the picture parameter set RBSP becomes the active texture picture parameter set RBSP \nfor the particular value of VOIdx), it is activated for texture view components with the particular value of VOIdx. This \nsubset sequence parameter set RBSP is called the active texture MVCD sequence parameter set RBSP for the particular \nvalue of VOIdx until it is deactivated when another MVCD sequence parameter set RBSP becomes the active texture \nMVCD sequence parameter set RBSP for the particular value of VOIdx. A subset sequence parameter set RBSP, with that \nparticular value of seq_parameter_set_id, shall be available to the decoding process prior to its activation. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active texture MVCD sequence parameter set RBSP for a particular value of VOIdx less than or equal to \nVOIdxMax  and  it  is  referred  to  by  an  activating  texture  buffering  period  SEI  message  (using  that  value  of \nseq_parameter_set_id) that is included in an MVC scalable nesting SEI message and associated with the particular value \nof VOIdx, this subset sequence parameter set RBSP is activated for texture view components with the particular value of \nVOIdx. This subset sequence parameter set RBSP is called the active texture MVCD sequence parameter set RBSP for the \nparticular value of VOIdx until it is deactivated when another MVCD sequence parameter set RBSP becomes the active \ntexture MVCD sequence parameter set RBSP for the particular value of VOIdx. A subset sequence parameter set RBSP, \nwith that particular value of seq_parameter_set_id, shall be available to the decoding process prior to its activation. \nFor the following specification, the activating view buffering period SEI message for a particular value of VOIdx is \nspecified as follows. \n–  If the access unit contains one or more than one buffering period SEI message included in an MVCD scalable nesting \nSEI message and associated with an operation point for which the greatest VOIdx in the associated bitstream subset \nis equal to the particular value of VOIdx, the first of these buffering period SEI messages, in decoding order, is the \nactivating view buffering period SEI message for the particular value of VOIdx. \n–  Otherwise, the access unit does not contain an activating view buffering period SEI message for the particular value \nof VOIdx. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active view MVCD sequence parameter set RBSP for a particular value of VOIdx less than VOIdxMax \nand it is referred to by activation of a picture parameter set RBSP (using that value of seq_parameter_set_id) and the picture \nparameter set RBSP is activated by a coded slice NAL unit with nal_unit_type equal to 21 and with the particular value of \nVOIdx (the picture parameter set RBSP becomes the active view picture parameter set RBSP for the particular value of \nVOIdx), it is activated for view components with the particular value of VOIdx. This subset sequence parameter set RBSP \nis called the active view MVCD sequence parameter set RBSP for the particular value of VOIdx until it is deactivated \nwhen another MVCD sequence parameter set RBSP becomes the active view MVCD sequence parameter set RBSP for \nthe particular value of VOIdx or when decoding an access unit with VOIdxMax less than or equal to the particular value \nof VOIdx. A subset sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be available \nto the decoding process prior to its activation. \nWhen a subset sequence parameter set RBSP (nal_unit_type is equal to 15) with a particular value of seq_parameter_set_id \nis not already the active view MVCD sequence parameter set RBSP for a particular value of VOIdx less than VOIdxMax \nand it is referred to by an activating view buffering period SEI message (using that value of seq_parameter_set_id) that is \nincluded in an MVCD scalable nesting SEI message and associated with the particular value of VOIdx, this subset sequence \nparameter set RBSP is activated for view components with the particular value of VOIdx. This subset sequence parameter \nset RBSP is called the active view MVCD sequence parameter set RBSP for the particular value of VOIdx until it is \ndeactivated when another MVCD sequence parameter set RBSP becomes the active view MVCD sequence parameter set \n    Rec. ITU-T H.264 (06/2019)  721 \n \nRBSP for the particular value of VOIdx or when decoding an access unit with VOIdxMax less than or equal to the particular \nvalue of VOIdx. A subset sequence parameter set RBSP, with that particular value of seq_parameter_set_id, shall be \navailable to the decoding process prior to its activation. \nAn MVCD sequence parameter set RBSP that includes a value of profile_idc not specified in Annex A or Annex H or \nAnnex I shall not be referred to by activation of a picture parameter set RBSP as the active picture parameter set RBSP or \nas  active  view  picture  parameter  set  RBSP  or  as  active  texture  picture  parameter  set  RBSP  (using  that  value  of \nseq_parameter_set_id) or referred to by a buffering period SEI message (using that value of seq_parameter_set_id). An \nMVCD sequence parameter set RBSP including a value of profile_idc not specified in Annex A or Annex H or Annex I is \nignored in the decoding for profiles specified in Annex A or Annex H or Annex I. \nIt is a requirement of bitstream conformance that the following constraints are obeyed: \n–  For each particular value of VOIdx, all coded slice NAL units (with nal_unit_type equal to 1, 5, 20, or 21) of a coded \nvideo sequence shall refer to the same value of seq_parameter_set_id (via the picture parameter set RBSP that is \nreferred to by the value of pic_parameter_set_id). \n–  The value of seq_parameter_set_id in a buffering period SEI message that is not included in an MVC scalable nesting \nSEI message shall be identical to the value of seq_parameter_set_id in the picture parameter set RBSP that is referred \nto by coded slice NAL units with nal_unit_type equal to 1 or 5 (via the value of pic_parameter_set_id) in the same \naccess unit. \n–  The value of seq_parameter_set_id in a buffering period SEI message that is included in an MVC scalable nesting \nSEI message and is associated with a particular value of VOIdx shall be identical to the value of seq_parameter_set_id \nin the picture parameter set RBSP that is referred to by coded slice NAL units with nal_unit_type equal to 1, 5 or 20 \nwith the particular value of VOIdx (via the value of pic_parameter_set_id) in the same access unit. \n–  The value of seq_parameter_set_id in a buffering period SEI message that is included in an MVCD scalable nesting \nSEI message and is associated with a particular value of VOIdx shall be identical to the value of seq_parameter_set_id \nin the picture parameter set RBSP that is referred to by coded slice NAL units with nal_unit_type equal to 21 with the \nparticular value of VOIdx (via the value of pic_parameter_set_id) in the same access unit. \nThe active view MVCD sequence parameter set RBSPs for different values of VOIdx may be the same MVCD sequence \nparameter set RBSP. The active MVCD sequence parameter set RBSP and an active view MVCD sequence parameter set \nRBSP for a particular value of VOIdx may be the same MVCD sequence parameter set RBSP. \nThe active texture MVCD sequence parameter set RBSPs for different values of VOIdx may be the same MVCD sequence \nparameter set RBSP. The active MVCD sequence parameter set RBSP and an active texture MVCD sequence parameter \nset RBSP for a particular value of VOIdx may be the same MVCD sequence parameter set RBSP. \nWhen the active MVCD sequence parameter set RBSP for a coded picture is a sequence parameter set RBSP, any sequence \nparameter set RBSP in the coded video sequence containing this coded picture and with the value of seq_parameter_set_id \nfor the active MVCD sequence parameter set RBSP shall have the same content as that of the active MVCD sequence \nparameter set RBSP. \nWhen the active MVCD sequence parameter set RBSP for a coded picture is a subset sequence parameter set RBSP, any \nsubset sequence parameter set RBSP in the coded video sequence containing this coded picture and with the value of \nseq_parameter_set_id for the active MVCD sequence parameter set RBSP shall have the same content as that of the active \nMVCD sequence parameter set RBSP. \nFor each particular value of VOIdx, the following applies: \n–  When the active texture MVCD sequence parameter set RBSP for a coded picture is a sequence parameter set RBSP, \nany sequence parameter set RBSP in the coded video sequence containing this coded picture and with the value of \nseq_parameter_set_id for the active texture MVCD sequence parameter set RBSP shall have the same content as that \nof the active texture MVCD sequence parameter set RBSP. \n–  When the active texture MVCD sequence parameter set RBSP for a coded picture is a subset sequence parameter set \nRBSP, any subset sequence parameter set RBSP in the coded video sequence containing this coded picture and with \nthe value of seq_parameter_set_id for the active texture MVCD sequence parameter set RBSP shall have the same \ncontent as that of the active texture MVCD sequence parameter set RBSP. \n–  The active view MVCD sequence parameter set RBSP for a coded picture is a subset sequence parameter set RBSP, \nand any subset sequence parameter set RBSP in the coded video sequence containing this coded picture and with the \nvalue of seq_parameter_set_id for the active view MVCD sequence parameter set RBSP shall have the same content \nas that of the active view MVCD sequence parameter set RBSP. \nNOTE 3 – If picture parameter set RBSPs or MVCD sequence parameter set RBSPs are conveyed within the bitstream, these \nconstraints impose an order constraint on the NAL units that contain the picture parameter set RBSPs or MVCD sequence parameter \nset RBSPs, respectively. Otherwise (picture parameter set RBSPs or MVCD sequence parameter set RBSPs are conveyed by other \n722  Rec. ITU-T H.264 (06/2019) \n \nmeans not specified in this Recommendation | International Standard), they must be available to the decoding process in a timely \nfashion such that these constraints are obeyed. \nWhen present, a sequence parameter set extension RBSP includes parameters having a similar function to those of a \nsequence parameter set RBSP. For purposes of establishing constraints on the syntax elements of the sequence parameter \nset extension RBSP and for purposes of determining activation of a sequence parameter set extension RBSP, the sequence \nparameter set extension RBSP shall be considered part of the preceding sequence parameter set RBSP with the same value \nof seq_parameter_set_id. When a sequence parameter set RBSP is present that is not followed by a sequence parameter \nset extension RBSP with the same value of seq_parameter_set_id prior to the activation of the sequence parameter set \nRBSP, the sequence parameter set extension RBSP and its syntax elements shall be considered not present for the active \nMVCD sequence parameter set RBSP. The contents of sequence parameter set extension RBSPs only apply when the base \ntexture view, which conforms to one or more of the profiles specified in Annex A, of a coded video sequence conforming \nto one or more profiles specified in Annex I is decoded. Subset sequence parameter set RBSPs shall not be followed by a \nsequence parameter set extension RBSP. \nNOTE 4 – Sequence parameter sets extension RBSPs are not considered to be part of a subset sequence parameter set RBSP and \nsubset sequence parameter set RBSPs must not be followed by a sequence parameter set extension RBSP. \nFor view components with VOIdx equal to VOIdxMax, all constraints that are expressed on the relationship between the \nvalues of the syntax elements (and the values of variables derived from those syntax elements) in MVCD sequence \nparameter sets and picture parameter sets and other syntax elements are expressions of constraints that apply only to the \nactive MVCD sequence parameter set and the active picture parameter set. For view components with a particular value \nof VOIdx less than VOIdxMax, all constraints that are expressed on the relationship between the values of the syntax \nelements (and the values of variables derived from those syntax elements) in MVCD sequence parameter sets and picture \nparameter sets and other syntax elements are expressions of constraints that apply only to the active view MVCD sequence \nparameter set and the active view picture parameter set for the particular value of VOIdx. If any MVCD sequence parameter \nset RBSP having profile_idc equal to the value of one of the profile_idc values specified in Annex A or Annex H or Annex I \nis present that is never activated in the bitstream (i.e., it never becomes the active MVCD sequence parameter set or an \nactive view MVCD sequence parameter set), its syntax elements shall have values that would conform to the specified \nconstraints if it were activated by reference in an otherwise-conforming bitstream. If any picture parameter set RBSP is \npresent that is never activated in the bitstream (i.e., it never becomes the active picture parameter set or an active view \npicture parameter set), its syntax elements shall have values that would conform to the specified constraints if it were \nactivated by reference in an otherwise-conforming bitstream. \nDuring operation of the decoding process (see clause I.8), for view components with VOIdx equal to VOIdxMax, the \nvalues of parameters of the active picture parameter set and the active MVCD sequence parameter set shall be considered \nin effect. For view components with a particular value of VOIdx less than VOIdxMax, the values of the parameters of the \nactive view picture parameter set and the active view MVCD sequence parameter set for the particular value of VOIdx \nshall be considered in effect. For interpretation of SEI messages that apply to the entire access unit or the view component \nwith VOIdx equal to VOIdxMax, the values of the parameters of the active picture parameter set and the active MVCD \nsequence parameter set for the same access unit shall be considered in effect unless otherwise specified in the SEI message \nsemantics. For interpretation of SEI messages that apply to view components with a particular value of VOIdx less than \nVOIdxMax, the values of the parameters of the active view picture parameter set and the active view MVCD sequence \nparameter set for the particular value of VOIdx for the same access unit shall be considered in effect unless otherwise \nspecified in the SEI message semantics. \nFor any active MVCD sequence parameter set or active view MVCD sequence parameter set, part of the syntax elements \nin the MVC sequence parameter set extension applies only to the depth views referring to this sequence parameter set, \nwhile the some other parts of the syntax elements in the MVCD sequence parameter set extension collectively apply to \nboth the depth views referring to this sequence parameter set and the corresponding texture views. More specifically, the \nview dependency information of the MVCD sequence parameter set extension applies only to the depth views, and the \nlevel definitions collectively apply to operation points, each of which contains both depth views and their corresponding \ntexture views. Moreover, the mvcd_vui_parameters_extension( ) applies collectively to both the depth views referring to \nthis MVCD sequence parameter set and the corresponding texture views. The vui_parameters( ) included in the sequence \nparameter set data syntax structure, if present, apply collectively to both the depth views referring to this sequence \nparameter set and the corresponding texture views, except for the aspect ratio information and the bitstream restriction \ninformation, if present, which apply only to the depth views referring to this MVCD sequence parameter set. The aspect \nratio information and the bitstream restriction information for the texture views may be present in the vui_parameters( ) \nsyntax structure included in an MVC sequence parameter set. \nI.7.4.1.2.2  Order of access units and association to coded video sequences \nThe specification of clause H.7.4.1.2.2 apply. \nI.7.4.1.2.3  Order of NAL units and coded pictures and association to access units \nThe specification of clause H.7.4.1.2.3 applies with the following modifications. \n    Rec. ITU-T H.264 (06/2019)  723 \n \nNOTE – Some bitstreams that conform to one or more profiles specified in this annex do not conform to any profile specified in \nAnnex A  (prior  to  operation  of  the  base  view  extraction  process  specified  in  clause I.8.5.4).  As  specified  in  clauses 7.4.1 \nand 7.4.1.2.3 for the profiles specified in Annex A, NAL units with nal_unit_type equal to 21 are classified as non-VCL NAL units \nthat must be preceded within each access unit by at least one NAL unit with nal_unit_type in the range of 1 to 5, inclusive. For this \nreason, any bitstream that conforms to one or more profiles specified in this annex does not conform to any profile specified in \nAnnex A when it contains any of the following: \n–  any access unit that does not contain any NAL units with nal_unit_type equal to 1 or 5, but contains one or more NAL units \nwith nal_unit_type equal to 6, 7, 8, 9, or 15 \n–  any access unit in which one or more NAL units with nal_unit_type equal to 7, 8, or 15 is present after the last NAL unit in the \naccess unit with nal_unit_type equal to 1 or 5. \nThe association of VCL NAL units to primary or redundant coded pictures is specified in clause I.7.4.1.2.5. \nThe constraints for the detection of the first VCL NAL unit of a primary coded picture are specified in clause I.7.4.1.2.4. \nThe constraint expressed in clause H.7.4.1.2.3 on the order of a buffering period SEI message is replaced by the following \nconstraints. \n–  When an SEI NAL unit containing a buffering period SEI message is present, the following applies: \n–  If the buffering period SEI message is the only buffering period SEI message in the access unit and it is not \nincluded in an MVC scalable nesting SEI message or an MVCD scalable nesting SEI message, the buffering \nperiod SEI message shall be the first SEI message payload of the first SEI NAL unit in the access unit. \n–  Otherwise (the buffering period SEI message is not the only buffering period SEI message in the access unit or \nit is included in an MVC scalable nesting SEI message or it is included in an MVCD scalable nesting SEI \nmessage), the following constraints are specified: \n–  When a buffering period SEI message that is not included in either an MVC scalable nesting SEI message \nor an MVCD scalable nesting SEI message is present, this buffering period SEI message shall be the only \nSEI message payload of the first SEI NAL unit in the access unit. \n–  An MVC scalable nesting SEI message that includes a buffering period SEI message shall not include any \nother SEI messages and shall be the only SEI message inside the SEI NAL unit. \n–  An MVCD scalable nesting SEI message that includes a buffering period SEI message shall not include any \nother SEI messages and shall be the only SEI message inside the SEI NAL unit. \n–  All SEI NAL units that precede an SEI NAL unit that contains an MVC scalable nesting SEI message with \na buffering period SEI message as payload, or an MVCD scalable nesting SEI message with a buffering \nperiod SEI message as payload in an access unit shall only contain buffering period SEI messages or MVC \nscalable nesting SEI messages with a buffering period SEI message as payload, or MVCD scalable nesting \nSEI messages with a buffering period SEI message. \nI.7.4.1.2.4  Detection of the first VCL NAL unit of a primary coded picture \nThe specification of clause H.7.4.1.2.4 applies. \nI.7.4.1.2.5  Order of VCL NAL units and association to coded pictures \nThe specification of clause H.7.4.1.2.5 applies with following modifications. \nEach VCL NAL unit is part of a coded picture. \nLet voIdx be the value of VOIdx of any particular VCL NAL unit. The order of the VCL NAL units within a coded picture \nis constrained as follows: \n–  For all VCL NAL units following this particular VCL NAL unit, the value of VOIdx shall be greater than or equal \nto voIdx. \n–  All VCL NAL units for a depth view component, if present, shall follow any VCL NAL unit of a texture view \ncomponent with a same value of VOIdx. \nFor each set of VCL NAL units within a texture or depth view component, the following applies: \n–  If arbitrary slice order, as specified in Annex A, clause H.10 or clause I.10, is allowed, coded slice NAL units of a \nview component may have any order relative to each other. \n–  Otherwise (arbitrary slice order is not allowed), coded slice NAL units of a slice group shall not be interleaved with \ncoded slice NAL units of another slice group and the order of coded slice NAL units within a slice group shall be in \nthe order of increasing macroblock address for the first macroblock of each coded slice NAL unit of the same slice \ngroup. \n724  Rec. ITU-T H.264 (06/2019) \n \nThe following applies: \n–  If a coded texture view component with a particular view_id is the first field view component of a complementary \nfield pair, the depth view component with the same view_id value, if present in the access unit, shall be a coded frame \nview component or the first field view component of a complementary field pair. \n–  Otherwise, if a coded texture view component with a particular view_id is the second field view component of a \ncomplementary field pair, the depth view component with the same view_id value, if present in the access unit, shall \nbe the second field view component of a complementary field pair. \n–  Otherwise, if a coded texture view component  with a particular view_id is a non-paired field, the depth view \ncomponent with the same view_id value, if present in the access unit, shall be a coded frame view component or a \nnon-paired field. \n–  Otherwise (a coded texture view component with a particular view_id is a coded frame), the depth view component \nwith the same view_id value, if present in the access unit, shall be a coded frame view component. \nNAL units having nal_unit_type equal to 12 may be present in the access unit but shall not precede the first VCL NAL \nunit of the primary coded picture within the access unit. \nNAL units having nal_unit_type equal to 0 or in the range of 24 to 31, inclusive, which are unspecified, may be present in \nthe access unit but shall not precede the first VCL NAL unit of the primary coded picture within the access unit. \nNAL units having nal_unit_type in the range of 22 to 23, inclusive, which are reserved, shall not precede the first VCL \nNAL unit of the primary coded picture within the access unit (when specified in the future by ITU-T | ISO/IEC). \nI.7.4.2  Raw byte sequence payloads and RBSP trailing bits semantics \nI.7.4.2.1  Sequence parameter set RBSP semantics \nThe semantics specified in clause 7.4.2.1 apply. \nI.7.4.2.1.1  Sequence parameter set data semantics \nThe semantics specified in clause H.7.4.2.1.1 apply with the substitution of MVCD sequence parameter set for MVC \nsequence parameter set. All constraints specified in clause H.7.4.2.1.1 apply only to the texture view components for which \nthe MVCD sequence parameter set is the active texture MVC sequence parameter set or to the depth view components for \nwhich the MVCD sequence parameter set is the active view MVC sequence parameter set as specified in clause I.7.4.1.2.1. \nI.7.4.2.1.1.1  Scaling list semantics \nThe semantics specified in clause H.7.4.2.1.1.1 apply. \nI.7.4.2.1.2  Sequence parameter set extension RBSP semantics \nThe semantics specified in clause 7.4.2.1.2 apply. Additionally, the following applies. \nSequence parameter set extension RBSPs can only follow sequence parameter set RBSPs in decoding order. Subset \nsequence parameter set RBSPs shall not be followed by a sequence parameter set extension RBSP. The contents of \nsequence parameter set extension RBSPs only apply when the base view, which conforms to one or more of the profiles \nspecified in Annex A, of a coded video sequence conforming to one or more profiles specified in Annex I is decoded. \nI.7.4.2.1.3  Subset sequence parameter set RBSP semantics \nThe semantics specified in clause 7.4.2.1.3 apply with the following additions. \nmvcd_vui_parameters_present_flag equal to 0 specifies that the syntax structure mvc_vui_parameters_extension( ) \ncorresponding to MVCD VUI parameters extension is not present. mvcd_vui_parameters_present_flag equal to 1 specifies \nthat the syntax structure mvc_vui_parameters_extension( ) is present and referred to as MVCD VUI parameters extension. \ntexture_vui_parameters_present_flag equal to 0 specifies that the syntax structure mvc_vui_parameters_extension( ) \ncorresponding  to  MVCD  texture  sub-bitstream  VUI  parameters  extension  is  not  present. \ntexture_vui_parameters_present_flag equal to 1 specifies that the syntax structure mvc_vui_parameters_extension( ) is \npresent and referred to as MVCD texture sub-bitstream VUI parameters extension. \nI.7.4.2.1.4  Sequence parameter set MVCD extension semantics \nThe semantics  specified in  clause H.7.4.2.1.4 apply  with  the substitution of texture view component or depth  view \ncomponent for view component and with the following additions: \ndepth_view_present_flag[ i ] equal to 0 specifies that there is no depth view having a view_id equal to view_id[ i ] and \nVOIdx equal to i. depth_view_present_flag[ i ] equal to 1 specifies that there is a depth view having a view_id equal to \nview_id[ i ]. \n    Rec. ITU-T H.264 (06/2019)  725 \n \ntexture_view_present_flag[ i ] equal to 0 specifies that there is no texture view having a view_id equal to view_id[ i ] \nand VOIdx equal to i. texture_view_present_flag[ i ] equal to 1 specifies that there is a texture view having a view_id equal \nto view_id[ i ] and VOIdx equal to i. When depth_view_present_flag[ i ] is equal to 0, texture_view_present_flag[ i ] shall \nbe equal to 1. \nnum_anchor_refs_l0[ i ],  anchor_ref_l0[ i ][ j ],  num_anchor_refs_l1[ i ],  anchor_ref_l1[ i ][ j ], \nnum_non_anchor_refs_l0[ i ],  non_anchor_ref_l0[ i ][ j ],  num_non_anchor_refs_l1[ i ],  and  non_anchor_ref_l1[ i ][ j ] \napply to depth view components. \napplicable_op_depth_flag[ i ][ j ][ k ]  equal  to  0  indicates  that  the  depth  view  with  view_id  equal  to \napplicable_op_target_view_id[ i ][ j ][ k ] is not included in the j-th operation point. applicable_op_depth_flag[ i ][ j ][ k ] \nequal to 1 indicates that the depth view with view_id equal to applicable_op_target_view_id[ i ][ j ][ k ] is included in the \nj-th operation point. \napplicable_op_texture_flag[ i ][ j ][ k ]  equal  to  0  indicates  that  the  texture  view  with  view_id  equal  to \napplicable_op_target_view_id[ i ][ j ][ k ]  is  not  included  in  the  j-th  operation  point. \napplicable_op_texture_flag[ i ][ j ][ k ]  equal  to  1  indicates  that  the  texture  view  with  view_id  equal  to \napplicable_op_target_view_id[ i ][ j ][ k ]  is  included  in  the  j-th  operation  point.  When \napplicable_op_depth_flag[ i ][ j ][ k ] is equal to 0, applicable_op_texture_flag[ i ][ j ][ k ] shall be equal to 1. \napplicable_op_num_texture_views_minus1[ i ][ j ] plus 1 specifies the number of texture views required for decoding \nthe target output views corresponding to the j-th operation point to which the level indicated by level_idc[ i ] applies. The \nnumber of texture views specified by applicable_op_num_views_minus1 includes the texture views of the target output \nviews  and  the  texture  views  that  the  target  output  views  depend  on.  The  value  of \napplicable_op_num_texture_views_minus1[ i ][ j ] shall be in the range of 0 to 1023, inclusive. \napplicable_op_num_depth_views[ i ][ j ] specifies the number of depth views required for decoding the target output \nviews corresponding to the j-th operation point to which the level indicated by level_idc[ i ] applies. The number of depth \nviews specified by applicable_op_num_depth_views_minus1 includes the depth views of the target output views and the \ndepth  views  that  the  depth  views  of  the  target  output  views  depend  on.  The  value  of \napplicable_op_num_depth_views_minus1[ i ][ j ] shall be in the range of 0 to 1023, inclusive. \nAll sequence parameter set MVCD extensions that are included in the active view MVCD sequence parameter set RBSPs \nof one coded video sequence shall be identical. \nI.7.4.2.2  Picture parameter set RBSP semantics \nThe semantics specified in clause H.7.4.2.2 apply with substituting MVCD sequence parameter set for MVC sequence \nparameter set. All constraints specified in clause H.7.4.2.2 apply only to the texture or depth view components for which \nthe picture parameter set is the active picture parameter set or the active view picture parameter set or the active texture \npicture parameter set as specified in clause I.7.4.1.2.1. \nI.7.4.2.3  Supplemental enhancement information RBSP semantics \nThe semantics specified in clause H.7.4.2.3 apply. \nI.7.4.2.3.1  Supplemental enhancement information message semantics \nThe semantics specified in clause H.7.4.2.3.1 apply. \nI.7.4.2.4  Access unit delimiter RBSP semantics \nThe semantics specified in clause H.7.4.2.4 apply. \nNOTE – The value of primary_pic_type applies to the slice_type values in all slice headers of the primary coded picture, including \nthe slice_type syntax elements in all NAL units with nal_unit_type equal to 1, 5, 20 or 21. NAL units with nal_unit_type equal to 2 \nare not present in bitstreams conforming to any of the profiles specified in this annex. \nI.7.4.2.5  End of sequence RBSP semantics \nThe semantics specified in clause H.7.4.2.5 apply. \nI.7.4.2.6  End of stream RBSP semantics \nThe semantics specified in clause H.7.4.2.6 apply. \nI.7.4.2.7  Filler data RBSP semantics \nThe semantics specified in clause H.7.4.2.7 apply with the following modifications. \nFiller data NAL units shall be considered to contain the syntax elements priority_id, view_id, and temporal_id with values \nthat are inferred as follows: \n1.  Let prevMvcNalUnit be the most recent NAL unit in decoding order that has nal_unit_type equal to 14, 20 or 21. \n726  Rec. ITU-T H.264 (06/2019) \n \nNOTE – The most recent NAL unit in decoding order with nal_unit_type equal to 14, 20 or 21 always belongs to the same \naccess unit as the filler data NAL unit. \n2.  The values of priority_id, view_id, and temporal_id for the filler data NAL unit are inferred to be equal to the \nvalues of priority_id, view_id, and temporal_id, respectively, of the NAL unit prevMvcNalUnit. \nI.7.4.2.8  Slice layer without partitioning RBSP semantics \nThe semantics specified in clause H.7.4.2.8 apply. \nI.7.4.2.9  Slice data partition RBSP semantics \nSlice data partition syntax is not present in bitstreams conforming to one or more of the profiles specified in Annex I. \nI.7.4.2.10  RBSP slice trailing bits semantics \nThe semantics specified in H.7.4.2.10 apply. \nI.7.4.2.11  RBSP trailing bits semantics \nThe semantics specified in clause H.7.4.2.11 apply. \nI.7.4.2.12  Prefix NAL unit RBSP semantics \nThe semantics specified in clause H.7.4.2.12 apply. \nI.7.4.2.13  Slice layer extension RBSP semantics \nThe semantics specified in clause H.7.4.2.13 apply. \nI.7.4.3  Slice header semantics \nThe semantics specified in clause H.7.4.3 apply with the substitution of texture view component (for nal_unit_type equal \nto 1, 5, and 20) or depth view component (for nal_unit_type equal to 21 and avc_3d_extension_flag equal to 0) for view \ncomponent and with the following modifications. \nWhen nal_unit_type is equal to 1, 5, or 20, all constraints specified in clause H.7.4.3 apply only to the texture view \ncomponents with the same value of VOIdx. When nal_unit_type is equal to 21 and avc_3d_extension_flag is equal to 0, \nall constraints specified in clause H.7.4.3 apply only to the depth view components with the same value of VOIdx. \nThe value of the following MVCD sequence parameter set syntax elements shall be the same across all coded slice NAL \nunits of nal_unit_type equal to 1, 5, and 20 of an access unit: chroma_format_idc. \nThe value of the following slice header syntax elements shall be the same across all coded slice NAL units of nal_unit_type \nequal to 1, 5, and 20 of an access unit: field_pic_flag and bottom_field_flag. \nThe value of the following slice header syntax elements shall be the same across all coded slice NAL units of nal_unit_type \nequal to 21 of an access unit: field_pic_flag and bottom_field_flag. \nI.7.4.3.1  Reference picture list modification semantics \nThe semantics specified in clause H.7.4.3.1 apply. \nI.7.4.3.1.1  Reference picture list MVC modification semantics \nThe semantics specified in clause H.7.4.3.1.1 apply. \nI.7.4.3.2  Prediction weight table semantics \nThe semantics specified in clause H.7.4.3.2 apply. \nI.7.4.3.3  Decoded reference picture marking semantics \nThe semantics specified in clause 7.4.3.3 apply to each view independently, with \"sequence parameter set\" being replaced \nby \"MVCD sequence parameter set\", and \"primary coded picture\" being replaced by \"texture view component\" for \nnal_unit_type equal to 1, 5, and 20, and by \"depth view component\" for nal_unit_type equal to 21. \nI.7.4.4  Slice data semantics \nThe semantics specified in clause H.7.4.4 apply. \nI.7.4.5  Macroblock layer semantics \nThe semantics specified in clause H.7.4.5 apply. \n    Rec. ITU-T H.264 (06/2019)  727 \n \nI.7.4.5.1  Macroblock prediction semantics \nThe semantics specified in clause H.7.4.5.1 apply. \nI.7.4.5.2  Sub-macroblock prediction semantics \nThe semantics specified in clause H.7.4.5.2 apply. \nI.7.4.5.3  Residual data semantics \nThe semantics specified in clause H.7.4.5.3 apply. \nI.7.4.5.3.1  Residual luma semantics \nThe semantics specified in clause H.7.4.5.3.1 apply. \nI.7.4.5.3.2  Residual block CAVLC semantics \nThe semantics specified in clause H.7.4.5.3.2 apply. \nI.7.4.5.3.3  Residual block CABAC semantics \nThe semantics specified in clause H.7.4.5.3.3 apply. \nI.8  MVCD decoding process \nThis clause specifies the decoding process for an access unit of a coded video sequence conforming to one or more of the \nprofiles specified in Annex I. Specifically, this clause specifies how the decoded picture with multiple texture view \ncomponents and multiple depth view components is derived from syntax elements and global variables that are derived \nfrom NAL units in an access unit when the decoder is decoding the operation point identified by the target temporal level \nand the target output texture and depth views. \nThe decoding process is specified such that all decoders shall produce numerically identical results for the target output \ntexture and depth views. Any decoding process that produces identical results for the target output texture and depth views \nto the process described here conforms to the decoding process requirements of this Recommendation | International \nStandard. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the decoding process \nspecified in this clause and all child processes invoked from the process specified in this clause are the syntax elements \nand derived upper-case variables for the current access unit. \nThe target output texture and depth views are either specified by external means not specified in this Specification, or, \nwhen not specified by external means, there shall be one target output texture view which is the base texture view. \nNOTE – The association of VOIdx values to view_id values according to the decoding process of clause I.8 may differ from that \nof the decoding process of clause H.8. \nA target output view may include only a texture view, only a depth view, or both the texture view and the depth view, \nwhich have the same view_id value. \nAll sub-bitstreams that can be derived using the sub-bitstream extraction process with depthPresentFlagTarget equal to 0 \nor 1, pIdTarget equal to any value in the range of 0 to 63, inclusive, tIdTarget equal to any value in the range of 0 to 7, \ninclusive, viewIdTargetList consisting of any one or more viewIdTarget's identifying the views in the bitstream as inputs \nas specified in clause I.8.5 shall result in a set of coded video sequences, with each coded video sequence conforming to \none or more of the profiles specified in Annex A, Annex H and Annex I. \nLet vOIdxList be a list of integer values specifying the VOIdx values of the view components of the access unit. The \nvariable VOIdxMax is set equal to the maximum value of the entries in the list vOIdxList, and the variable vOIdxMin is \nset to the minimum value of the entries in the list vOIdxList. When the current access unit is an anchor access unit, the \nvariable VOIdxMin is set to vOIdxMin. \nThe MVCD video decoding process specified in this clause is repeatedly invoked for each texture and depth view \ncomponent with VOIdx from vOIdxMin to VOIdxMax, inclusive, which is present in the list vOIdxList, in increasing \norder of VOIdx and in decoding order of texture or depth view components as specified in clause I.7.4.1.2.5. \nOutputs of the MVCD video decoding process are decoded samples of the current primary coded picture including all \ndecoded texture and depth view components of the target output texture and depth views. \nFor each texture view component and each depth view component, the specifications in clause H.8 apply, with the decoding \nprocesses  for  picture  order  count,  reference  picture  lists  construction  and  decoded  reference  picture  marking  being \nmodified in clauses I.8.1, I.8.2, I.8.3, and I.8.4, respectively. The MVCD inter prediction and inter-view prediction process \nis specified in clause I.8.4. \n728  Rec. ITU-T H.264 (06/2019) \n \nI.8.1  MVCD decoding process for picture order count \nThe specifications in clause 8.2.1 apply independently for each texture view or depth view. \nI.8.2  MVC decoding process for reference picture lists construction \nThe specification of clause H.8.2 apply with substituting \"view component\" as either \"texture view component\" or \"depth \nview  component\",  and  \"frame  view  component\"\"  as  either  \"depth  frame  view  component\"  or  \"texture  frame  view \ncomponent \", and \"field view component\" as \"texture field view component\" or \"depth field view component\". \nAdditionally, an inter-view reference component or the inter-view only reference component is identified by the view_id \nand a depth view component when the current slice is a part of a coded depth view component or a texture view component \nif the current slice is a part of a coded texture view component. \nI.8.2.1  Initialization process for reference picture list for inter-view prediction references \nThe specifications of clause H.8.2.1 apply. \nI.8.2.2  Modification process for reference picture lists \nThe specifications of clause H.8.2.2 apply. \nI.8.2.2.1  Modification process of reference picture lists for short-term reference pictures for inter prediction \nThe specifications of clause H.8.2.2.1 apply. \nI.8.2.2.2  Modification process of reference picture lists for long-term reference pictures for inter prediction \nThe specifications of clause H.8.2.2.2 apply. \nI.8.2.2.3  Modification process for reference picture lists for inter-view prediction references \nThe specifications of clause H.8.2.2.3 apply. \nI.8.3  MVCD decoded reference picture marking process \nThe specifications of clause H.8.3 apply. Additionally, the following applies. \nThe process specified in this clause is invoked for a particular texture view or depth view with view order index VOIdx. \nThe specifications in clause H.8.3 apply with \"view component\" being replaced by either \"texture view component\" or \n\"depth view component\", \"frame view component\" being replaced by either \"texture frame view component\" or \"depth \nframe view component\", and \"field view component\" being replaced by either \"texture field view component\" or \"depth \nfield view component\". During the invocation of the process for a particular texture view, only texture view components \nof the particular view are considered. During the invocation of the process for a particular depth view, only depth view \ncomponents of the particular view are considered. The marking of view components of other views is not changed. \nNOTE – A texture view component of a picture may have a different marking status than other texture view components of the \nsame picture. A depth view component of a picture may have a different marking status than other depth view components of the \nsame picture. A texture view component of a picture may have a different marking status than a depth view component. \nI.8.4  MVCD inter prediction and inter-view prediction process \nThe specifications of clause H.8.4 apply. \nI.8.5  Specification of bitstream subsets \nThe specifications of clause H.8.5 apply. \nI.8.5.1  Derivation process for required anchor view components \nWhen invoked for a depth view, the specification of clause H.8.5.1 apply with substituting \"view component\" with \"depth \nview component\" and \"view\" with \"depth view\". \nWhen invoked for a texture view, the specification of clause H.8.5.1 apply with substituting \"view component\" with \n\"texture view component\" and \"view\" with \"texture view\". \nI.8.5.2  Derivation process for required non-anchor view components \nWhen invoked for a depth view, the specification of clause H.8.5.2 apply with substituting \"view component\" with \"depth \nview component\" and \"view\" with \"depth view\". \nWhen invoked for a texture view, the specification of clause H.8.5.2 apply with substituting \"view component\" with \n\"texture view component\" and \"view\" with \"texture depth view\". \n    Rec. ITU-T H.264 (06/2019)  729 \n \nI.8.5.3  Sub-bitstream extraction process \nIt is requirement of bitstream conformance that any sub-bitstream that is the output of the process specified in this clause \nwith depthPresentFlagTarget equal to 0 or 1, pIdTarget equal to any value in the range of 0 to 63, inclusive, tIdTarget equal \nto any value in the range of 0 to 7, inclusive, viewIdTargetList consisting of any one or more values of viewIdTarget \nidentifying the views in the bitstream, shall be conforming to this Recommendation | International Standard. \nNOTE 1 – A conforming bitstream contains one or more coded slice NAL units with priority_id equal to 0 and temporal_id equal \nto 0. \nNOTE 2 – It is possible that not all operation points of sub-bitstreams resulting from the sub-bitstream extraction process have an \napplicable level_idc or level_idc[ i ]. In this case, each coded video sequence in a sub-bitstream must still conform to one or more \nof the profiles specified in Annex A, Annex H and Annex I, but may not satisfy the level constraints specified in clauses A.3, H.10.2 \nand I.10.2, respectively. \nInputs to this process are: \n–  a variable depthPresentFlagTarget (when present), \n–  a variable pIdTarget (when present), \n–  a variable tIdTarget (when present), \n–  a list viewIdTargetList consisting of one or more values of viewIdTarget (when present). \n–  a list viewIdDepthTargetList consisting of one or more value of viewIdDepthTarget (when present). \nOutputs of this process are a sub-bitstream and a list of VOIdx values VOIdxList. \nWhen depthPresentFlagTarget is not present as input to this clause, depthPresentFlagTarget is inferred to be equal to 0. \nWhen pIdTarget is not present as input to this clause, pIdTarget is inferred to be equal to 63. \nWhen tIdTarget is not present as input to this clause, tIdTarget is inferred to be equal to 7. \nWhen  viewIdTargetList is not present as input to this  clause, there shall be one value of viewIdTarget inferred in \nviewIdTargetList and the value of viewIdTarget is inferred to be equal to view_id of the base view. \nWhen viewIdDepthTargetList is not present as input to this clause, the viewIdDepthTargetList is inferred to be identical \nto viewIdTargetList. viewIdDepthTargetList shall not be present as input if depthPresentFlagTarget is equal to 0. \nThe sub-bitstream is derived by applying the following operations in sequential order: \n1.  Let VOIdxList be empty and minVOIdx be the VOIdx value of the base view. \n2.  For each value of viewIdTarget included in viewIdTargetList, invoke the process specified in clause I.8.5.1 for \ntexture views with the viewIdTarget as input. \n3.  If depthPresentFlagTarget is equal to 1, for each value of viewIdTarget included in viewIdDepthTargetList, \ninvoke the process specified in clause I.8.5.1 for depth views with the viewIdTarget as input. \n4.  For each value of viewIdTarget included in viewIdTargetList, invoke the process specified in clause I.8.5.2 for \ntexture views with the value of viewIdTarget as input. \n5.  If depthPresentFlagTarget is equal to 1, for each value of viewIdTarget included in viewIdDepthTargetList, \ninvoke the process specified in clause I.8.5.2 for depth views with the viewIdTarget as input. \n6.  Mark all VCL NAL units and filler data NAL units for which any of the following conditions are true as \"to be \nremoved from the bitstream\": \n–  priority_id is greater than pIdTarget, \n–  temporal_id is greater than tIdTarget, \n–  nal_unit_type is not equal to 21 and view_id is not in the viewIdTargetList, \n–  nal_unit_type is equal to 21 and view_id is not in the viewIdDepthTargetList, \n–  nal_unit_type is equal to 21 and depthPresentFlagTarget is equal to 0. \n7.  Remove all access units for which all VCL NAL units are marked as \"to be removed from the bitstream\". \n8.  Remove all VCL NAL units and filler data NAL units that are marked as \"to be removed from the bitstream\". \n9.  When VOIdxList contains only one value of VOIdx that is equal to minVOIdx, remove the following NAL units: \n–  all NAL units with nal_unit_type equal to 14 or 15, \n730  Rec. ITU-T H.264 (06/2019) \n \n–  all NAL units with nal_unit_type equal to 6 in which the first SEI message has payloadType in the range \nof 36 to 44, inclusive, or equal to 46, or in the range of 48 to 53, inclusive. \nNOTE 3 – When VOIdxList contains only one value of VOIdx equal to minVOIdx, the sub-bitstream contains only the base \nview or only a temporal subset of the base view. \n10.  Remove all NAL units with nal_unit_type equal to 6 in which the first SEI message has payloadType equal to 0 \nor  1,  or  the  first  SEI  message  has  payloadType  equal  to 37  (MVC  scalable  nesting  SEI  message)  and \noperation_point_flag in the first SEI message is equal to 1. \nNOTE 4 – The buffering period SEI and picture timing SEI messages, when not nested or nested in the MVC scalable \nnesting SEI message, apply for a sub-bitstream obtained with the sub-bitstream extraction process of clause H.8.5.3, \nwhich does not process NAL units of nal_unit_type equal to 21. \n11.  When depthPresentFlagTarget is equal to 0, the following applies in sequential order. \n–  Replace each NAL unit with nal_unit_type equal to 6 in which payloadType indicates an MVCD scalable \nnesting SEI message with sei_op_texture_only_flag equal to 0 with a NAL unit containing an MVC scalable \nnesting SEI message with the same values of num_view_components_op_minus1, sei_op_view_id[ i ] and \nsei_op_temporal_id and the same nested SEI messages. \n–  Remove all NAL units with nal_unit_type equal to 6 in which payloadType indicates an MVCD texture \nscalable nesting SEI message. \n–  The following applies for each active texture MVCD sequence parameter set RBSP. \n–  Replace  mvc_vui_parameters_extension( )  syntax  structure  in  an  active  texture  MVCD  sequence \nparameter set RBSPs with the mvc_vui_parameters_extension( ) syntax structure of the MVCD texture \nsub-bitstream VUI parameters extension, if both mvc_vui_parameters_extension( ) syntax structures \napply to the same views. \n–  Otherwise,  remove  mvc_vui_parameters_extension( )  syntax  structure  in  an  active  texture  MVCD \nsequence parameter set RBSP. \n–  Remove all NAL units with nal_unit_type equal to 6 in which the first SEI message has payloadType in the \nrange of 48 to 53, inclusive. \n12.  Let maxTId be the maximum temporal_id of all the remaining VCL NAL units. Remove all NAL units with \nnal_unit_type equal to 6 that only contain SEI messages that are part of an MVC scalable nesting SEI message or \nMVCD scalable nesting SEI message with any of the following properties: \n–  operation_point_flag  is  equal  to 0  and  all_view_components_in_au_flag  is  equal  to 0  and  none  of \nsei_view_id[ i ] for all i in the range of 0 to num_view_components_minus1, inclusive, corresponds to a \nVOIdx value included in VOIdxList, \n–  operation_point_flag is equal to 1 and either sei_op_temporal_id is greater than  maxTId or the list of \nsei_op_view_id[ i ] for all i in the range of 0 to num_view_components_op_minus1, inclusive, is not a subset \nof  viewIdTargetList  (i.e.,  it  is  not  true  that  sei_op_view_id[ i ]  for  any  i  in  the  range  of 0  to \nnum_view_components_op_minus1, inclusive, is equal to a value in viewIdTargetList). \n13.  Remove each view scalability information SEI message and each operation point not present SEI message, when \npresent. \n14.  When VOIdxList does not contain a value of VOIdx equal to minVOIdx, the view with VOIdx equal to the \nminimum VOIdx value included in VOIdxList is converted to the base view of the extracted sub-bitstream. \nNOTE 5 – When VOIdxList does not contain a value of VOIdx equal to minVOIdx, the resulting sub-bitstream \naccording to the operation steps 1-9 above does not contain a base view that conforms to one or more profiles specified \nin Annex A. In this case, by this operation step, the remaining view with the new minimum VOIdx value is converted \nto be the new base view that conforms to one or more profiles specified in Annex A and Annex H. \nI.8.5.4  Specification of the base view bitstream \nA bitstream that conforms to one or more profiles as specified in Annex I shall contain a base view bitstream that conforms \nto one or more of the profiles specified in Annex A. This base view bitstream is derived by invoking the sub-bitstream \nextraction process as specified in clause I.8.5.3 with no input and the base view bitstream being the output. \nNOTE – Although all multiview bitstreams that conform to one or more of the profiles specified in this annex contain a base view \nbitstream that conforms to one or more of the profiles specified in Annex A, the complete multiview bitstream (prior to operation of \nthe base view extraction process specified in this clause) may not conform to any profile specified in Annex A. \n    Rec. ITU-T H.264 (06/2019)  731 \n \nI.8.5.5  Specification of the stereoscopic texture bitstream \nA bitstream that conforms to a profile as specified in Annex I shall contain at least one sub-bitstream that conforms to one \nor more of the profiles specified in Annex H with number of views equal to 2. This stereoscopic texture bitstream is derived \nby invoking the sub-bitstream extraction process as specified in clause I.8.5.3 with depthPresentFlagTarget equal to 0 and \nviewIdTargetList containing the view_id values of the base view and a non-base view, the texture of which does not depend \non any other non-base view for decoding. \nI.9  Parsing process \nThe specifications in clause 9 apply. \nI.10  Profiles and levels \nThe specifications in Annex H apply. Additional profiles and specific values of profile_idc are specified in the following. \nThe profiles that are specified in clause I.10.1 are also referred to as the profiles specified in Annex I. \nI.10.1  Profiles \nAll constraints for picture parameter sets that are specified in the following are constraints for picture parameter sets that \nbecome the active picture parameter set or an active view picture parameter set inside the bitstream. All constraints for \nMVCD sequence parameter sets that are specified in the following are constraints for MVCD sequence parameter sets that \nbecome the active MVCD sequence parameter set or an active view MVCD sequence parameter set inside the bitstream. \nI.10.1.1 Multiview Depth High profile \nBitstreams conforming to the Multiview Depth High profile shall obey the following constraints: \n–  The base view bitstream as specified in clause I.8.5.4 shall obey all constraints of the High profile specified in \nclause A.2.4 and all active sequence parameter sets shall fulfil one of the following conditions: \n–  profile_idc is equal to 77 or constraint_set1_flag is equal to 1, \n–  profile_idc is equal to 100. \n–  The sub-bitstream of stereoscopic texture bitstream as specified in clause I.8.5.5 shall obey all constraints of the \nStereo High profile specified in clause H.10.2 and all active MVC sequence parameter sets shall fulfil one of the \nfollowing conditions: \n–  profile_idc is equal to 128, \n–  profile_idc is equal to 118 and constraint_set5_flag is equal to 1, \n–  profile_idc is equal to 100, \n–  profile_idc is equal to 77 or constraint_set1_flag is equal to 1. \n–  Only I, P, and B slice types may be present. \n–  NAL unit streams shall not contain nal_unit_type values in the range of 2 to 4, inclusive. \n–  Arbitrary slice order is not allowed. \n–  Picture parameter sets shall have num_slice_groups_minus1 equal to 0 only. \n–  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0 only. \n–  When  frame_mbs_only_flag  is  equal  to  1  in  an  active  sequence  parameter  set  for  a  texture  view, \nframe_mbs_only_flag shall be equal to 1 in the active sequence parameter set for the depth view having the same \nview_id. \n–  When  frame_mbs_only_flag  is  equal  to  0  in  an  active  sequence  parameter  set  for  a  depth  view, \nmb_adaptive_frame_field_flag shall be equal to 0. \n–  MVCD sequence parameter sets for the depth views shall have chroma_format_idc equal to 0 only. \n–  MVCD sequence parameter sets shall have bit_depth_luma_minus8 equal to 0 only. \n–  MVCD sequence parameter sets shall have bit_depth_chroma_minus8 equal to 0 only. \n–  MVCD sequence parameter sets shall have qpprime_y_zero_transform_bypass_flag equal to 0 only. \n732  Rec. ITU-T H.264 (06/2019) \n \n–  For each access unit, the value of level_idc for all active view MVCD sequence parameter set RBSPs shall be the \nsame as the value of level_idc for the active MVCD sequence parameter set RBSP. \n–  The level constraints specified for the Multiview Depth High profile in clause I.10.2 shall be fulfilled. \nConformance of a bitstream to the Multiview Depth High profile is indicated by profile_idc being equal to 138. \nDecoders conforming to the Multiview Depth High profile at a specific level shall be capable of decoding all bitstreams in \nwhich both of the following conditions are true: \na)  All active MVCD sequence parameter sets have one or more of the following conditions fulfilled: \n–  profile_idc is equal to 138, \n–  profile_idc is equal to 128, \n–  profile_idc is equal to 118 and constraint_set5_flag is equal to 1, \n–  profile_idc is equal to 100, \n–  profile_idc is equal to 77 or constraint_set1_flag is equal to 1. \nb)  All active MVCD sequence parameter sets have one or more of the following conditions fulfilled: \n–  level_idc or (level_idc and constraint_set3_flag) represent a level less than or equal to the specific level, \n–  level_idc[ i ] or (level_idc[ i ] and constraint_set3_flag) represent a level less than or equal to the specific level. \nI.10.1.2 MFC Depth High profile \nBitstreams conforming to the MFC Depth High profile shall obey the following constraints: \n–  The base view bitstream as specified in clause I.8.5.4 shall obey all constraints of the High profile specified in \nclause A.2.4, and all active sequence parameter sets shall fulfil one of the following conditions: \n–  profile_idc is equal to 77 or constraint_set1_flag is equal to 1, \n–  profile_idc is equal to 100. \n–  The sub-bitstream of stereoscopic texture bitstream, as specified in clause I.8.5.5, shall obey all constraints of the MFC \nHigh profile specified in clause H.10.1.3 and all active MVC sequence parameter sets shall fulfil one of the following \nconditions: \n–  profile_idc is equal to 134, \n–  profile_idc is equal to 100, \n–  profile_idc is equal to 77 or constraint_set1_flag is equal to 1. \n–  Only I, P, and B slice types may be present. \n–  NAL unit streams shall not contain nal_unit_type values in the range of 2 to 4, inclusive. \n–  Arbitrary slice order is not allowed. \n–  Picture parameter sets shall have num_slice_groups_minus1 equal to 0 only. \n–  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0 only. \n–  When frame_mbs_only_flag is equal to 1 in an active sequence parameter set for a texture view, frame_mbs_only_flag \nshall be equal to 1 in the active sequence parameter set for the depth view having the same view_id. \n–  When  frame_mbs_only_flag  is  equal  to  0  in  an  active  sequence  parameter  set  for  a  depth  view, \nmb_adaptive_frame_field_flag shall be equal to 0. \n–  MVCD sequence parameter sets for the depth views shall have chroma_format_idc equal to 0 only. \n–  MVCD sequence parameter sets shall have bit_depth_luma_minus8 equal to 0 only. \n–  MVCD sequence parameter sets shall have bit_depth_chroma_minus8 equal to 0 only. \n–  MVCD sequence parameter sets shall have qpprime_y_zero_transform_bypass_flag equal to 0 only. \n–  For each access unit, the value of level_idc for all active view MVCD sequence parameter set RBSPs shall be the \nsame as the value of level_idc for the active MVCD sequence parameter set RBSP. \n–  The level constraints specified for the MFC Depth High profile in clause I.10.2 shall be fulfilled. \n    Rec. ITU-T H.264 (06/2019)  733 \n \nConformance of a bitstream to the MFC Depth High profile is indicated by profile_idc being equal to 135. \nDecoders conforming to the MFC Depth High profile at a specific level shall be capable of decoding all bitstreams in \nwhich both of the following conditions are true: \na)  All active MVCD sequence parameter sets have one or more of the following conditions fulfilled: \n–  profile_idc is equal to 135, \n–  profile_idc is equal to 138, \n–  profile_idc is equal to 134, \n–  profile_idc is equal to 128, \n–  profile_idc is equal to 118 and constraint_set5_flag is equal to 1, \n–  profile_idc is equal to 100, \n–  profile_idc is equal to 77 or constraint_set1_flag is equal to 1. \nb)  All active MVCD sequence parameter sets have one or more of the following conditions fulfilled: \n–  level_idc or (level_idc and constraint_set3_flag) represent a level less than or equal to the specific level, \n–  level_idc[ i ] or (level_idc[ i ] and constraint_set3_flag) represent a level less than or equal to the specific level. \nI.10.2  Levels \nThe following is specified for expressing the constraints in this clause: \n–  Let access unit n be the n-th access unit in decoding order with the first access unit being access unit 0. \n–  Let picture n be the primary coded picture or the corresponding decoded picture of access unit n. \nLet the variable fR be derived as follows: \n–  If the level number is equal to 6.0, 6.1, or 6.2, fR is set equal to 1 ÷ 300. \n–  Otherwise, if picture n is a frame, fR is set equal to 1 ÷ 172. \n–  Otherwise (picture n is a field), fR is set equal to 1 ÷ (172 * 2). \nThe value of mvcScaleFactor is set equal to 2. \nThe value of mvcdScaleFactor is set equal to 2.5. \nThe value of NumViews indicates the number of views, including texture views and depth views, which are required for \ndecoding the target output views corresponding to the j-th operation point for level_idc[ i ] as signalled in the subset \nsequence  parameter  set,  and  is  set  equal  to  applicable_op_num_depth_views_minus1[ i ][ j ]  + \napplicable_op_num_depth_views_minus1[ i ][ j ] + 2. \nThe value of PicWidthInMbs and FrameHeightInMbs refer to the width and height of each view component, while the \nvalue of TotalPicSizeInMbs indicates the total number of macroblocks in the texture view components and depth view \ncomponents of a picture. \nI.10.2.1 Level limits common to Multiview Depth High profiles \nBitstreams conforming to the Multiview Depth High profile at a specified level shall obey the following constraints: \na)  The nominal removal time of access unit n (with n > 0) from the CPB as specified in clause C.1.2, satisfies the \nconstraint  that  t ( n ) − t ( n − 1 )  is  greater  than  or  equal \nr,n r\nto Max( TotalPicSizeInMbs ÷ ( mvcdScaleFactor * MaxMBPS ), fR ), where MaxMBPS is the value specified in \nTable A-1 that applies to picture n − 1, and TotalPicSizeInMbs is the total number of macroblocks in the texture \nview components and depth view components of picture n − 1. \nb)  The difference between consecutive output times of pictures from the DPB as specified in clause C.2.2, satisfies \nthe  constraint  that  t ( n ) >= Max( TotalPicSizeInMbs ÷ ( mvcdScaleFactor * MaxMBPS ),  fR ),  where \no,dpb\nMaxMBPS is the value specified in Table A-1 for picture n, and TotalPicSizeInMbs is the total number of \nmacroblocks in the texture view components and depth view components of picture n, provided that picture n is \na picture that is output and is not the last picture of the bitstream that is output. \nc)  PicWidthInMbs * FrameHeightInMbs <= MaxFS, where MaxFS is specified in Table A-1. \nd)  PicWidthInMbs <= Sqrt( MaxFS * 8 ), where MaxFS is specified in Table A-1. \n734  Rec. ITU-T H.264 (06/2019) \n \ne)  FrameHeightInMbs <= Sqrt( MaxFS * 8 ), where MaxFS is specified in Table A-1. \nf)  max_dec_frame_buffering <= MaxDpbFrames,  where  MaxDpbFrames  is  equal  to \nMin( mvcdScaleFactor * MaxDpbMbs / ( TotalPicSizeInMbs / NumViews ) ), \nMax( 1, Ceil( log2( NumViews ) ) ) * 16 ) and MaxDpbMbs is specified in Table A-1. \ng)  The vertical motion vector component range for luma motion vectors does not exceed the range from −MaxVmvR \nto ( MaxVmvR − 0.25 ) in units of luma frame samples, where MaxVmvR is specified in Table A-1. \nh)  The horizontal motion vector component range for luma motion vectors does not exceed the following range: \n–  If the level number is less than 6.0, the specified range is from −2048 to 2047.75, inclusive, in units of luma \nsamples. \n–  Otherwise, the specified range is from −8192 to 8191.75, inclusive, in units of luma samples. \ni)  Let setOf2Mb be the set of unsorted pairs of macroblocks that contains the unsorted pairs of macroblocks \n(mbA, mbB) of a coded video sequence for which any of the following conditions are true: \n–  mbA and mbB are macroblocks that belong to the same slice and are consecutive in decoding order, \n–  separate_colour_plane_flag is equal to 0, mbA is the last macroblock (in decoding order) of a slice, and mbB \nis the first macroblock (in decoding order) of the next slice in decoding order, \n–  separate_colour_plane_flag is equal to 1, mbA is the last macroblock (in decoding order) of a slice with a \nparticular value of colour_plane_id, and mbB is the first macroblock (in decoding order) of the next slice \nwith the same value of colour_plane_id in decoding order. \nNOTE 1 – In the two above conditions, the macroblocks mbA and mbB can belong to different \npictures. \nFor each unsorted pair of macroblocks (mbA, mbB) of the set setOf2Mb, the total number of motion vectors \n(given by the sum of the number of motion vectors for macroblock mbA and the number of motion vectors for \nmacroblock mbB) does not exceed MaxMvsPer2Mb, where MaxMvsPer2Mb is specified in Table A-1. The \nnumber of motion vectors for each macroblock is the value of the variable MvCnt after the completion of the intra \nor inter prediction process for the macroblock. \nNOTE 2 – When separate_colour_plane_flag is equal to 0, the constraint specifies that the total number \nof  motion  vectors  for  two  consecutive  macroblocks  in  decoding  order  must  not  exceed \nMaxMvsPer2Mb. When separate_colour_plane_flag is equal to 1, the constraint specifies that the total \nnumber of motion vectors for two consecutive macroblocks with the same value of colour_plane_id in \ndecoding order must not exceed MaxMvsPer2Mb. For macroblocks that are consecutive in decoding \norder but are associated with a different value of colour_plane_id, no constraint for the total number \nof motion vectors is specified. \nj)  The number of bits of macroblock_layer( ) data for any macroblock is not  greater than 128 + RawMbBits. \nDepending on entropy_coding_mode_flag, the bits of macroblock_layer( ) data are counted as follows: \n–  If entropy_coding_mode_flag is equal to 0, the number of bits of macroblock_layer( ) data is given by the \nnumber of bits in the macroblock_layer( ) syntax structure for a macroblock. \n–  Otherwise (entropy_coding_mode_flag is equal to 1), the number of bits of macroblock_layer( ) data for a \nmacroblock is given by the number of times read_bits( 1 ) is called in clauses 9.3.3.2.2 and 9.3.3.2.3 when \nparsing the macroblock_layer( ) associated with the macroblock. \nk)  The removal time of access unit 0 shall satisfy the constraint that the number of slices in picture 0 is less than or \nequal  to  mvcdScaleFactor * ( Max( PicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * ( t ( 0 ) − t ( 0 ) ) ) ÷ \nr r,n\nSliceRate, where MaxMBPS and SliceRate are the values specified in Table A-1 and Table A-4, respectively, that \napply to picture 0 and PicSizeInMbs is the number of macroblocks in a single texture view component of picture 0. \nl)  The removal time of access unit 0 shall satisfy the constraint that the number of slices in each view component of \npicture  0  is  less  than  or  equal  to  ( Max( PicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * \n( t ( 0 ) − t ( 0 ) ) ) ÷ SliceRate,  where  MaxMBPS  and  SliceRate  are  the  values  specified  in  Table A-1  and \nr r,n\nTable A-4, respectively, that apply to picture 0 and PicSizeInMbs is the number of macroblocks in a single view \ncomponent of picture 0. \nm)  The difference between consecutive removal times of access units n and n − 1 with n > 0 shall satisfy the constraint \nthat  the  number  of  slices  in  picture  n  is  less  than  or  equal  to \nmvcdScaleFactor * MaxMBPS * ( t ( n ) − t ( n − 1 ) ) ÷ SliceRate,  where  SliceRate  is  the  value  specified  in \nr r\nTable A-4 that applies to picture n. \n    Rec. ITU-T H.264 (06/2019)  735 \n \nn)  The difference between consecutive removal times of access units n and n − 1 with n > 0 shall satisfy the constraint \nthat  the  number  of  slices  in  each  view  component  of  picture  n  is  less  than  or  equal  to \nMaxMBPS * ( t ( n ) − t ( n − 1 ) ) ÷ SliceRate, where SliceRate is the value specified in Table A-4 that applies to \nr r\npicture n. \no)  MVCD sequence parameter sets shall  have direct_8x8_inference_flag equal to 1 for the levels specified in \nTable A-4. \np)  The value of sub_mb_type[ mbPartIdx ] with mbPartIdx = 0..3 in B macroblocks with mb_type equal to B_8x8 \nshall not be equal to B_Bi_8x4, B_Bi_4x8, or B_Bi_4x4 for the levels in which MinLumaBiPredSize is shown \nas 8x8 in Table A-4. \nq)  For  the  VCL  HRD  parameters,  BitRate[ SchedSelIdx ] <= cpbBrVclFactor * MaxBR  and \nCpbSize[ SchedSelIdx ] <= cpbBrVclFactor *MaxCPB  for  at  least  one  value  of  SchedSelIdx,  where \ncpbBrVclFactor is equal to 1250. With vui_mvc_vcl_hrd_parameters_present_flag[ i ] being the syntax element, \nin the MVCD VUI parameters extension of the active MVCD sequence parameter set, that is associated with the \nVCL HRD parameters that are used for conformance checking (as specified in Annex C), BitRate[ SchedSelIdx ] \nand CpbSize[ SchedSelIdx ] are given as follows: \n–  If  vui_mvc_vcl_hrd_parameters_present_flag  equal  to 1,  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are given by Equations E-53 and E-54, respectively, using the syntax elements of \nthe  hrd_parameters( )  syntax  structure  that  immediately  follows \nvui_mvc_vcl_hrd_parameters_present_flag. \n–  Otherwise  (vui_mvc_vcl_hrd_parameters_present_flag  equal  to  0),  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are inferred as specified in clause E.2.2 for VCL HRD parameters. \nMaxBR and MaxCPB are specified in Table A-1 in units of cpbBrVclFactor bits/s and cpbBrVclFactor bits, \nrespectively. The bitstream shall satisfy these conditions for at least one value of SchedSelIdx in the range 0 to \ncpb_cnt_minus1, inclusive. \nr)  For  the  NAL  HRD  parameters,  BitRate[ SchedSelIdx ] <= cpbBrNalFactor * MaxBR  and \nCpbSize[ SchedSelIdx ] <= cpbBrNalFactor *MaxCPB  for  at  least  one  value  of  SchedSelIdx,  where \ncpbBrNalFactor is equal to 1500. With vui_mvc_nal_hrd_parameters_present_flag[ i ] being the syntax element, \nin the MVCD VUI parameters extension of the active MVCD sequence parameter set, that is associated with the \nNAL HRD parameters that are used for conformance checking (as specified in Annex C), BitRate[ SchedSelIdx ] \nand CpbSize[ SchedSelIdx ] are given as follows: \n–  If  vui_mvc_nal_hrd_parameters_present_flag  equal  to 1,  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are given by Equations E-53 and E-54, respectively, using the syntax elements of \nthe  hrd_parameters( )  syntax  structure  that  immediately  follows \nvui_mvc_nal_hrd_parameters_present_flag. \n–  Otherwise  (vui_mvc_nal_hrd_parameters_present_flag  equal  to  0),  BitRate[ SchedSelIdx ]  and \nCpbSize[ SchedSelIdx ] are inferred as specified in clause E.2.2 for NAL HRD parameters. \nMaxBR and MaxCPB are specified in Table A-1 in units of cpbBrNalFactor bits/s and cpbBrNalFactor bits, \nrespectively. The bitstream shall satisfy these conditions for at least one value of SchedSelIdx in the range 0 to \ncpb_cnt_minus1, inclusive. \ns)  The  sum  of  the  NumBytesInNALunit  variables  for  access  unit  0  is  less  than  or  equal  to \n384 * mvcdScaleFactor * ( Max( PicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * ( t ( 0 ) − t ( 0 ) ) ) ÷ MinCR\nr r,n\n, where MaxMBPS and MinCR are the values specified in Table A-1 that apply to picture 0 and PicSizeInMbs is \nthe number of macroblocks in a single texture view component of picture 0. \nt)  The sum of the NumBytesInNALunit variables for the VCL NAL units of each view component of access unit 0 \nis  less  than  or  equal  to  384 * ( Max( PicSizeInMbs, fR * MaxMBPS ) + MaxMBPS * ( t ( 0 ) − t ( 0 ) ) ) ÷ \nr r,n\nMinCR,  where  MaxMBPS  and  MinCR  are  the  values  specified  in  Table A-1  that  apply  to  picture  0  and \nPicSizeInMbs is the number of macroblocks in a single view component of picture 0. \nu)  The  sum  of  the  NumBytesInNALunit  variables  for  access  unit n  with  n  >  0  is  less  than  or  equal  to \n384 * mvcdScaleFactor * MaxMBPS * ( t ( n ) − t ( n − 1 ) ) ÷ MinCR,  where  MaxMBPS  and  MinCR  are  the \nr r\nvalues specified in Table A-1 that apply to picture n. \nv)  The sum of the NumBytesInNALunit variables for the VCL NAL units of each view component of access unit n \nwith n > 0 is less than or equal to 384 * MaxMBPS * ( t ( n ) − t ( n − 1 ) ) ÷ MinCR, where MaxMBPS and \nr r\nMinCR are the values specified in Table A-1 that apply to picture n. \nw)  When PicSizeInMbs is greater than 1620, the number of macroblocks in any coded slice shall not exceed MaxFS \n/ 4, where MaxFS is specified in Table A-1. \n736  Rec. ITU-T H.264 (06/2019) \n \nx)  max_num_ref_frames shall be less than or equal to MaxDpbFrames / mvcScaleFactor for each texture view \ncomponent, where MaxDpbFrames is specified in item f). \ny)  MVCD sequence parameter sets shall have frame_mbs_only_flag equal to 1 for the levels specified in Table A-4. \nTable A-1 specifies the limits for each level. A definition of all levels identified in the \"Level number\" column of Table A-1 \nis specified for the Multiview Depth High profile. Table A-4 specifies limits for each level that are specific to bitstreams \nconforming  to  the  Multiview  Depth  High  profile.  Each  entry  in  Table A-1  and  Table A-4  indicates,  for  the  level \ncorresponding to the row of the table, the absence or value of a limit that is imposed by the variable corresponding to the \ncolumn of the table, as follows: \n–  If the table entry is marked as \"-\", no limit is imposed by the value of the variable as a requirement of bitstream \nconformance to the profile at the specified level. \n–  Otherwise, the table entry specifies the value of the variable for the associated limit that is imposed as a requirement \nof bitstream conformance to the profile at the specified level. \nFor coded video sequences conforming to the Multiview Depth High profile, the level_idc value is specified as follows: \n–  If level_idc is not equal to 0, level_idc indicates the level that applies to the coded video sequence operating with all \nthe views being target output views. \nNOTE 3 – A level_idc value that is not equal to zero may indicate a higher level than necessary to decode the \ncoded video sequence operating with all the views being target output views. This may occur when a subset of \nviews or temporal subsets are removed from a coded video sequence according to the sub-bitstream extraction \nprocess specified in clause I.8.5.3, and the level_idc value is not updated accordingly. \n–  Otherwise (level_idc is equal to 0), the level that applies to the coded video sequence operating with all the views \nbeing target output views is unspecified. \nNOTE 4 – When profile_idc is equal to 118 or 128 and level_idc is equal to 0, there may exist a level indicated \nby level_idc[ i ] that is applicable to the coded video sequence operating with all the views being target output \nviews. This may occur when a subset of views or temporal subsets are removed from a coded video sequence \naccording to the sub-bitstream extraction process specified in clause I.8.5.3, and a particular value of level_idc[ i ] \ncorresponds to the resulting coded video sequence. \nIn bitstreams conforming to the Multiview Depth High profile, the conformance of the bitstream to a specified level is \nindicated by the syntax element level_idc or level_idc[ i ] as follows: \n–  If level_idc or level_idc[ i ] is equal to 9, the indicated level is level 1b. \n–  Otherwise (level_idc or level_idc[ i ] is not equal to 9), level_idc or level_idc[ i ] is equal to a value of ten times \nthe level number (of the indicated level) specified in Table A-1. \nI.10.2.2 Profile specific level limits \na)  In bitstreams conforming to the Multiview Depth High profile, MVCD sequence parameter sets shall have \nframe_mbs_only_flag equal to 1 for the levels specified in Table A-4. \nI.11  Byte stream format \nThe specifications in Annex B apply. \nI.12  MVCD hypothetical reference decoder \nThe specifications in Annex C apply with substituting MVCD sequence parameter set for MVC sequence parameter set. \nI.13  MVCD SEI messages \nThe specifications in Annex D together with the extensions and modifications specified in this clause apply. \nI.13.1  SEI message syntax \nI.13.1.1 MVCD view scalability information SEI message syntax \n \nmvcd_view_scalability_info( payloadSize ) {  C  Descriptor \n  num_operation_points_minus1  5  ue(v) \n  for( i = 0; i <= num_operation_points_minus1; i++ ) {     \n    operation_point_id[ i ]  5  ue(v) \n    priority_id[ i ]  5  u(5) \n    Rec. ITU-T H.264 (06/2019)  737 \n \n    temporal_id[ i ]  5  u(3) \n    num_target_output_views_minus1[ i ]  5  ue(v) \n    for( j = 0; j <= num_target_output_views_minus1[ i ]; j++ ) {     \n      view_id[ i ][ j ]  5  ue(v) \n      mvcd_op_view_info( )     \n    }     \n    profile_level_info_present_flag[ i ]  5  u(1) \n    bitrate_info_present_flag[ i ]  5  u(1) \n    frm_rate_info_present_flag[ i ]  5  u(1) \n    if( !num_target_output_views_minus1[ i ] )      \n      view_dependency_info_present_flag[ i ]  5  u(1) \n    parameter_sets_info_present_flag[ i ]  5  u(1) \n    bitstream_restriction_info_present_flag[ i ]  5  u(1) \n    if( profile_level_info_present_flag[ i ] )     \n      op_profile_level_idc[ i ]   5  u(24) \n    if( bitrate_info_present_flag[ i ] ) {     \n      avg_bitrate[ i ]  5  u(16) \n      max_bitrate[ i ]  5  u(16) \n      max_bitrate_calc_window[ i ]  5  u(16) \n    }     \n    if( frm_rate_info_present_flag[ i ] ) {     \n      constant_frm_rate_idc[ i ]  5  u(2) \n      avg_frm_rate[ i ]  5  u(16) \n    }     \n    if( view_dependency_info_present_flag[ i ] ) {     \n      num_directly_dependent_views[ i ]  5  ue(v) \n      for( j = 0; j < num_directly_dependent_views[ i ]; j++ ) {     \n        directly_dependent_view_id[ i ][ j ]  5  ue(v) \n        mvcd_op_view_info( )     \n      }     \n    } else     \n      view_dependency_info_src_op_id[ i ]  5  ue(v) \n    if( parameter_sets_info_present_flag[ i ] ) {     \n      num_seq_parameter_set_minus1[ i ]  5  ue(v) \n      for( j = 0; j <= num_seq_parameter_set_minus1[ i ]; j++ )     \n        seq_parameter_set_id_delta[ i ][ j ]  5  ue(v) \n      num_subset_seq_parameter_set_minus1[ i ]  5  ue(v) \n      for( j = 0; j <= num_subset_seq_parameter_set_minus1[ i ]; j++ )     \n        subset_seq_parameter_set_id_delta[ i ][ j ]  5  ue(v) \n      num_pic_parameter_set_minus1[ i ]  5  ue(v) \n      for( j = 0; j <= num_init_pic_parameter_set_minus1[ i ]; j++ )     \n        pic_parameter_set_id_delta[ i ][ j ]  5  ue(v) \n    } else     \n      parameter_sets_info_src_op_id[ i ]  5  ue(v) \n738  Rec. ITU-T H.264 (06/2019) \n \n    if( bitstream_restriction_info_present_flag[ i ] ) {     \n      motion_vectors_over_pic_boundaries_flag[ i ]  5  u(1) \n      max_bytes_per_pic_denom[ i ]  5  ue(v) \n      max_bits_per_mb_denom[ i ]  5  ue(v) \n      log2_max_mv_length_horizontal[ i ]  5  ue(v) \n      log2_max_mv_length_vertical[ i ]  5  ue(v) \n      num_reorder_frames[ i ]  5  ue(v) \n      max_dec_frame_buffering[ i ]  5  ue(v) \n    }     \n  }     \n}     \n \nI.13.1.1.1  MVCD operation point view information syntax \n \nmvcd_op_view_info( ) {  C  Descriptor \n  view_info_depth_view_present_flag  5  u(1) \n  if( view_info_depth_view_present_flag )     \n    mvcd_depth_view_flag  5  u(1) \n  view_info_texture_view_present_flag  5  u(1) \n  if( view_info_texture_view_present_flag )     \n    mvcd_texture_view_flag  5  u(1) \n}     \n \nI.13.1.2 MVCD scalable nesting SEI message syntax \n \nmvcd_scalable_nesting( payloadSize ) {  C  Descriptor \n  operation_point_flag  5  u(1) \n  if( !operation_point_flag ) {     \n    all_view_components_in_au_flag  5  u(1) \n    if( !all_view_components_in_au_flag ) {     \n      num_view_components_minus1  5  ue(v) \n      for( i = 0; i <= num_view_components_minus1; i++ ) {     \n        sei_view_id[ i ]  5  u(10) \n        sei_view_applicability_flag[ i ]  5  u(1) \n      }     \n    }     \n  } else {     \n    sei_op_texture_only_flag  5  u(1) \n    num_view_components_op_minus1  5  ue(v) \n    for( i = 0; i <= num_view_components_op_minus1; i++ ) {     \n      sei_op_view_id[ i ]  5  u(10) \n      if( !sei_op_texture_only_flag ) {     \n        sei_op_depth_flag[ i ]     \n        sei_op_texture_flag[ i ]     \n      }     \n    }     \n    sei_op_temporal_id  5  u(3) \n  }     \n  while( !byte_aligned( ) )     \n    sei_nesting_zero_bit /* equal to 0 */  5  f(1) \n  sei_message( )  5   \n}     \n    Rec. ITU-T H.264 (06/2019)  739 \n \n \nI.13.1.3 Depth representation information SEI message syntax \n \ndepth_representation_info( payloadSize ) {  C  Descriptor \n  all_views_equal_flag  5  u(1) \n  if( all_views_equal_flag  = =  0 ) {     \n    num_views_minus1  5  ue(v) \n    numViews = num_views_minus1 + 1     \n  } else     \n    numViews = 1     \n  z_near_flag  5  u(1) \n  z_far_flag  5  u(1) \n  if( z_near_flag   | |  z_far_flag ) {     \n    z_axis_equal_flag  5  u(1) \n    if( z_axis_equal_flag )     \n      common_z_axis_reference_view  5  ue(v) \n  }     \n  d_min_flag  5  u(1) \n  d_max_flag  5  u(1) \n  depth_representation_type  5  ue(v) \n  for( i = 0; i < numViews; i++ ) {     \n    depth_info_view_id[ i ]  5  ue(v) \n    if( ( z_near_flag  | |  z_far_flag )  &&  ( z_axis_equal_flag  = =  0 ) )     \n      z_axis_reference_view[ i ]  5  ue(v) \n    if( d_min_flag  | |  d_max_flag )     \n      disparity_reference_view[ i ]  5  ue(v) \n    if( z_near_flag )     \n      depth_representation_sei_element( ZNearSign, ZNearExp,     \n                          ZNearMantissa, ZNearManLen ) \n    if( z_far_flag )     \n      depth_representation_sei_element( ZFarSign, ZFarExp,     \n                          ZFarMantissa, ZFarManLen ) \n    if( d_min_flag )     \n      depth_representation_sei_element( DMinSign, DMinExp,     \n                          DMinMantissa, DMinManLen ) \n    if( d_max_flag )     \n      depth_representation_sei_element( DMaxSign, DMaxExp,     \n                          DMaxMantissa, DMaxManLen ) \n  }     \n  if( depth_representation_type  = =  3 ) {     \n    depth_nonlinear_representation_num_minus1  5  ue(v) \n    for( i = 1; i <= depth_nonlinear_representation_num_minus1 + 1; i++ )     \n      depth_nonlinear_representation_model[ i ]  5  ue(v) \n  }     \n}     \n \n740  Rec. ITU-T H.264 (06/2019) \n \nI.13.1.3.1  Depth representation SEI element syntax \n \ndepth_representation_sei_element( outSign, outExp, outMantissa,  C  Descriptor \n  outManLen ) { \n  da_sign_flag  5  u(1) \n  da_exponent  5  u(7) \n  da_mantissa_len_minus1  5  u(5) \n  da_mantissa  5  u(v) \n}     \nI.13.1.4 3D reference displays information SEI message syntax \n \nthree_dimensional_reference_displays_info( payloadSize ) {  C  Descriptor \n  prec_ref_baseline  5  ue(v) \n  prec_ref_display_width  5  ue(v) \n  ref_viewing_distance_flag  5  u(1) \n  if( ref_viewing_distance_flag )     \n    prec_ref_viewing_dist  5  ue(v) \n  num_ref_displays_minus1  5  ue(v) \n  numRefDisplays  = num_ref_displays_minus1 + 1     \n  for( i = 0; i < numRefDisplays; i++ ) {     \n    exponent_ref_baseline[ i ]  5  u(6) \n    mantissa_ref_baseline[ i ]  5  u(v) \n    exponent_ref_display_width[ i ]  5  u(6) \n    mantissa_ref_display_width[ i ]  5  u(v) \n    if( ref_viewing_distance_flag ) {     \n      exponent_ref_viewing_distance[ i ]  5  u(6) \n      mantissa_ref_viewing_distance[ i ]  5  u(v) \n    }     \n    additional_shift_present_flag[ i ]  5  u(1) \n    if( additional_shift_present[ i ] )     \n      num_sample_shift_plus512[ i ]  5  u(10) \n  }     \n  three_dimensional_reference_displays_extension_flag  5  u(1) \n}     \n \nI.13.1.5 Depth timing SEI message syntax \n \ndepth_timing( payloadSize ) {  C  Descriptor \n  per_view_depth_timing_flag  5  u(1) \n  if( per_view_depth_timing_flag )     \n    for( i = 0; i < NumDepthViews; i++ )     \n      depth_timing_offset( )     \n  else     \n    depth_timing_offset( )     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  741 \n \nI.13.1.5.1  Depth timing offset syntax \n \ndepth_timing_offset( ) {  C  Descriptor \n  offset_len_minus1  5  u(5) \n  depth_disp_delay_offset_fp  5  u(v) \n  depth_disp_delay_offset_dp  5  u(6) \n}     \n \nI.13.1.6 Alternative depth information SEI message syntax \n \nalternative_depth_info( payloadSize ) {  C  Descriptor \n  depth_type  5  ue(v) \n  if( depth_type  = =  0 ) {     \n    num_constituent_views_gvd_minus1  5  ue(v) \n    depth_present_gvd_flag  5  u(1) \n    z_gvd_flag  5  u(1) \n    intrinsic_param_gvd_flag  5  u(1) \n    rotation_gvd_flag  5  u(1) \n    translation_gvd_flag  5  u(1) \n    if( z_gvd_flag )      \n      for( i = 0; i  <=  num_constituent_views_gvd_minus1 + 1; i++ ) {     \n        sign_gvd_z_near_flag[ i ]  5  u(1) \n        exp_gvd_z_near[ i ]  5  u(7) \n        man_len_gvd_z_near_minus1[ i ]  5  u(5) \n        man_gvd_z_near[ i ]  5  u(v) \n        sign_gvd_z_far_flag[ i ]  5  u(1) \n        exp_gvd_z_far[ i ]  5  u(7) \n        man_len_gvd_z_far_minus1[ i ]  5  u(5) \n        man_gvd_z_far[ i ]  5  u(v) \n      }     \n    if( intrinsic_param_gvd_flag ) {     \n      prec_gvd_focal_length  5  ue(v) \n      prec_gvd_principal_point  5  ue(v) \n    }     \n    if( rotation_gvd_flag )     \n      prec_gvd_rotation_param  5  ue(v) \n    if( translation_gvd_flag )     \n      prec_gvd_translation_param  5  ue(v) \n    for( i = 0; i  <=  num_constituent_views_gvd_minus1 + 1; i++ ) {     \n      if( intrinsic_param_gvd_flag ) {     \n        sign_gvd_focal_length_x[ i ]  5  u(1) \n        exp_gvd_focal_length_x[ i ]  5  u(6) \n        man_gvd_focal_length_x[ i ]  5  u(v) \n        sign_gvd_focal_length_y[ i ]  5  u(1) \n        exp_gvd_focal_length_y[ i ]  5  u(6) \n        man_gvd_focal_length_y[ i ]  5  u(v) \n        sign_gvd_principal_point_x[ i ]  5  u(1) \n        exp_gvd_principal_point_x[ i ]  5  u(6) \n742  Rec. ITU-T H.264 (06/2019) \n \n        man_gvd_principal_point_x[ i ]  5  u(v) \n        sign_gvd_principal_point_y[ i ]  5  u(1) \n        exp_gvd_principal_point_y[ i ]  5  u(6) \n        man_gvd_principal_point_y[ i ]  5  u(v) \n      }     \n      if( rotation_gvd_flag )     \n        for( j = 0; j < 3; j++ ) /* row */     \n         for( k = 0; k < 3; k++ ) { /* column */     \n           sign_gvd_r[ i ][ j ][ k ]  5  u(1) \n           exp_gvd_r[ i ][ j ][ k ]  5  u(6) \n           man_gvd_r[ i ][ j ][ k ]  5  u(v) \n        }     \n      if( translation_gvd_flag ) {     \n        sign_gvd_t_x[ i ]  5  u(1) \n        exp_gvd_t_x[ i ]  5  u(6) \n        man_gvd_t_x[ i ]  5  u(v) \n      }     \n    }     \n  }     \n}     \n \nI.13.1.7 Depth sampling information SEI message syntax \n \ndepth_sampling_info( payloadSize ) {  C  Descriptor \n  dttsr_x_mul  5  u(16) \n  dttsr_x_dp  5  u(4) \n  dttsr_y_mul  5  u(16) \n  dttsr_y_dp  5  u(4) \n  per_view_depth_grid_pos_flag  5  u(1) \n  if( per_view_depth_grid_pos_flag ) {     \n    num_video_plus_depth_views_minus1  5  ue(v) \n    for( i = 0; i <= num_video_plus_depth_views_minus1; i++ ) {     \n      depth_grid_view_id[ i ]  5  ue(v) \n      depth_grid_position( )     \n    }     \n  } else     \n    depth_grid_position( )     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  743 \n \nI.13.1.7.1  Depth grid position syntax \n \ndepth_grid_position( ) {  C  Descriptor \n  depth_grid_pos_x_fp  5  u(20) \n  depth_grid_pos_x_dp  5  u(4) \n  depth_grid_pos_x_sign_flag  5  u(1) \n  depth_grid_pos_y_fp  5  u(20) \n  depth_grid_pos_y_dp  5  u(4) \n  depth_grid_pos_y_sign_flag  5  u(1) \n}     \n \nI.13.2  SEI message semantics \nDepending on payloadType, the corresponding SEI message semantics are extended as follows: \n–  If payloadType is equal to 2, 3, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 45, 47, 137, 142, 144, \n147, 148, 149, 150, 151, 154, 155, 156, 200, or 201, the following applies: \n–  If the SEI message is not included in an MVC scalable nesting SEI message or an MVCD scalable nesting SEI \nmessage, it applies to the texture view component of the current access unit with VOIdx equal to VOIdxMin. \n–  Otherwise, if included in an MVC scalable nesting SEI message and not included in an MVCD scalable nesting \nSEI  message,  it  applies  to  all  texture  view  components  of  the  current  access  unit  when \nall_view_components_in_au_flag is equal to 1, or it applies to all texture view components of the current access \nunit with view_id equal to sei_view_id[ i ] for any i in the range of 0 to num_view_components_minus1, \ninclusive, when all_view_components_in_au_flag is equal to 0. When payloadType is equal to 10 for the SEI \nmessage that is included in an MVC scalable nesting SEI message, the semantics for sub_seq_layer_num of the \nsub-sequence information SEI message is modified as follows: \nsub_seq_layer_num specifies the sub-sequence layer number of the current picture. When the current \npicture resides in a sub-sequence for which the first picture in decoding order is an IDR picture, the value \nof sub_seq_layer_num shall be equal to 0. For a non-paired reference field, the value of sub_seq_layer_num \nshall be equal to 0. sub_seq_layer_num shall be in the range of 0 to 255, inclusive. \n–  Otherwise, if not included in an MVC scalable nesting SEI message and included in an MVCD scalable nesting \nSEI message, it applies to all depth view components or view component pairs of the current access unit when \nall_view_components_in_au_flag is equal to 1, or it applies to all depth view components or view component \npairs  of  the  current  access  unit  with  view_id  equal  to  sei_view_id[ i ]  for  any  i  in  the  range  of 0  to \nnum_view_components_minus1,  inclusive,  when  all_view_components_in_au_flag  is  equal  to 0.  When \npayloadType is equal to 10 for the SEI message that is included in an MVCD scalable nesting SEI message, the \nsemantics for sub_seq_layer_num of the sub-sequence information SEI message is modified as follows: \nsub_seq_layer_num specifies the sub-sequence layer number of the current picture. When the current \npicture resides in a sub-sequence for which the first picture in decoding order is an IDR picture, the value \nof sub_seq_layer_num shall be equal to 0. For a non-paired reference field, the value of sub_seq_layer_num \nshall be equal to 0. sub_seq_layer_num shall be in the range of 0 to 255, inclusive. \n–  Otherwise, if payloadType is equal to 41, 42 or 43, the following applies: \n–  If the SEI message is not included in MVCD scalable nesting SEI message, it applies to texture views only and \nNAL units having nal_unit_type equal to 21 are non-VCL NAL units. \n–  Otherwise (the SEI message is included in MVCD scalable nesting SEI message), the SEI message applies to \ndepth views, to texture views or both texture views all depth views, depending on the values of the syntax \nelements of the MVCD scalable nesting SEI message. \n–  Otherwise, if payloadType is equal to 0 or 1, the following applies: \n–  If the SEI message is not included in an MVC scalable nesting SEI message or an MVCD scalable nesting SEI \nmessage or an MVCD texture sub-bitstream HRD nesting SEI message, the following applies. When the SEI \nmessage and all other SEI messages with payloadType equal to 0 or 1 not included in an MVC scalable nesting \nSEI message or an MVCD scalable nesting SEI message or an MVCD texture sub-bitstream HRD nesting SEI \nmessage  are  used  as  the  buffering  period  and  picture  timing  SEI  messages  for  checking  the  bitstream \n744  Rec. ITU-T H.264 (06/2019) \n \nconformance according to Annex C and the decoding process specified in clauses 2 to 9 is used, the bitstream \nshall be conforming to this Recommendation | International Standard. \n–  Otherwise, if the SEI message is included in an MVC scalable nesting SEI message and not included in an \nMVCD scalable nesting SEI message or a MVCD texture sub-bitstream HRD nesting SEI message, the following \napplies. When the SEI message and all other SEI messages with payloadType equal to 0 or 1 included in an \nMVC scalable nesting SEI message with identical values of sei_op_temporal_id and sei_op_view_id[ i ] for all \ni in the range of 0 to num_view_components_op_minus1, inclusive, are used as the buffering period and picture \ntiming SEI messages for checking the bitstream conformance according to Annex C, the bitstream that would be \nobtained by invoking the bitstream extraction process as specified in  clause H.8.3 with tIdTarget equal to \nsei_op_temporal_id  and  viewIdTargetList  equal  to  sei_op_view_id[ i ]  for  all  i  in  the  range  of 0  to \nnum_view_components_op_minus1,  inclusive,  shall  be  conforming  to  this  Recommendation | \nInternational Standard. \nIn  the  semantics  of  clauses D.2.1  and  D.2.3,  the  syntax  elements  num_units_in_tick,  time_scale, \nfixed_frame_rate_flag,  nal_hrd_parameters_present_flag,  vcl_hrd_parameters_present_flag, \nlow_delay_hrd_flag,  and  pic_struct_present_flag  and  the  derived  variables  NalHrdBpPresentFlag, \nVclHrdBpPresentFlag,  and  CpbDpbDelaysPresentFlag  are  substituted  with  the  syntax  elements \nvui_mvc_num_units_in_tick[ i ],  vui_mvc_time_scale[ i ],  vui_mvc_fixed_frame_rate_flag[ i ], \nvui_mvc_nal_hrd_parameters_present_flag[ i ],  vui_mvc_vcl_hrd_parameters_present_flag[ i ], \nvui_mvc_low_delay_hrd_flag[ i ],  and  vui_mvc_pic_struct_present_flag[ i ]  and  the  derived  variables \nVuiMvcNalHrdBpPresentFlag[ i ],  VuiMvcVclHrdBpPresentFlag[ i ],  and \nVuiMvcCpbDpbDelaysPresentFlag[ i ]. \nThe values of seq_parameter_set_id's in all buffering period SEI messages included in MVC scalable nesting \nSEI messages and associated with operation points for which the greatest VOIdx values in the associated \nbitstream subsets are identical shall be identical. \n–  Otherwise, if the SEI message is included in a MVCD scalable nesting SEI message and not included in an MVC \nscalable nesting SEI message or an MVCD texture sub-bitstream HRD nesting SEI message, the following \napplies. When the SEI message and all other SEI messages with payloadType equal to 0 or 1 included in an \nMVCD scalable nesting SEI message with identical values of sei_op_temporal_id and sei_op_view_id[ i ] for \nall i in the range of 0 to num_view_components_op_minus1, inclusive, are used as the buffering period and \npicture timing SEI messages for checking the bitstream conformance according to Annex C, the bitstream that \nwould  be  obtained  by  invoking  the  bitstream  extraction  process  as  specified  in  clause I.8.5  with \ndepthPresentTargetFlag  equal  to  1,  tIdTarget  equal  to  sei_op_temporal_id  and  viewIdTargetList  equal  to \nsei_op_view_id[ i ]  for  all  i  in  the  range  of 0  to  num_view_components_op_minus1,  inclusive,  shall  be \nconforming to this Recommendation | International Standard. \nIn  the  semantics  of  clauses D.2.1  and  D.2.3,  the  syntax  elements  num_units_in_tick,  time_scale, \nfixed_frame_rate_flag,  nal_hrd_parameters_present_flag,  vcl_hrd_parameters_present_flag, \nlow_delay_hrd_flag,  and  pic_struct_present_flag  and  the  derived  variables  NalHrdBpPresentFlag, \nVclHrdBpPresentFlag,  and  CpbDpbDelaysPresentFlag  are  substituted  with  the  syntax  elements \nvui_mvc_num_units_in_tick[ i ],  vui_mvc_time_scale[ i ],  vui_mvc_fixed_frame_rate_flag[ i ], \nvui_mvc_nal_hrd_parameters_present_flag[ i ],  vui_mvc_vcl_hrd_parameters_present_flag[ i ], \nvui_mvc_low_delay_hrd_flag[ i ],  and  vui_mvc_pic_struct_present_flag[ i ]  and  the  derived  variables \nVuiMvcNalHrdBpPresentFlag[ i ],  VuiMvcVclHrdBpPresentFlag[ i ],  and \nVuiMvcCpbDpbDelaysPresentFlag[ i ] for the MVCD VUI parameters extension. \nThe values of seq_parameter_set_id's in all buffering period SEI messages included in MVCD scalable nesting \nSEI messages and not included in either MVC scalable nesting SEI messages or MVCD texture sub-bitstream \nHRD nesting SEI messages and associated with operation points for which the greatest VOIdx values in the \nassociated bitstream subsets are identical shall be identical. \n–  Otherwise, if the SEI message is included in an MVCD texture sub-bitstream HRD nesting SEI message, the \nfollowing applies. When the SEI message and all other SEI messages included in an MVCD texture sub-bitstream \nHRD  nesting  SEI  message  with  identical  values  of  texture_subbitstream_temporal_id  and \ntexture_subbitstream_view_id[ i ]  for  all  i  in  the  range  of 0  to \nnum_texture_subbitstream_view_components_minus1, inclusive, are used as the buffering period and picture \ntiming SEI messages for checking the bitstream conformance according to Annex C, the bitstream that would be \nobtained by invoking the bitstream extraction process as specified in clause I.8.5 with depthPresentTargetFlag \nequal  to  0,  tIdTarget  equal  to  texture_subbitstream_temporal_id  and  viewIdTargetList  equal  to \ntexture_subbitstream_view_id[ i ]  for  all  i  in  the  range  of  0  to \nnum_texture_subbitstream_view_components_minus1, inclusive, shall be conforming to this Recommendation | \nInternational Standard. \n    Rec. ITU-T H.264 (06/2019)  745 \n \nIn  the  semantics  of  clauses D.2.1  and  D.2.3,  the  syntax  elements  num_units_in_tick,  time_scale, \nfixed_frame_rate_flag,  nal_hrd_parameters_present_flag,  vcl_hrd_parameters_present_flag, \nlow_delay_hrd_flag,  and  pic_struct_present_flag  and  the  derived  variables  NalHrdBpPresentFlag, \nVclHrdBpPresentFlag,  and  CpbDpbDelaysPresentFlag  are  substituted  with  the  syntax  elements \nvui_mvc_num_units_in_tick[ i ],  vui_mvc_time_scale[ i ],  vui_mvc_fixed_frame_rate_flag[ i ], \nvui_mvc_nal_hrd_parameters_present_flag[ i ],  vui_mvc_vcl_hrd_parameters_present_flag[ i ], \nvui_mvc_low_delay_hrd_flag[ i ],  and  vui_mvc_pic_struct_present_flag[ i ]  and  the  derived  variables \nVuiMvcNalHrdBpPresentFlag[ i ],  VuiMvcVclHrdBpPresentFlag[ i ],  and \nVuiMvcCpbDpbDelaysPresentFlag[ i ] for the MVCD texture sub-bitstream VUI parameters extension. \nThe values of seq_parameter_set_id's in all buffering period SEI messages included in MVCD texture sub-\nbitstream HRD nesting SEI messages and associated with operation points for which the greatest VOIdx values \nin the associated bitstream subsets are identical shall be identical. \n–  Otherwise (all remaining payloadType values), the corresponding SEI message semantics are not extended. \nWhen an SEI message having a particular value of payloadType equal to 137 or 144, contained in an MVCD scalable \nnesting SEI message, and applying to a particular combination of a list of view_id and a temporal_id is present in an access \nunit, the SEI message with the particular value of payloadType applying to the particular combination of a list of view_id \nand a temporal_id shall be present an MVCD scalable nesting SEI message in the IDR access unit that is the first access \nunit of the coded video sequence. \nAll SEI messages having a particular value of payloadType equal to 137 or 144, contained in MVCD scalable nesting SEI \nmessages, and applying to a particular combination of a list of view_id and a temporal_id present in a coded video sequence \nshall have the same content. \nFor the semantics of SEI messages with payloadType in the range of 0 to 23, inclusive, or equal to 45, 47, 137, 142, 144, \n147, 148, 149, 150, 151, 154, 155, 156, 200, or 201, which are specified in clause D.2, MVCD sequence parameter set is \nsubstituted for sequence parameter set; the parameters of MVCD sequence parameter set RBSP and picture parameter set \nRBSP that are in effect are specified in clauses I.7.4.2.1 and I.7.4.2.2, respectively. \nCoded video sequences conforming to one or more of the profiles specified in Annex I shall not include SEI NAL units \nthat contain SEI messages with payloadType in the range of 24 to 35, inclusive. \nWhen an SEI NAL unit contains an SEI message with payloadType in the range of 36 to 44, inclusive, or equal to 46, or \nin the range of 48 to 53, inclusive, it shall not contain any SEI messages with payloadType less than 36 or equal to 45, 47, \n137, 142, 144, 147, 148, 149, 150, 151, 154, 155, 156, 200, or 201, and the first SEI message in the SEI NAL unit shall \nhave payloadType in the range of 36 to 44, inclusive, or equal to 46, or in the range of  48 to 53, inclusive. \nWhen an MVC scalable nesting SEI message (payloadType equal to 37), a view scalability information SEI message \n(payloadType equal to 38), an operation point not present SEI message (payloadType equal to 43), an MVCD scalable \nnesting SEI message (payloadType equal to 48), or an MVCD view scalability information SEI messages (payloadType \nequal to 49) is present in an SEI NAL unit, it shall be the only SEI message in the SEI NAL unit. \nI.13.2.1 MVCD view scalability information SEI message semantics \nThe syntax elements in the MVCD view scalability information SEI message that have the same names as those in the \nview scalability information SEI message specified in Annex H, except num_directly_dependent_depth_views[ i ] and \ndirectly_dependent_depth_view_id[ i ][ j ], have the same semantics as the corresponding syntax elements in the view \nscalability information SEI message, but apply to operation points that may potentially contain depth view components as \nwell as texture view components. \nnum_directly_dependent_views[ i ] and directly_dependent_view_id[ i ][ j ] apply only to the texture view components \nof an operation point if the operation point contains both texture and depth, and otherwise have the same semantics as the \ncorresponding syntax elements in the view scalability information SEI message. \nI.13.2.1.1  MVCD operation point view information semantics \nview_info_depth_view_present_flag equal to 0 specifies that the depth view is not included in the operation point for the \nview for which the mvcd_op_view_info( ) syntax structure is present. view_info_depth_view_present_flag equal to 1 \nspecifies that the depth view is included in the operation point for the view for which the mvcd_op_view_info( ) syntax \nstructure is present. \nmvcd_depth_view_flag equal to 0 indicates that some VCL NAL units for the depth view for the view for which the \nmvcd_op_view_info( )  syntax  structure  is  present  may  include  NAL  units  with  nal_unit_type  equal  to  21  and \navc_3d_extension_flag equal to 1. mvcd_depth_view_flag equal to 1 indicates that the VCL NAL units for the depth view \nfor the view for which the mvcd_op_view_info( ) syntax structure is present does not include NAL units with both \nnal_unit_type equal to 21 and avc_3d_extension_flag equal to 1. \n746  Rec. ITU-T H.264 (06/2019) \n \nview_info_texture_view_present_flag equal to 0 specifies that the texture view is not included in the operation point for \nthe view for which the mvcd_op_view_info( ) syntax structure is present. view_info_depth_view_present_flag equal to 1 \nspecifies that the texture view is included in the operation point for the view for which the mvcd_op_view_info( ) syntax \nstructure is present. When view_info_depth_view_present_flag is equal to 0, view_info_texture_view_present_flag shall \nbe equal to 1. \nmvcd_texture_view_flag equal to 0 indicates that some VCL NAL units for the texture view for the view for which the \nmvcd_op_view_info( )  syntax  structure  is  present  may  include  NAL  units  with  nal_unit_type  equal  to  21  and \navc_3d_extension_flag equal to 1. mvcd_texture_view_flag equal to 0 indicates that the VCL NAL units for the texture \nview for the view for which the mvcd_op_view_info( ) syntax structure is present does not include NAL units with both \nnal_unit_type equal to 21 and avc_3d_extension_flag equal to 1. \nI.13.2.2 MVCD scalable nesting SEI message semantics \nThe syntax elements in the MVCD scalable nesting SEI message have the same semantics as the ones with the same names \nand present in the MVC scalable nesting SEI message in Annex H. \nsei_view_applicability_flag[ i ]  equal  to  1  indicates  that  the  nested  SEI  message  applies  to  both  the  texture  view \ncomponent  and  the  depth  view  component  of  the  view  with  view_id  equal  to  sei_view_id[ i ]. \nsei_view_applicability_flag[ i ] equal to 0 indicates that the nested SEI message applies only to the depth view component \nof the view with view_id equal to sei_view_id[ i ]. \nsei_op_texture_only_flag equal to 0 specifies that the semantics of sei_op_view_id[ i ] and sei_op_temporal_id apply to \nboth texture and depth views, if present. sei_op_texture_only_flag equal to 1 specifies that the nested SEI message as well \nas the semantics of sei_op_view_id[ i ] and sei_op_temporal_id apply to the sub-bitstream obtained by the sub-bitstream \nextraction process of clause I.8.5.3 with depthPresentFlagTarget equal to 0, tIdTarget equal to sei_op_temporal_id, and \nviewIdTargetList equal to sei_op_view_id[ i ] for all values of i in the range of 0 to num_view_components_op_minus1, \ninclusive, as inputs. \nNOTE 1 – MVC scalable nesting SEI message should be used for nesting SEI messages, when depth views may or may not be \npresent in the bitstream, the nested SEI messages apply only to indicated texture view components and the semantics of the nested \nSEI messages apply when VCL and non-VCL NAL units are classified according to Annex H NAL unit type class of Table 7-1. \nNOTE 2 – MVCD scalable nesting SEI message with sei_op_texture_only_flag equal to 1 should be used when the nested SEI \nmessages concern a sub-bitstream from which depth views have been excluded. For example, MVCD scalable nesting SEI message \nwith sei_op_texture_only_flag equal to 1 may include buffering period and picture timing SEI messages which apply only to a sub-\nbitstream containing texture views from which depth views have been removed using the sub-bitstream extraction process of \nclause I.8.5.3 with depthPresentFlagTarget equal to 0. \nsei_op_depth_flag[ i ] equal to 0 specifies that the depth view with view_id equal to sei_op_view_id[ i ] is not included \nin the operation point to which the nested SEI message applies. sei_op_depth_flag[ i ] equal to 1 specifies that the depth \nview with view_id equal to sei_op_view_id[ i ] is included in the operation point to which the nested SEI message applies. \nIf sei_op_depth_flag[ i ] is not present, it is inferred to be equal to 1. \nsei_op_texture_flag[ i ] equal to 0 specifies that the texture view with view_id equal to sei_op_view_id[ i ] is not included \nin the operation point to which the nested SEI message applies. sei_op_texture_flag[ i ] equal to 1 specifies that the texture \nview with view_id equal to sei_op_view_id[ i ] is included in the operation point to which the nested SEI message applies. \nIf  sei_op_texture_flag[ i ]  is  not  present,  it  is  inferred  to  be  equal  to 1. When  sei_op_depth_flag[ i ]  is  equal  to  0, \nsei_op_texture_flag[ i ] shall be equal to 1. \nI.13.2.3 Depth representation information SEI message semantics \nThe syntax elements in the depth representation information SEI message specifies various parameters for depth views for \nthe purpose of processing decoded texture and depth view components prior to rendering on a 3D display, such as view \nsynthesis. Specifically, depth or disparity ranges for depth views are specified. When present, the depth representation \ninformation SEI message may be associated with any access unit. It is recommended, when present, the SEI message is \nassociated with an IDR access unit for the purpose of random access. The information indicated in the SEI message applies \nto all the access units from the access unit the SEI message is associated with to the next access unit, in decoding order, \ncontaining an SEI message of the same type, exclusive, or to the end of the coded video sequence, whichever is earlier in \ndecoding order. \nNOTE 1 – Camera parameters for depth views may be indicated by including a multiview acquisition information SEI message in \nan MVCD scalable nesting SEI message with operation_point_flag equal to 0. \nall_views_equal_flag equal to 0 specifies that depth acquisition information may not be identical to respective values for \neach view in target views. all_views_equal_flag equal to 1 specifies that the depth acquisition information are identical to \nrespective values for all target views. \nnum_views_minus1 plus 1 specifies the number of views to which subsequent syntax element apply. When present, \nnum_views_minus1 shall be less than or equal to NumDepthViews − 1. The value of num_views_minus1 shall be in the \nrange of 0 to 1023, inclusive. \n    Rec. ITU-T H.264 (06/2019)  747 \n \nz_near_flag equal to 0 specifies that the syntax elements specifying the nearest depth value are not present in the syntax \nstructure. z_near_flag equal to 1 specifies that the syntax elements specifying the nearest depth value are present in the \nsyntax structure. \nz_far_flag equal to 0 specifies that the syntax elements specifying the farthest depth value are not present in the syntax \nstructure. z_far_flag equal to 1 specifies that the syntax elements specifying the farthest depth value are present in the \nsyntax structure. \nz_axis_equal_flag equal to 0 specifies that the syntax element z_axis_reference_view[ i ] is present. z_axis_equal_flag \nequal to 1 specifies that the ZNear and ZFar values, when present, and the decoded samples of depth views, when \ndepth_representation_type is equal to 0 or 2, have the same Z-axis, which is the Z-axis of the depth view indicated by the \nsyntax element common_z_axis_reference view. \ncommon_z_axis_reference_view specifies the view_id value of the depth view of the Z-axis of the ZNear and ZFar values, \nwhen present, and the decoded samples of depth views, when depth_representation_type is equal to 0 or 2. The value of \ncommon_z_axis_reference_view shall be in the range of 0 to 1023, inclusive. \nd_min_flag equal to 0 specifies that the syntax elements specifying the minimum disparity value are not present in the \nsyntax structure. d_min_flag equal to 1 specifies that the syntax elements specifying the minimum disparity value are \npresent in the syntax structure. \nd_max_flag equal to 0 specifies that the syntax elements specifying the maximum disparity value are not present in the \nsyntax structure. d_max_flag equal to 1 specifies that the syntax elements specifying the maximum disparity value are \npresent in the syntax structure. \ndepth_representation_type specifies the representation definition of decoded luma samples of depth views as specified \nin Table I-1. In Table I-1, disparity specifies the horizontal displacement between two texture views and Z value specifies \nthe distance from a camera. \nTable I-1 – Definition of depth_representation_type \n \ndepth_representation_type  Interpretation \nEach decoded luma sample value of depth views represents an inverse of Z \n0  value that is uniformly quantized into the range of 0 to 255, inclusive. \nEach decoded luma sample value of depth views represents disparity that is \n1  uniformly quantized into the range of 0 to 255, inclusive. \nEach decoded luma sample value of depth views represents a Z value \n2  uniformly quantized into the range of 0 to 255, inclusive. \nEach decoded luma sample value of depth views represents a nonlinearly \nmapped disparity, normalized in range from 0 to 255, as specified by \n3 \ndepth_nonlinear_representation_num_minus1 and \ndepth_nonlinear_representation_model[ i ]. \nOther values  Reserved for future use \ndepth_info_view_id[ i ]  specifies  the  view_id  value  for  which  subsequent  syntax  elements  apply  to.  The  value  of \ndepth_info_view_id[ i ] shall be in the range of 0 to 1023, inclusive. \nz_axis_reference_view[ i ] specifies the view_id value of the depth view of the Z-axis of the ZNear[ i ] and ZFar[ i ] \nvalues, when present, and the decoded samples of the depth view with view_id equal to depth_info_view_id[ i ], when \ndepth_representation_type is equal to 0 or 2. The value of z_axis_reference_view[ i ] shall be in the range of 0 to 1023, \ninclusive. \ndisparity_reference_view[ i ] specifies the view_id value of the depth view used to derive the DMin[ i ] and Dmax[ i ] \nvalues, when present, and the decoded samples of the depth view with view_id equal to depth_info_view_id[ i ], when \ndepth_representation_type is equal to 1 or 3. The value of disparity_reference_view[ i ] shall be in the range of 0 to 1023, \ninclusive. \nThe variables in the x column of Table I-2 are derived as follows from the respective variables in the s, e, n, and v columns \nof Table I-2 as follows. \n748  Rec. ITU-T H.264 (06/2019) \n \n–  If 0 < e < 127, x = ( −1 )s * 2( e − 31 ) * ( 1 + n ÷ 2v ). \n–  Otherwise (e is equal to 0), x = ( −1 )s * 2−( 30 + v ) * n. \nNOTE 2 – The above specification is similar to that found in IEC 60559. \nTable I-2 – Association between depth parameter variables and syntax elements \n \nx  s  e  n  v \nZNear[ vId ]  ZNearSign[ vId ]  ZNearExp[ vId ]  ZNearMantissa[ vId ]  ZNearManLen[ vId ] \nZFar[ vId ]  ZFarSign[ vId ]  ZFarExp[ vId ]  ZFarMantissa[ vId ]  ZFarManLen[ vId ] \nDMax[ vId ]  DMaxSign[ vId ]  DMaxExp[ vId ]  DMaxMantissa[ vId ]  DMaxManLen[ vId ] \nDMin[ vId ]  DMinSign[ vId ]  DMinExp[ vId ]  DMinMantissa[ vId ]  DMinManLen[ vId ] \n \nIf all_views_equal_flag is equal to 0, the variables x in Table I-2 are specified as follows: \n–  ZNear[ vId ]: The closest depth value for view_id equal to vId. \n–  ZFar[ vId ]: The farthest depth value for view_id equal to vId. \n–  DMax[ vId ]: The maximum disparity value for view_id equal to vId. \n–  DMin[ vId ]: The minimum disparity value for view_id equal to vId. \nOtherwise, the variables x in Table I-2 are specified as follows: \n–  ZNear[ 0 ]: The closest depth value for all depth views. \n–  ZFar[ 0 ]: The farthest depth value for all depth views. \n–  DMax[ 0 ]: The maximum disparity value for all depth views. \n–  DMin[ 0 ]: The minimum disparity value for all depth views. \nThe DMin and DMax values, when present, are specified in units of a luma sample width of the texture views. \nThe ZNear and ZFar values, when present, are specified in units of a unit vector of the 3-dimensional coordinate system \nused to specify the extrinsic camera parameters as specified by the Multiview Acquisition Information SEI message \nassociated with the respective depth views, if present. Otherwise, ZNear and ZFar values, when present, are specified in \nunits of a unit vector of the 3-dimensional coordinate system used to specify the extrinsic camera parameters specified by \nthe Multiview Acquisition Information SEI message associated with the respective texture views, if present. Otherwise, \nthe units for the ZNear and ZFar values, if present, are identical but unspecified. \ndepth_nonlinear_representation_num_minus1 + 2 specifies the number of piecewise linear segments for mapping of \ndepth values to a scale that is uniformly quantized in terms of disparity. \ndepth_nonlinear_representation_model[ i ]  specifies  the  piecewise  linear  segments  for  mapping  of  decoded  luma \nsample values of depth views to a scale that is uniformly quantized in terms of disparity. \nNOTE 3 – When depth_representation_type is equal to 3, depth view component contains nonlinearly transformed depth samples. \nVariable DepthLUT[ i ], as specified below, is used to transform coded depth sample values from nonlinear representation to the \nlinear representation – disparity normalized in range from 0 to 255. The shape of this transform is defined by means of line-segment-\napproximation in two-dimensional linear-disparity-to-nonlinear-disparity space. The first (0, 0) and the last (255, 255) nodes of the \ncurve are predefined. Positions of additional nodes are transmitted in form of deviations (depth_nonlinear_representation_model[ i ]) \nfrom the straight-line curve. These deviations are uniformly distributed along the whole range of 0 to 255, inclusive, with spacing \ndepending on the value of nonlinear_depth_representation_num_minus1. \nVariable DepthLUT[ i ] for i in the range of 0 to 255, inclusive, is specified as follows. \ndepth_nonlinear_representation_model[ 0 ] = 0 \ndepth_nonlinear_representation_model[depth_nonlinear_representation_num_minus1 + 2 ] = 0 \nfor( k=0; k<= depth_nonlinear_representation_num_minus1 + 1; ++k ) { \n  pos1 = ( 255 * k ) / (depth_nonlinear_representation_num_minus1 + 2 ) \n  dev1 = depth_nonlinear_representation_model[ k ] \n  pos2 = ( 255 * ( k+1 ) ) / (depth_nonlinear_representation_num_minus1 + 2 ) ) \n  dev2 = depth_nonlinear_representation_model[ k+1 ] \n \n  x1 = pos1 − dev1 \n  y1 = pos1 + dev1 \n    Rec. ITU-T H.264 (06/2019)  749 \n \n  x2 = pos2 − dev2 \n  y2 = pos2 + dev2 \n \n  for ( x = max( x1, 0 ); x <= min( x2, 255 ); ++x ) \n     DepthLUT[ x ] = Clip3( 0, 255, Round( ( ( x - x1 ) * ( y2 - y1 ) ) ÷ ( x2 - x1 ) + y1 ) ) \n} \nWhen depth_representation_type is equal to 3, DepthLUT[ dS ] for all decoded luma sample values dS of depth views in \nthe range of 0 to 255, inclusive, represents disparity that is uniformly quantized into the range of 0 to 255, inclusive. \nI.13.2.3.1  Depth representation SEI element semantics \nThe syntax structure specifies the value of an element in depth representation information. \nThe syntax structure sets the values of the outSign, outExp, outMantissa, and outManLen variables that represent a floating-\npoint value. When the syntax structure is included in another syntax structure, the variable names outSign, outExp, \noutMantissa, and outManLen are to be interpreted as being replaced by the variable names used when the syntax structure \nis included. \nda_sign_flag equal to 0 indicates that the sign of the floating-point value is positive. da_sign_flag equal to 1 indicates that \nthe sign is negative. The variable outSign is set equal to da_sign_flag. \nda_exponent specifies the exponent of the floating-point value. The value of da_exponent shall be in the range of 0 \nto 27 − 2, inclusive. The value 27 − 1 is reserved for future use by ITU-T | ISO/IEC. Decoders shall treat the value 27 − 1 \nas indicating an unspecified value. The variable outExp is set equal to da_exponent. \nda_mantissa_len_minus1  +  1  specifies  the  number  of  bits  in  the  da_mantissa  syntax  element.  The  value  of \nda_mantissa_len_minus1  shall  be  in  the  range  of  0  to 31,  inclusive.  The  variable  outManLen  is  set  equal  to \nda_mantissa_len_minus + 1. \nda_mantissa specifies the mantissa of the floating-point value. The variable outMantissa is set equal to da_mantissa. \nI.13.2.4 3D reference displays information SEI message semantics \nWhen present, this SEI message shall be associated with an IDR access unit. A reference displays information message \ncontains information about the reference display width(s) and reference viewing distance(s) as well as information about \nthe corresponding baseline distance(s) and additional horizontal image shift(s), which form a stereo-pair for the reference \ndisplay width and the reference viewing distance. This information enables a view renderer to produce a proper stereo-pair \nfor the target screen width and the viewing distance. The reference display width and viewing distance values are signalled \nin units of centimetres. The reference baseline values shall be signalled in the same units as the x component of the \ntranslation vector in the multiview acquisition information SEI message that is valid for the same access unit. When a \nreference displays information SEI message is present in an access unit, the multiview acquisition information SEI message \nshall also be present in the same access unit. The baseline and shift information signalled for the reference display is valid \nfor all access units they associated with and until the next IDR access unit or the next access unit containing multiview \nacquisition information SEI message or reference displays information SEI message. \nNOTE – The reference displays information SEI message specifies display parameters for which the 3D sequence was optimized \nand the corresponding reference parameters. Each reference display (i.e. a reference display width and possibly a corresponding \nviewing distance) is associated with one reference baseline distance. \nThe following formulas can be used for calculating the baseline distance and horizontal shift for the receiver's display when the \nratio between the receiver's viewing distance and the reference viewing distance is the same as the ratio between the receiver screen \nwidth and the reference screen width: \n      baseline = ref_baseline * ( ref_display_width ÷ display_width ) \n      shift = ref_shift * ( ref_display_width ÷ display_width ) \nIn the provided formulas, the width of the visible part of the display used for showing the video sequence should be understood \nunder \"display width\". The same formulas can also be used for choosing the baseline distance and horizontal shift in cases when \nthe viewing distance is not scaled proportionally to the screen width compared to the reference display parameters. In this case, the \neffect of applying these formulas would be to keep the perceived depth in the same proportion to the viewing distance as in the \nreference setup. \nWhen camera parameters are updated by a multiview acquisition information SEI message in a following access unit and the \nbaseline between the views used in the view synthesis process in the following access unit changes relative to that in the in the \naccess unit which the reference displays information SEI belongs to, the baseline and the horizontal shift for the receiver's display \nin the following access unit should be modified accordingly. Let the scaling factor s be equal to the ratio of the baseline between \ntwo views in the following access unit and the baseline between the same two views in the access unit, which the reference displays \ninformation SEI message belongs to, where the two views are used in the view synthesis process. Then the baseline distance for \nthe receiver's display in the following access unit should be modified with the scaling factor s relative to the baseline distance for \n750  Rec. ITU-T H.264 (06/2019) \n \nthe receiver's display in the access unit which the reference displays information SEI belongs to. The horizontal shift for the \nreceiver's display should also be modified by scaling it with the same factor as that used to scale the baseline distance. \nprec_ref_baseline specifies the exponent of the maximum allowable truncation error for ref_baseline[ i ] as given by \n2−prec_ref_baseline. The value of prec_ref_baseline shall be in the range of 0 to 31, inclusive. \nprec_ref_display_width specifies the exponent of the maximum allowable truncation error for ref_display_width[ i ] as \ngiven by 2−prec_ref_display_width. The value of prec_ref_display_width shall be in the range of 0 to 31, inclusive. \nref_viewing_distance_flag equal to 1 indicates the presence of reference viewing distance. ref_viewing_distance_flag \nequal to 0 indicates that the reference viewing distance is not present in the bitstream. \nprec_ref_viewing_dist specifies the exponent of the maximum allowable truncation error for ref_viewing_dist[ i ] as \ngiven by 2−prec_ref_viewing_dist. The value of prec_ref_viewing_dist shall be in the range of 0 to 31, inclusive. \nnum_ref_displays_minus1 plus 1 specifies the number of reference displays that are signalled in the bitstream. The value \nof num_ref_displays_minus1 shall be in the range of 0 to 31, inclusive. \nexponent_ref_baseline[ i ] specifies the exponent part of the reference baseline for the i-th reference display. The value \nof exponent_ref_baseline[ i ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved for future use by \nITU-T | ISO/IEC. Decoders shall treat the value 63 as indicating an unspecified reference baseline. \nmantissa_ref_baseline[ i ] specifies the mantissa part of the reference baseline for the i-th reference display. The length \nof the mantissa_ref_baseline[ i ] syntax element is variable and determined as follows. \n–  If exponent_ref_baseline[ i ] = = 0, the length is Max( 0, prec_ref_baseline − 30 ). \n–  Otherwise (0 < exponent_ref_baseline[ i ] < 63), the length is Max( 0, exponent_ref_baseline[ i ] + prec_ref_baseline \n− 31 ). \nexponent_ref_display_width[ i ] specifies the exponent part of the reference display width of the i-th reference display. \nThe value of exponent_ref_display_width[ i ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved for future \nuse by ITU-T | ISO/IEC. Decoders shall treat the value 63 as indicating an unspecified reference display width. \nmantissa_ref_display_width[ i ] specifies the mantissa part of the reference display width of the i-th reference display. \nThe length of the mantissa_ref_display_width[ i ] syntax element is variable and determined as follows. \n–  If exponent_ref_display_width[ i ] = = 0, the length is Max( 0, prec_ref_display_width − 30 ). \n–  Otherwise  (0  <  exponent_ref_display_width[ i ]  <  63),  the  length  is  Max( 0,  exponent_ref_display_width[ i ]  + \nprec_ref_display_width − 31 ). \nexponent_ref_viewing_distance[ i ] specifies the exponent part of the reference viewing distance of the i-th reference \ndisplay. The value of exponent_ref_viewing_distance[ i ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved \nfor future use by ITU-T | ISO/IEC. Decoders shall treat the value 63 as indicating an unspecified reference display width. \nmantissa_ref_viewing_distance[ i ] specifies the mantissa part of the reference viewing distance of the i-th reference \ndisplay. The length of the mantissa_ref_viewing_distance[ i ] syntax element is variable and determined as follows. \n–  If exponent_ref_viewing_distance[ i ]  = = 0, the length is Max( 0, prec_ref_viewing_distance − 30 ). \n–  Otherwise ( 0 < exponent_ref_viewing_distance[ i ] < 63 ), the length is Max( 0, exponent_ref_viewing_distance[ i ]  \n+ prec_ref_viewing_distance − 31 ). \nThe variables in the x column of Table I-3 are derived as follows from the respective variables or values in the s, e, and n \ncolumns of Table I-3 as follows. \n–  If 0 < e < 63, x = ( −1 )s * 2( e − 31 ) * ( 1 + n ÷ 2v ). \n–  Otherwise (e is equal to 0), x = ( −1 )s * 2−( 30 + v ) * n. \nNOTE – The above specification is similar to that found in IEC 60559. \n    Rec. ITU-T H.264 (06/2019)  751 \n \nTable I-3 – Association between camera parameter variables and syntax elements \n \nx  s  e  n \nrefBaseline[ i ]  0  exponent_ref_baseline[ i ]  mantissa_ref_baseline[ i ] \nrefDisplayWidth[ i ]  0  exponent_ref_display_width[ i ]  mantissa_ref_display_width[ i ] \nrefViewingDistance[ i ]  0  exponent_ref_viewing_distance[ i ]  mantissa_ref_viewing_distance[ i ] \n \nadditional_shift_present_flag[ i ] equal to 1 indicates that the information about additional horizontal shift of the left and \nright views for the i-th reference display is present in the bitstream. additional_shift_present_flag[ i ] equal to 0 indicates \nthat the information about additional horizontal shift of the left and right views for the i-th reference display is not present \nin the bitstream. \nnum_sample_shift_plus512[ i ] indicates the recommended additional horizontal shift for a stereo-pair corresponding to \nthe i-th reference baseline and the i-th reference display. If ( num_sample_shift_plus512[ i ] − 512 ) is less than 0, it is \nrecommended that the left view of the stereo-pair corresponding to the i-th reference baseline and the i-th reference display \nis shifted in the left direction by ( 512 − num_sample_shift_plus512[ i ] ) samples with respect to the right view of the \nstereo-pair;  if  num_sample_shift_plus512[ i ]  is  equal  to  512,  it  is  recommended  that  shifting  is  not  applied;  if \n( num_sample_shift_plus512[ i ] −  512 )  is  greater  than  0,  it  is  recommended  that  the  left  view  in  the  stereo-pair \ncorresponding to the i-th reference baseline and the i-th reference display should be shifted in the right direction by ( 512 − \nnum_sample_shift_plus512[ i ] )  samples  with  respect  to  the  right  view  of  the  stereo-pair.  The  value  of \nnum_sample_shift_plus512[ i ] shall be in the range of 0 to 1023, inclusive. \nthree_dimensional_reference_displays_extension_flag equal to 0 indicates that no additional data follows within the \nreference displays SEI message. The value of three_dimensional_reference_displays_extension_flag shall be equal to 0. \nThe value of 1 for three_dimensional_reference_displays_extension_flag is reserved for future use by ITU-T | ISO/IEC. \nDecoders shall ignore all data that follows the value of 1 for three_dimensional_reference_displays_extension_flag in a \nreference displays SEI message. \nNOTE – Shifting the left view in the left (or right) direction by X samples with respect to the right view can be performed by the \nfollowing two-step processing: \n1)  shift the left view by X / 2 samples in the left (or right) direction, and shift the right view by X / 2 samples in the right (or \nleft) direction \n2)  fill the left and right image margins of X / 2 samples in width in both the left and right views in background colour. \nThe following pseudo code explains the recommended shifting processing in the case of shifting the left view in the left direction \nby X samples with respect to the right view. \nfor ( i = X / 2; i < width − X / 2; i++ ) { \n  for  ( j = 0;  j < height; j++ ) { \n    left_view[ j ][ i ] = left_view[ j ][ i + X / 2 ]  \n    right_view[ j ][ width − 1 − i ] = right_view[ j ][ width − 1 − i − X / 2 ]  \n  } \n} \nfor ( i = 0; i < X / 2; i++ ) { \n  for ( j = 0; j < height; j++ ) { \n    left_view[ j ][ width − 1 − i ] = left_view[ j ][ i ] = BackgroundColour \n    right_view[ j ][ width − 1 − i ] = right_view[ j ][ i ] = BackgroundColour \n  } \n} \nThe following pseudo code explains the recommended shifting processing in the case of shifting the left view in the right direction \nby X samples with respect to the right view. \nfor ( i = X / 2; i < width − X / 2; i++ ) { \n  for ( j = 0; j < height; j++ ) { \n    left_view[ j ][ width − 1 − i ] = left_view[ j ][ width − 1 − i − X / 2 ]  \n    right_view[ j ][ i ] = right_view[ j ][ i + X / 2 ] \n  } \n} \nfor ( i=0; i < X / 2; i++ ) { \n  for ( j = 0; j < height; j++ ) { \n    left_view[ j ][ width − 1− i ] = left_view[ j ][ i ] = BackgroundColour \n    right_view[ j ][ width − 1− i ] = right_view[ j ][ i ] = BackgroundColour \n752  Rec. ITU-T H.264 (06/2019) \n \n  } \n} \nBackgroundColour may take different values in different systems, for example black or grey. \nI.13.2.5 Depth timing SEI message semantics \nThe depth timing SEI message indicates the acquisition time of the depth view components of one or more access units \nrelative to the DPB output time of the same access units. The depth timing SEI message may be present in any access unit \nand it pertains until the end of the coded video sequence or until the next depth timing SEI message, whichever is earlier \nin decoding order. The access units that the message pertains to are referred to as the target access unit set. \nper_view_depth_timing_flag equal to 0 specifies that all the depth view components within the target access unit set have \nthe same acquisition time offset relative to the DPB output time of the respective access unit in the target access unit set. \nThe single occurrence of the depth_timing_offset structure specifies this acquisition time offset. \nper_view_depth_timing_flag equal to 1 specifies that a depth_timing_offset syntax structure is present for each depth view \nin ascending order of view order index values for the depth views and specifies the acquisition time offset for that view. \nI.13.2.5.1  Depth timing offset semantics \noffset_len_minus1 specifies the length of the depth_disp_delay_offset_fp syntax element. \ndepth_disp_delay_offset_fp and depth_disp_delay_offset_dp specify that the acquisition offset of the respective depth \nview component or components relative to the DPB output time of the access unit containing the depth view component \nor components is equal to depth_disp_delay_offset_fp ÷ 2depth_disp_delay_offset_dp in units of clock ticks as specified in Annex C. \nThe length of depth_disp_delay_offset_fp syntax element is equal to offset_len_minus1 + 1. \nIf depth_disp_delay_offset_fp is not present, it is inferred to be equal to 0. If depth_disp_delay_offset_dp is not present, it \nis inferred to be equal to 0. \nI.13.2.6 Alternative depth information SEI message semantics \nThe alternative depth information SEI message indicates that the view components of one output view contain samples of \nmultiple distinct spatially packed constituent pictures. The related output view is not suitable to be displayed directly. This \nSEI message can be used by the application after the decoder output to rearrange the samples to produce additional views \nthat are appropriate for display or use by a server for other purposes (which are outside the scope of this Recommendation | \nInternational Standard). \nWhen the alternative depth information SEI message is present, the texture and depth views referred to by this SEI message \nshall  conform  to  the  specifications  in  Annexes  I  and  J,  ChromaArrayType  shall  be  equal  to  1  (4:2:0), \nbit_depth_luma_minus8 shall be equal to 0, bit_depth_chroma_minus8 shall be equal to 0, and the depth representation \ninformation SEI message shall be present. The depth_representation_type is defined in the depth representation information \nSEI message. The depth representation is only carried in the luma component. \nThe alternative depth information SEI message, when present, shall be associated with an IDR access unit. The information \nsignalled in this SEI message applies to all the access units in the coded video sequence. Also, num_anchor_refs_l0[ i ], \nnum_anchor_refs_l1[ i ], num_non_anchor_refs_l0[ i ] and num_non_anchor_refs_l1[ i ] shall be equal to 0 in the active \nSPS RBSP syntax structure for the coded video sequence and avc_3d_extension_flag shall be equal to 0 in all VCL NAL \nunits of the coded video sequence. \nNOTE 1 – These constraints disable inter-view and inter-component prediction. \nIn such a coded video sequence, there shall be two output views. The base view is a complete view and the non-base view \ncontains a packing arrangement of 1 to 4 additional views with half the width and half the height of the base view. Such \nlower-resolution views are referred to as constituent pictures herein. \nNOTE 2 – The view_id of the non-base view is not used in any particular way for this SEI message. \nAll  constituent  pictures  have  a  width  and  a  height  equal  to  ( ( pic_width_in_mbs_minus1  +  1 )  *  8 )  and \n( ( pic_height_in_map_unit_minus1 + 1 ) * 8 ) in luma samples, respectively. frame_mbs_only_flag shall be equal to 1. \nThe variable i, with a value from 0 to num_constituent_views_gvd_minus1 + 1, inclusive, indicates the location of the \nconstituent pictures in the non-base texture view as specified in Table I-4. i equal to 0 indicates the base texture view. i \ngreater than 0 indicates the constituent texture view. \n    Rec. ITU-T H.264 (06/2019)  753 \n \nTable I-4 –  Locations of the top-left luma samples of constituent pictures packed in a non-base texture view \nrelative to the top-left luma sample of this picture \n \nConstituent picture index i  Location of the top-left luma sample in a non-base texture view \n1  ( 0, 0 ) \n2  ( 0, ( pic_height_in_map_unit_minus1 + 1 ) * 8 ) \n3  ( ( pic_width_in_mbs_minus1 + 1 ) * 8, 0 ) \n4  ( (pic_width_in_mbs_minus1 + 1 ) * 8, ( pic_height_in_map_unit_minus1 + 1 ) * 8 ) \n \nThe decoded depth views have the same structure as the decoded texture views, i.e., they consist of a base depth view (i \nequal to 0) and a non-base depth view. The non-base depth view contains up to four constituent depth pictures (i in the \nrange of 1 to 4) for the constituent views. The constituent depth pictures are packed in the non-base depth view in the same \narrangement as the constituent texture pictures as specified in Table I-4. \nThis arrangement of texture and depth constituent views is referred to as global view and depth (GVD) information. \ndepth_type shall be equal to 0. Other values are reserved for future use by ITU-T | ISO/IEC and shall not be present in \nbitstreams conforming to this Specification. Decoders shall ignore alternative depth information SEI messages in which \nsuch other values are present. \nnum_constituent_views_gvd_minus1 plus 1 identifies the number of constituent texture pictures packed into each texture \ncomponent of the non-base view. num_constituent_views_gvd_minus1 shall be in the range of 0 to 3, inclusive. \ndepth_present_gvd_flag equal to 1 indicates that constituent depth pictures are packed into the depth components of the \nnon-base view, with a packing arrangement as described above. depth_present_gvd_flag equal to 0 specifies that the depth \ncomponent of the non-base view is not present. \nEach constituent picture in the depth component of the non-base view is associated with a constituent picture in the texture \ncomponent of the non-base view in the same relative location. The number of depth views in the coded video sequence is \nequal to 1 + depth_present_gvd_flag. The depth component of the base view shall always be present, independent of the \nvalue of depth_present_gvd_flag. \nNOTE 3 – The following SEI message parameters can be used along with the decoded depth components to project samples from \nthe base view into the coordinates of constituent views such that reconstructed views can be generated by combining projected \nsamples and samples from the constituent views. \nThe function binToFp( s, e, n, v ) is specified as follows: \nbinToFp( s, e, n, v ) = ( −1 )s * ( e  = =  0 ? ( 2−( 30 + v ) * n ) : ( 2( e − 31 ) * ( 1 + n ÷ 2v ) ) )   (I-1) \nNOTE 4 – The  above  specification  is  similar  to  what  is  found  in  IEC  60559:1989,  Binary  floating-point  arithmetic  for \nmicroprocessor systems. \nz_gvd_flag equal to 1 indicates the presence of the syntax elements sign_gvd_z_near_flag[ i ], exp_gvd_z_near[ i ],  \nman_len_gvd_z_near_minus1[ i ],  man_gvd_z_near[ i ],  sign_gvd_z_far_flag[ i ],  exp_gvd_z_far[ i ], \nman_len_gvd_z_far_minus1[ i ], and man_gvd_z_far[ i ], for i in the range of 0 to num_constituent_views_gvd_minus1 + \n1, inclusive. z_gvd_flag equal to 0 indicates that these syntax elements are not present. \nintrinsic_param_gvd_flag  equal  to  1  indicates  the  presence  of  intrinsic  camera  parameter  syntax  elements. \nintrinsic_param_gvd_flag equal to 0 indicates that these syntax elements are not present. \nrotation_gvd_flag equal to 1 indicates the presence of rotation camera parameter syntax elements. rotation_gvd_flag equal \nto 0 indicates that these syntax elements are not present. When rotation_gvd_flag is 0, a default rotation camera parameter \nof a unit matrix value is inferred. \ntranslation_gvd_flag  equal to 1 indicates the presence of horizontal translation camera parameter syntax elements. \ntranslation_gvd_flag equal to 0 indicates that these syntax elements are not present. \nsign_gvd_z_near_flag[ i ] equal to 0 indicates that the sign of the nearest depth value of the i-th camera is positive. \nsign_gvd_z_near[ i ] equal to 1 indicates that the sign of the nearest depth value of the i-th camera is negative. \nexp_gvd_z_near[ i ]  specifies  the  exponent  part  of  the  nearest  depth  value  of  the  i-th  camera.  The  value  of \nexp_gvd_z_near[ i ] shall be in the range of 0 to 126, inclusive. The value 127 is reserved for future use by ITU-T | \nISO/IEC. When exp_gvd_z_near[ i ] is equal to 127, the value of zNear[ i ] is unspecified. \nman_len_gvd_z_near_minus1[ i ] + 1 specifies the length in bits of the mantissa of the nearest depth value of the i-th \ncamera. The value of man_len_gvd_z_near_minus1 [ i ] shall be in the range of 0 to 31, inclusive. \nman_gvd_z_near[ i ]  specifies  the  mantissa  part  of  the  nearest  depth  value  of  the  i-th  camera.  The  length  of \nman_gvd_z_near[ i ] syntax elements is man_len_gvd_z_near_minus1[ i ] + 1 bits. \n754  Rec. ITU-T H.264 (06/2019) \n \nWhen  exp_gvd_z_near[ i ]  is  not  equal  to  127,  zNear[ i ]  is  set  equal  to \nbinToFp( sign_gvd_z_near_flag[ i ], exp_gvd_z_near[ i ], man_gvd_z_near[ i ], man_len_gvd_z_near_minus1[ i ] + 1 ). \nsign_gvd_z_far_flag[ i ] equal to 0 indicates that the sign of the farthest depth value of the i-th camera is positive. \nsign_gvd_z_far_flag[ i ] equal to 1 indicates that the sign of the farthest depth value of the i-th camera is negative. \nexp_gvd_z_far[ i ]  specifies  the  exponent  part  of  the  farthest  depth  value  of  the  i-th  camera.  The  value  of \nexp_gvd_z_far[ i ] shall be in the range of 0 to 126, inclusive. The value 127 is reserved for future use by ITU-T | ISO/IEC. \nWhen exp_gvd_z_far[ i ] is equal to 127, the value of zFar[ i ] is unspecified. \nman_len_gvd_z_far_minus1[ i ] + 1 specifies the length in bits of the mantissa of the farthest depth value of the i-th \ncamera. The value of man_len_gvd_z_far_minus1[ i ] shall be in the range of 0 to 31, inclusive. \nman_gvd_z_far[ i ]  specifies  the  mantissa  part  of  the  farthest  depth  value  of  the  i-th  camera.  The  length  of \nman_gvd_z_far[ i ] syntax elements is man_len_gvd_z_far_minus1[ i ] + 1 bits. \nWhen  exp_gvd_z_far[ i ]  is  not  equal  to  127,  zFar[ i ]  is  set  equal  to \nbinToFp( sign_gvd_z_far_flag[ i ], exp_gvd_z_far[ i ], man_gvd_z_far[ i ], man_len_gvd_z_far_minus1[ i ] + 1 ). \nprec_gvd_focal_length specifies the exponent of the maximum allowable truncation error for focalLengthX[ i ] and \nfocalLengthY[ i ] as given by 2−prec_gvd_focal_length. The value of prec_gvd_focal_length shall be in the range of 0 to 31, \ninclusive. \nprec_gvd_principal_point specifies the exponent of the maximum allowable truncation error for principalPointX[ i ] and \nprincipalPointY[ i ] as given by 2−prec_gvd_principal_point. The value of prec_gvd_principal_point shall be in the range of 0 to 31, \ninclusive. \nprec_gvd_rotation_param specifies the exponent of the maximum allowable truncation error for r[ i ][ j ][ k ] as given \nby 2−pre_gvdc_rotation_param. The value of prec_gvd_rotation_param shall be in the range of 0 to 31, inclusive. \nprec_gvd_translation_param specifies the exponent of the maximum allowable truncation error for tX[ i ] as given by \n2−prec_gvd_translation_param. The value of prec_gvd_translation_param shall be in the range of 0 to 31, inclusive. \nsign_gvd_focal_length_x[ i ] equal to 0 indicates that the sign of the focal length of the i-th camera in the horizontal \ndirection is positive. sign_gvd_focal_length_x[ i ] equal to 1 indicates that the sign of the focal length of the i-th camera \nin the horizontal direction is negative. \nexp_gvd_focal_length_x[ i ] specifies the exponent part of the focal length of the i-th camera in the horizontal direction. \nThe value of exp_gvd_focal_length_x[ i ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved for future use \nby ITU-T | ISO/IEC. When exp_gvd_focal_length_x[ i ] is equal to 63, the value of focal length of the horizontal direction \nfor the i-th camera is unspecified. \nman_gvd_focal_length_x[ i ] specifies the mantissa part of the focal length of the i-th camera in the horizontal direction. \nThe length v of the man_gvd_focal_length_x[ i ] syntax element is determined as follows: \n–  If exp_gvd_focal_length_x[ i ] is equal to 0, the length v is set equal to Max( 0, prec_gvd_focal_length − 30 ). \n–  Otherwise  (exp_gvd_focal_length_x[ i ]  is  in  the  range  of  1  to  62,  inclusive),  the  length  v  is \nMax( 0, exp_gvd_focal_length_x[ i ] + prec_gvd_focal_length − 31 ). \nWhen  exp_gvd_focal_length_x[ i ]  is  not  equal  to  63,  the  variable  focalLengthX[ i ]  is  set  equal  to \nbinToFp( sign_gvd_focal_length_x[ i ], exp_gvd_focal_length_x[ i ], man_gvd_focal_length_x[ i ], v ). \nsign_gvd_focal_length_y[ i ] equal to 0 indicates that the sign of the focal length of the i-th camera in the vertical direction \nis positive. sign_gvd_focal_length_y[ i ] equal to 1 indicates that the sign of the focal length of the i-th camera in the \nvertical direction is negative. \nexp_gvd_focal_length_y[ i ] specifies the exponent part of the focal length of the i-th camera in the vertical direction. The \nvalue of exp_gvd_focal_length_y[ i ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved for future use by \nITU-T | ISO/IEC. When exp_gvd_focal_length_y[ i ] is equal to 63, the value of focal length of the vertical direction is \nunspecified. \nman_gvd_focal_length_y[ i ] specifies the mantissa part of the focal length of the i-th camera in the vertical direction. \nThe length v of the man_gvd_focal_length_y[ i ] syntax element is determined as follows: \n–  If exp_gvd_focal_length_y[ i ] is equal to 0, the length v is set equal to Max( 0, prec_gvd_focal_length − 30 ). \n–  Otherwise  (exp_gvd_focal_length_y[ i ]  is  in  the  range  of  1  to  62,  inclusive),  the  length  v  is  set  equal  to \nMax( 0, exp_gvd_focal_length_y[ i ] + prec_gvd_focal_length − 31 ). \nWhen  exp_gvd_focal_length_y[ i ]  is  not  equal  to  63,  the  variable  focalLengthY[ i ]  is  set  equal  to \n    Rec. ITU-T H.264 (06/2019)  755 \n \nbinToFp( sign_gvd_focal_length_y[ i ], exp_gvd_focal_length_y[ i ], man_gvd_focal_length_y[ i ], v ). \nsign_gvd_principal_point_x[ i ] equal to 0 indicates that the sign of the principal point of the i-th camera in the horizontal \ndirection is positive. sign_gvd_principal_point_x[ i ] equal to 1 indicates that the sign of the principal point of the i-th \ncamera in the horizontal direction is negative. \nexp_gvd_principal_point_x[ i ] specifies the exponent part of the principal point of the i-th camera in the horizontal \ndirection. The value of exp_gvd_principal_point_x[ i ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved \nfor future use by ITU-T | ISO/IEC. When exp_gvd_principal_point_x[ i ] is equal to 63, the value of principal point in the \nhorizontal direction for the i-th camera is unspecified. \nman_gvd_principal_point_x[ i ] specifies the mantissa part of the principal point of the i-th camera in the horizontal \ndirection The length v of the man_gvd_principal_point_x[ i ] syntax element in units of bits is determined as follows: \n–  If exp_gvd_principal_point_x[ i ] is equal to 0, the length v is set equal to Max( 0, prec_gvd_principal_point − 30 ). \n–  Otherwise  (exp_gvd_principal_point_x[ i ]  is  in  the  range  of  1  to  62,  inclusive),  the  length  v  is  set  equal  to \nMax( 0, exp_gvd_principal_point_x[ i ] + prec_gvd_principal_point − 31 ). \nWhen  exp_gvd_principal_point_x[ i ]  is  not  equal  to  63,  the  variable  principalPointX[ i ]  is  set  equal  to \nbinToFp( sign_gvd_principal_point_x[ i ], exp_gvd_principal_point_x[ i ], man_gvd_principal_point_x[ i ], v ). \nsign_gvd_principal_point_y[ i ] equal to 0 indicates that the sign of the principal point of the i-th camera in the vertical \ndirection is positive. sign_gvd_principal_point_y[ i ] equal to 1 indicates that the sign of the principal point of the i-th \ncamera in the vertical direction is negative. \nexp_gvd_principal_point_y[ i ] specifies the exponent part of the principal point  of the i-th camera in the  vertical \ndirection. The value of exp_gvd_principal_point_y[ i ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved \nfor future use by ITU-T | ISO/IEC. When exp_gvd_principal_point_y[ i ] is equal to 63, the value of principal point in the \nvertical direction for the i-th camera is unspecified. \nman_gvd_principal_point_y[ i ] specifies the mantissa part of the principal point  of the i-th camera in the vertical \ndirection The length v of the man_gvd_principal_point_y[ i ] syntax element in units of bits is determined as follows: \n–  If exp_gvd_principal_point_y[ i ] is equal to 0, the length v is set equal to Max( 0, prec_gvd_principal_point − 30 ). \n–  Otherwise  (exp_gvd_principal_point_y[ i ]  is  in  the  range  of  1  to  62,  inclusive),  the  length  v  is  set  equal  to \nMax( 0, exp_gvd_principal_point_y[ i ] + prec_gvd_principal_point − 31 ). \nWhen  exp_gvd_principal_point_y[ i ]  is  not  equal  to  63,  the  variable  principalPointY[ i ]  is  set  equal  to \nbinToFp( sign_gvd_principal_point_y[ i ], exp_gvd_principal_point_y[ i ], man_gvd_principal_point_y[ i ], v ). \nsign_gvd_r[ i ][ j ][ k ] equal to 0 indicates that the sign of the (j, k) component of the rotation matrix for the i-th camera \nis positive. sign_gvd_r[ i ][ j ][ k ] equal to 1 indicates that the sign of the (j, k) component of the rotation matrix for the i-\nth camera is negative. \nexp_gvd_r[ i ][ j ][ k ] specifies the exponent part of the (j, k) component of the rotation matrix for the i-th camera. The \nvalue of exp_gvd_r[ i ][ j ][ k ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved for future use by ITU-T \n| ISO/IEC. When exp_gvd_r[ i ][ j ][ k ] is equal to 63, the value of rotation matrix is unspecified. \nman_gvd_r[ i ][ j ][ k ] specifies the mantissa part of the (j, k) component of the rotation matrix for the i-th camera. \nThe length v of the man_gvd_r[ i ][ j ][ k ] syntax element in units of bits is determined as follows: \n–  If exp_gvd_r[ i ][ j ][ k ] is equal to 0, the length v is set equal to Max( 0, prec_gvd_rotation_param − 30 ). \n–  Otherwise  (exp_gvd_r[ i ][ j ][ k ]  is  in  the  range  of  1  to  62,  inclusive),  the  length  v  is  set  equal  to \nMax( 0, exp_gvd_r[ i ][ j ][ k ] + prec_gvd_rotation_param − 31 ). \nWhen  exp_gvd_r[ i ][ j ][ k ]  is  not  equal  to  63,  the  variable  r[ i ][ j ][ k ]  is  set  equal  to \nbinToFp( sign_gvd_r[ i ][ j ][ k ], exp_gvd_r[ i ][ j ][ k ], man_gvd_r[ i ][ j ][ k ], v ). \nThe rotation matrix R[ i ] for i-th camera is represented as follows: \n r[ i ][ 0 ][ 0 ] r[ i ][ 0 ][ 1 ] r[ i ][ 0 ][ 2 ] \nR[ i ] = [ r[  i ][ 1 ][ 0 ] r[ i ][ 1 ][ 1 ] r[ i ][ 1 ][ 2 ] ]  (I-2) \n r[ i ][ 2 ][ 0 ] r[ i ][ 2 ][ 1 ] r[ i ][ 2 ][ 2 ] \nsign_gvd_t_x[ i ] equal to 0 indicates that the sign of the horizontal component of the translation vector for the i-th camera \nis positive. sign_gvd_t_x[ i ] equal to 1 indicates that the sign of the horizontal component of the translation vector for the \ni-th camera is negative. \n756  Rec. ITU-T H.264 (06/2019) \n \nexp_gvd_t_x[ i ] specifies the exponent part of the horizontal component of the translation vector for the i-th camera. The \nvalue of exp_gvd_t_x[ i ] shall be in the range of 0 to 62, inclusive. The value 63 is reserved for future use by ITU-T | \nISO/IEC. When exp_gvd_t_x[ i ] is equal to 63, the value of the translation vector is unspecified. \nman_gvd_t_x[ i ] specifies the mantissa part of the horizontal component of the translation vector for the i-th camera. \nThe length v of the man_gvd_t_x[ i ] syntax element in units of bits is determined as follows: \n–  If exp_gvd_t_x[ i ] is equal to 0, the length v is set equal to Max( 0, prec_gvd_translation_param − 30 ). \n–  Otherwise  (exp_gvd_t_x[ i ]  is  in  the  range  of  1  to  62,  inclusive),  the  length  v  is  set  equal  to \nMax( 0, exp_gvd_t_x[ i ] + prec_gvd_translation_param − 31 ). \nWhen  exp_gvd_t_x[ i ]  is  not  equal  to  63,  the  variable  tX[ i ]  is  set  equal  to \nbinToFp( sign_gvd_t_x[ i ], exp_gvd_t_x[ i ], man_gvd_t_x[ i ], v ). \nI.13.2.7 Depth sampling information SEI message semantics \nThe depth sampling information SEI message specifies the depth sample size relative to luma texture sample size. In \naddition, the depth sampling information SEI message specifies the depth sampling grid position of one or more depth \nview components of the associated access unit relative to the sampling grid of the texture view components of the same \naccess unit with the same view_id value. When present, the depth sampling information SEI message shall be associated \nwith an IDR access unit. The semantics of the message are valid for the current coded video sequence. \nNOTE – The depth sample size and the depth sampling grid position are indicated for frame or field view components that are \npresent in the associated IDR access unit. In subsequent access units in the coded video sequence the depth view components may \nhave different values of field_pic_flag and bottom_field_flag compared to those of the depth view components of the IDR access \nunit. Likewise, in subsequent access units in the coded video sequence the texture view components may have different values of \nfield_pic_flag and bottom_field_flag compared to those of the texture view components of the IDR access unit. The depth sample \nsize and depth sampling grid position should be modified according to the values of field_pic_flag and bottom_field_flag of the \ntexture and depth view components of an access unit compared to those of the IDR access unit. \ndttsr_x_mul and dttsr_x_dp indicate that the width of a depth sample relative to the width of a luma texture sample is \napproximately dttsr_x_mul ÷ 2dttsr_x_dp. When dttsr_x_mul is not present, it is inferred to be equal to 1. When dttsr_x_dp is \nnot present, it is inferred to be equal to 0. The value of 0 for dttsr_x_mul is reserved. \ndttsr_y_mul and dttsr_y_dp indicate that the height of a depth sample relative to the height of a luma texture sample is \napproximately dttsr_y_mul ÷ 2dttsr_y_dp. When dttsr_y_mul is not present, it is inferred to be equal to 1. When dttsr_y_dp is \nnot present, it is inferred to be equal to 0. The value of 0 for dttsr_y_mul is reserved. \nper_view_depth_grid_pos_flag equal to 0 specifies that the depth sampling grid position information is the same for all \ndepth  views  for  which  there  is  a  texture  view  with  the  same  view_id  present.  The  single  occurrence  of  the \ndepth_grid_position( ) syntax structure indicates the depth sampling grid position. per_view_depth_grid_pos_flag equal \nto 1 specifies that a depth_grid_position( ) syntax structure is present for indicated depth views. \nnum_video_plus_depth_views_minus1 (when present) + 1 specifies the number of views for which the depth sampling \ngrid position information is present in this SEI message. \ndepth_grid_view_id[ i ] specifies the i-th  view_id value  for  which  the depth sampling  grid position information is \nspecified with the depth_grid_position( ) structure following in the syntax structure. \nI.13.2.7.1  Depth grid position semantics \ndepth_grid_pos_x_fp,  depth_grid_pos_x_dp  and  depth_grid_pos_x_sign_flag  indicate  that  the  location  of  the \nhorizontal position of the top-left sample in the sampling grid for a depth view component, relative to the location of the \ntop-left sample in the sampling grid for the luma component of the texture view component with the same value of view_id, \nis equal to ( 1 − 2 * depth_grid_pos_x_sign_flag ) * ( depth_grid_pos_x_fp ÷ 2depth_grid_pos_x_dp ). \nWhen  depth_grid_pos_x_fp,  depth_grid_pos_x_dp,  and  depth_grid_pos_x_sign_flag  are  not  present,  they  should  be \ninferred to be equal to 0. \ndepth_grid_pos_y_fp, depth_grid_pos_y_dp and depth_grid_pos_y_sign_flag indicate that the location of the vertical \nposition of the top-left sample in the sampling grid for a depth view component, relative to the location of the top-left \nsample in the sampling grid for the luma component of the texture view component with the same value of view_id, is \nequal to ( 1 − 2 * depth_grid_pos_y_sign_flag ) * ( depth_grid_pos_y_fp ÷ 2depth_grid_pos_y_dp ). \nWhen  depth_grid_pos_y_fp,  depth_grid_pos_y_dp,  and  depth_grid_pos_y_sign_flag  are  not  present,  they  should  be \ninferred to be equal to 0. \n    Rec. ITU-T H.264 (06/2019)  757 \n \nI.14  Video usability information \nI.14.1  MVCD VUI parameters extension syntax \n \nmvcd_vui_parameters_extension( ) {  C  Descriptor \n  vui_mvcd_num_ops_minus1  0  ue(v) \n  for( i = 0; i <= vui_mvcd_num_ops_minus1; i++ ) {     \n    vui_mvcd_temporal_id[ i ]  0  u(3) \n    vui_mvcd_num_target_output_views_minus1[ i ]  0  ue(v) \n    for( j = 0; j <= vui_mvcd_num_target_output_views_minus1[ i ]; j++ ) {     \n      vui_mvcd_view_id[ i ][ j ]  0  ue(v) \n      vui_mvcd_depth_flag[ i ][ j ]  0  u(1) \n      vui_mvcd_texture_flag[ i ][ j ]  0  u(1) \n    }     \n    vui_mvcd_timing_info_present_flag[ i ]  0  u(1) \n    if( vui_mvcd_timing_info_present_flag[ i ] ) {     \n      vui_mvcd_num_units_in_tick[ i ]  0  u(32) \n      vui_mvcd_time_scale[ i ]  0  u(32) \n      vui_mvcd_fixed_frame_rate_flag[ i ]  0  u(1) \n    }     \n    vui_mvcd_nal_hrd_parameters_present_flag[ i ]  0  u(1) \n    if( vui_mvcd_nal_hrd_parameters_present_flag[ i ] )     \n      hrd_parameters( )  0   \n    vui_mvcd_vcl_hrd_parameters_present_flag[ i ]  0  u(1) \n    if( vui_mvcd_vcl_hrd_parameters_present_flag[ i ] )     \n      hrd_parameters( )  0   \n    if( vui_mvcd_nal_hrd_parameters_present_flag[ i ]  | |       \n      vui_mvcd_vcl_hrd_parameters_present_flag[ i ] ) \n      vui_mvcd_low_delay_hrd_flag[ i ]  0  u(1) \n    vui_mvcd_pic_struct_present_flag[ i ]   0  u(1) \n  }     \n}     \n \nI.14.2  MVCD VUI parameters extension semantics \nThe MVCD VUI parameters extension specifies VUI parameters that apply to one or more operation points for the coded \nvideo sequence. In Annex C it is specified which of the HRD parameter sets specified in the MVCD VUI parameters \nextension are used for conformance checking. All MVCD VUI parameters extensions that are referred to by a coded video \nsequence shall be identical. \nSome texture and depth views identified by vui_mvcd_view_id[ i ][ j ] may not be present in the coded video sequence. \nSome temporal subsets identified by vui_mvcd_temporal_id[ i ] may not be present in the coded video sequence. \nvui_mvcd_num_ops_minus1 plus 1 specifies the number of operation points for which timing information, NAL HRD \nparameters,  VCL  HRD  parameters,  and  the  pic_struct_present_flag  may  be  present.  The  value  of \nvui_mvcd_num_ops_minus1 shall be in the range of 0 to 1023, inclusive. \nvui_mvcd_temporal_id[ i ] indicates the maximum value of temporal_id for all VCL NAL units in the representation of \nthe i-th operation point. \nvui_mvcd_num_target_output_views_minus1[ i ] plus one specifies the number of target output views for the i-th \noperation  point.  The  value  of  vui_mvcd_num_target_output_views_minus1[ i ]  shall  be  in  the  range  of 0  to 1023, \ninclusive. \nvui_mvcd_view_id[ i ][ j ]  indicates  the  j-th  target  output  view  in  the  i-th  operation  point.  The  value  of \nvui_mvcd_view_id[ i ] shall be in the range of 0 to 1023, inclusive. \n758  Rec. ITU-T H.264 (06/2019) \n \nvui_mvcd_depth_flag[ i ][ j ] equal to 0 specifies that no depth view with view_id equal to vui_mvcd_view_id[ i ][ j ] is \nincluded in the j-th operation point. vui_mvcd_depth_flag[ i ][ j ] equal to 1 specifies that the depth view with view_id \nequal to vui_mvcd_view_id[ i ][ j ] is included in the j-th operation point. \nThe value of vuimvcdOpDepthPresent[ i ] is derived as follows: \nvuimvcdOpDepthPresent[ i ] = 0 \nfor( k = 0; k < vui_mvcd_num_target_output_views_minus1[ i ]; k++ ) \n   vuimvcdOpDepthPresent[ i ] = vuimvcdOpDepthPresent[ i ] | vui_mvcd_depth_flag[ i ][ k ] \nvui_mvcd_texture_flag[ i ][ j ] equal to 0 specifies that no texture view with view_id equal to vui_mvcd_view_id[ i ][ j ] \nis included in the j-th operation point. vui_mvcd_depth_flag[ i ][ j ] equal to 1 specifies that the texture view with view_id \nequal to vui_mvcd_view_id[ i ][ j ] is included in the j-th operation point. When vui_mvcd_depth_flag[ i ][ j ]  is equal to \n0, vui_mvcd_texture_flag[ i ][ j ] shall be equal to 1. \nThe following syntax elements apply to the coded video sequence that is obtained by the sub-bitstream extraction process \nas  specified  in  clause I.8.5.3  with  tIdTarget  equal  to  vui_mvcd_temporal_id[ i ],  viewIdTargetList  containing \nvui_mvcd_view_id[ i ][ j ] for all j in the range of 0 to vui_mvcd_num_target_output_views_minus1[ i ], inclusive, for \nwhich vui_mvcd_texture_flag[ i ][ j ] is equal to 1, depthPresentFlagTarget equal to vuimvcdOpDepthPresent[ i ], and, if \nvuimvcdOpDepthPresent[ i ] is equal to 1, viewIdDepthTargetList containing vui_mvcd_view_id[ i ][ j ] for all j in the \nrange of 0 to vui_mvcd_num_target_output_views_minus1[ i ], inclusive, for which vui_mvcd_depth_flag[ i ][ j ] is equal \nto 1 as the inputs and the i-th sub-bitstream as the output. \nvui_mvcd_timing_info_present_flag[ i ]  equal  to  1  specifies  that  vui_mvcd_num_units_in_tick[ i ], \nvui_mvcd_time_scale[ i ], and vui_mvcd_fixed_frame_rate_flag[ i ] for the i-th sub-bitstream are present in the MVCD \nVUI  parameters  extension.  vui_mvcd_timing_info_present_flag[ i ]  equal  to 0  specifies  that \nvui_mvcd_num_units_in_tick[ i ], vui_mvcd_time_scale[ i ], and vui_mvcd_fixed_frame_rate_flag[ i ] for the i-th sub-\nbitstream are not present in the MVCD VUI parameters extension. \nThe following syntax elements for the i-th sub-bitstream are specified using references to Annex E. For these syntax \nelements  the  same  semantics  and  constraints  as  the  ones  specified  in  Annex E  apply,  as  if  these  syntax  elements \nvui_mvcd_num_units_in_tick[ i ],  vui_mvcd_time_scale[ i ],  vui_mvcd_fixed_frame_rate_flag[ i ], \nvui_mvcd_nal_hrd_parameters_present_flag[ i ],  vui_mvcd_vcl_hrd_parameters_present_flag[ i ], \nvui_mvcd_low_delay_hrd_flag[ i ],  and  vui_mvcd_pic_struct_present_flag[ i ]  were  present  as  the  syntax  elements \nnum_units_in_tick,  time_scale,  fixed_frame_rate_flag,  nal_hrd_parameters_present_flag, \nvcl_hrd_parameters_present_flag, low_delay_hrd_flag, and pic_struct_present_flag, respectively, in the VUI parameters \nof the active MVCD sequence parameter sets for the i-th sub-bitstream. \nvui_mvcd_num_units_in_tick[ i ] specifies the value of num_units_in_tick, as specified in clause E.2.1, for the i-th sub-\nbitstream. \nvui_mvcd_time_scale[ i ] specifies the value of time_scale, as specified in clause E.2.1, for the i-th sub-bitstream. \nvui_mvcd_fixed_frame_rate_flag[ i ] specifies the value of fixed_frame_rate_flag, as specified in clause E.2.1, for the i-\nth sub-bitstream. \nvui_mvcd_nal_hrd_parameters_present_flag[ i ] specifies the value of nal_hrd_parameters_present_flag, as specified \nin clause E.2.1, for the i-th sub-bitstream. \nWhen vui_mvcd_nal_hrd_parameters_present_flag[ i ] is equal to 1, NAL HRD parameters (clauses E.1.2 and E.2.2) for \nthe i-th sub-bitstream immediately follow the flag. \nThe variable VuiMvcNalHrdBpPresentFlag[ i ] is derived as follows: \n–  If any of the following is true, the value of VuiMvcNalHrdBpPresentFlag[ i ] shall be set equal to 1: \n–  vui_mvcd_nal_hrd_parameters_present_flag[ i ] is present in the bitstream and is equal to 1, \n–  for the i-th sub-bitstream, the need for presence of buffering periods for NAL HRD operation to be present in \nthe bitstream in buffering period SEI messages is determined by the application, by some means not specified in \nthis Recommendation | International Standard. \n–  Otherwise, the value of VuiMvcNalHrdBpPresentFlag[ i ] shall be set equal to 0. \nvui_mvcd_vcl_hrd_parameters_present_flag[ i ] specifies the value of vcl_hrd_parameters_present_flag, as specified \nin clause E.2.1, for the i-th sub-bitstream. \nWhen vui_mvcd_vcl_hrd_parameters_present_flag[ i ] is equal to 1, VCL HRD parameters (clauses E.1.2 and E.2.2) for \nthe i-th sub-bitstream immediately follow the flag. \nThe variable VuiMvcVclHrdBpPresentFlag[ i ] is derived as follows: \n–  If any of the following is true, the value of VuiMvcVclHrdBpPresentFlag[ i ] shall be set equal to 1: \n    Rec. ITU-T H.264 (06/2019)  759 \n \n–  vui_mvcd_vcl_hrd_parameters_present_flag[ i ] is present in the bitstream and is equal to 1, \n–  for the i-th sub-bitstream, the need for presence of buffering period parameter s for VCL HRD operation in the \nbitstream in buffering period SEI messages is determined by the application, by some means not specified in this \nRecommendation | International Standard. \n–  Otherwise, the value of VuiMvcVclHrdBpPresentFlag[ i ] shall be set equal to 0. \nThe variable VuiMvcCpbDpbDelaysPresentFlag[ i ] is derived as follows: \n–  If any of the following is true, the value of VuiMvcCpbDpbDelaysPresentFlag[ i ] shall be set equal to 1: \n–  vui_mvcd_nal_hrd_parameters_present_flag[ i ] is present in the bitstream and is equal to 1, \n–  vui_mvcd_vcl_hrd_parameters_present_flag[ i ] is present in the bitstream and is equal to 1, \n–  for the i-th sub-bitstream, the need for presence of CPB and DPB output delays in the bitstream in picture timing \nSEI  messages  is  determined  by  the  application,  by  some  means  not  specified  in  this  Recommendation  | \nInternational Standard. \n–  Otherwise, the value of VuiMvcCpbDpbDelaysPresentFlag[ i ] shall be set equal to 0. \nvui_mvcd_low_delay_hrd_flag[ i ] specifies the value of low_delay_hrd_flag, as specified in clause E.2.1, for the i-th \nsub-bitstream. \nvui_mvcd_pic_struct_present_flag[ i ] specifies the value of pic_struct_present_flag, as specified in clause E.2.1, for the \ni-th sub-bitstream. \n \n   \n760  Rec. ITU-T H.264 (06/2019) \n \nAnnex J \n \n \nMultiview and depth video with enhanced non-base view coding \n(This annex forms an integral part of this Recommendation | International Standard.) \n \nThis annex specifies multiview and depth video with enhanced non-base view coding, referred to as 3D-AVC. \nJ.1  Scope \nBitstreams and decoders conforming to the profile specified in this annex are completely specified in this annex with \nreference made to clauses 2 to 9 and Annexes A to I. \nJ.2  Normative references \nThe specifications in clause 2 apply. \nJ.3  Definitions \nFor the purpose of this annex, the following definitions apply in addition to the definitions in clause I.3. These definitions \nare either not present in clause I.3 or replace definitions in clause I.3. \nJ.3.1  MVC texture view component: A texture view component composed of coded slice NAL units of nal_unit_type \nnot equal to 21. \nJ.3.2  texture view component: A coded representation of the texture of a view in a single access unit. A texture view \ncomponent may be a 3D-AVC texture view component or an MVC texture view component. \nJ.3.3  view component pair: A texture view component and a depth view component of the same view within the same \naccess unit. \nJ.3.4  view synthesis prediction: A prediction derived from samples of inter-view reference components using motion \nvectors derived from a depth view component for decoding a texture view component. \nJ.3.5  3D-AVC sequence parameter set: A collective term for sequence parameter set or subset sequence parameter \nset. \nJ.3.6  3D-AVC  texture  view  component:  A  texture  view  component  composed  of  coded  slice  NAL  units  of \nnal_unit_type equal to 21. \nJ.3.7  3DV acquisition parameters: The closest and farthest depth values. \nJ.4  Abbreviations \nThe specifications in clause 4 apply with the following additions: \n3D-AVC Multiview Video Coding with Depth as specified in Annex J \nVSP  View Synthesis Prediction \nJ.5  Conventions \nThe specifications in clause 5 apply. \nJ.6  Source,  coded,  decoded  and  output  data  formats,  scanning  processes,  and  neighbouring \nrelationships \nThe specifications in clause 6 apply with substitution of 3D-AVC sequence parameter set for sequence parameter set and \nby replacing references to clause 6.4.2.2 with reference to clause J.6.1. \nJ.6.1  Inverse sub-macroblock partition scanning process \nInputs to this process are the index of a macroblock partition mbPartIdx and the index of a sub-macroblock partition \nsubMbPartIdx. \n    Rec. ITU-T H.264 (06/2019)  761 \n \nOutput of this process is the location ( x, y ) of the upper-left luma sample for the sub-macroblock partition subMbPartIdx \nrelative to the upper-left sample of the sub-macroblock. \nThe inverse sub-macroblock partition scanning process is specified as follows: \n–  If mb_type is equal to P_8x8, P_8x8ref0, or B_8x8, \nx = InverseRasterScan( subMbPartIdx, SubMbPartWidth( sub_mb_type[ mbPartIdx ] ),  \n                                               SubMbPartHeight( sub_mb_type[ mbPartIdx ] ), 8, 0 )   (J-1) \ny = InverseRasterScan( subMbPartIdx, SubMbPartWidth( sub_mb_type[ mbPartIdx ] ),  \n                                               SubMbPartHeight( sub_mb_type[ mbPartIdx ] ), 8, 1 )   (J-2) \n–  Otherwise, if both of the following are true: \n–  mb_type is equal to B_8x8 and sub_mb_type[ mbPartIdx ] is equal to B_Direct_8x8, or mb_type is equal to \nB_Skip, or mb_type is equal to B_Direct_16x16; and \n–  MbVSSkipFlag is equal to 1 or mb_direct_type_flag is equal to 1, \nthe following applies: \nx = InverseRasterScan( subMbPartIdx, 8, 8, 8, 0 )    (J-3) \ny = InverseRasterScan( subMbPartIdx, 8, 8, 8, 1 )    (J-4) \n–  Otherwise, \nx = InverseRasterScan( subMbPartIdx, 4, 4, 8, 0 )    (J-5) \ny = InverseRasterScan( subMbPartIdx, 4, 4, 8, 1 )    (J-6) \nJ.7  Syntax and semantics \nThis clause specifies syntax and semantics for coded video sequences that conform to one or more of the profiles specified \nin this annex. \nJ.7.1  Method of specifying syntax in tabular form \nThe specifications in clause I.7.1 apply. \nJ.7.2  Specification of syntax functions, categories, and descriptors \nThe specifications in clause I.7.2 apply. \nJ.7.3  Syntax in tabular form \nJ.7.3.1  NAL unit syntax \nThe syntax table is specified in clause I.7.3.1. \nJ.7.3.1.1  NAL unit header 3D-AVC extension syntax \n \nnal_unit_header_3davc_extension( ) {  C  Descriptor \n  view_idx  All  u(8) \n  depth_flag  All  u(1) \n  non_idr_flag  All  u(1) \n  temporal_id  All  u(3) \n  anchor_pic_flag  All  u(1) \n  inter_view_flag  All  u(1) \n}     \n \n762  Rec. ITU-T H.264 (06/2019) \n \nJ.7.3.2  Raw byte sequence payloads and RBSP trailing bits syntax \nJ.7.3.2.1  Sequence parameter set RBSP syntax \nThe syntax table is specified in clause I.7.3.2.1. \nJ.7.3.2.1.1  Sequence parameter set data syntax \nThe syntax table is specified in clause I.7.3.2.1.1. \nJ.7.3.2.1.1.1 Scaling list syntax \nThe syntax table is specified in clause I.7.3.2.1.1.1. \nJ.7.3.2.1.2  Sequence parameter set extension RBSP syntax \nThe syntax table is specified in clause I.7.3.2.1.2. \nJ.7.3.2.1.3  Subset sequence parameter set RBSP syntax \nThe syntax table is specified in clause I.7.3.2.1.3. \nJ.7.3.2.1.4  Sequence parameter set MVC extension syntax \nThe syntax table is specified in clause I.7.3.2.1.4. \nJ.7.3.2.1.5  Sequence parameter set 3D-AVC extension syntax \n \nseq_parameter_set_3davc_extension( ) {  C  Descriptor \n  if( NumDepthViews > 0 ) {     \n    3dv_acquisition_idc  0  ue(v) \n    for( i = 0; i < NumDepthViews; i++ )     \n      view_id_3dv[ i ]  0  ue(v) \n    if( 3dv_acquisition_idc ) {     \n      depth_ranges( NumDepthViews, 2, 0 )     \n      vsp_param( NumDepthViews, 2, 0  )     \n    }     \n    reduced_resolution_flag  0  u(1) \n    if( reduced_resolution_flag ) {     \n      depth_pic_width_in_mbs_minus1  0  ue(v) \n      depth_pic_height_in_map_units_minus1  0  ue(v) \n      depth_hor_mult_minus1  0  ue(v) \n      depth_ver_mult_minus1  0  ue(v) \n      depth_hor_rsh  0  ue(v) \n      depth_ver_rsh  0  ue(v) \n    }     \n    depth_frame_cropping_flag  0  u(1) \n    if( depth_frame_cropping_flag ) {     \n      depth_frame_crop_left_offset  0  ue(v) \n      depth_frame_crop_right_offset  0  ue(v) \n      depth_frame_crop_top_offset  0  ue(v) \n      depth_frame_crop_bottom_offset  0  ue(v) \n    }     \n    grid_pos_num_views  0  ue(v) \n    for( i = 0; i < grid_pos_num_views; i++ ) {     \n      grid_pos_view_id[ i ]  0  ue(v) \n      grid_pos_x[ grid_pos_view_id[ i ] ]  0  se(v) \n      grid_pos_y[ grid_pos_view_id[ i ] ]  0  se(v) \n    }     \n    slice_header_prediction_flag  0  u(1) \n    Rec. ITU-T H.264 (06/2019)  763 \n \n    seq_view_synthesis_flag  0  u(1) \n  }     \n  alc_sps_enable_flag  0  u(1) \n  enable_rle_skip_flag  0  u(1) \n  if( !AllViewsPairedFlag ) {     \n    for( i = 1; i <= num_views_minus1; i++ )     \n      if( texture_view_present_flag[ i ] ) {     \n        num_anchor_refs_l0[ i ]  0  ue(v) \n        for( j = 0; j < num_anchor_refs_l0[ i ]; j++ )     \n          anchor_ref_l0[ i ][ j ]  0  ue(v) \n        num_anchor_refs_l1[ i ]  0  ue(v) \n        for( j = 0; j < num_anchor_refs_l1[ i ]; j++ )     \n          anchor_ref_l1[ i ][ j ]  0  ue(v) \n      }     \n    for( i = 1; i <= num_views_minus1; i++ )     \n      if( texture_view_present_flag[ i ] ) {     \n        num_non_anchor_refs_l0[ i ]  0  ue(v) \n        for( j = 0; j < num_non_anchor_refs_l0[ i ]; j++ )     \n          non_anchor_ref_l0[ i ][ j ]  0  ue(v) \n        num_non_anchor_refs_l1[ i ]  0  ue(v) \n        for( j = 0; j < num_non_anchor_refs_l1[ i ]; j++ )     \n          non_anchor_ref_l1[ i ][ j ]  0  ue(v) \n      }     \n  }     \n}     \n \nJ.7.3.2.2  Picture parameter set RBSP syntax \nThe syntax table is specified in clause I.7.3.2.2. \nJ.7.3.2.3  Supplemental enhancement information RBSP syntax \nThe syntax table is specified in clause I.7.3.2.3. \nJ.7.3.2.3.1  Supplemental enhancement information message syntax \nThe syntax table is specified in clause I.7.3.2.3.1. \nJ.7.3.2.4  Access unit delimiter RBSP syntax \nThe syntax table is specified in clause I.7.3.2.4. \nJ.7.3.2.5  End of sequence RBSP syntax \nThe syntax table is specified in clause I.7.3.2.5. \nJ.7.3.2.6  End of stream RBSP syntax \nThe syntax table is specified in clause I.7.3.2.6. \nJ.7.3.2.7  Filler data RBSP syntax \nThe syntax table is specified in clause I.7.3.2.7. \nJ.7.3.2.8  Slice layer without partitioning RBSP syntax \nThe syntax table is specified in clause I.7.3.2.8. \nJ.7.3.2.9  Slice data partition RBSP syntax \nSlice data partition syntax is not present in coded video sequences conforming to one or more of the profiles specified in \nthis annex. \n764  Rec. ITU-T H.264 (06/2019) \n \nJ.7.3.2.10  RBSP slice trailing bits syntax \nThe syntax table is specified in clause I.7.3.2.10. \nJ.7.3.2.11  RBSP trailing bits syntax \nThe syntax table is specified in clause I.7.3.2.11. \nJ.7.3.2.12  Prefix NAL unit RBSP syntax \nThe syntax table is specified in clause I.7.3.2.12. \nJ.7.3.2.13  Depth parameter set RBSP syntax \n \ndepth_parameter_set_rbsp( ) {  C  Descriptor \n  depth_parameter_set_id  11  ue(v) \n  pred_direction  11  ue(v) \n  if( pred_direction  = =  0  | |  pred_direction  = =  1 ) {     \n    ref_dps_id0  11  ue(v) \n    predWeight0 = 64     \n  }     \n  if( pred_direction  = =  0 ) {     \n    ref_dps_id1  11  ue(v) \n    pred_weight0  11  u(6) \n    predWeight0 = pred_weight0     \n  }     \n  num_depth_views_minus1  11  ue(v) \n  depth_ranges( num_depth_views_minus1 + 1, pred_direction,      \n    depth_parameter_set_id ) \n  vsp_param_flag  11  u(1) \n  if( vsp_param_flag )     \n    vsp_param( num_depth_views_minus1 + 1, pred_direction,      \n    depth_parameter_set_id ) \n  depth_param_additional_extension_flag  11  u(1) \n  nonlinear_depth_representation_num  11  ue(v) \n  for( i = 1; i <= nonlinear_depth_representation_num; i++ )     \n    nonlinear_depth_representation_model[ i ]  11  ue(v) \n  if(depth_param_additional_extension_flag  = =  1 )     \n    while( more_rbsp_data( ) )     \n      depth_param_additional_extension_data_flag  11  u(1) \n  rbsp_trailing_bits( )     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  765 \n \nJ.7.3.2.13.1  Depth ranges syntax \n \ndepth_ranges( numViews, predDirection, index ) {  C  Descriptor \n  z_near_flag  11  u(1) \n  z_far_flag  11  u(1) \n  if( z_near_flag )     \n    3dv_acquisition_element( numViews, 0, predDirection, 7, 0, ZNearSign,     \nZNearExp, ZNearMantissa, ZNearManLen ) \n  if( z_far_flag )     \n    3dv_acquisition_element( numViews, 0, predDirection, 7, 0, ZFarSign,     \nZFarExp, ZFarMantissa, ZFarManLen ) \n}     \n \nJ.7.3.2.13.2  3DV acquisition element syntax \n \n3dv_acquisition_element( numViews, deltaFlag, predDirection, precMode,  C  Descriptor \nexpLen, outSign, outExp, outMantissa, outManLen ) { \n  if( numViews – deltaFlag > 1 )     \n    element_equal_flag  11  u(1) \n  if( element_equal_flag  = =  0 )     \n    numValues = numViews – deltaFlag      \n  else     \n    numValues = 1     \n  for( i = 0; i < numValues; i++ ) {     \n    if( predDirection  = =  2  &&  i  = =  0 ) {     \n      if( precMode  = =  0 ) {     \n        mantissa_len_minus1  11  u(5) \n        outManLen[ index, i ] = manLen = mantissa_len_minus + 1     \n      } else     \n        prec  11  u(5) \n    }     \n    if( predDirection  = =  2 ) {     \n      sign0  11  u(1) \n      outSign[ index, i ] = sign0     \n      exponent0  11  u(v) \n      outExp[ index, i ] = exponent0     \n      if( precMode  = =  1 ) {     \n        if( exponent0  = =  0 )     \n          outManLen[ index, i ] = manLen = Max( 0, prec – 30 )     \n        else     \n          outManLen[ index, i ] = manLen =      \n            Max( 0, exponent0 + prec – 31 ) \n      }     \n      mantissa0  11  u(manLen) \n      outMantissa[ index, i ] = mantissa0     \n    } else {     \n      skip_flag  11  u(1) \n      if( skip_flag  = =  0 ) {     \n        sign1  11  u(1) \n        outSign[ index, i ] = sign1     \n        exponent_skip_flag  11  u(1) \n766  Rec. ITU-T H.264 (06/2019) \n \n        if( exponent_skip_flag  = =  0 ) {     \n          exponent1  11  u(v) \n          outExp[ index, i ] = exponent1     \n        } else     \n          outExp[ index, i ] = outExp[ ref_dps_id0, i ]     \n        mantissa_diff  11  se(v) \n        mantissaPred = (( OutMantissa[ ref_dps_id0, i ] * predWeight0 +     \n          outMantissa[ ref_dps_id1, i ] * ( 64-predWeight0 ) + 32 ) >> 6 ) \n        outMantissa[ index, i ] = mantissaPred + mantissa_diff     \n        outManLen[ index, i ] = outManLen[ ref_dps_id0, i ]     \n      } else {     \n        outSign[ index, i ] = outSign[ ref_dps_id0, i ]     \n        outExp[ index, i ] = outExp[ ref_dps_id0, i ]     \n        outMantissa[ index, i ] = outMantissa[ ref_dps_id0, i ]     \n        outManLen[ index, i ] = outManLen[ ref_dps_id0, i ]     \n      }     \n    }     \n  }     \n  if( element_equal_flag  = =  1 ) {     \n    for( i = 1; i < num_views_minus1 + 1 – deltaFlag; i++ ) {     \n      outSign[ index, i ] = outSign[ index, 0 ]     \n      outExp[ index, i ] = outExp[ index, 0 ]     \n      outMantissa[ index, i ] = outMantissa[ index, 0 ]     \n      outManLen[ index, i ] = outManLen[ index, 0 ]     \n    }     \n  }     \n}     \n \nJ.7.3.2.13.3  View synthesis prediction parameters syntax \n \nvsp_param( numViews, predDirection, index ) {  C  Descriptor \n  for( i = 0; i < numViews; i++ )     \n    for( j = 0; j < i; j++ ) {     \n      disparity_diff_wji[ j ][ i ]  0  ue(v) \n      disparity_diff_oji[ j ][ i ]  0  ue(v) \n      disparity_diff_wij[ i ][ j ]  0  ue(v) \n      disparity_diff_oij[ i ][ j ]  0  ue(v) \n    }     \n}     \n \nJ.7.3.2.14  Slice layer extension RBSP syntax \nThe syntax table is specified in clause I.7.3.2.13. \nJ.7.3.3  Slice header syntax \nThe syntax table is specified in clause I.7.3.3. \nJ.7.3.3.1  Reference picture list modification syntax \nThe syntax table is specified in clause I.7.3.3.1. \nJ.7.3.3.1.1  Reference picture list MVC modification syntax \nThe syntax table is specified in clause I.7.3.3.1.1. \n    Rec. ITU-T H.264 (06/2019)  767 \n \nJ.7.3.3.2  Prediction weight table syntax \nThe syntax table is specified in clause I.7.3.3.2. \nJ.7.3.3.3  Decoded reference picture marking syntax \nThe syntax table is specified in clause I.7.3.3.3. \nJ.7.3.3.4  Slice header in 3D-AVC extension syntax \n \nslice_header_in_3davc_extension( ) {  C  Descriptor \n  first_mb_in_slice  2  ue(v) \n  slice_type  2  ue(v) \n  pic_parameter_set_id  2  ue(v) \n  if( avc_3d_extension_flag  &&  slice_header_prediction_flag  !=  0 ) {     \n    pre_slice_header_src  2  u(2) \n    if( slice_type  = =  P  | |  slice_type  = =  SP     \n      | |  slice_type  = =  B ) { \n      pre_ref_lists_src  2  u(2) \n      if( !pre_ref_lists_src ) {     \n        num_ref_idx_active_override_flag  2  u(1) \n        if( num_ref_idx_active_override_flag ) {     \n        num_ref_idx_l0_active_minus1  2  ue(v) \n        if( slice_type  = =  B )     \n          num_ref_idx_l1_active_minus1  2  ue(v) \n        }     \n        ref_pic_list_mvc_modification( )  /* specified in Annex H */  2   \n      }     \n    }     \n    if( ( weighted_pred_flag  &&  ( slice_type  = =  P  | |     \n      slice_type  = =  SP ) )  | | \n      ( weighted_bipred_idc  = =  1  &&  slice_type  = =  B ) ) { \n      pre_pred_weight_table_src  2  u(2) \n      if( !pre_pred_weight_table_src )     \n        pred_weight_table( )  2   \n    if( nal_ref_idc != 0 ) {     \n      pre_dec_ref_pic_marking_src  2  u(2) \n      if( !pre_dec_ref_pic_marking_src )     \n        dec_ref_pic_marking( )  2   \n    }     \n    slice_qp_delta  2  se(v) \n  } else {     \n    if( separate_colour_plane_flag  = =  1 )     \n      colour_plane_id  2  u(2) \n    frame_num  2  u(v) \n    if( !frame_mbs_only_flag ) {     \n      field_pic_flag  2  u(1) \n      if( field_pic_flag )     \n        bottom_field_flag  2  u(1) \n    }     \n    if( IdrPicFlag )     \n      idr_pic_id  2  ue(v) \n    if( pic_order_cnt_type  = =  0 ) {     \n768  Rec. ITU-T H.264 (06/2019) \n \n      pic_order_cnt_lsb  2  u(v) \n      if( bottom_field_pic_order_in_frame_present_flag &&  !field_pic_flag )     \n        delta_pic_order_cnt_bottom  2  se(v) \n    }     \n    if( pic_order_cnt_type = = 1 && !delta_pic_order_always_zero_flag ) {     \n      delta_pic_order_cnt[ 0 ]  2  se(v) \n      if( bottom_field_pic_order_in_frame_present_flag  &&     \n        !field_pic_flag ) \n        delta_pic_order_cnt[ 1 ]  2  se(v) \n    }     \n    if( redundant_pic_cnt_present_flag )     \n      redundant_pic_cnt  2  ue(v) \n    if( slice_type  = =  B )     \n      direct_spatial_mv_pred_flag  2  u(1) \n    if( slice_type  = =  P  | |  slice_type  = =  SP  | |  slice_type  = =  B ) {     \n      num_ref_idx_active_override_flag  2  u(1) \n      if( num_ref_idx_active_override_flag ) {     \n        num_ref_idx_l0_active_minus1  2  ue(v) \n        if( slice_type  = =  B )     \n          num_ref_idx_l1_active_minus1  2  ue(v) \n      }     \n    }     \n    if( nal_unit_type  = =  20  | |  nal_unit_type  = =  21 )     \n      ref_pic_list_mvc_modification( )  /* specified in Annex H */  2   \n    else     \n      ref_pic_list_modification( )  2   \n    if( ( weighted_pred_flag  &&  ( slice_type  = =  P  | |     \n        slice_type  = =  SP ) )  | | \n      ( weighted_bipred_idc  = =  1  &&  slice_type  = =  B ) ) \n      pred_weight_table( )  2   \n    if( nal_ref_idc != 0 )     \n      dec_ref_pic_marking( )  2   \n    if( entropy_coding_mode_flag  &&  slice_type  !=  I  &&     \n      slice_type  !=  SI ) \n      cabac_init_idc  2  ue(v) \n    slice_qp_delta  2  se(v) \n    if( slice_type  = =  SP  | |  slice_type  = =  SI ) {     \n      if( slice_type  = =  SP )     \n        sp_for_switch_flag  2  u(1) \n      slice_qs_delta  2  se(v) \n    }     \n    if( deblocking_filter_control_present_flag ) {     \n      disable_deblocking_filter_idc  2  ue(v) \n      if( disable_deblocking_filter_idc  !=  1 ) {     \n        slice_alpha_c0_offset_div2  2  se(v) \n        slice_beta_offset_div2  2  se(v) \n      }     \n    }     \n    if( num_slice_groups_minus1 > 0  &&     \n      slice_group_map_type >= 3  &&  slice_group_map_type <= 5) \n    Rec. ITU-T H.264 (06/2019)  769 \n \n      slice_group_change_cycle  2  u(v) \n    if( nal_unit_type = =  21  && ( slice_type  !=  I  &&     \n      slice_type  !=  SI ) ) { \n      if( DepthFlag )     \n        depth_weighted_pred_flag  2  u(1) \n      else if( avc_3d_extension_flag  ) {     \n        dmvp_flag  2  u(1) \n        if( seq_view_synthesis_flag )     \n          slice_vsp_flag  2  u(1) \n      }     \n      if( 3dv_acquisition_idc != 1  &&     \n        ( depth_weighted_pred_flag  | |  dmvp_flag ) ) \n        dps_id  2  ue(v) \n    }     \n  }     \n}     \n \nJ.7.3.4  Slice data syntax \nThe syntax table is specified in clause I.7.3.4. \n \nJ.7.3.4.1  Slice data in 3D-AVC extension syntax \nslice_data_in_3davc_extension( ) {  C  Descriptor \n  if( entropy_coding_mode_flag )     \n    while( !byte_aligned( ) )     \n      cabac_alignment_one_bit  2  f(1) \n  CurrMbAddr = first_mb_in_slice * ( 1 + MbaffFrameFlag )     \n  moreDataFlag = 1     \n  prevMbSkipped = 0     \n  RunLength = 0     \n  do {     \n    if( slice_type  !=  I  &&  slice_type  !=  SI )     \n      if( !entropy_coding_mode_flag ) {     \n        mb_skip_run  2  ue(v) \n        prevMbSkipped = ( mb_skip_run > 0 )     \n        for( i=0; i<mb_skip_run; i++ )     \n          CurrMbAddr = NextMbAddress( CurrMbAddr )     \n        if( nal_unit_type  = =  21  &&  !DepthFlag  &&      \n          mb_skip_run > 0  &&  VspRefExist ) \n          mb_skip_type_flag  2  u(1) \n        if( mb_skip_run > 0 )     \n          moreDataFlag = more_rbsp_data( )     \n      } else {     \n        if( nal_unit_type  = =  21  &&  !DepthFlag  &&     \n          VspRefExist  &&  leftMbVSSkipped  && \n          upMbVSSkipped ) { \n          mb_vsskip_flag  2  ae(v) \n          moreDataFlag = !mb_vsskip_flag     \n          if( !mb_vsskip_flag ) {     \n            mb_skip_flag  2  ae(v) \n770  Rec. ITU-T H.264 (06/2019) \n \n            moreDataFlag = !mb_skip_flag     \n          }     \n          RunLength = 0     \n        } else {     \n          rleCtx = RLESkipContext( )     \n          if( rleCtx  &&  !RunLength ) {     \n            mb_skip_run_type  2  ae(v) \n            RunLength = 16     \n          } else if( !rleCtx  &&  RunLength )     \n            RunLength = 0     \n          if( rleCtx  &&  mb_skip_run_type )     \n            RunLength -= 1     \n          else     \n            mb_skip_flag  2  ae(v) \n          if( rleCtx  &&  !mb_skip_flag )     \n            RunLength = 0     \n          moreDataFlag = !mb_skip_flag     \n          if( nal_unit_type  = =  21  &&  !DepthFlag  &&      \n            VspRefExist  &&  !mb_skip_flag ) { \n            mb_vsskip_flag  2  ae(v) \n            moreDataFlag = !mb_vsskip_flag     \n          }     \n        }     \n        if(alc_sps_enable_flag  &&  nal_unit_type  = =  21     \n          &&  slice_type  = =  P  &&  !DepthFlag  && \n          !mb_vsskip_flag  &&  mb_skip_flag  = =  1 ) \n          mb_alc_skip_flag  2  ae(v) \n      }     \n    if( moreDataFlag ) {     \n      if( MbaffFrameFlag && ( CurrMbAddr % 2  = =  0  | |     \n        ( CurrMbAddr % 2  = =  1  &&  prevMbSkipped ) ) ) \n        mb_field_decoding_flag  2  u(1) | ae(v) \n      macroblock_layer_in_3davc_extension( )  2 | 3 | 4   \n    }     \n    if( !entropy_coding_mode_flag )     \n      moreDataFlag = more_rbsp_data( )     \n    else {     \n      if( slice_type  !=  I  &&  slice_type  !=  SI )     \n        prevMbSkipped = mb_skip_flag  | |  mb_vsskip_flag     \n      if( MbaffFrameFlag  &&  CurrMbAddr % 2  = =  0 )     \n        moreDataFlag = 1     \n      else {     \n        end_of_slice_flag  2  ae(v) \n        moreDataFlag = !end_of_slice_flag     \n      }     \n    }     \n    CurrMbAddr = NextMbAddress( CurrMbAddr )     \n  } while( moreDataFlag )     \n}     \n \n    Rec. ITU-T H.264 (06/2019)  771 \n \nJ.7.3.5  Macroblock layer syntax \nThe syntax table is specified in clause I.7.3.5. \nJ.7.3.5.1  Macroblock prediction syntax \nThe syntax table is specified in clause I.7.3.5.1. \nJ.7.3.5.2  Sub-macroblock prediction syntax \nThe syntax table is specified in clause I.7.3.5.2. \nJ.7.3.5.3  Residual data syntax \nThe syntax table is specified in clause I.7.3.5.3. \nJ.7.3.5.3.1  Residual luma syntax \nThe syntax table is specified in clause I.7.3.5.3.1. \nJ.7.3.5.3.2  Residual block CAVLC syntax \nThe syntax table is specified in clause I.7.3.5.3.2. \nJ.7.3.5.3.3  Residual block CABAC syntax \nThe syntax table is specified in clause I.7.3.5.3.3. \nJ.7.3.6  Macroblock layer in 3D-AVC extension syntax \n \nmacroblock_layer_in_3davc_extension( ) {  C  Descriptor \n  mb_type  2  ue(v) | ae(v) \n  if( nal_unit_type  = = 21  &&  !DepthFlag       \n    &&  slice_type  = =  B  \n    &&  direct_spatial_mv_pred_flag  &&  VspRefExist \n    &&  mb_type  = =  B_Direct_16x16 ) \n    mb_direct_type_flag  2  u(1) | ae(v) \n  if( alc_sps_enable_flag  &&  nal_unit_type  = =  21  &&     \n    slice_type  = =  P  &&  !DepthFlag  && \n    ( mb_type  = =  P_L0_16x16  | |   \n      mb_type  = =  P_L0_L0_16x8  | | \n      mb_type  = =  P_L0_L0_8x16 ) ) \n    mb_alc_flag  2  u(1) | ae(v) \n  if( mb_type  = =  I_PCM ) {     \n    while( !byte_aligned( ) )     \n      pcm_alignment_zero_bit  3  f(1) \n    for( i = 0; i < 256; i++ )     \n      pcm_sample_luma[ i ]  3  u(v) \n    for( i = 0; i < 2 * MbWidthC * MbHeightC; i++ )     \n      pcm_sample_chroma[ i ]  3  u(v) \n  } else {     \n    noSubMbPartSizeLessThan8x8Flag = 1     \n    if( mb_type  !=  I_NxN  &&     \n      MbPartPredMode( mb_type, 0 )  !=  Intra_16x16  && \n      NumMbPart( mb_type )  = =  4 ) { \n      sub_mb_pred_in_3davc_extension( mb_type )  2   \n      for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n        if( sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8 ) {     \n          if( NumSubMbPart( sub_mb_type[ mbPartIdx ] )  >  1 )     \n            noSubMbPartSizeLessThan8x8Flag = 0     \n        } else if( !direct_8x8_inference_flag )     \n          noSubMbPartSizeLessThan8x8Flag = 0     \n    } else {     \n772  Rec. ITU-T H.264 (06/2019) \n \n      if( transform_8x8_mode_flag  &&  mb_type  = =  I_NxN )     \n        transform_size_8x8_flag  2  u(1) | ae(v) \n      mb_pred_in_3davc_extension( mb_type )  2   \n    }     \n    if( MbPartPredMode( mb_type, 0 )  !=  Intra_16x16 ) {     \n      coded_block_pattern  2  me(v) | ae(v) \n      if( ( CodedBlockPatternLuma > 0 | | mb_alc_flag = = 1 ) &&     \n         transform_8x8_mode_flag  &&  mb_type  !=  I_NxN  && \n         noSubMbPartSizeLessThan8x8Flag  && \n         ( mb_type  !=  B_Direct_16x16  | | \n            direct_8x8_inference_flag ) ) \n        transform_size_8x8_flag  2  u(1) | ae(v) \n    }     \n    if( CodedBlockPatternLuma > 0  | |       \n      CodedBlockPatternChroma > 0  | | \n      MbPartPredMode( mb_type, 0 )  = =  Intra_16x16 ) { \n      mb_qp_delta  2  se(v) | ae(v) \n      residual( 0, 15 )  3 | 4   \n    }     \n  }     \n}     \n \nJ.7.3.6.1  Macroblock prediction in 3D-AVC extension syntax \n \nmb_pred_in_3davc_extension( mb_type ) {  C  Descriptor \n  if( MbPartPredMode( mb_type, 0 )  = =  Intra_4x4  | |       \n    MbPartPredMode( mb_type, 0 )  = =  Intra_8x8  | |   \n    MbPartPredMode( mb_type, 0 )  = =  Intra_16x16 ) { \n    if( MbPartPredMode( mb_type, 0 )  = =  Intra_4x4 )     \n      for( luma4x4BlkIdx=0; luma4x4BlkIdx<16; luma4x4BlkIdx++ ) {     \n        prev_intra4x4_pred_mode_flag[ luma4x4BlkIdx ]  2  u(1) | ae(v) \n        if( !prev_intra4x4_pred_mode_flag[ luma4x4BlkIdx ] )     \n          rem_intra4x4_pred_mode[ luma4x4BlkIdx ]  2  u(3) | ae(v) \n      }     \n    if( MbPartPredMode( mb_type, 0 )  = =  Intra_8x8 )     \n      for( luma8x8BlkIdx=0; luma8x8BlkIdx<4; luma8x8BlkIdx++ ) {     \n        prev_intra8x8_pred_mode_flag[ luma8x8BlkIdx ]  2  u(1) | ae(v) \n        if( !prev_intra8x8_pred_mode_flag[ luma8x8BlkIdx ] )     \n          rem_intra8x8_pred_mode[ luma8x8BlkIdx ]  2  u(3) | ae(v) \n      }     \n    if( ChromaArrayType  = =  1  | |  ChromaArrayType  = =  2 )     \n      intra_chroma_pred_mode  2  ue(v) | ae(v) \n  } else if( MbPartPredMode( mb_type, 0 )  !=  Direct ) {     \n    for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type );     \nmbPartIdx++ ) \n      if( ( num_ref_idx_l0_active_minus1 > 0  | |     \n          mb_field_decoding_flag  !=  field_pic_flag ) &&   \n        MbPartPredMode( mb_type, mbPartIdx )  !=  Pred_L1  && \n        mb_alc_flag  = =  0 ) { \n        ref_idx_l0[ mbPartIdx ]  2  te(v) | ae(v) \n        if( VspRefL0Flag[ mbPartIdx ]  &&  slice_vsp_flag )     \n    Rec. ITU-T H.264 (06/2019)  773 \n \n          bvsp_flag_l0[ mbPartIdx ]  2  u(1) | ae(v) \n      }     \n    for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type );     \nmbPartIdx++ ) \n      if( ( num_ref_idx_l1_active_minus1  >  0  | |     \n          mb_field_decoding_flag  !=  field_pic_flag ) &&   \n        MbPartPredMode( mb_type, mbPartIdx )  !=  Pred_L0 ) { \n        ref_idx_l1[ mbPartIdx ]  2  te(v) | ae(v) \n        if( VspRefL1Flag[ mbPartIdx ]  &&  slice_vsp_flag )     \n          bvsp_flag_l1[ mbPartIdx ]  2  u(1) | ae(v) \n      }     \n    for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type );     \nmbPartIdx++ ) \n      if( MbPartPredMode ( mb_type, mbPartIdx )  !=  Pred_L1  &&     \n        ( !VspRefL0Flag[ mbPartIdx ]  | |  !bvsp_flag_l0[ mbPartIdx ] ) \n) \n        for( compIdx = 0; compIdx < 2; compIdx++ )     \n          mvd_l0[ mbPartIdx ][ 0 ][ compIdx ]  2  se(v) | ae(v) \n    for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type );     \nmbPartIdx++ ) \n      if( MbPartPredMode( mb_type, mbPartIdx )  !=  Pred_L0  &&     \n        ( !VspRefL1Flag[ mbPartIdx ]  | |  !bvsp_flag_l1[ mbPartIdx ] ) \n) \n        for( compIdx = 0; compIdx < 2; compIdx++ )     \n          mvd_l1[ mbPartIdx ][ 0 ][ compIdx ]  2  se(v) | ae(v) \n  }     \n}     \n \nJ.7.3.6.2  Sub-macroblock prediction syntax \n \nsub_mb_pred_in_3davc_extension( mb_type ) {  C  Descriptor \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n    sub_mb_type[ mbPartIdx ]  2  ue(v) | ae(v) \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n    if( ( num_ref_idx_l0_active_minus1  >  0  | |       \n        mb_field_decoding_flag  !=  field_pic_flag ) && \n      mb_type  !=  P_8x8ref0  && \n      sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8  && \n      SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L1  && \n      mb_alc_flag  = =  0 ) { \n      ref_idx_l0[ mbPartIdx ]  2  te(v) | ae(v) \n      if( VspRefL0Flag[ mbPartIdx ]  &&  slice_vsp_flag )     \n        bvsp_flag_l0[ mbPartIdx ]  2  u(1) | ae(v) \n    }     \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n    if( ( num_ref_idx_l1_active_minus1  >  0  | |       \n        mb_field_decoding_flag  !=  field_pic_flag ) && \n        sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8  && \n        SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L0 ) { \n      ref_idx_l1[ mbPartIdx ]  2  te(v) | ae(v) \n      if( VspRefL1Flag[ mbPartIdx ]  &&  slice_vsp_flag )     \n        bvsp_flag_l1[ mbPartIdx ]  2  u(1) | ae(v) \n    }     \n774  Rec. ITU-T H.264 (06/2019) \n \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n    if( sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8  &&     \n      SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L1 && \n      ( !VspRefL0Flag[ mbPartIdx ]  | |  !bvsp_flag_l0[ mbPartIdx ] ) ) \n      for( subMbPartIdx = 0;      \n           subMbPartIdx < \nNumSubMbPart( sub_mb_type[ mbPartIdx ] ); \n           subMbPartIdx++ ) \n        for( compIdx = 0; compIdx < 2; compIdx++ )     \n          mvd_l0[ mbPartIdx ][ subMbPartIdx ][ compIdx ]  2  se(v) | ae(v) \n  for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )     \n    if( sub_mb_type[ mbPartIdx ]  !=  B_Direct_8x8  &&     \n      SubMbPredMode( sub_mb_type[ mbPartIdx ] )  !=  Pred_L0 && \n      ( !VspRefL1Flag[ mbPartIdx ]  | |  !bvsp_flag_l1[ mbPartIdx ] ) ) \n      for( subMbPartIdx = 0;      \n           subMbPartIdx < \nNumSubMbPart( sub_mb_type[ mbPartIdx ] ); \n           subMbPartIdx++ ) \n        for( compIdx = 0; compIdx < 2; compIdx++ )     \n          mvd_l1[ mbPartIdx ][ subMbPartIdx ][ compIdx ]  2  se(v) | ae(v) \n}     \n \nJ.7.4  Semantics \nSemantics  associated  with  the  syntax  structures  and  syntax  elements  within  these  structures  (in  clause J.7.3  and  in \nclause I.7.3 by reference in clause J.7.3) are specified in this clause and by reference to clause I.7.4. When the semantics \nof a syntax element are specified using a table or a set of tables, any values that are not specified in the table(s) shall not \nbe present in the bitstream unless otherwise specified in this Recommendation | International Standard. \nJ.7.4.1  NAL unit semantics \nThe semantics for the syntax elements clause J.7.3.1 are specified in clause I.7.3.1. \nJ.7.4.1.1  NAL unit header MVC extension semantics \nview_idx specifies the view oder index for the NAL unit. \nview_id is inferred to be equal to view_id[ view_idx ], where view_id[ ] is present in the active sequence parameter set. \nThe variable VOIdx, representing the view order index of the view identified by view_id[ i ], is set equal to view_idx. \ndepth_flag equal to 1 indicates that the current NAL unit belongs to a depth view component, depth_flag equal to 0 \nindicates that the current NAL unit belongs to a texture view component. \nnon_idr_flag, temporal_id, anchor_pic_flag, and inter_view_flag have the same semantics as those syntax elements \nwith the same names in Annex H. \nJ.7.4.1.2  Order of NAL units and association to coded pictures, access units, and video sequences \nThe specification of clause I.7.4.1.2 applies. \nJ.7.4.1.2.1  Order  of  3D-AVC  sequence  parameter  set  RBSPs  and  picture  parameter  set  RBSPs  and  their \nactivation \nThe specification of clause I.7.4.1.2.1 applies. \nIn addition, the following applies for the activation of depth parameter set. \nA depth parameter set includes parameters that can be referred to by the coded slice NAL units of one or more texture view \nor depth view components of one or more coded pictures. A depth parameter set associated with depth_parameter_set_id \nequal to 0 contains the depth ranges syntax structure and the view synthesis prediction parameter syntax structure included \nin the active sequence parameter set. A depth parameter set with depth_parameter_set_id greater than 0 is a depth parameter \nset RBSP with that depth_parameter_set_id value. \nEach depth parameter set is initially considered not active at the start of the operation of the decoding process. At most one \ndepth parameter set is considered as the active depth parameter set at any given moment during the operation of the \n    Rec. ITU-T H.264 (06/2019)  775 \n \ndecoding process, and when any particular depth parameter set becomes the active depth parameter set, the previously-\nactive depth parameter set (if any) is deactivated. \nWhen a depth parameter set (with a particular value of depth_parameter_set_id) is not the active depth parameter set and \nit is referred to by a coded slice NAL unit (when dps_id is present in a slice header), it is activated. This depth parameter \nset is called the active depth parameter set until it is deactivated when another depth parameter set becomes the active \ndepth parameter set. A depth parameter set, with that particular value of depth_parameter_set_id, shall be available to the \ndecoding process prior to its activation. When a depth parameter set is activated, the same depth parameter set shall remain \nactive for subsequent coded slice NAL units of the same access unit. \nIf any depth parameter set is present that is never activated in the bitstream (i.e., it never becomes the active depth parameter \nset), its syntax elements shall have values that would conform to the specified constraints if it were activated by reference \nin an otherwise-conforming bitstream. \nJ.7.4.1.2.2  Order of access units and association to coded video sequences \nThe specification of clause I.7.4.1.2.2 apply. \nJ.7.4.1.2.3  Order of NAL units and coded pictures and association to access units \nThe specification of clause H.7.4.1.2.3 applies with the following modifications. \nThe association of VCL NAL units to primary or redundant coded pictures is specified in clause I.7.4.1.2.5. \nJ.7.4.1.2.4  Detection of the first VCL NAL unit of a primary coded picture \nThe specification of clause H.7.4.1.2.4 applies. \nJ.7.4.1.2.5  Order of VCL NAL units and association to coded pictures \nEach VCL NAL unit is part of a coded picture. \nLet voIdx be the value of VOIdx of any particular VCL NAL unit. The order of the VCL NAL units within a coded picture \nis constrained as follows: \n–  For all VCL NAL units following this particular VCL NAL unit, the value of VOIdx shall be greater than or equal \nto voIdx. \n–  All VCL NAL units for a depth view component, if present, shall follow any VCL NAL unit of an MVC texture \nview component with a same value of VOIdx. \nFor each set of VCL NAL units within a texture or depth view component, the following applies: \n–  If arbitrary slice order, as specified in Annex A, clause H.10, clause I.10 or clause J.10, is allowed, coded slice NAL \nunits of a view component may have any order relative to each other. \n–  Otherwise (arbitrary slice order is not allowed), coded slice NAL units of a slice group shall not be interleaved with \ncoded slice NAL units of another slice group and the order of coded slice NAL units within a slice group shall be in \nthe order of increasing macroblock address for the first macroblock of each coded slice NAL unit of the same slice \ngroup. \nThe following applies: \n–  If a coded texture view component with a particular view_id is the first field view component of a complementary \nfield pair, the depth view component with the same view_id value, if present in the access unit, shall be a coded frame \nview component or the first field view component of a complementary field pair. \n–  Otherwise, if a coded texture view component with a particular view_id is the second field view component of a \ncomplementary field pair, the depth view component with the same view_id value, if present in the access unit, shall \nbe the second field view component of a complementary field pair. \n–  Otherwise, if a coded texture view component  with a particular view_id is a non-paired field, the depth view \ncomponent with the same view_id value, if present in the access unit, shall be a coded frame view component or a \nnon-paired field. \n–  Otherwise (a coded texture view component with a particular view_id is a coded frame), the depth view component \nwith the same view_id value, if present in the access unit, shall be a coded frame view component. \nNAL units having nal_unit_type equal to 12 may be present in the access unit but shall not precede the first VCL NAL \nunit of the primary coded picture within the access unit. \nNAL units having nal_unit_type equal to 0 or in the range of 24 to 31, inclusive, which are unspecified, may be present in \nthe access unit but shall not precede the first VCL NAL unit of the primary coded picture within the access unit. \n776  Rec. ITU-T H.264 (06/2019) \n \nNAL units having nal_unit_type in the range of 22 to 23, inclusive, which are reserved, shall not precede the first VCL \nNAL unit of the primary coded picture within the access unit (when specified in the future by ITU-T | ISO/IEC). \nJ.7.4.2  Raw byte sequence payloads and RBSP trailing bits semantics \nJ.7.4.2.1  Sequence parameter set RBSP semantics \nThe semantics specified in clause I.7.4.2.1 apply. \nJ.7.4.2.1.1  Sequence parameter set data semantics \nThe semantics specified in clause I.7.4.2.1.1 apply. \nJ.7.4.2.1.1.1 Scaling list semantics \nThe semantics specified in clause I.7.4.2.1.1.1 apply. \nJ.7.4.2.1.2  Sequence parameter set extension RBSP semantics \nThe semantics specified in clause I.7.4.2.1.2 apply. \nJ.7.4.2.1.3  Subset sequence parameter set RBSP semantics \nThe semantics specified in clause I.7.4.2.1.3 apply. \nJ.7.4.2.1.4  Sequence parameter set MVCD extension semantics \nThe  semantics  specified  in  clause I.7.4.2.1.4  apply  with  the  substitution  of  texture  view  component  or  depth  view \ncomponent for view component. \nJ.7.4.2.1.5  Sequence parameter set 3D-AVC extension semantics \nThe function ViewCompOrder( depthFlag, viewId ) is specified to return the value of viewCompOrder derived as follows: \ni = 0 \nwhile ( i <= num_views_minus1  &&  ( view_id[ i ]  !=  viewId  | |   \n    ( depthFlag  &&  !depth_view_present_flag[ i ] )  | |  \n    ( !depthFlag  &&  !texture_view_present_flag[ i ] ) )  (J-7) \n  i++ \nif( i > num_views_minus1 ) \n  viewCompOrder = MAX_INT \nelse \n  viewCompOrder = 2 * i + depthFlag \n3dv_acquisition_idc equal to 0 indicates that no depth ranges or view synthesis prediction parameters syntax structures \nare present in the sequence parameter set. 3dv_acquisition_idc equal to 1 indicates that depth ranges and view synthesis \nprediction parameters syntax structures are present in the sequence parameter set and valid for the entire coded video \nsequence. 3dv_acquisition_idc equal to 2 indicates that depth ranges and view synthesis prediction parameters syntax \nstructures are present in the sequence parameter set and depth parameter sets with depth_parameter_set_id greater than 0 \nmay be activated. 3dv_acquisition_idc values greater than 2 are reserved. \nThe  function  ViewIdTo3DVAcquisitionParamIndex( viewId )  is  specified  to  return  the  value  of  i  for  which \nview_id_3dv[ i ] is equal to viewId in the active sequence parameter set. \nreduced_resolution_flag equal to 1 specifies that the depth view components of a view component pair have a lower \nspatial resolution than the luma component of the texture view component of the same view component pair, and the width \nand height (as represented by pic_width_in_mbs_minus1+1 and pic_height_in_map_units_minus1+1 in the referred subset \nsequence parameter set) of the depth view components are both half of the width and height of all the texture view \ncomponents.  reduced_resolution_flag  equal  to  0  specifies  that  when  both  depth  view  components  and  texture  view \ncomponents are present, they have the same spatial resolution. \ndepth_pic_width_in_mbs_minus1 and depth_pic_height_in_map_units_minus1, when present, are used to infer the \nwidth  and  height  of  depth  view  components.  When  reduced_resolution_flag  is  equal  to  1,  the  values  of \npic_width_in_mbs_minus1  and  pic_height_in_map_units_minus1  are  inferred  to  be  equal  to \ndepth_pic_width_in_mbs_minus1 and depth_pic_height_in_map_units_minus1 for depth views for which this 3D-AVC \nsequence parameter set is an active view 3D-AVC sequence parameter set. \ndepth_hor_mult_minus1, depth_ver_mult_minus1, depth_hor_rsh and depth_ver_rsh are used for specifying the \ndepth-based disparity value derivation process (specified in clause J.8.2.1.1). When not present, depth_hor_mult_minus1 \nand depth_ver_mult_minus1 are inferred to be equal to 1, and depth_hor_rsh and depth_ver_rsh are inferred to be equal to \n0. depth_hor_mult_minus1 and depth_ver_mult_minus1 shall be in the range of 0 to 1023, inclusive. depth_hor_rsh and \n    Rec. ITU-T H.264 (06/2019)  777 \n \ndepth_ver_rsh shall be in the range of 0 to 31, inclusive. \ndepth_frame_cropping_flag equal to 0 specifies that the frame cropping offset parameters for depth view components \nfollow next in the sequence parameter set. depth_frame_cropping_flag equal to 0 specifies that the frame cropping offset \nparameters for depth view components are not present. \ndepth_frame_crop_left_offset,  depth_frame_crop_right_offset,  depth_frame_crop_top_offset  and \ndepth_frame_crop_bottom_offset  specify  the  samples  of  the  decoded  depth  view  components  in  the  coded  video \nsequence that are output from the decoding process, in terms of a rectangular region specified in frame coordinates for \noutput. \nWhen  depth_frame_cropping_flag  is  equal  to  0,  the  values  of  depth_frame_crop_left_offset, \ndepth_frame_crop_right_offset, depth_frame_crop_top_offset, and depth_frame_crop_bottom_offset  are inferred to be \nequal to 0. \nThe values of frame_crop_left_offset, frame_crop_right_offset, frame_crop_top_offset, frame_crop_bottom_offset are \ninferred to be equal to depth_frame_crop_left_offset, depth_frame_crop_right_offset, depth_frame_crop_top_offset, and \ndepth_frame_crop_bottom_offset for the decoding and output of depth views for which this 3D-AVC sequence parameter \nset is an active view 3D-AVC sequence parameter set. \nLet the variables DepthCropLeftCoord, DepthCropRightCoord, DepthCropTopCoord and DepthCropBottomCoord be \nderived from the values of PicWidthInSamples , CropUnitX, CropUnitY, FrameHeightInMBs that apply to depth view \nL\ncomponents as follows: \nDepthCropLeftCoord = CropUnitX * depth_frame_crop_left_offset \nDepthCropRightCoord = PicWidthInSamples  − ( CropUnitX * depth_frame_crop_right_offset + 1 )  (J-8) \nL\nDepthCropTopCoord = CropUnitY * depth_frame_crop_top_offset \nDepthCropBottomCoord = ( 16 * FrameHeightInMbs ) − ( CropUnitY * depth_frame_crop_bottom_offset + 1 ) \ngrid_pos_num_views specifies the number of views for which grid_pos_view_id[ i ], grid_pos_x[ grid_pos_view_id[ i ] ] \nand grid_pos_y[ grid_pos_view_id[ i ] ] are present. grid_pos_num_views shall be in the range of 0 to 1024, inclusive. \ngrid_pos_view_id[ i ] specifies a view_id value of a texture view. \ngrid_pos_x[ grid_pos_view_id[ i ] ] specifies a horizontal offset of a depth sampling grid relative to the luma texture \nsampling grid in texture luma sample units. \ngrid_pos_y[ grid_pos_view_id[ i ] ]  specifies  a  vertical  offset  of  a  depth  sampling  grid  relative  to  the  luma  texture \nsampling grid in texture luma sample units. \nWhen  no  value  of  grid_pos_view_id[ i ]  is  equal  to  a  view_id  value  of  a  texture  view,  grid_pos_x[ view_id ]  and \ngrid_pos_y[ view_id ] are inferred to be equal to 0. \ngrid_pos_x[ grid_pos_view_id[ i ] ]  and  grid_pos_y[ grid_pos_view_id[ i ] ]    are  used  for  specifying  the  depth-based \ndisparity value derivation process (specified in clause J.8.2.1.1). \nslice_header_prediction_flag equal to 0 indicates that slice header prediction from texture view component to depth view \ncomponent or vice versa is disallowed. slice_header_prediction_flag equal to 1 indicates that the prediction is used. \nseq_view_synthesis_flag equal to 1 indicates view synthesis prediction is enabled. seq_view_synthesis_flag equal to 0 \nindicates that view synthesis prediction is disabled for all view components referring the current sequence parameter set. \nalc_sps_enable_flag equal to 0 specifies that mb_alc_skip_flag and mb_alc_flag are not present. alc_sps_enable_flag \nequal to 1 specifies that specifies that mb_alc_skip_flag and mb_alc_flag may be present. \nenable_rle_skip_flag equal to 0 specifies that mb_skip_run_type are not present. enable_rle_skip_flag equal to 1 specifies \nthat mb_skip_run_type may be present. When enable_rle_skip_flag is not present, it is inferred to be equal to 0. \nThe variable AllViewsPairedFlag is derived as follows: \nAllViewsPairedFlag = 1 \nfor( i = 1; i <= num_views_minus1; i++ ) \n  AllViewsPairedFlag = ( AllViewsPairedFlag  &&  depth_view_present_flag[ i ]  &&    (J-9) \n    texture_view_present_flag[ i ] ) \nFor  num_anchor_refs_l0[ i ],  anchor_ref_l0[ i ][ j ],  num_anchor_refs_l1[ i ],  anchor_ref_l1[ i ][ j ], \nnum_non_anchor_refs_l0[ i ], non_anchor_ref_l0[ i ][ j ], num_non_anchor_refs_l1[ i ], and non_anchor_ref_l1[ i ][ j ], \nthe semantics specified in subclause H.7.4.2.1.4 is applied with the substitution of texture view component for view \ncomponent.  When  num_anchor_refs_l0[ i ],  anchor_ref_l0[ i ][ j ],  num_anchor_refs_l1[ i ],  anchor_ref_l1[ i ][ j ], \nnum_non_anchor_refs_l0[ i ],  non_anchor_ref_l0[ i ][ j ],  num_non_anchor_refs_l1[ i ],  and  non_anchor_ref_l1[ i ][ j ] \n778  Rec. ITU-T H.264 (06/2019) \n \nare  not  present,  they  are  inferred  to  have  the  same  values  as  the  respective  syntax  elements  in  the \nseq_parameter_set_mvcd_extension( ) syntax structure in the same subset_seq_parameter_set_rbsp( ) syntax structure that \nalso contains this seq_parameter_set_3davc_extension( ) syntax structure. \nJ.7.4.2.2  Picture parameter set RBSP semantics \nThe semantics specified in in clause I.7.4.2.2 apply. \nJ.7.4.2.3  Supplemental enhancement information RBSP semantics \nThe semantics specified in clause I.7.4.2.3 apply. \nJ.7.4.2.3.1  Supplemental enhancement information message semantics \nThe semantics specified in clause I.7.4.2.3.1 apply. \nJ.7.4.2.4  Access unit delimiter RBSP semantics \nThe semantics specified in clause I.7.4.2.4 apply. \nJ.7.4.2.5  End of sequence RBSP semantics \nThe semantics specified in clause I.7.4.2.5 apply. \nJ.7.4.2.6  End of stream RBSP semantics \nThe semantics specified in clause I.7.4.2.6 apply. \nJ.7.4.2.7  Filler data RBSP semantics \nThe semantics specified in clause I.7.4.2.7 apply. \nJ.7.4.2.8  Slice layer without partitioning RBSP semantics \nThe semantics specified in clause I.7.4.2.8 apply. \nJ.7.4.2.9  Slice data partition RBSP semantics \nSlice data partition syntax is not present in bitstreams conforming to one or more of the profiles specified in Annex J. \nJ.7.4.2.10  RBSP slice trailing bits semantics \nThe semantics specified in clause I.7.4.2.10 apply. \nJ.7.4.2.11  RBSP trailing bits semantics \nThe semantics specified in clause I.7.4.2.11 apply. \nJ.7.4.2.12  Prefix NAL unit RBSP semantics \nThe semantics specified in clause I.7.4.2.12 apply. \nJ.7.4.2.13  Depth parameter set RBSP semantics \ndepth_parameter_set_id  identifies  the  depth  parameter  set  that  is  referred  to  in  the  slice  header.  The  value  of \ndepth_parameter_set_id shall be in the range of 1 to 63, inclusive. \npred_direction equal to 0 specifies that the closest and farthest depth values for the base view may be predicted from the \nrespective variables of two pictures. pred_direction equal to 1 specifies that the closest and farthest depth values for the \nbase view may be predicted from the respective variables of one picture. pred_direction equal to 2 specifies that the closest \nand farthest depth values for the base view are not predicted. The value of pred_direction shall be in the range of 0 to 2, \ninclusive. \nref_dps_id0 specifies a first reference depth parameter set to be used in prediction of the closest and farthest depth value. \nThe value of ref_dps_id0 shall be in the range of 0 to 63, inclusive. \nref_dps_id1 specifies a second reference depth parameter set to be used in prediction of the closest and farthest depth \nvalue. The value of ref_dps_id1 shall be in the range of 0 to 63, inclusive. \npred_weight0 specifies a weight associated with the a first reference depth parameter set derived from ref_dps_id0. The \nvalue of pred_weight0 shall be in the range of 0 to 63, inclusive. \nnum_views_minus1 plus 1 specifies the number of views for which depth parameters are specified in the included \n3dv_acquisition_element( ) structure. num_view_minus1 shall be in the range of 0 to 1023, inclusive. \nvsp_param_flag equal to 1 indicates the presence of the vsp_param( ) syntax structure. vsp_param_flag equal to 0 \nindicates the absence of the vsp_param( ) syntax structure. \n    Rec. ITU-T H.264 (06/2019)  779 \n \nnonlinear_depth_representation_num + 1 specifies the number of piecewise linear segments for mapping of depth \nvalues to a scale that is uniformly quantized in terms of disparity. \nnonlinear_depth_representation_model[ i ] specifies the piecewise linear segments for mapping of depth values to a \nscale that is uniformly quantized in terms of disparity. \nNOTE – When nonlinear_depth_representation_num is equal to 0, a depth sample represents a disparity normalized to the range of \n0 to 255, inclusive, so that 0 corresponds to ZFar value and 255 corresponds to ZNear value. Depending on the value of \nnonlinear_depth_representation_num, a depth view component is composed of either depth samples that can be converted to \ndisparity using a linear equation or nonlinearly transformed depth samples. If nonlinear_depth_representation_num is equal to 0, \ndepth view component contains directly depth samples that are uniformly quantized in terms of disparity, i.e. depth samples that can \nbe transformed to disparity using a linear equation. If nonlinear_depth_representation_num is greater than 0, depth view component \ncontains nonlinearly transformed depth samples. \nWhen nonlinear_depth_representation_num is greater than 0, NdrInverse[ i ], as specified below, is used to transform depth sample \nvalues from nonlinear representation to the linear representation. The shape of this transform is defined by means of line-segment-\napproximation in two-dimensional linear-disparity-to-nonlinear-disparity space. The first (0, 0) and the last (255, 255) nodes of the \ncurve are predefined. Positions of additional nodes are transmitted in form of deviations (nonlinear_depth_representation_model[ i ]) \nfrom the straight-line curve. These deviations are uniformly distributed along the whole range of 0 to 255, inclusive, with spacing \ndepending on the value of nonlinear_depth_representation_num. \nIf nonlinear_depth_representation_num is equal to 0, variable NdrInverse[ i ] for i in the range of 0 to 255, inclusive, is \nspecified as follows. \nnonlinear_depth_representation_model[ 0 ] = 0 \nnonlinear_depth_representation_model[ nonlinear_depth_representation_num + 1 ] = 0 \nfor( k = 0; k <= nonlinear_depth_representation_num; ++k ) \n{ \n  pos1 = ( 255 * k ) / ( nonlinear_depth_representation_num + 1 ) \n  pos2 = ( 255 * ( k+1 ) ) / ( nonlinear_depth_representation_num + 1 ) ) \n \n  x1 = pos1     (J-10) \n  y1 = pos1 \n  x2 = pos2 \n  y2 = pos2 \n \n  for ( x = Max( x1, 0 ); x <= Min( x2, 255 ); ++x ) \n    NdrInverse[ x ] = Clip3( 0, 255, Round( ( ( x - x1 ) * ( y2 - y1 ) ) ÷ ( x2 - x1 ) + y1 ) ) \n} \nOtherwise (nonlinear_depth_representation_num is greater than 0), variable NdrInverse[ i ] for i in the range of 0 to 255, \ninclusive, is specified as follows. \nnonlinear_depth_representation_model[ 0 ] = 0 \nnonlinear_depth_representation_model[ nonlinear_depth_representation_num + 1 ] = 0 \nfor( k = 0; k <= nonlinear_depth_representation_num; ++k ) { \n  pos1 = ( 255 * k ) / ( nonlinear_depth_representation_num + 1 ) \n  dev1 = nonlinear_depth_representation_model[ k ] \n  pos2 = ( 255 * ( k+1 ) ) / ( nonlinear_depth_representation_num + 1 ) ) \n  dev2 = nonlinear_depth_representation_model[ k+1 ] \n \n  x1 = pos1 - dev1    (J-11) \n  y1 = pos1 + dev1 \n  x2 = pos2 - dev2 \n  y2 = pos2 + dev2 \n \n  for ( x = Max( x1, 0 ); x <= Min( x2, 255 ); ++x ) \n    NdrInverse[ x ] = Clip3( 0, 255, Round( ( ( x - x1 ) * ( y2 - y1 ) ) ÷ ( x2 - x1 ) + y1 ) ) \n} \ndepth_param_additional_extension_flag equal to 0 indicates that no additional data follows within the depth parameter \nset RBSP prior to the RBSP trailing bits. The value of depth_param_additional_extension_flag shall be equal to 0. The \nvalue of 1 for depth_param_additional_extension_flag is reserved for future use by ITU-T | ISO/IEC. Decoders shall ignore \nall data that follows the value of 1 for depth_param_additional_extension_flag in a depth parameter set RBSP. \nJ.7.4.2.13.1  Depth ranges semantics \nThe contents of the syntax structure are controlled through input variables predDirection and index the semantics of which \n780  Rec. ITU-T H.264 (06/2019) \n \nare as follows. \n–  predDirection equal to 2 specifies that the first loop entry of the element is not predicted and coded in the sign, \nexponent, and mantissa syntax elements. predDirection equal to 0 or 1 specifies that the first loop entry of the element \nis predicted and a difference relative to a prediction value is coded in the difference syntax element. \n–  index may be equal to the depth_parameter_set_id of the depth parameter set wherein the parameters are present. \nz_near_flag equal to 0 specifies that the syntax elements specifying the closest depth value are not present in the syntax \nstructure. z_near_flag equal to 1 specifies that the syntax elements specifying the closest depth value are present in the \nsyntax structure. \nz_far_flag equal to 0 specifies that the syntax elements specifying the farthest depth value are not present in the syntax \nstructure. z_near_flag equal to 1 specifies that the syntax elements specifying the farthest depth value are present in the \nsyntax structure. \nJ.7.4.2.13.2  3DV acquisition element semantics \nThe syntax structure specifies the value of an element in the depth ranges syntax structure. The element may contain one \nor more loop entries i of the order specified by view_id_3dv syntax elements. \nThe contents of the syntax structure are controlled through input variables predDirection, precMode, and expLen the \nsemantics of which are as follows. \n–  deltaFlag equal to 0 specifies that the each loop entry corresponds to a value specific to the view indicated by i. \ndeltaFlag equal to 1 specifies that each loop entry corresponds to a difference of values between the views indicated \nby i and i + 1. \n–  predDirection equal to 2 specifies that the first loop entry of the element is not predicted and coded in the sign, \nexponent, and mantissa syntax elements. predDirection equal to 0 or 1 specifies that the first loop entry of the element \nis predicted and a difference relative to a prediction value is coded in the difference syntax element. \n–  precMode equal to 0 specifies that the number of bits in the mantissa syntax element. \n–  expLen specifies the number of bits in the exponent syntax element. \nThe syntax structure uses outSign, outExp, outMantissa and outManLen variables for both input and output, where each \nvariable is indexed by [ index, viewIdc ], index being an identifier (equal to either 0 when decoding depth ranges in \nsequence parameter set or depth_parameter_set_id value when decoding depth range parameter set) to a depth parameter \nset and viewIdc being a view indicator (in the order of views for 3DV acquisition parameters). \nelement_equal_flag equal to 0 specifies that the sign, exponent, and mantissa may not be identical to respective values \nfor any two loop entries i and j. element_equal_flag equal to 1 specifies that the sign, exponent, and mantissa are identical \nto respective values for any two loop entries i and j. \nmantissa_len_minus1 + 1 specifies the number of bits in the mantissa syntax element. The value of mantissa_len_minus1 \nshall be in the range of 0 to 31, inclusive. \nprec specifies the exponent of the maximum allowable truncation error for the value represented by the sign, exponent, \nand mantissa given by 2−prec. The value of prec shall be in the range of 0 to 31, inclusive. \nsign0 equal to 0 indicates that the sign of the value provided in the loop entry is positive. sign0 equal to 1 indicates that \nthe sign is negative. \nexponent0 specifies the exponent of the value provided by the loop entry. The syntax element exponent0 is represented \nby expLen bits. The value of exponent0 shall be in the range of 0 to 2expLen – 2, inclusive. The value 2expLen – 1 is reserved \nfor future use by ITU-T | ISO/IEC. Decoders shall treat the value 2expLen – 1 as indicating an unspecified value. \nmantissa0 specifies the mantissa of the value provided by the loop entry. The syntax element mantissa0 is represented by \nmanLen bits. \nskip_flag equal to 0 specifies that syntax elements sign1, exponent_skip_flag and mantissa_diff are present for the loop \nentry. skip_flag equal to 1 specifies that elements sign1, exponent_skip_flag and mantissa_diff are not present for the loop \nentry. \nsign1 equal to 0 indicates that the sign of the value provided in the loop entry is positive. sign1 equal to 1 indicates that \nthe sign is negative. \nexponent1, if present, specifies the exponent of the value provided by the loop entry. The syntax element exponent1 is \nrepresented by expLen bits. The value of exponent1 shall be in the range of 0 to 2expLen – 2, inclusive. The value 2expLen – \n1 is reserved for future use by ITU-T | ISO/IEC. Decoders shall treat the value 2expLen – 1 as indicating an unspecified \nvalue. \n    Rec. ITU-T H.264 (06/2019)  781 \n \nmantissa_diff specifies the difference of the mantissa of the value provided by the loop entry relative to its prediction \nvalue. \nJ.7.4.2.13.3  View synthesis prediction parameters semantics \nThe contents of the syntax structure are controlled through input variables predDirection and index the semantics of which \nare as follows. \n–  predDirection equal to 2 specifies that the first loop entry of the element is not predicted and coded in the sign, \nexponent, and mantissa syntax elements. predDirection equal to 0 or 1 specifies that the first loop entry of the element \nis predicted and a difference relative to a prediction value is coded in the difference syntax element. \n–  index identifies a depth parameter set. \ndisparity_diff_wji[ j ][ i ], disparity_diff_oji[ j ][ i ], disparity_diff_wij[ i ][ j ] and disparity_diff_oij[ i ][ j ] specify \nthe variables DisparityScale and DisparityOffset as follows. \nif( predDirection  = =  2 ) { \n  DisparityScale[ index ][ j ][ i ] = disparity_diff_wji[ j ][ i ] \n  DisparityOffset[ index ][ j ][ i ] = disparity_ diff_oji[ j ][ i ] \n  DisparityScale[ index ][ i ][ j ] = disparity_diff_wij[ i ][ j ] – disparity_diff_wji[ j ][ i ] \n  DisparityOffset[ index ][ i ][ j ] = disparity_diff_oij[ i ][ j ] – disparity_diff_oji[ j ][ i ] \n} else {          (J-12) \n  DisparityScale[ index ][ j ][ i ] = disparity_diff_wji[ j ][ i ] + ( DisparityScale[ ref_dps_id0 ][ j ][ i ] * \n    predWeight0 + DisparityScale[ ref_dps_id1 ][ j ][ i ] * ( 64 – predWeight0 ) + 32 ) >> 6 \n  DisparityOffset[ index ][ j ][ i ] = disparity_diff_oji[ j ][ i ] + ( DisparityOffset[ ref_dps_id0 ][ j ][ i ] * \n    predWeight0 + DisparityOffset[ ref_dps_id1][ j ][ i ] * ( 64 – predWeight0 ) + 32 ) >> 6 \n  DisparityScale[ index ][ i ][ j ] = disparity_diff_wij[ i ][ j ] + ( DisparityScale[ ref_dps_id0 ] i ][ j ] *  \n    predWeight0 + DisparityScale[ ref_dps_id1 ][ i ][ j ] * ( 64 – predWeight0 ) + 32 ) >> 6 \n  DisparityOffset[ index ][ i ][ j ] = disparity_diff_oij[ i ][ j ] + ( DisparityOffset[ ref_dps_id0 ][ i ][ j ] *  \n    predWeight0 + DisparityOffset[ ref_dps_id1 ][ i ][ j ] * ( 64 – predWeight0 ) + 32 ) >> 6 \n} \nJ.7.4.2.14  Slice layer extension RBSP semantics \nThe semantics specified in clause I.7.4.2.13 apply. \nJ.7.4.3  Slice header semantics \nThe semantics specified in clause I.7.4.3 apply. \nJ.7.4.3.1  Reference picture list modification semantics \nThe semantics specified in clause I.7.4.3.1 apply. \nJ.7.4.3.1.1  Reference picture list MVC modification semantics \nThe semantics specified in clause I.7.4.3.1.1 apply. \nJ.7.4.3.2  Prediction weight table semantics \nThe semantics specified in clause I.7.4.3.2 apply. \nJ.7.4.3.3  Decoded reference picture marking semantics \nThe semantics specified in clause I.7.4.3.3 apply to each view independently, with \"sequence parameter set\" being replaced \nby \"3D-AVC sequence parameter set\", and \"primary coded picture\" being replaced by \"texture view component\" for \nnal_unit_type equal to 1, 5, and 20 as well as nal_unit_type 21 when DepthFlag is equal to 1, and by \"depth view \ncomponent\" for nal_unit_type equal to 21 when DepthFlag is equal to 0. \nJ.7.4.3.4  Slice header in 3D-AVC semantics \nThe semantics specified in clause H.7.4.3 apply with the substitution of texture view component or depth view component \nfor view component and with the following modifications. \nWhen nal_unit_type is equal to 1, 5, 20, or 21 with DepthFlag equal to 0, all constraints specified in clause H.7.4.3 apply \nonly to the texture view components with the same value of VOIdx. When nal_unit_type is equal to 21 and DepthFlag is \nequal to 1, all constraints specified in clause H.7.4.3 apply only to the depth view components with the same value of \nVOIdx. \nThe value of the following 3D-AVC sequence parameter set syntax elements shall be the same across all coded slice NAL \nunits of nal_unit_type 1, 5, 20 and 21 with DepthFlag equal to 0 of an access unit: chroma_format_idc. \n782  Rec. ITU-T H.264 (06/2019) \n \nThe value of the following slice header syntax elements shall be the same across all coded slice NAL units of nal_unit_type \n1, 5, 20 and 21 with DepthFlag equal to 0 of an access unit: field_pic_flag and bottom_field_flag. \nThe value of the following slice header syntax elements shall be the same across all coded slice NAL units of nal_unit_type \nequal to 21 and DepthFlag equal to 1 of an access unit: field_pic_flag and bottom_field_flag. \npre_slice_header_src, pre_ref_lists_src, pre_pred_weight_table_src and pre_dec_ref_pic_marking_src specify if the \nrespective syntax elements are present in the slice header, and, if not, the slice header from which the values of the \nrespective syntax elements are taken as specified in Table J-1 and Table J-2. \nWhen a syntax element has an inferred value in the slice header from which its value is taken according to Table J-1 and \nTable J-2, the syntax element value in the current slice header is equal to this inferred value. When a syntax element is not \npresent and has no inferred value in the slice header from which its value is taken according to Table J-1 and Table J-2, \nthe syntax element is inferred to be absent in the current slice header. \npre_slice_header_src shall not be equal to 0. \nWhen  ViewCompOrder( DepthFlag,  view_id )  is  smaller  than  ViewCompOrder( !DepthFlag,  view_id ), \npre_slice_header_src, pre_ref_lists_src, pre_pred_weight_table_src and pre_dec_ref_pic_marking_src shall not be equal \nto 2. \nTable J-1 – Respective syntax elements for pre_slice_header_src, pre_ref_lists_src, pre_pred_weight_table_src \nand pre_dec_ref_pic_marking_src \nPrediction indication syntax  Respective syntax elements \nelement  \npre_slice_header_src  colour_plane_id,  frame_num,  field_pic_flag,  bottom_field_flag,  idr_pic_id, \npic_order_cnt_lsb,  delta_pic_order_cnt_bottom,  delta_pic_order_cnt[ 0 ], \ndelta_pic_order_cnt[  1  ],  redundant_pic_cnt,  direct_spatial_mv_pred_flag,  cabac_init_idc, \nsp_for_switch_flag,  slice_qs_delta,  disable_deblocking_filter_idc, \nslice_alpha_c0_offset_div2,  slice_beta_offset_div2,  slice_group_change_cycle, \ndepth_weighted_pred_flag, dmvp_flag, slice_vsp_flag, dps_id \npre_ref_lists_src  num_ref_idx_active_override_flag,  num_ref_idx_l0_active_minus1, \nnum_ref_idx_l1_active_minus1 and reference picture list modification syntax table \npre_pred_weight_table_src  pred_weight_table( ) syntax structure \npre_dec_ref_pic_marking_src  dec_ref_pic_marking( ) syntax structure \n \nTable J-2 – Semantics of the values of pre_slice_header_src, pre_ref_lists_src, pre_pred_weight_table_src and \npre_dec_ref_pic_marking_src \nValue of pre_slice_header_src,  Semantics \npre_ref_lists_src, \npre_pred_weight_table_src or \npre_dec_ref_pic_marking_src \n0  The respective syntax elements are not predicted but included in the slice header. \n1  The values of the respective syntax elements are taken from the slice header of the first slice of \nthe previous view component in decoding order having the same value of DepthFlag as the \ncurrent slice, belonging to a dependent view of the current view, and residing in the same access \nunit. \n2  The values of the respective syntax elements are taken from the first slice header of the first \nslice of the view component having the same view_id as the current slice and a different value \nof DepthFlag. \n3  The values of the respective syntax elements are taken from the first slice header of the first \nslice of the view component in the same access unit having view order index equal to 0 and the \nsame value of DepthFlag as the current slice. \n \ndepth_weighted_pred_flag equal to 0 specifies that no depth-range-based weighted prediction is used for corresponding \nslice  RBSP.  depth_weighted_pred_flag  equal  to  1  specifies  that  depth-range-based  weighted  prediction  is  used  for \ncorresponding  slice  RBSP.  When  not  present,  depth_weighted_pred_flag  is  inferred  to  be  equal  to  0.  When \n    Rec. ITU-T H.264 (06/2019)  783 \n \ndepth_weighted_pred_flag is equal to 1, the process of derivation of prediction weights specified in clause J.8.2.2 applies. \ndmvp_flag is used in the decoding process for inter prediction, inter-view prediction, view synthesis prediction and \nadaptive luminance compensation as specified in clause J.8.2. \nslice_vsp_flag together with bvsp_flag[ mbPartIdx ] specify, when ref_idx_lX[ mbPartIdx ] (with X equal to 0 or 1) refers \nto an inter-view reference picture, which motion vector derivation process specified in clause J.8.2.1 is in use. \ndps_id specifies the depth parameter set in use. The value of dps_id shall be in the range of 0 to 63, inclusive. When dps_id \nis equal to 0, depth parameters are set according to syntax elements in seq_parameter_set_3davc_extension( ) of the active \nsequence parameter set. When present, the value of dps_id shall be the same in all slice headers within an access unit. \nJ.7.4.4  Slice data semantics \nThe semantics specified in clause I.7.4.4 apply. \nJ.7.4.4.1  Slice data in 3D-AVC extension semantics \nThe semantics specified in clause I.7.4.4 apply with the following additions. \nWhen mb_skip_flag is not present, it is inferred to be equal to 0. \nmb_skip_type_flag is used to derive the variable MbVSSkipFlag. When mb_skip_type_flag is present, the variable \nMbVSSkipFlag is set equal to mb_skip_type_flag. \nmb_vsskip_flag  is  used  to  derive  the  variable  MbVSSkipFlag.  When  mb_vsskip_flag  is  present,  the  variable \nMbVSSkipFlag is set equal to mb_vsskip_flag. \nNOTE – MbVSSkipFlag controls whether clause J.8.2.1.2 or J.8.2.1.3 is used for deriving motion vectors for P_Skip macroblocks \nand whether clause J.8.2.1.4 or J.8.2.1.6 is used for deriving motion vectors and reference indices for B_Skip macroblocks. \nleftMbVSSkipped is derived to be 1 if the left macroblock adjacent to the current macroblock is available and the \nMbVSSkipFlag of the left macroblock is equal to 1, leftMbVSSkipped is derived to be 0 otherwise. \nupMbVSSkipped is derived to be 1 if the upper macroblock adjacent to the current macroblock is available and the \nMbVSSkipFlag of the upper macrolbock is equal to 1, upMbVSSkipped is derived to be 0 otherwise. \nThe function RLESkipContext( ) is specified as follows: \n–  The derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned \nto mbAddrA and mbAddrB; \n–  If all of the following conditions are true, the return value of RLESkipContext( ) is equal to TRUE. \n–  enable_rle_skip_flag is equal to 1 \n–  nal_unit_type is equal to 21 \n–  slice_type is equal to B \n–  mbAddrA is unavailable or mb_skip_flag for the macroblock mbAddrA is equal to 1 \n–  mbAddrB is unavailable or mb_skip_flag for the macroblock mbAddrB is equal to 1 \n–  Otherwise, the return value of RLESkipContext( ) is equal to FALSE. \nmb_skip_run_type equal to 0 specifies that mb_skip_run_type is not present in the slice_data( ) until mb_skip_flag is \nequal 0. When RunLength is greater than 0 and mb_skip_run_type equal to 1, mb_skip_flag is inferred to be equal to 1. \nmb_skip_run_type shall be equal to 0 or 1. \nmb_alc_skip_flag equal to 1 specifies that the adaptive luminance compensation is applied for the current macroblock. \nmb_alc_skip_flag equal to 0 specifies that the adaptive luminance compensation is not applied for the current macroblock. \nWhen not present, mb_alc_skip_flag is inferred to be equal to 0. When mb_alc_skip_flag is equal to 1, the current \nmacroblock shall be coded as P_Skip. \nJ.7.4.5  Macroblock layer semantics \nThe semantics specified in clause I.7.4.5 apply. \nJ.7.4.5.1  Macroblock prediction semantics \nThe semantics specified in clause I.7.4.5.1 apply. \nJ.7.4.5.2  Sub-macroblock prediction semantics \nThe semantics specified in clause I.7.4.5.2 apply. \n784  Rec. ITU-T H.264 (06/2019) \n \nJ.7.4.5.3  Residual data semantics \nThe semantics specified in clause I.7.4.5.3 apply. \nJ.7.4.5.3.1  Residual luma semantics \nThe semantics specified in clause I.7.4.5.3.1 apply. \nJ.7.4.5.3.2  Residual block CAVLC semantics \nThe semantics specified in clause I.7.4.5.3.2 apply. \nJ.7.4.5.3.3  Residual block CABAC semantics \nThe semantics specified in clause I.7.4.5.3.3 apply. \nJ.7.4.6  Macroblock layer in 3D-AVC extension semantics \nThe semantics specified in clause  I.7.4.5 apply by replacing Table 7-13 with Table J-3 and with the following additions. \nmb_direct_type_flag  is  used  to  determine  the  derivation  process  for  motion  vectors  and  reference  indices  for \nB_Direct_16x16 macroblocks and B_Direct_8x8 sub-macroblocks as specified in clause J.8.2.1. \nmb_alc_flag equal to 1 specifies that the adaptive luminance compensation mode is in use for the current macroblock. \nmb_alc_flag equal to 0 specifies that the adaptive luminance compensation mode is not in use for the current macroblock. \nWhen mb_alc_flag is not present, it is inferred to be equal to 0. When mb_alc_flag is equal to 1, the current macroblock \nshall be coded as P_L0_16x16, P_L0_L0_16x8, or P_L0_L0_8x16. \nTable J-3 – Macroblock type values 0 to 4 for P and SP slices \n  e   e   e\n  p e b _ t y p   P a r t     ) p e d M o d       ) 0 e , d M o d       ) 1 e ,   W i d t h     ) p e   e i g h t     ) p e\ny m by ep ep y Hy\n_ t f   M _ t P r t y P r t y r t _ t r t _ t\nb o mb t_ t_ ab ab\nm   m rb rb Pm Pm\na m e N u   ( b P a   ( m b P a   ( m M b   ( M b   (\nN M M\n0  P_L0_16x16  1  Pred_L0  na  16  16 \n1  P_L0_L0_16x8  2  Pred_L0  Pred_L0  16  8 \n2  P_L0_L0_8x16  2  Pred_L0  Pred_L0  8  16 \n3  P_8x8  4  na  na  8  8 \n4  P_8x8ref0  4  na  na  8  8 \ninferred  P_Skip  1  Pred_L0  na  16  16 \n(when \nMbVSSkipFlag \nis equal to 0) \ninferred  P_Skip  4  Pred_L0  na  8  8 \n(when \nMbVSSkipFlag \nis equal to 1) \n \nJ.7.4.6.1  Macroblock prediction in 3D-AVC extension semantics \nThe semantics specified in clause I.7.4.5.1 apply with the following additions. \nbvsp_flag_lX[ mbPartIdx ] (X being equal to 0 or 1) equal to 0 specifies, when ref_idx_lX[ mbPartIdx ] (with X equal to \n0 or 1) refers to an inter-view reference picture, which motion vector derivation process specified in clause J.8.2.1 is in \nuse.  When  bvsp_flag_lX[ mbPartIdx ]  is  not  present  and  VspRefLXFlag[ mbPartIdx ]  is  equal  to  0, \nbvsp_flag_lX[ mbPartIdx ]  is  inferred  to  be  equal  to  0.  When  bvsp_flag_lX[ mbPartIdx ]  is  not  present  and \nVspRefLXFlag[ mbPartIdx ] is equal to 1, bvsp_flag_lX[ mbPartIdx ] is inferred to be equal to slice_vsp_flag. \n    Rec. ITU-T H.264 (06/2019)  785 \n \nJ.7.4.6.2  Sub-macroblock prediction in 3D-AVC semantics \nThe semantics specified in clause I.7.4.5.2 apply with the following additions. \nbvsp_flag_lX[ mbPartIdx ] has the same semantics as bvsp_flag_lX[ mbPartIdx ] in clause J.7.4.6.1. \nsub_mb_type shall be equal to P_L0_8x8 when both of the following apply: \n–  The macroblock type is equal to a P macroblock type. \n–  bvsp_flag_l0[ mbPartIdx ] is equal to 1. \nsub_mb_type shall be equal to B_L0_8x8, B_L1_8x8, or B_Bi_8x8 when both of the following apply: \n–  The macroblock type is equal to a B macroblock type. \n–  bvsp_flag_l0[ mbPartIdx ] is equal to 1 or bvsp_flag_l1[ mbPartIdx ] is equal to 1. \nJ.8  3D-AVC decoding process \nThis clause specifies the decoding process for an access unit of a coded video sequence conforming to one or more of the \nprofiles specified in Annex J. Specifically, this clause specifies how the decoded picture with multiple  texture view \ncomponents and multiple depth view components is derived from syntax elements and global variables that are derived \nfrom NAL units in an access unit when the decoder is decoding the operation point identified by the target temporal level \nand the target output views. \nThe decoding process is specified such that all decoders shall produce numerically identical results for the target output \nviews. Any decoding process that produces identical results for the target output views to the process described here \nconforms to the decoding process requirements of this Recommendation | International Standard. \nUnless stated otherwise, the syntax elements and derived upper-case variables that are referred to by the decoding process \nspecified in this clause and all child processes invoked from the process specified in this clause are the syntax elements \nand derived upper-case variables for the current access unit. \nThe target output texture and depth views are either specified by external means not specified in this Specification, or, \nwhen not specified by external means, there shall be one target output texture view which is the base texture view. \nNOTE – The association of VOIdx values to view_id values according to the decoding process of clause I.8 may differ from that \nof the decoding process of clause H.8. \nA target output view may include only a texture view, only a depth view, or both the texture view and the depth view, \nwhich have the same view_id value. \nAll sub-bitstreams that can be derived using the sub-bitstream extraction process with pIdTarget equal to any value in the \nrange of 0 to 63, inclusive, tIdTarget equal to any value in the range of 0 to 7, inclusive, viewIdTargetList consisting of \nany one or more viewIdTarget's identifying the views in the bitstream as inputs as specified in clause J.8.3 shall result in a \nset of coded video sequences, with each coded video sequence conforming to one or more of the profiles specified in \nAnnex A, Annex H, Annex I and Annex J. \nLet vOIdxList be a list of integer values specifying the VOIdx values of the view components of the access unit. The \nvariable VOIdxMax is set equal to the maximum value of the entries in the list vOIdxList, and the variable vOIdxMin is \nset to the minimum value of the entries in the list vOIdxList. VOIdxMax shall be the same for all access units within a \ncoded video sequence. vOIdxMin shall be the same for all anchor access units within a coded video sequence. When the \ncurrent access unit is an anchor access unit, the variable VOIdxMin is set to vOIdxMin. \nThe 3D-AVC decoding process specified in this clause is repeatedly invoked for each texture and depth view component \nwith VOIdx from vOIdxMin to VOIdxMax, inclusive, which is present in the list vOIdxList, in increasing order of VOIdx \nand in decoding order of texture or depth view components as specified in clause J.7.4.1.2.5. \nOutputs of the multiview video decoding process are decoded samples of the current primary coded picture including all \ndecoded texture and depth view components of the target output texture and depth views. \nFor  each  texture  view  component  and  each  depth  view  component,  TextureFirstFlag  is  set  equal  to \n(NumDepthViews  = =  0  | |  ( ViewCompOrder( 0,  view_idx )  <  ViewCompOrder( 1,  view_idx )  ?  1  :  0 ) ),  and  the \nspecifications in clause I.8 apply, with the decoding process for reference picture lists construction being modified in \nclause J.8.1. The 3D-AVC inter prediction, inter-view prediction, view synthesis prediction and inter prediction with \nadaptive luminance compensation processes are specified in clause J.8.3. The decoding process for depth range parameters \nis specified in clause J.8.4. Additionally, the specification of bitstream subsets is specified in clause J.8.2. \n786  Rec. ITU-T H.264 (06/2019) \n \nJ.8.1  3D-AVC decoding process for reference picture lists construction \nThe specifications of clause I.8.1 apply with the following additions: \n–  When DepthFlag is equal to 0, the variable VspRefExist is specified after applying clause H.8.2 as follows. \n–  If seq_view_synthesis_flag is equal to 0 (view synthesis prediction is disabled), VspRefExist is set to 0. \n–  Otherwise, if the current slice is a P or SP slice and there exists at least one inter-view reference component in \nRefPicList0, or if  the current slice is a B slice and there exists at least one inter-view reference component in \neither RefPicList0 or RefPicList1, VspRefExist is set to 1; \n–  Otherwise, VspRefExist is set to 0. \n–  The variable VspRefL0Flag[ mbPartIdx ] is specified as follows: \n–  If VspRefExist is equal to 1, ref_idx_l0[ mbPartIdx ] is present, and ref_idx_l0[ mbPartIdx ] indicates an inter-\nview reference component, the variable VspRefL0Flag[ mbPartIdx ] is set to 1. \n–  Otherwise, the variable VspRefL0Flag[ mbPartIdx ] is set to 0. \n–  The variable VspRefL1Flag[ mbPartIdx ] is specified as follows: \n–  If VspRefExist is equal to 1, ref_idx_l1[ mbPartIdx ] is present, and ref_idx_l1[ mbPartIdx ] indicates an inter-\nview reference component, the variable VspRefL1Flag[ mbPartIdx ] is set to 1. \n–  Otherwise, the variable VspRefL1Flag[ mbPartIdx ] is set to 0. \nJ.8.2  3D-AVC  inter  prediction,  inter-view  prediction,  view  synthesis  prediction  and  adaptive  luminance \ncompensation \nThis process is invoked when decoding P and B macroblock types and when nal_unit_type is equal to 21. \nOutputs of this process are Inter prediction samples for the current macroblock that are a 16x16 array pred  of luma samples \nL\nand when ChromaArrayType is not equal to 0 two (MbWidthC)x(MbHeightC) arrays pred  and pred  of chroma samples, \nCb Cr\none for each of the chroma components Cb and Cr. \nWhen  DepthFlag  is  equal  to  0  and  dmvp_flag  or  slice_vsp_flag  is  equal  to  1,  the  variables  DepthRefPicList0, \nDepthRefPicList1 for B slices, and DepthCurrPic are specified as follows. The variable DepthRefPicList0 is specified to \nconsist of  the depth  view components of the  view component pairs for  which the texture  view  components are in \nRefPicList0 in the order that RefPicList0[ i ] and DepthRefPicList0[ i ] form a view component pair for any value of \ni = 0.. num_ref_idx_l0_active_minus1. The variable DepthRefPicList1 is specified for B slices to consist of the depth view \ncomponents of the view component pairs for which the texture view components are in RefPicList1 in the order that \nRefPicList1[ i ]  and  DepthRefPicList1[ i ]  form  a  view  component  pair  for  any  value  of \ni = 0.. num_ref_idx_l1_active_minus1. The variable DepthCurrPic is specified to be the decoded sample array of the depth \nview component of the view component pair for which the texture view component is the current texture view component \nwhen TextureFirstFlag is equal to 0 and it is specified to be the decoded sample array of the depth view component of the \nview component pair for which the texture view component is the  texture view component of the base view when \nTextureFirstFlag is equal to 1. \nThe partitioning of a macroblock is specified by mb_type. Each macroblock partition is referred to by mbPartIdx. When \nthe macroblock partitioning consists of partitions that are equal to sub-macroblocks, each sub-macroblock can be further \npartitioned into sub-macroblock partitions as specified by sub_mb_type[ mbPartIdx ]. Each sub-macroblock partition is \nreferred to by subMbPartIdx. When the macroblock partitioning does not consist of sub-macroblocks, subMbPartIdx is set \nequal to 0. \nThe following steps are specified for each macroblock partition or for each sub-macroblock partition. \nThe functions MbPartWidth( ), MbPartHeight( ), SubMbPartWidth( ), and SubMbPartHeight( ) describing the width and \nheight of macroblock partitions and sub-macroblock partitions are specified in Tables 7-14, 7-17, 7-18, and J-3. For the \ndecoding processes specified in this clause, its subclauses, and any subclauses invoked by the decoding processes specified \nin this clause or its subclauses, references to Table 7-13 are replaced by references to Table J-3. \nWhen nal_unit_type is equal to 21, DepthFlag is equal to 0, TextureFirstFlag is equal to 1, InterViewRefAvailable is equal \nto 1 and either dmvp_flag or seq_view_synthesis_flag is equal to 1, DvMBX is set equal to zero when CurrMbAddr is \nequal to first_mb_in_slice, and clause J.8.2.1.8 is invoked. \nThe range of the macroblock partition index mbPartIdx is derived as follows: \n–  If mb_type is equal to B_Skip or B_Direct_16x16, mbPartIdx proceeds over values 0..3. \n    Rec. ITU-T H.264 (06/2019)  787 \n \n–  Otherwise  (mb_type  is  not  equal  to  B_Skip  or  B_Direct_16x16),  mbPartIdx  proceeds  over  values \n0..NumMbPart( mb_type ) − 1. \nFor each value of mbPartIdx, the variables partWidth and partHeight for the width and height of each macroblock partition \nor sub-macroblock partition in the macroblock are derived as follows: \n–  If mb_type is not equal to P_8x8, P_8x8ref0, B_Skip, B_Direct_16x16, or B_8x8, subMbPartIdx is set equal to 0 and \nthe following applies: \npartWidth = MbPartWidth( mb_type )     (J-13) \npartHeight = MbPartHeight( mb_type )     (J-14) \n–  Otherwise, if mb_type is equal to P_8x8 or P_8x8ref0, or mb_type is equal to B_8x8 and sub_mb_type[ mbPartIdx ] \nis  not  equal  to  B_Direct_8x8,  subMbPartIdx  proceeds  over  values \n0..NumSubMbPart( sub_mb_type[ mbPartIdx ] ) − 1, and partWidth and partHeight are derived as: \npartWidth = SubMbPartWidth( sub_mb_type[ mbPartIdx ] )   (J-15) \npartHeight = SubMbPartHeight( sub_mb_type[ mbPartIdx ] ).   (J-16) \n–  Otherwise  (mb_type  is  equal  to  B_Skip  or  B_Direct_16x16,  or  mb_type  is  equal  to  B_8x8  and \nsub_mb_type[ mbPartIdx ] is equal to B_Direct_8x8), the following applies: \n–  If either MbVSSkipFlag or mb_direct_type_flag is equal to 1, subMbPartIdx is set to 0 and partWidth and \npartHeight are derived as: \npartWidth = 8      (J-17) \npartHeight = 8     (J-18) \n–  Otherwise (both MbVSSkipFlag and mb_direct_type_flag are equal to 0), subMbPartIdx proceeds over values \n0..3, and partWidth and partHeight are derived as: \npartWidth = 4      (J-19) \npartHeight = 4     (J-20) \nWhen ChromaArrayType is not equal to 0, the variables partWidthC and partHeightC are derived as: \npartWidthC = partWidth / SubWidthC    (J-21) \npartHeightC = partHeight / SubHeightC    (J-22) \nLet the variable MvCnt be initially set equal to 0 before any invocation of clause J.8.2.1, J.8.2.3 or 8.4.1 for the macroblock. \nThe Inter prediction process for a macroblock partition mbPartIdx and a sub-macroblock partition subMbPartIdx consists \nof the following ordered steps: \n1.  The following applies: \n–  If nal_unit_type is equal to 21 and DepthFlag is equal to 0, the following applies: \n–  If mb_alc_skip_flag is equal to 1 or mb_alc_flag is equal to 1, clause J.8.2.3 is invoked. \n–  Otherwise, if dmvp_flag or slice_vsp_flag is equal to 1, clause J.8.2.1 is invoked. \n–  Otherwise, clause 8.4.1 is invoked. \n–  Otherwise, the derivation process for motion vector components and reference indices as specified in clause 8.4.1 \nis invoked. \nInputs to the processes in clauses J.8.2.1, J.8.2.3 and 8.4.1 are: \n–  a macroblock partition mbPartIdx, \n–  a sub-macroblock partition subMbPartIdx. \n788  Rec. ITU-T H.264 (06/2019) \n \nOutputs of the processes in clauses J.8.2.1, J.8.2.3 and 8.4.1 are: \n–  luma motion vectors mvL0 and mvL1 and when ChromaArrayType is not equal to 0, the chroma motion vectors \nmvCL0 and mvCL1 \n–  reference indices refIdxL0 and refIdxL1 \n–  prediction list utilization flags predFlagL0 and predFlagL1 \n–  the sub-macroblock partition motion vector count subMvCnt. \n2.  The variable MvCnt is incremented by subMvCnt. \n3.  When (weighted_pred_flag is equal to 1 and (slice_type % 5) is equal to 0 or 3) or (weighted_bipred_idc is greater \nthan 0 and (slice_type % 5) is equal to 1), the following applies: \n–  If mb_alc_skip_flag is equal to 1 or mb_alc_flag is equal to 1, clause J.8.2.4 is invoked. \n–  Otherwise, the derivation process for prediction weights as specified in clause 8.4.3 is invoked. \nInputs to these processes in clauses 8.4.3 and J.8.2.4 are: \n–  reference indices refIdxL0 and refIdxL1 \n–  prediction list utilization flags predFlagL0 and predFlagL1 \nOutputs of these processes in clauses 8.4.3 and J.8.2.4 are variables for weighted prediction logWD , w , w , o , \nC 0C 1C 0C\no  with C being replaced by L and, when ChromaArrayType is not equal to 0, Cb and Cr. \n1C\n4.  When (nal_unit_type is equal to 21 and depth_weighted_pred_flag is equal to 1 and (slice_type % 5) is equal to 0 \nor 3) or (depth_weighted_bipred_flag is equal to 1 and (slice_type % 5) is equal to 1), the derivation process for \nprediction weights in depth-range-based weighted prediction in clause J.8.2.2 is invoked. \n5.  The decoding process for Inter prediction samples as specified in clause 8.4.2 is invoked. \nInputs to this process are: \n–  a macroblock partition mbPartIdx, \n–  a sub-macroblock partition subMbPartIdx, \n–  variables specifying partition  width and height  for luma and chroma (if available),  partWidth, partHeight, \npartWidthC (if available), and partHeightC (if available), \n–  luma motion vectors mvL0 and mvL1 and when ChromaArrayType is not equal to 0, the chroma motion vectors \nmvCL0 and mvCL1, \n–  reference indices refIdxL0 and refIdxL1, \n–  prediction list utilization flags predFlagL0 and predFlagL1, \n–  variables  for  weighted  prediction  logWD ,  w ,  w ,  o ,  o   with  C  being  replaced  by  L  and,  when \nC 0C 1C 0C 1C\nChromaArrayType is not equal to 0, Cb and Cr. \nOutputs of this process are inter prediction samples (pred); which are a (partWidth)x(partHeight) array predPart  of \nL\nprediction luma samples and  when ChromaArrayType is  not equal to 0 two (partWidthC)x(partHeightC) arrays \npredPart , and predPart  of prediction chroma samples, one for each of the chroma components Cb and Cr. \nCr Cb\nFor use in derivation processes of variables invoked later in the decoding process, the following assignments are made: \nMvL0[ mbPartIdx ][ subMbPartIdx ] = mvL0    (J-23) \nMvL1[ mbPartIdx ][ subMbPartIdx ] = mvL1    (J-24) \nRefIdxL0[ mbPartIdx ] = refIdxL0    (J-25) \nRefIdxL1[ mbPartIdx ] = refIdxL1    (J-26) \nPredFlagL0[ mbPartIdx ] = predFlagL0    (J-27) \nPredFlagL1[ mbPartIdx ] = predFlagL1    (J-28) \n    Rec. ITU-T H.264 (06/2019)  789 \n \nThe location of the upper-left sample of the macroblock partition relative to the upper-left sample of the macroblock is \nderived by invoking the inverse macroblock partition scanning process as described in clause 6.4.2.1 with mbPartIdx as \nthe input and ( xP, yP ) as the output. \nThe location of the upper-left sample of the sub-macroblock partition relative to the upper-left sample of the macroblock \npartition is derived by invoking the inverse sub-macroblock partition scanning process as described in clause J.6.1 with \nsubMbPartIdx as the input and ( xS, yS ) as the output. \nThe macroblock prediction is formed by placing the macroblock or sub-macroblock partition prediction samples in their \ncorrect relative positions in the macroblock, as follows. \nThe variable pred [ xP + xS + x, yP + yS + y ] with x = 0..partWidth − 1, y = 0..partHeight − 1 is derived by: \nL\npred [ xP + xS + x, yP + yS + y ] = predPart [ x, y ]    (J-29) \nL L\nWhen ChromaArrayType is not equal to 0, the variable pred  with x = 0..partWidthC − 1, y = 0..partHeightC − 1, and C \nC\nin pred  and predPart  being replaced by Cb or Cr is derived by: \nC C\npred [ xP / SubWidthC + xS / SubWidthC + x, yP / SubHeightC + yS / SubHeightC + y ] =predPart [ x, y ] \nC C\n            (J-30) \nJ.8.2.1  Derivation process for motion vector components and reference indices \nInputs to this process are: \n–  a macroblock partition mbPartIdx, \n–  a sub-macroblock partition subMbPartIdx. \nOutputs of this process are: \n–  luma motion vectors mvL0 and mvL1 and when ChromaArrayType is not equal to 0, the chroma motion vectors \nmvCL0 and mvCL1, \n–  reference indices refIdxL0 and refIdxL1, \n–  prediction list utilization flags predFlagL0 and predFlagL1, \n–  a motion vector count variable subMvCnt. \nFor the derivation of the variables mvL0 and mvL1 as well as refIdxL0 and refIdxL1, the following applies: \n–  If mb_type is equal to P_Skip, the following applies: \n–  If MbVSSkipFlag is equal to 0, the following applies: \n–  If nal_unit_type is equal to 21 and DepthFlag is equal to 0 and dmvp_flag is equal to 1, the depth-based \nderivation process for luma motion vectors for skipped macroblock in P and SP slices in clause J.8.2.1.2 is \ninvoked  with  the  output  being  the  luma  motion  vectors  mvL0  and  reference  indices  refIdxL0,  and \npredFlagL0 is set equal to 1. \n–  Otherwise (nal_unit_type is not equal to 21 or DepthFlag is equal to 1 or dmvp_flag is equal to 0), the \nderivation process for luma motion vectors for skipped macroblock in P and SP slices in clause 8.4.1.1 is \ninvoked  with  the  output  being  the  luma  motion  vectors  mvL0  and  reference  indices  refIdxL0,  and \npredFlagL0 is set equal to 1. \n–  Otherwise (MbVSSkipFlag is equal to 1), the derivation process for luma motion vectors for VSP skipped \nmacroblock in P and SP slices in clause J.8.2.1.3 is invoked with mbPartIdx as input and with the output being \nthe luma motion vectors mvL0 and reference indices refIdxL0, and predFlagL0 is set equal to 1. \n–  mvL1 and refIdxL1 are marked as not available and predFlagL1 is set equal to 0. The motion vector count \nvariable subMvCnt is set equal to 1. \n–  Otherwise, if mb_type is equal to B_Skip or B_Direct_16x16 or sub_mb_type[ mbPartIdx ] is equal to B_Direct_8x8, \nthe following applies. \n–  The variable vspFlag is specified as follows: \n790  Rec. ITU-T H.264 (06/2019) \n \nvspFlag = !( sub_type[ mbPartIdx ]  = =  B_Direct_8x8  | |   \n  ( mb_type  = =  B_Skip  &&  MbVSSkipFlag  = =  0 )  | |    (J-31) \n  ( mb_type  = =  B_Direct_16x16  &&  !mb_direct_type_flag ) ) \n–  If vspFlag is equal to 0 and nal_unit_type is equal to 21 and DepthFlag is equal to 0 and dmvp_flag is equal to \n1, the depth-based derivation process for luma motion vectors for B_Skip, B_Direct_16x16, and B_Direct_8x8 \nin B slices in clause J.8.2.1.4 is invoked with mbPartIdx and subMbPartIdx as the input and the output being the \nluma motion vectors mvL0, mvL1, the reference indices refIdxL0, refIdxL1, the motion vector count variable \nsubMvCnt, and the prediction utilization flags predFlagL0 and predFlagL1. \n–  Otherwise, if both of the following are true: \n–  vspFlag is equal to 0, and \n–  nal_unit_type is not equal to 21 or DepthFlag is equal to 1 or dmvp_flag is equal to 0, \n  the derivation process for luma motion vectors for B_Skip, B_Direct_16x16, and B_Direct_8x8 in B slices in \nclause 8.4.1.2 is invoked with mbPartIdx and subMbPartIdx as the input and the output being the luma motion \nvectors mvL0, mvL1, the reference indices refIdxL0, refIdxL1, the motion vector count variable subMvCnt, and \nthe prediction utilization flags predFlagL0 and predFlagL1. \n–  Otherwise (vspFlag is equal to 1), the derivation process in clause J.8.2.1.6 is invoked with with mbPartIdx as \ninput and with the output being the luma motion vectors mvL0 and mvL1 and reference indices refIdxL0 and \nrefIdxL1. \n–  Otherwise, for X being replaced by either 0 or 1 in the variables predFlagLX, mvLX, refIdxLX, and in Pred_LX and \nin the syntax elements ref_idx_lX and mvd_lX, the following applies: \n1.  The variables refIdxLX and predFlagLX are derived as follows: \n–  If MbPartPredMode( mb_type, mbPartIdx ) or SubMbPredMode( sub_mb_type[ mbPartIdx ] ) is equal \nto Pred_LX or to BiPred, \nrefIdxLX = ref_idx_lX[ mbPartIdx ]    (J-32) \npredFlagLX = 1    (J-33) \n–  Otherwise, the variables refIdxLX and predFlagLX are specified by \nrefIdxLX = −1    (J-34) \npredFlagLX = 0    (J-35) \n2.  The motion vector count variable subMvCnt is set equal to predFlagL0 + predFlagL1. \n3.  The variable currSubMbType is derived as follows: \n–  If the macroblock type is equal to B_8x8, currSubMbType is set equal to sub_mb_type[ mbPartIdx ]. \n–  Otherwise (the macroblock type is not equal to B_8x8), currSubMbType is set equal to \"na\". \n4.  The following applies: \n–  If VspRefLXFlag[ mbPartIdx ] is equal to 0 or both VspRefLXFlag[ mbPartIdx ] is equal to 1 and \nbvsp_flag_lX[ mbPartIdx ] is equal to 0, the following applies: \n–  When predFlagLX is equal to 1 and DepthFlag is equal to 0 and dmvp_flag is equal to 1, the derivation \nprocess for luma motion vector prediction in clause J.8.2.1.7 is invoked with mbPartIdx subMbPartIdx, \nrefIdxLX, and currSubMbType as the inputs and the output being mvpLX. \n–  When predFlagLX is equal to 1 and either DepthFlag is equal to 1 or dmvp_flag is equal to 0, the \nderivation process for luma motion vector prediction in clause 8.4.1.3 is invoked with mbPartIdx \nsubMbPartIdx, refIdxLX, and currSubMbType as the inputs and the output being mvpLX. \n–  The luma motion vectors are derived by \nmvLX[ 0 ] = mvpLX[ 0 ] + mvd_lX[ mbPartIdx ][ subMbPartIdx ][ 0 ]  (J-36) \nmvLX[ 1 ] = mvpLX[ 1 ] + mvd_lX[ mbPartIdx ][ subMbPartIdx ][ 1 ]  (J-37) \n    Rec. ITU-T H.264 (06/2019)  791 \n \n–  Otherwise (VspRefLXFlag[ mbPartIdx ] is equal to 1 and bvsp_flag_lX[ mbPartIdx ] is equal to 1), the \nfollowing applies: \n–  If TextureFirstFlag is equal to 0, the depth-based disparity value derivation process in clause J.8.2.1.1 \nis invoked with depthPic equal to DepthCurrPic, (textureX, textureY) equal to the location of the top-\nleft sample of macroblock partition mbPartIdx, tBlWidth equal to the width the macroblock partition \nmbPartIdx, tBlHeight equal to the height the macroblock partition mbPartIdx, srcViewId equal to \nview_id  and  refViewId  equal  to  the  view_id  of  refIdxLX  as  inputs  and  the  output  assigned  to \nmvLX[ 0 ] and mvLX[ 1 ] is set equal to 0. \n–  Otherwise (TextureFirstFlag  is equal to 1),  the depth-based disparity  value derivation process in \nclause  J.8.2.1.1 is invoked with depthPic equal to DepthCurrPic, (textureX, textureY) equal to sum of \n( DvMBX >> 2 , 0 ) and the location of the top-left sample of current macroblock partition, tBlWidth \nequal to the width the macroblock partition mbPartIdx, tBlHeight equal to the height the macroblock \npartition mbPartIdx, srcViewId equal to view_id and refViewId equal to 0 as inputs and the output \nassigned to mvLX[ 0 ] and mvLX[ 1 ] is set equal to 0. \nWhen ChromaArrayType is not equal to 0 and predFlagLX (with X being either 0 or 1) is equal to 1, the derivation process \nfor chroma motion vectors in clause 8.4.1.4 is invoked with mvLX and refIdxLX as input and the output being mvCLX. \nJ.8.2.1.1  Depth-based disparity value derivation process \nInputs to this process are: \n–  a decoded depth view component depthPic, \n–  the location (textureX, textureY) of the block in a texture view component for which the disparity value is derived, \n–  the width tBlWidth and the height tBlHeight of the block in a texture view component for which the disparity value is \nderived, \n–  the view_id value srcViewId of the texture view component for which the disparity value is derived, and \n–  the view_id value refViewId of the reference view for the disparity value. \nOutput of this process is a disparity value dispVal. \nThe derivation of the disparity value dispVal is specified with the following ordered steps. \n1.  The variables depthX, depthY, blWidth and blHeight are specified as follows: \ndHM = depth_hor_mult_minus1 + 1 \ndVM = depth_ver_mult_minus1 + 1 \ndepthX = Clip3( DepthCropLeftCoord, DepthCropRightCoord,  \n  ( ( textureX + grid_pos_x[ srcViewId ] )* dHM ) >> depth_hor_rsh ) \ndepthY = Clip3( DepthCropTopCoord, DepthCropBottomCoord,  \n  ( ( textureY + grid_pos_y[ srcViewId ] ) * dVM ) >> depth_ver_rsh ) \ndepthXN = Clip3( DepthCropLeftCoord, DepthCropRightCoord,  \n  ( ( textureX + grid_pos_x[ srcViewId ] + tBlWidth – 1 ) * dHM ) >> depth_hor_rsh )  (J-38) \ndepthYN = Clip3( DepthCropTopCoord, DepthCropBottomCoord,  \n  ( ( textureY + grid_pos_y[ srcViewId ] + tBlHeight – 1 ) * dVM ) >> depth_ver_rsh ) \nblWidth = depthXN – depthX + 1 \nblHeight = depthYN – depthY + 1 \n2.  The variable maxDepth is specified as follows: \nmaxDepth = INT_MIN \nfor( j = 0; j < blHeight; j += ( blHeight – 1 ) ) \n  for( i = 0; i < blWidth; i += ( blWidth – 1 ) )    (J-39) \n    if( depthPic[ depthX + i, depthY + j ] > maxDepth )  \n      maxDepth = depthPic[ depthX + i, depthY + j ] \n3.  The variable dispVal is specified as follows: \n792  Rec. ITU-T H.264 (06/2019) \n \nlog2Div = BitDepth  + 6 \nY\nsrcIndex = ViewIdTo3DVAcquisitionParamIndex( srcViewId ) \nrefIndex = ViewIdTo3DVAcquisitionParamIndex( refViewId )  (J-40) \ndispVal = ( NdrInverse[ maxDepth ] * DisparityScale[ dps_id ][ srcIndex ][ refIndex ] +  \n  ( DisparityOffset[ dps_id ][ srcIndex ][ refIndex ] << BitDepth  ) +  \nY\n  ( 1 << ( log2Div – 1 ) ) ) >> log2Div \nJ.8.2.1.2  Depth-based derivation process for luma motion vectors for skipped macroblocks in P and SP slices \nThis process is invoked when mb_type is equal to P_Skip, nal_unit_type is equal to 21, DepthFlag is equal to 0, dmvp_flag \nis equal to 1 and MbVSSkipFlag is equal to 0. \nOutputs of this process are: \n–  the motion vector mvL0, \n–  the reference index refIdxL0. \nFor the derivation of the motion vector mvL0 and refIdxL0 of a P_Skip macroblock type, the following ordered steps are \nspecified: \n1.  The process specified in clause J.8.2.1.5 is invoked with mbPartIdx set equal to 0, subMbPartIdx set equal to 0, \ncurrSubMbType set equal to \"na\", and listSuffixFlag equal to 0 as input and the output is assigned to the motion \nvector mvL0 and the reference index refIdxL0. \n2.  When refIdxL0 is equal to -1, the following applies: \n–  The reference index refIdxL0 is set to 0. \n–  The derivation process for luma motion vector prediction in clause J.8.2.1.7 is invoked with mbPartIdx set \nequal to 0, subMbPartIdx set equal to 0, refIdxL0, and currSubMbType = \"na\" as the inputs and the output \nbeing mvL0. \nJ.8.2.1.3  Derivation process for luma motion vectors for VSP skipped macroblocks in P and SP slices \nThis process is invoked when mb_type is equal to P_Skip, nal_unit_type is equal to 21, DepthFlag is equal to 0, and \nMbVSSkipFlag is equal to 1. \nInputs to this process are current macroblock partition index mbPartIdx. \nOutputs of this process are the motion vector mvL0 and the reference index refIdxL0. \nThe inverse macroblock scanning process as specified in clause 6.4.1 is invoked with CurrMbAddr as the input and the \noutput is assigned to ( x1, y1 ). \nThe inverse macroblock partition scanning process specified in clause 6.4.2.1 is invoked with mbPartIdx as the input and \nthe output assigned to ( dx1, dy1 ). \nThe reference index refIdxL0 for a VSP skipped macroblock is derived as the inter-view picture that appears first in \nRefPicList0. \nIf TextureFirstFlag is equal to 0, the variable refViewId is set equal to the view_id of the inter-view picture refIdxL0. \nOtherwise (TextureFirstFlag is equal to1) the variable refViewId is set to 0. \nThe variable shiftedX is set to ( TextureFirstFlag ? ( DvMBX >> 2 ) : 0 ). \nThe depth-based disparity value derivation process in clause J.8.2.1.1 is invoked with depthPic equal to DepthCurrPic, \ntextureX equal to x1 + dx1+ shiftedX, textureY equal to y1 + dy1, tBlWidth equal to 8, tBlHeight equal to 8, srcViewId \nequal to view_id and refViewId equal to refViewId as inputs and the output assigned to mvL0[ 0 ]. \nmvL0[ 1 ] is set equal to 0. \nJ.8.2.1.4  Derivation process for luma motion vectors for B_Skip, B_Direct_16x16, and B_Direct_8x8 \nInputs to this process are current macroblock partition index mbPartIdx and subMbPartIdx. \nOutputs of this process are the reference indices refIdxL0, refIdxL1, the motion vectors mvL0 and mvL1, the motion vector \ncount variable subMvCnt, and the prediction list utilization flags, predFlagL0 and predFlagL1. \nFor the derivation of output, the following ordered steps are specified: \n1.  Let the variable currSubMbType be set equal to sub_mb_type[ mbPartIdx ]. \n    Rec. ITU-T H.264 (06/2019)  793 \n \n2.  The process specified in clause J.8.2.1.5 is invoked with mbPartIdx set equal to 0, subMbPartIdx set equal to 0, \ncurrSubMbType and listSuffixFlag set equal to 0 as input and the output is assigned to the motion vector mvL0 \nand the reference index refIdxL0. \n3.  The process specified in clause J.8.2.1.5 is invoked with mbPartIdx set equal to 0, subMbPartIdx set equal to 0, \ncurrSubMbType and listSuffixFlag set equal to 1 as input and the output is assigned to the motion vector mvL1 \nand the reference index refIdxL1. \n4.  When both reference indices refIdxL0 and refIdxL1 are equal to -1, the following applies: \n–  The reference index refIdxL0 is set equal to 0. \n–  The derivation process for luma motion vector prediction in clause J.8.2.1.7 is invoked with mbPartIdx set \nequal to 0, subMbPartIdx set equal to 0, refIdxLX (with X being 0 or 1), and currSubMbType as the inputs \nand the output being mvLX. \nJ.8.2.1.5  Derivation process for the motion vector in inter-view reference \nInputs to this process are mbPartIdx, subMbPartIdx, and listSuffixFlag. \nOutputs of this process are the motion vector mvCorrespond and the reference index refIdxCorrespond. \nInter-view reference picture InterViewPic and an offset vector dV are derived as follows: \n–  If TextureFirstFlag is equal to 0, the following ordered steps apply: \n–  The inverse macroblock scanning process as specified in clause 6.4.1 is invoked with CurrMbAddr as the input \nand the output is assigned to ( x1, y1 ). \n–  The inverse macroblock partition scanning process specified in clause 6.4.2.1 is invoked with mbPartIdx as the \ninput and the output assigned to ( dx1, dy1 ). \n–  The inverse sub-macroblock partition scanning process specified in clause J.6.1 is invoked with mbPartIdx and \nsubMbPartIdx as the input and the output assigned to ( dx2, dy2 ). \n–  The following applies to derive an inter-view reference picture or inter-view only reference picture InterViewPic \nand to set the variable interViewAvailable: \ninterViewAvailable = 0 \nfor( cIdx = 0; cIdx <= num_ref_idx_l0_active_minus1  &&  !interViewAvailable; cIdx++ ) \n  if ( view order index of RefPicList0[ cIdx ] is not equal to view_idx ) { \n    InterViewPic = RefPicList0[ cIdx ]    (J-41) \n    interViewAvailable = 1 \n  } \n–  When interViewAvailable is equal to 1, the depth-based disparity value derivation process in clause J.8.2.1.1 is \ninvoked with depthPic equal to DepthCurrPic, textureX equal to x1 + dx1 + dx2, textureY equal to y1 + dy1 + \ndy2,  tBlWidth  equal  to  the  width  the  sub-macroblock  partition  CurrMbAddr\\mbPartIdx\\subMbPartIdx, \ntBlHeight equal to the height the sub-macroblock partition CurrMbAddr\\mbPartIdx\\subMbPartIdx, srcViewId \nequal to view_id and refViewId equal to the view_id of InterViewPic as inputs and the output assigned to dV[ 0 ] \nand dV[ 1 ] is set to 0. \n–  Otherwise (TextureFirstFlag is equal to 1), the following ordered steps apply: \n–  dV is set to (DvMBX, 0) and interViewAvailable is set to InterViewRefAvailable. \n–  When interViewAvailable is equal to 1, InterViewPic is set to be the texture view component of the base view. \nThe refIdxCorrespond and mvCorrespond are set as follows. \n–  If interViewAvailable is equal to 0, refIdxCorrespond is set to -1, and mvCorrespond[ 0 ] and mvCorrespond[ 1 ] are \nboth set to 0. \n–  Otherwise, the following step applies in order. \n–  The variable xCorrespond is set equal to x1 + 7 + ( dV[ 0 ] >> 2 ), and the variable yCorrespond is set equal to \ny1 + 7 + ( dV[ 1 ] >> 2 ). \n–  The variable mbAddrCorrespond is set equal to ( ( CurrMbAddr / PicWidthInMbs ) + ( dV[ 1 ] >> 6 ) ) * \nPicWidthInMbs + ( CurrMbAddr % PicWidthInMbs ) + ( dV[ 0 ] >> 6 ). \n794  Rec. ITU-T H.264 (06/2019) \n \n–  The variable xRelative is set equal to xCorrespond – ( ( xCorrespond >> 4 ) << 4 ), and the variable yRelative is \nset equal to yCorrespond – ( ( yCorrespond >> 4 ) << 4 ). \n–  Set mbTypeCorrespond to the syntax element mb_type of the macroblock with address mbAddrCorrespond \ninside  the  picture  InterViewPic.  When  mbTypeCorrespond  is  equal  to  P_8x8,  P_8x8ref0,  or  B_8x8, \nsubMbTypeCorrespond  is  set  to  be  the  syntax  element  sub_mb_type  of  the  macroblock  with  address \nmbAddrCorrespond inside the picture InterViewPic. \n–  Set  mbPartIdxCorrespond  to  the  macroblock  partition  index  of  the  corresponding  partition  and \nsubMbPartIdxCorrespond to the sub-macroblock partition index of the corresponding sub-macroblock partition. \nThe derivation process for macroblock and sub-macroblock partition indices as specified in clause 6.4.13.4 is \ninvoked  with  the  luma  location  equal  to  ( xRelative, yRelative ),  the  macroblock  type  equal  to \nmbTypeCorrespond, and when mbTypeCorrespond is equal to P_8x8, P_8x8ref0, or B_8x8, the list of sub-\nmacroblock types subMbTypeCorrespond as the inputs and the outputs are  the macroblock partition index \nmbPartIdxCorrespond and the sub-macroblock partition index subMbPartIdxCorrespond. \n–  The motion vector mvCorrespond and the reference index refIdxCorrespond are derived as follows. \n–  If  the  macroblock  mbAddrCorrespond  is  coded  as  Intra  prediction  mode,  both  components  of \nmvCorrespond are set equal to 0 and refIdxCorrespond is set equal to −1. \n–  Otherwise (the macroblock mbAddrCorrespond is not coded as Intra prediction mode), the prediction \nutilization  flags  predFlagLXCorrespond  is  set  equal  to  PredFlagLX[ mbPartIdxCorrespond ],  the \nprediction utilization flag of the macroblock partition mbAddrCorrespond\\mbPartIdxCorrespond of \nthe picture InterViewPic. In addition, the following applies. \n–  When predFlagLXCorrespond is equal to 1 and RefIdxLX[ mbPartIdxCorrespond ] is less than \nor  equal  to  num_ref_idx_lX_active_minus1,  the  mvCorrespond  and  the  reference  index \nrefIdxCorrespond are set equal to MvLX[ mbPartIdxCorrespond ][ subMbPartIdxCorrespond ] \nand RefIdxLX[ mbPartIdxCorrespond ], respectively, which are the motion vector mvLX and the \nreference  index  refIdxLX  that  have  been  assigned  to  the  (sub-)macroblock  partition \nmbAddrCorrespond\\mbPartIdxCorrespond\\subMbPartIdxCorrespond  inside  the  picture \nInterViewPic. \nJ.8.2.1.6  Derivation process for luma motion vectors for VSP skipped/direct macroblocks in B slices \nInputs to this process are current macroblock partition index mbPartIdx. \nOutputs of this process are the motion vector mvL0, mvL1 and the reference index refIdxL0, refIdxL1. \nThe inverse macroblock scanning process as specified in clause 6.4.1 is invoked with CurrMbAddr as the input and the \noutput is assigned to ( x1, y1 ). \nThe inverse macroblock partition scanning process specified in clause 6.4.2.1 is invoked with mbPartIdx as the input and \nthe output assigned to ( dx1, dy1 ). \nThe reference index refIdxLX for a VSP skipped/direct macroblock is derived as the inter-view reference component that \nappears first in the reference picture list X, with X being replaced by 0 or 1. When there is no inter-view picture in the \nreference picture list X, refIdxLX is set equal to 0. \nThe variable refViewIdX is set equal to the view_id of the inter-view reference component refIdxLX if TextureFirstFlag \nis equal to 0 and set equal to 0 otherwise. \nThe variable shiftedX is set to ( TextureFirstFlag ? ( DvMBX >> 2 ) : 0 ). \nThe motion vector mvLX, with X being replaced by 0 or 1, is derived as follows. \n–  The depth-based disparity value derivation process in clause J.8.2.1.1 is invoked with depthPic equal to DepthCurrPic, \ntextureX equal to x1 + dx1 + shiftedX, textureY equal to y1 + dy1, tBlWidth equal to the width the macroblock \npartition mbPartIdx, tBlHeight equal to the height the macroblock partition mbPartIdx, srcViewId equal to view_id \nand refViewId equal to the refViewIdX as inputs and the output assigned to mvLX[ 0 ]. \n–  mvLX[ 1 ] is set equal to 0. \nJ.8.2.1.7  Derivation process for luma motion vector prediction \nInputs to this process are: \n–  the macroblock partition index mbPartIdx, \n–  the sub-macroblock partition index subMbPartIdx, \n    Rec. ITU-T H.264 (06/2019)  795 \n \n–  the reference index of the current partition refIdxLX (with X being 0 or 1), \n–  the variable currSubMbType. \nOutput of this process is the prediction mvpLX of the motion vector mvLX (with X being 0 or 1). \nThe specifications of clause 8.4.1.3 apply with the following changes. \n–  The following additional sentence is applied \n–  If refIdxLX is not equal to refIdxLXN for any N = A, B, or C and X equal to 0 or 1, the following applies: \nmbAddrN\\mbPartIdxN\\subMbPartIdxN is marked as not available \nrefIdxLXN = -1 \nmvLXN 0 ] = 0    (J-42) \nmvLXN[ 1 ] = 0 \nafter the following paragraph in clause 8.4.1.3: \n–  The derivation process for the neighbouring blocks for motion data in clause 8.4.1.3.2 is invoked with \nmbPartIdx, subMbPartIdx, currSubMbType, and listSuffixFlag = X (with X being 0 or 1 for refIdxLX being \nrefIdxL0 or refIdxL1, respectively) as the input and with mbAddrN\\mbPartIdxN\\subMbPartIdxN, reference \nindices refIdxLXN and the motion vectors mvLXN with N being replaced by A, B, or C as the output \n–  The following additional sentence is applied \n–  Otherwise, if refIdxLX is a reference index to an inter-view reference component or an inter-view only \nreference component, the depth-based derivation process for median luma motion vector prediction in \nclause J.8.2.1.7.1 is invoked with mbAddrN\\mbPartIdxN\\subMbPartIdxN, mvLXN, refIdxLXN with N \nbeing replaced by A, B, or C, and refIdxLX as the inputs and the output is assigned to the motion vector \npredictor mvpLX. \n–  Otherwise, if refIdxLX is a reference index to a reference picture which is not an inter-view reference \ncomponent or an inter-view only reference component, the depth-based derivation process for median luma \ntemporal  motion  vector  prediction  in  clause J.8.2.1.7.2  is  invoked  with \nmbAddrN\\mbPartIdxN\\subMbPartIdxN, mvLXN, refIdxLXN with N being replaced by A, B, or C, and \nrefIdxLX as the inputs and the output is assigned to the motion vector predictor mvpLX. \nafter the following paragraph in clause 8.4.1.3 \n–  Otherwise, if MbPartWidth( mb_type ) is equal to 8, MbPartHeight( mb_type ) is equal to 16, mbPartIdx is \nequal to 1, and refIdxLXC is equal to refIdxLX, the motion vector predictor mvpLX is set equal to mvLXC. \nJ.8.2.1.7.1  Depth-based derivation process for median luma motion vector prediction \nInputs to this process are: \n–  the neighbouring partitions mbAddrN\\mbPartIdxN\\subMbPartIdxN (with N being replaced by A, B, or C), \n–  the motion vectors mvLXN (with N being replaced by A, B, or C) of the neighbouring partitions, \n–  the reference indices refIdxLXN (with N being replaced by A, B, or C) of the neighbouring partitions,, \n–  the reference index refIdxLX of the current partition. \nOutput of this process is the motion vector prediction mvpLX. \nWhen either partition mbAddrN\\mbPartIdxN\\subMbPartIdxN is not available or refIdxLXN is not equal to refIdxLX, \nmvLXN is derived as specified by the following: \n–  If TextureFirstFlag is equal to 0, the following steps apply in order: \n1.  The inverse macroblock scanning process as specified in clause 6.4.1 is invoked with CurrMbAddr as the input \nand the output is assigned to ( x1, y1 ). \n2.  The inverse macroblock partition scanning process specified in clause 6.4.2.1 is invoked with mbPartIdx as the \ninput and the output assigned to ( dx1, dy1 ). \n3.  The inverse sub-macroblock partition scanning process specified in clause J.6.1 is invoked with mbPartIdx and \nsubMbPartIdx as the input and the output assigned to ( dx2, dy2 ). \n796  Rec. ITU-T H.264 (06/2019) \n \n4.  The modification process of inter-view motion vector in median luma motion vector prediction as specified in \nclause J.8.2.1.7.1.1 is invoked with depthPic being equal to DepthRefPicList0[ refIdxL0 ], mbx1 being equal to \nx1 and mby1 being equal to y1 as inputs and the output is assigned to the motion vector mvLXN. \n–  Otherwise (TextureFirstFlag is equal to 1), mvLXN is set equal to ( DvMBX , 0 ). \nEach component of the motion vector prediction mvpLX is given by the median of the corresponding vector components \nof the motion vector mvLXA, mvLXB, and mvLXC: \nmvpLX[ 0 ] = Median( mvLXA[ 0 ], mvLXB[ 0 ], mvLXC[ 0 ] )   (J-43) \nmvpLX[ 1 ] = Median( mvLXA[ 1 ], mvLXB[ 1 ], mvLXC[ 1 ] )  (J-44) \nJ.8.2.1.7.1.1 Modification process for inter view motion vector in median luma motion vector prediction \nInputs to this process are: \n–  depth reference view component depthPic, \n–  the location of a top-left sample ( mbx1, mby1 ) of the current macroblock. \nOutput of this process is the motion vector mv. \nLet refViewId be the view_id value of depthPic. \nThe variable mv is derived as follows: \n–  The depth-based disparity value derivation process in clause J.8.2.1.1is invoked with depthPic equal to DepthCurrPic, \ntextureX equal to mbx1, textureY equal to mby1, tBlWidth equal to 16, tBlHeight equal to 16, srcViewId equal to \nview_id and refViewId equal to the refViewId as inputs and the output assigned to mv[ 0 ]. \n–  mv[ 1 ] is set equal to 0. \nJ.8.2.1.7.2  Depth-based derivation process for median luma temporal motion vector prediction \nInputs to this process are: \n–  the neighbouring partitions mbAddrN\\mbPartIdxN\\subMbPartIdxN (with N being replaced by A, B, or C), \n–  the motion vectors mvLXN (with N being replaced by A, B, or C) of the neighbouring partitions, \n–  the reference indices refIdxLXN (with N being replaced by A, B, or C) of the neighbouring partitions, \n–  the reference index refIdxLX of the current partition. \nOutput of this process is the motion vector prediction mvpLX. \nWhen either partition mbAddrN\\mbPartIdxN\\subMbPartIdxN is not available or refIdxLXN is not equal to refIdxLX, \nmvLXN is derived as specified by the following ordered steps: \n1.  When TextureFirstFlag is equal to 0, the inverse macroblock scanning process as specified in clause 6.4.1 is \ninvoked with CurrMbAddr as the input and the output is assigned to ( x1, y1 ). \n2.  When TextureFirstFlag is equal to 0, the inverse macroblock partition scanning process specified in clause 6.4.2.1 \nis invoked with mbPartIdx as the input and the output assigned to ( dx1, dy1 ). \n3.  When  TextureFirstFlag  is  equal  to  0,  the  inverse  sub-macroblock  partition  scanning  process  specified  in \nclause J.6.1 is invoked with mbPartIdx and subMbPartIdx as the input and the output assigned to ( dx2, dy2 ). \n4.  When TextureFirstFlag is equal to 0, the process specified in clause J.8.2.1.7.2.1 is invoked with depthPic set to \nDepthCurrPic, mbx1 set to x1, mby1 set to y1 and listSuffixFlag as input and InterViewPic, an offset vector dV \nand a variable interViewAvailable as outputs. \n5.  When TextureFirstFlag is equal to 1, dV is set equal to ( DvMBX , 0 ) and a variable interViewAvailable is set \nequal to InterViewRefAvailable. \n6.  The refIdxCorrespond and mvCorrespond are set as follows. \n–  If  interViewAvailable  is  equal  to  0,  refIdxCorrespond  is  set  to  -1,  and  mvCorrespond[ 0 ]  and \nmvCorrespond[ 1 ] are both set to 0. \n–  Otherwise, the following steps apply in order. \n–  The variable luma4x4BlkIdx is set equal to ( 4 * mbPartIdx + subMbPartIdx ). \n    Rec. ITU-T H.264 (06/2019)  797 \n \n–  The  inverse  4x4  luma  block  scanning  process  as  specified  in  clause 6.4.3  is  invoked  with \nluma4x4BlkIdx as the input and ( x, y ) as the output. In addition, ( xCorrespond, yCorrespond ) is set \nequal  to  ( x  +  ( dV[ 0 ]  >>  4 ),  y  +  ( dV[ 1 ]  >>  4 ) )  and  mbAddrCorrespond  is  set  equal  to \n( ( CurrMbAddr  /  PicWidthInMbs )  +  ( dV[ 1 ]  >>  6 ) )  *  PicWidthInMbs  +  ( CurrMbAddr  % \nPicWidthInMbs ) + ( dV[ 0 ] >> 6 ). \n–  Set  mbTypeCorrespond  to  the  syntax  element  mb_type  of  the  macroblock  with  address \nmbAddrCorrespond inside the picture InterViewPic. When mbTypeCorrespond is equal to P_8x8, \nP_8x8ref0, or B_8x8, subMbTypeCorrespond is set to be the syntax element sub_mb_type of the \nmacroblock with address mbAddrCorrespond inside the picture InterViewPic. \n–  Set  mbPartIdxCorrespond  to  the  macroblock  partition  index  of  the  corresponding  partition  and \nsubMbPartIdxCorrespond to the sub-macroblock partition index of the corresponding sub-macroblock \npartition. The derivation process for macroblock and sub-macroblock partition indices as specified in \nclause 6.4.13.4  is  invoked  with  the  luma  location  equal  to  ( xCorrespond, yCorrespond ),  the \nmacroblock  type  equal  to  mbTypeCorrespond,  and  when  mbTypeCorrespond  is  equal  to  P_8x8, \nP_8x8ref0, or B_8x8, the list of sub-macroblock types subMbTypeCorrespond as the inputs and the \noutputs are the macroblock partition index mbPartIdxCorrespond and the sub-macroblock partition \nindex subMbPartIdxCorrespond. \n–  The motion vector mvCorrespond and the reference index refIdxCorrespond are derived as follows. \n–  If the macroblock mbAddrCorrespond is coded as Intra prediction mode, both components of \nmvCorrespond are set equal to 0 and refIdxCorrespond is set equal to −1. \n–  Otherwise  (the  macroblock  mbAddrCorrespond  is  not  coded  as  Intra  prediction  mode),  the \nprediction  utilization  flags  predFlagLXCorrespond  is  set  equal  to \nPredFlagLX[ mbPartIdxCorrespond ], the prediction utilization flag of the macroblock partition \nmbAddrCorrespond\\mbPartIdxCorrespond of the picture InterViewPic. In addition, the following \napplies. \n–  When predFlagLXCorrespond is equal to 1, the mvCorrespond and the reference index \nrefIdxCorrespond  are  set  equal  to \nMvLX[ mbPartIdxCorrespond ][ subMbPartIdxCorrespond ]  and \nRefIdxLX[ mbPartIdxCorrespond ], respectively, which are the motion vector mvLX and \nthe reference index refIdxLX that have been assigned to the (sub-)macroblock partition \nmbAddrCorrespond\\mbPartIdxCorrespond\\subMbPartIdxCorrespond  inside  the  picture \nInterViewPic. \n7.  The motion vectors mvLXN is derived as follows. \n–  If refIdxCorrespond is equal to refIdxLX, the following applies: \nmvLXN[ 0 ] = mvCorrespond[ 0 ] \nmvLXN[ 1 ] = mvCorrespond[ 1 ]    (J-45) \n–  Otherwise, the following applies: \nmvLXN[ 0 ] = 0 \nmvLXN[ 1 ] = 0 \n8.  The following applies for the derivation of mvpLX[ 0 ] and mvpLX[ 1 ]: \nmvpLX[ 0 ] = Median( mvLXA[ 0 ], mvLXB[ 0 ], mvLXC[ 0 ] )  (J-46) \nmvpLX[ 1 ] = Median( mvLXA[ 1 ], mvLXB[ 1 ], mvLXC[ 1 ] )  (J-47) \nJ.8.2.1.7.2.1 Derivation process for the disparity vector and the inter-view reference \nInputs to this process are depth reference view component depthPic, the location of a top-left sample ( mbx1, mby1 ) of \nthe current macroblock and the listSuffixFlag. \nOutputs of this process are a picture InterViewPic, an offset vector dV and a variable interViewAvailable. \nThe variable interViewAvailable is set equal to 0. \nThe following applies to derive an inter-view reference picture or inter-view only reference picture, InterViewPic, with X \nset to 1 when listSuffixFlag is 1 or 0 otherwise: \n798  Rec. ITU-T H.264 (06/2019) \n \nfor( cIdx = 0;cIdx<num_ref_idx_l0_active_minus1 + 1 && !interViewAvailable; cIdx ++ ) \n  if ( view order index of RefPicList0[ cIdx ] is not equal to view_idx) { \n    InterViewPic = RefPicList0[ cIdx ]    (J-48) \n    interViewAvailable = 1 \n  } \nWhen interViewAvailable is equal to 1, the depth-based disparity value derivation process in clause J.8.2.1.1 is invoked \nwith depthPic equal to DepthCurrPic, textureX equal to mbx1, textureY equal to mby1, tBlWidth equal to 16, tBlHeight \nequal to 16, srcViewId equal to view_id and refViewId equal to view_id of InterViewPic as inputs and the output assigned \nto dV. \nJ.8.2.1.8  Macroblock-level neighbouring block based disparity vector derivation process \nInput to this process is a macroblock currMB. \nLet the variable availableDvFlag equal to 0, ( xP, yP ) be equal to the output of the clause 6.4.2.1 (the location of upper-\nleft luma sample for currMB partition 0). \nThe variables dvMBCur and DvMBX are derived as specified by the following ordered steps: \n1.  For each X from 0 to 1, the following steps apply in order. \n–  When availableDvFlag is equal to 0 and RefPicListY[ 0 ] is available (with Y equal to 1-X), the \nfollowing applies: \n–  Set refPicListCol0 to the reference picture list 0 of RefPicListY[ 0 ]. \n–  mvColL0 and refIdxColL0 are set to the motion vector mvL0 and reference index refIdxL0 that \nhave  been  assigned  to  the  block  covering  ( xP + 16,  yP + 16 )  in  picture  RefPicListY[ 0 ], \nrespectively. \n–  When  refPicListCol0[ refIdxColL0 ]  is  available,  the  view  order  index  of \nrefPicListCol0[ refIdxColL0 ] is unequal to the view_idx, and mvColL0[ 0 ] is unequal to 0, \ndvMBCur is set equal to mvColL0[ 0 ] and availableDvFlag is set to 1. \n2.  The process in clause 6.4.11.7 is invoked with mbPartIdx equal to 0, currSubMbType equal to P_L0_16x16, and \nsubMbPartIdx equal to 0 as input and the output is assigned to mbAddrN\\mbPartIdxN\\subMbPartIdxN with N being \nreplaced by A, B, C, or D. For each N being A, B, C and D, its reference index refIdxL0N and motion vector mvL0N \nare set equal to RefIdxL0[ mbPartIdxN ] and MvL0[ mbPartIdxN ][ subMbPartIdxN ], respectively, which are the \nreference  index  refIdxL0  and  motion  vector  mvL0  that  have  been  assigned  to  the  (sub-)macroblock  partition \nmbAddrN\\mbPartIdxN\\subMbPartIdxN, and when availableDvFlag is equal to 0, the following applies: \n–  When  RefPicList0[ refIdxL0N ]  is  available  and  the  view  order  index  of  RefPicList0[ refIdxL0N ]  is \nunequal  to  the  view_idx,  and  mvL0N[ 0 ]  is  unequal  to  0,  dvMBCur  is  set  to  mvL0N[ 0 ]  and \navailableDvFlag is set to 1. \n3.  When availableDvFlag is equal to 0, dvMBCur is set to DvMBX. \n4.  When seq_view_synthesis_flag is equal to 1, the following steps apply in order. \n–  The variables currIndex and refIndex are derived by: \ncurrIndex = ViewIdTo3DVAcquisitionParamIndex( view_id of the current view ) \nrefIndex = ViewIdTo3DVAcquisitionParamIndex( view_id of DepthCurrPic )  (J-49) \n–  The depth-based disparity value derivation process in clause J.8.2.1.1 is invoked with depthPic equal to \nDepthCurrPic,  ( textureX , textureY )  equal  to  ( xP + (dvMBCur>>2) ,  yP ),  tBlWidth  equal  to  16, \ntBlHeight equal to 16, srcViewId equal to currIndex and refViewId equal to refIndex and the output \nassigned to dvMBCur. \n5.  DvMBX is set equal to dvMBCur. \nJ.8.2.2  Derivation of prediction weights in depth-range-based weighted prediction \nThe process specified in this clause is invoked when either or both of the following conditions apply: \n–  nal_unit_type is equal to 21 and depth_weighted_pred_flag is equal to 1 and (slice_type % 5) is equal to 0 or 3, \n–  depth_weighted_bipred_flag is equal to 1 and (slice_type % 5) is equal to 1 \nInputs to this process are: \n    Rec. ITU-T H.264 (06/2019)  799 \n \n–  the reference indices refIdxL0 and refIdxL1, \n–  the prediction utilization flags predFlagL0 and predFlagL1. \nOutputs of this process are variables for weighted prediction logWD , w , w , o , and o  with C being replaced by L \nC 0C 1C 0C 1C\n(luma). \nThe variables currIndex, refIndex, dpsIdCurr and dpsIdRef are derived as follows: \nlogWD  = 5      (J-50) \nC\ncurrIndex = ViewIdTo3DVAcquisitionParamIndex( view_id of the current view )  (J-51) \nrefIndex = ViewIdTo3DVAcquisitionParamIndex( view_id of the view of the reference picture)  (J-52) \ndpsIdCurr = dps_id of the current picture    (J-53) \ndpsIdRef = dps_id of the reference picture    (J-54) \nWhen predFlagL0 is equal to 1, the following is applied. \n–  The  derivation  process  for  a  single  prediction  weight  in  depth-range-based  weighted  prediction  specified  in \nclause J.8.2.2.1 is invoked with zNearCurr equal to ZNear[ dpsIdCurr, currIndex ], zFarCurr equal to ZFar[ dpsIdCurr, \ncurrIndex ],  zNearRef  equal  to  ZNear[ dpsIdRef,  refIndex ],  zFarRef  equal  to  ZFar[ dpsIdRef,  refIndex ],  and \nreference list identifier X equal to 0. \nWhen predFlagL1 is equal to 1 and depth_weighted_bipred_flag is equal to 1, the following is applied. \n–  The derivation process for a single prediction weight in depth-range-based weighted prediction specified in \nclause J.8.2.2.1 is invoked with zNearCurr equal to ZNear[ dpsIdCurr, currIndex], zFarCurr equal to ZFar[ dpsIdCurr, \ncurrIndex  ], zNearRef equal to ZNear[ dpsIdRe, refIndex ], zFarRef equal to ZFar[ dpsIdRef, refIndex ], and reference list \nidentifier X equal to 1. \nJ.8.2.2.1  Derivation of weight and offset parameteres \nInputs of this process are variables zNearCurr, zNearRef, zFarCurr, and zFarRef and the reference list identifier X with X \nbeing replaced by 0 or 1. \nOutputs of this process are variables w  and o  for weighted prediction. \nXC XC\nThe variable w  with X being replaced by 0 or 1 and C being replaced by L is calculated by the following steps. \nXC\n1.  scaleW is set equal to 8. \n2.  Calculate variable wFactorA as follows: \nk = zFarRef − zNearRef  \nm = zFarRef \nx = ( k + ( m >> 1 ) ) / m \nsignVal = ( ( k − x * m ) < 0 ) ? −1 : 1    (J-55) \nwFactorA = ( x << scaleW  ) \nwFactorA += ( ( ( k − x * m ) << scaleW ) + signVal * ( m >> 1 ) ) / m \n3.  Calculate variable wFactorB as follows: \nk = zFarCurr \nm = zFarCurr − zNearCurr \nx = ( k + ( m >> 1 ) ) / m \nsignVal = ( ( k − x * m ) < 0 ) ? −1 : 1    (J-56) \nwFactorB = ( x << scaleW ) \nwFactorB += ( ( ( k − x * m ) << scaleW ) + signVal * ( m >> 1) ) / m \n4.  Calculate variable wFactorC as follows: \nk = zNearCurr \nm = zNearRef \nx = ( k + ( m >> 1 ) ) / m    (J-57) \nsignVal = ( ( k − x * m ) < 0 ) ? −1 : 1 \nwFactorC = ( x << scaleW ) \nwFactorC += ( ( ( k − x * m ) << scaleW ) + signVal * ( m >> 1 ) ) / m \n5.  Calculate variable w : \nXC\n800  Rec. ITU-T H.264 (06/2019) \n \nw  = ( wFactorA * wFactorB * wFactorC + ( 1 << ( scaleW * 3 − logWD  − 1 ) ) ) \nXC C\n      >> ( scaleW * 3 − logWD  ) \nC\nw  = Clip( −127, 128, w  )    (J-58) \nXC XC\nThe variable o  is calculated by the following steps: \nXC\n1.  scaleO is set equal to 8. \n2.  Calculate variable oFactorA as follows: \noFactorA=( ( zNearCurr << ( scaleO ) ) + ( zFarRef >> 1 ) ) / zFarRef    (J-59) \n3.  Calculate variable oFactorB: \nk = zFarCurr − zFarRef \nm = zFarCurr − zNearCurr \nsignVal= ( k < 0 ) ? −1 : 1 \nx = ( k + signVal * ( m >> 1 ) ) / m    (J-60) \nsignVal = ( ( k − x * m ) < 0 ) ? −1 : 1 \noFactorB = ( x << scaleO ) \noFactorB += ( ( ( k − x * m ) << scaleO ) + signVal * ( m >> 1 ) ) / m \n4.  Calculate variable o : \nXC\no  = ( oFactorA * oFactorB + ( 1 << ( scaleO * 2 − 8 − 1 ) ) ) >> ( scaleO * 2 − 8 )  (J-61) \nXC\no  = Clip( −127, 128, o  ) \nXC XC\nJ.8.2.3  Derivation process for motion vectors and reference indices for adaptive luminance compensation \nInputs to this process are: \n–  a macroblock partition mbPartIdx, \n–  a sub-macroblock partition subMbPartIdx. \nOutputs of this process are: \n–  luma motion vectors mvL0 and mvL1 and when ChromaArrayType is not equal to 0, the chroma motion vectors \nmvCL0 and mvCL1, \n–  reference indices refIdxL0 and refIdxL1, \n–  prediction list utilization flags predFlagL0 and predFlagL1, \n–  a motion vector count variable subMvCnt. \nThe motion vector count variable subMvCnt is set equal to 1. \nSet interViewAvailable equal to 0. \nThe reference index refIdxL0 for a skipped macroblock is derived as: \nfor( cIdx = 0; cIdx  <=  num_ref_idx_l0_active_minus1 && !interViewAvailable; cIdx ++ ) \n  if (RefPicList0[ cIdx ] and the current view component have different values of view oder index) { \n    refIdxL0 = cIdx    (J-62) \n    interViewAvailable = 1 \n  } \nIf dmvp_flag is equal to 1 and mb_alc_skip_flag is equal to 1, clause J.8.2.1.7 is invoked and mvL0 is set equal to mvpL0, \nthe output of clause J.8.2.1.7. \nOtherwise, if dmvp_flag is equal to 1 and mb_alc_ flag is equal to 1, clause J.8.2.1 is invoked for derivation of mvL0. \nOtherwise, clause 8.4.1 is invoked and mvL0 is set equal to mvpL0, the output of clause 8.4.1. \nJ.8.2.4  Derivation process for prediction weights in adaptive luminance compensation \nInputs to this process are: \n–  reference index refIdxL0 \n    Rec. ITU-T H.264 (06/2019)  801 \n \n–  the luma sample array of the selected reference picture refPicL0L. \n–  the current partition given by its partition index mbPartIdx and its sub-macroblock partition index subMbPartIdx \n–  Luma4x4BlkIdx \n–  the width and height partWidth, partHeight of this partition in luma-sample units \n–  a luma motion vector mvL0 given in quarter-luma-sample units \n–  array cSL containing already constructed luma samples prior to deblocking filter process. \nOutputs of this process are: \n–  variables for weighted prediction of the current partition logWD , w , w , o , o , with C being replaced by \nC 0C 1C 0C 1C\nL and, when ChromaArrayType is not equal to 0, Cb and Cr. \nThe variables W  , O  are derived as follows for C equal to L, Cb or Cr: \n1C 1C\nlogWD  = 0      (J-63) \nC\nw  = 0        (J-64) \n1C\no  = 0         (J-65) \n1C\nThe variables W , O  are derived as follows for C if equal to Cb or Cr: \n0C 0C\nlogWD  = 0      (J-66) \nC\nw  = 1        (J-67) \n0C\no =0        (J-68) \n0C\nWhen C is equal to L for luma samples, clauses J.8.2.4.1 through J.8.2.4.5 are invoked sequentially to derive LogWD  \nL,\nw , and o . \n0C 0C\nJ.8.2.4.1  Defining of coordinates and sizes of a luma block to be predicted \nLet ( xM, yM ) be equal to the output of clause 6.4.1 (the location of upper-left luma sample for the current macroblock \nwith address mbAddr relative to the upper-left sample of the picture). \nLet ( xP, yP ) be equal to the output of clause 6.4.2.1 (the location of upper-left luma sample for the macroblock partition \nmbPartIdx). \nLet ( xB, yB ) be equal to the output of clause J.6.1 (the location of upper-left luma sample for the 4x4 luma block defined \nby Luma4x4BlkIdx that can be 0...15) relative to the top-left sample of the sub-macroblock. \nThe variables xT, yT, xBlockWidth, yBlockHeight are set as follows: \n–  xT is set equal to xM + xP; \n–  yT is set equal to yM +yP; \n–  xBlockWidth is set equal to MbPartWidth( mb_type ); \n–  yBlockHeight is set equal to MbPartHeight( mb_type ); \nIf one or more of the following conditions are true, W  is set equal to 1 and logWD  is set equal to 15. \n0C C\n–  ( mvL0[ 0 ] + ( ( xT − 1 ) << 2 ) ) is smaller than 0; \n–  ( mvL0[ 1 ] + ( ( yT − 1 ) << 2 ) ) is smaller than 0; \n–  ( mvL0[ 0 ] + (( xT + xBlockWidth ) << 2 ) ) is greater than or equal to ( PicWidthInSamples  << 2 ); \nL\n–  ( mvL0[ 1 ] + ( ( yT + yBlockHeight) << 2 ) ) is greater than or equal to ( PicHeightInSamples  << 2 ). \nL\nOtherwise LRef, URef, LRec, URec sample values are derived as it is specified in clauses J.8.2.4.2 and J.8.2.4.3 followed \nby calculation of variables NeighbourRefSum, NeighbourSum and W , O  specified in clauses J.8.2.4.4 and J.8.2.4.5 \n0L 0L\ncorrespondently. \nJ.8.2.4.2  Deriving of left and up reference samples of the current block \nLRec and URec blocks belong to an (PicWidthInSamples )x(PicHeightInSamples ) array cSL containing constructed luma \nL L\nsamples prior to the deblocking filter process. \nEach luma sample LRec[ 0, yL ] for 0 <= yL < yBlockHeight is specified as follows: \n802  Rec. ITU-T H.264 (06/2019) \n \nLRec[ 0, yL ] = cSL[ xT − 1, yT + yL ]    (J-69) \nEach luma sample URec[ xL, 0 ]  for 0 <= xL < xBlockWidth is specified as follows: \nURec[ xL, yL ] = cSL[ xT + xL, yT − 1]    (J-70) \nJ.8.2.4.3  Deriving of left and up reference samples of the reference block \nFor each luma sample location (0, y ) such as: 0<=y < yBlockHeight inside LRef block, sample value LRef[ 0, y  ] is \nL L L\nderived by the following ordered steps: \n1.  The variables xIntL, yIntL, xFracL, and yFracL are derived by: \nxInt  = xT + ( mvL0[ 0 ] >> 2 ) - 1    (J-71) \nL\nyInt  = yT + ( mvL0[ 1 ] >> 2 ) + y     (J-72) \nL L\nxFrac = mvL0[ 0 ] & 3    (J-73) \nL\nyFrac = mvL0[ 1 ] & 3    (J-74) \nL\n2.  LRef[ 0, yL ] sample is derived as an output of the process specified in clause 8.4.2.2.1 with ( xIntL, yIntL), \n( xFracL, yFracL ) and refPicL0L given as input. \nFor each luma sample location ( x , 0 ) such as: 0<=x < xBlockWidth inside URef block sample value URef[ x , 0 ] is \nL L L\nderived by the following ordered steps: \n1.  The variables xIntL, yIntL, xFracL, and yFracL are derived by: \nxIntL = xT + ( mvL0[ 0 ] >> 2 ) + x     (J-75) \nL\nyIntL = yT + ( mvL0[ 1 ] >> 2 ) − 1    (J-76) \nxFrac  = mvL0[ 0 ] & 3    (J-77) \nL\nyFrac = mvL0[ 1 ] & 3    (J-78) \nL\n2.  URef[ x , y  ] sample is derived as an output of the process specified in clause 8.4.2.2.1 with ( xIntL, yIntL ), \nL L\n( xFrac , yFrac  ) and refPicL0  given as input. \nL L L\nJ.8.2.4.4  Deriviation of NeighbourRefSum and NeighbourSum \nBoth NeighbourRefSum and NeighbourSum are set equal to 1 and further calculated as follows: \nfor( j=0; j< yBlockHeight;j++ ) \n  if ( Abs( LRec[ 0, j ] − LRef[ 0, j ] ) < 31 ) { \n    NeighbourRefSum = NeighbourRefSum + LRef[ 0, j ]  (J-79) \n    NeighbourSum = NeighbourSum + LRec[ 0, j ] \n  } \nfor( i=0; i< xBlockWidth; i++ ) \n  if ( Abs( URec[ i, 0 ] − URef[ i , 0 ] ) < 31 ) { \n    NeighbourRefSum = NeighbourRefSum + URef[ i, 0 ]  (J-80) \n    NeighbourSum = NeighbourSum + URec[ i, 0 ] \n  } \nJ.8.2.4.5  Deriviation of prediction weights \nO  is set equal to 0. W  and LogWD  are derived as follows: \n0L 0L L\nIf (NeighbourSum >> 4) is equal to (NeighbourRefSum >> 4), W  is set equal to 1 and LogWD  is set equal to 0. \n0L L\nOtherwise,  LogWD   is  set  equal  to  15  and  W is  equal  to \nL 0L \n( ( 1 << LogWD ) * NeighbourSum + ( NeighbourRefSum >> 1 ) ) / NeighbourRefSum. \nL \nJ.8.3  Specification of bitstream subsets \nThe specifications of clause I.8.5 apply. \nJ.8.4  Decoding process for depth range parameters \nThis process is invoked for decoding of the depth_ranges( ) syntax structure in sequence parameter set 3D-AVC extension \nand for decoding of a depth parameter set RBSP. \nInputs of this process are the variables obtained from parsing the active depth range parameter set RBSP: \n    Rec. ITU-T H.264 (06/2019)  803 \n \n–  the variables relative to the closest depth: ZNearSign[ dps_id, i ], ZNearExp[ dps_id, i ], ZNearMantissa[ dps_id, i ], \nZNearManLen[ dps_id, i ]; \n–  the variables relative to the farthest depth: ZFarSign[ dps_id, i ], ZFarExp[ dps_id, i ], ZNearMantissa[ dps_id, i ], \nZNearManLen[ dps_id, i ] \nwhere i is the index to the order of views for 3DV acquisition parameters. \nOutputs of this process are \n–  the closest depth values ZNear[ dps_id, i ] and the respective variables respective variables ZNearSign[ dps_id, i ], \nZNearExponent[ dps_id, i ], ZNearMantissa[ dps_id, i ], ZNearManLen[ dps_id, i ]; \n–  the farthest depth values ZFar[ dps_id, i ] and the respective variables respective variables ZFarSign[ dps_id, i ], \nZFarExponent[ dps_id, i ], ZFarMantissa[ dps_id, i ], ZFarManLen[ dps_id, i ]. \nSome of the views for which the 3DV acquisition parameters are specified may not be present in the coded video sequence. \nThe output variables x in Table J-4 are derived as follows from the respective variables f, s, e, n, and v indicated in \nTable J-4. \n–  If f is equal to 0 in the depth parameter set RBSP, f in the active sequence parameter set 3D-AVC extension shall be \nequal to 1 and x[ dps_id, i ] = x[ 0, i ], s[ dps_id, i ] = s[ 0, i ], e[ dps_id, i ] = e[ 0, i ], and n[ dps_id, i ] = n[ 0, i ] for \nall values of i. \n–  Otherwise (f is equal to 1 in the depth parameter set RBSP), the variable x computed as follows for [ dps_id, i ] \nwhere i is index to the order of views for 3DV acquisition parameters: \n–  If f is equal to 0 in the depth parameter set RBSP, f in the active sequence parameter set 3D-AVC extension shall be \nequal to 1 and x[ dps_id, i ] = x[ 0, i ], s[ dps_id, i ] = s[ 0, i ], e[ dps_id, i ] = e[ 0, i ], and n[ dps_id, i ] = n[ 0, i ] for \nall values of i. \n–  Otherwise (f is equal to 1 in the depth parameter set RBSP), the variable x computed as follows for [ dps_id, i ] where \ni is index to the order of views for 3DV acquisition parameters: \n–  If 0 < e < 127, x = ( −1 )s * 2( e − 31 ) * ( 1 + n ÷ 2v ). \n–  Otherwise (e is equal to 0), x = ( −1 )s * 2−( 30 + v ) * n. \nNOTE – The above specification is similar to that found in IEC 60559:1989, Binary floating-point arithmetic for microprocessor \nsystems. \nTable J-4 – Association between depth parameter variables and syntax elements \nx  f  s  E  n  v \nZNear  z_near_flag  ZNearSign  ZNearExp  ZNearMantissa  ZNearManLen \nZFar  z_far_flag  ZFarSign  ZFarExp  ZFarMantissa  ZFarManLen \n \nJ.9  Parsing process \nThe specifications in clause 9 apply. Additionally, the following modifications are specified and added. \nJ.9.1  Alternative CABAC parsing process for slice data and macroblock layer in depth extension \nClause J.9.1.1 specifies the initialization process for the alternative CABAC parsing process for slice data and macroblock \nlayer when nal_unit_type is equal to 21 and avc_3d_extension_flag is equal to 1. \nClause J.9.1.2 specifies the binarization process for the alternative CABAC parsing process for slice data and macroblock \nlayer when nal_unit_type is equal to 21 and avc_3d_extension_flag is equal to 1 \nClause J.9.1.3  specifies  the  decoding  process  flow  for  the  alternative  CABAC  parsing  process  for  slice  data  and \nmacroblock layer when nal_unit_type is equal to 21 and avc_3d_extension_flag is equal to 1. \nJ.9.1.1  Initialization process \nOutputs of this process are the initialized CABAC context variables indexed by ctxIdx. \nTable J-6 contains the values of the variables n and m used in the initialization of context variables that are assigned to \nsyntax elements mb_vsskip_flag, and mb_direct_type_flag. Table J-7 contains the values of the variables n and m used in \nthe  initialization  of  context  variables  that  are  assigned  to  syntax  element  mb_skip_run_type,  mb_alc_skip_flag, \n804  Rec. ITU-T H.264 (06/2019) \n \nmb_alc_flag and mb_vsp_flag. The initialization proces for two variables pStateIdx and valMPS is the same as other syntax \nelements, as defined in Equation 9-5. For all other syntax elements in clause 7.3.5 the initialization process of context \nvariables as specified in clause 9.3.1 applies. \nTable J-5 – Association of ctxIdx and syntax elements in the initialization process \nSlice type \nSyntax element  Table \nI  P  B \nmb_vsskip_flag  Table J-6    1031..1033  1034..1036 \nmb_direct_type_flag  Table J-6      1037..1039 \nmb_skip_run_type  Table J-7      1040 \nmb_alc_skip_flag  Table J-7    1041 .. 1043   \nmb_alc_flag  Table J-7    1044 .. 1046   \nmb_vsp_flag  Table J-7    1047..1049  1050..1052 \n \n \nTable J-6 – Values of variables m and n for ctxIdx from 1031 to 1039 \nValue of  ctxIdx \nInitializatio\ncabac_init_idc \nn variables \n1031  1032  1033  1034  1035  1036  1037  1038  1039 \n0  m  23  23  21  18  9  29  −46  −20  1 \nn  33  2  0  64  43  0  127  104  67 \n1  m  22  34  16  26  19  40  −45  −15  −4 \nn  25  0  0  34  22  0  127  101  76 \n2  m  29  25  14  20  20  29  −32  −22  −2 \nn  16  0  0  40  10  0  127  −117  74 \n \nTable J-7 – Values of variables m and n for ctxIdx from 1040 to 1052 \nctxIdx \nInitialization \nvariables \n1040  1041  1042  1043  1044  1045  1046  1047  1048  1049  1050  1051  1052 \nm  18  14  14  10  14  14  10  0  0  0  0  0  0 \nn  64  4  27  52  4  27  52  64  64  64  64  64  64 \n \nJ.9.1.2  Binarization process \nInput to this process is a request for a syntax element. \nOutput of this process is the binarization of the syntax element, maxBinIdxCtx, ctxIdxOffset, and bypassFlag. \nAssociated with each binarization or binarization part of a syntax element is a specific value of the context index offset \n(ctxIdxOffset) variable and a specific value of the maxBinIdxCtx variable as given in Table J-8. \nThe use of the DecodeBypass process and the variable bypassFlag is derived as follows: \n–  If no value is assigned to ctxIdxOffset for the corresponding binarization or binarization part in Table J-8 labelled as \n\"na\", all bins of the bit strings of the corresponding binarization or of the binarization prefix/suffix part are decoded \nby invoking the DecodeBypass process as specified in clause 9.3.3.2.3. In such a case, bypassFlag is set equal to 1, \n    Rec. ITU-T H.264 (06/2019)  805 \n \nwhere bypassFlag is used to indicate that for parsing the value of the bin from the bitstream the DecodeBypass process \nis applied. \n–  Otherwise, for each possible value of binIdx up to the specified value of maxBinIdxCtx given in Table J-8, a specific \nvalue of the variable ctxIdx is further specified in clause 9.3.3. bypassFlag is set equal to 0. \nThe possible values of the context index ctxIdx are in the range 1031 to 1052, inclusive. The value assigned to ctxIdxOffset \nspecifies the lower value of the range of ctxIdx assigned to the corresponding binarization or binarization part of a syntax \nelement. \nTable J-8 – Syntax elements and associated types of binarization, maxBinIdxCtx, and ctxIdxOffset \nSyntax element  Type of binarization  maxBinIdxCtx  ctxIdxOffset \nmb_vsskip_flag (P slices only)  FL, cMax=1  0  1031 \nmb_vsskip_flag (B slices only)  FL, cMax=1  0  1034 \nmb_direct_type_flag (B slices only)  FL, cMax=1  0  1037 \nmb_skip_run_type (B slices only)  FL, cMax=1  0  1040 \nmb_alc_skip_flag \nFL, cMax=1  0  1041 \nmb_alc_flag \nFL, cMax=1  0  1044 \nmb_vsp_flag (P slices only) \nFL, cMax=1  0  1047 \nmb_vsp_flag (B slices only) \nFL, cMax=1  0  1050 \n \nJ.9.1.3  Decoding process flow \nInput to this process is a binarization of the requested syntax element, maxBinIdxCtx, bypassFlag and ctxIdxOffset as \nspecified in clause 9.1.2. \nOutput of this process is the value of the syntax element. \nThis process specifies how each bit of a bit string is parsed for each syntax element. \nAfter parsing each bit, the resulting bit string is compared to all bin strings of the binarization of the syntax element and \nthe following applies. \n–  If the bit string is equal to one of the bin strings, the corresponding value of the syntax element is the output. \n–  Otherwise (the bit string is not equal to one of the bin strings), the next bit is parsed. \nWhile parsing each bin, the variable binIdx is incremented by 1 starting with binIdx being set equal to 0 for the first bin. \nThe parsing of each bin is specified by the following two ordered steps: \n1.  Given binIdx, maxBinIdxCtx and ctxIdxOffset, ctxIdx is derived as specified in clause J.9.1.3.1. \n2.  Given ctxIdx, the value of the bin from the bitstream as specified in clause 9.3.3.2 is decoded. \nJ.9.1.3.1  Derivation process for ctxIdx \nInputs to this process are binIdx, maxBinIdxCtx and ctxIdxOffset. \nOutput of this process is ctxIdx. \nTable J-9 shows the assignment of ctxIdx increments (ctxIdxInc) to binIdx for all ctxIdxOffset values for the syntax \nmb_vsskip_flag, mb_direct_type_flag, mb_alc_skip_flag, mb_alc_flag and mb_vsp_flag. \nThe ctxIdx to be used with a specific binIdx is the sum of ctxIdxOffset and ctxIdxInc, which is found in Table J-9. When \nmore than one value is listed in Table J-9 or 9-39 for a binIdx, the assignment process for ctxIdxInc for that binIdx is \nfurther specified in the clauses given in parenthesis of the corresponding table entry. \nAll  entries  in  Table J-9  labelled  with  \"na\"  correspond  to values  of  binIdx  that  do  not  occur  for  the  corresponding \nctxIdxOffset. \n806  Rec. ITU-T H.264 (06/2019) \n \nTable J-9 – Assignment of ctxIdxInc to binIdx for the ctxIdxOffset values related to the syntax elements \nmb_vsskip_flag, mb_direct_type_flag, mb_alc_skip_flag, mb_alc_flag and mb_vsp_flag \nbinIdx \nctxIdxOffset \n0  >= 1 \n0,1,2 \n1031  na \n(clause J.9.1.3.2) \n0,1,2 \n1034  na \n(clause J.9.1.3.2) \n0,1,2 \n1037  na \n(clause J.9.1.3.3) \n0,1,2 \n1041  na \n(clause J.9.1.3.4) \n0,1,2 \n1044  na \n(clause J.9.1.3.5) \n0,1,2 \n1047  na \n(clause J.9.1.3.6) \n0,1,2 \n1050  na \n(clause J.9.1.3.6) \n \nJ.9.1.3.2  Derivation process of ctxIdxInc for the syntax element mb_vsskip_flag \nOutput of this process is ctxIdxInc. \nThe derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to \nmbAddrA and mbAddrB. \nLet the variable condTermFlagN (with N being either A or B) be derived as follows. \n–  If mbAddrN is not available or mb_vsskip_flag for the macroblock mbAddrN is equal to 1, condTermFlagN is set \nequal to 0. \n–  Otherwise (mbAddrN is available and mb_vsskip_flag for the macroblock mbAddrN is equal to 0), condTermFlagN \nis set equal to 1. \nThe variable ctxIdxInc is derived by: \nctxIdxInc = condTermFlagA + condTermFlagB    (J-81) \nJ.9.1.3.3  Derivation process of ctxIdxInc for the syntax element mb_direct_type_flag \nOutput of this process is ctxIdxInc. \nThe derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to \nmbAddrA and mbAddrB. \nLet the variable condTermFlagN (with N being either A or B) be derived as follows. \n–  If any of the following conditions is true, condTermFlagN is set to 0: \n–  If mbAddrN is not available, \n–  Both mb_vsskip_flag and mb_direct_type_flag for the macroblock mbAddrN is equal to 0 \n–  Otherwise, condTermFlagN is set equal to 1. \nThe variable ctxIdxInc is derived by: \nctxIdxInc = condTermFlagA + condTermFlagB    (J-82) \nJ.9.1.3.4  Derivation process of ctxIdxInc for the syntax element mb_alc_skip_flag \nOutput of this process is ctxIdxInc. \n    Rec. ITU-T H.264 (06/2019)  807 \n \nThe derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to \nmbAddrA and mbAddrB. \nLet the variable condTermFlagN (with N being either A or B) be derived as follows. \n–  If  mbAddrN  is  available  and  mb_alc_skip_flag  or  mb_alc_flag  for  the  macroblock  mbAddrN  is  equal  to  1, \ncondTermFlagN is set equal to 1. \n–  Otherwise (mbAddrN is not available or mb_alc_skip_flag and mb_alc_flag for the macroblock mbAddrN is equal to \n0), condTermFlagN is set equal to 0. \nThe variable ctxIdxInc is derived by \nctxIdxInc = condTermFlagA + condTermFlagB    (J-83) \nJ.9.1.3.5  Derivation process of ctxIdxInc for the syntax element mb_alc_flag \nOutput of this process is ctxIdxInc. \nThe derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to \nmbAddrA and mbAddrB. \nLet the variable condTermFlagN (with N being either A or B) be derived as follows. \n–  If mbAddrN is available and mb_alc_skip_flag or mb_alc_flag for the macroblock mbAddrN is equal to 1, \ncondTermFlagN is set equal to 1. \n–  Otherwise (mbAddrN is not available or mb_alc_skip_flag and mb_alc_flag for the macroblock mbAddrN is \nequal to 0), condTermFlagN is set equal to 0. \nThe variable ctxIdxInc is derived by: \nctxIdxInc = condTermFlagA + condTermFlagB    (J-84) \nJ.9.1.3.6  Derivation process of ctxIdxInc for the syntax element mb_vsp_flag \nOutput of this process is ctxIdxInc. \nThe derivation process for neighbouring macroblocks specified in clause 6.4.11.1 is invoked and the output is assigned to \nmbAddrA and mbAddrB. \nLet the variable condTermFlagN (with N being either A or B) be derived as follows. \n–  If mbAddrN is not available or mb_vsp_flag for the macroblock mbAddrN is equal to 0, condTermFlagN is set equal \nto 1. \n–  Otherwise (mbAddrN is available and mb_vsp_flag for the macroblock mbAddrN is equal to 1), condTermFlagN is \nset equal to 0. \nThe variable ctxIdxInc is derived by: \nctxIdxInc = condTermFlagA + condTermFlagB    (J-85) \nJ.10  Profiles and levels \nThe specifications in Annex I apply. Additional profiles and specific values of profile_idc are specified in the following. \nThe profiles that are specified in clause J.10.1 are also referred to as the profiles specified in Annex J. \nJ.10.1  Profiles \nAll constraints for picture parameter sets that are specified in the following are constraints for picture parameter sets that \nbecome the active picture parameter set or an active view picture parameter set inside the bitstream. All constraints for 3D-\nAVC sequence parameter sets that are specified in the following are constraints for 3D-AVC sequence parameter sets that \nbecome the active 3D-AVC sequence parameter set or an active view 3D-AVC sequence parameter set inside the bitstream. \nJ.10.1.1 Enhanced Multiview Depth High profile \nBitstreams conforming to the Enhanced Multiview Depth High profile shall obey the following constraints: \n–  The base view bitstream as specified in clause I.8.5.3 shall obey all constraints of the High profile specified in \nclause A.2.4 and all active sequence parameter sets shall fulfil one of the following conditions: \n808  Rec. ITU-T H.264 (06/2019) \n \n–  profile_idc is equal to 77 or constraint_set1_flag is equal to 1, \n–  profile_idc is equal to 100. \n–  Only I, P, and B slice types may be present. \n–  NAL unit streams shall not contain nal_unit_type values in the range of 2 to 4, inclusive. \n–  Arbitrary slice order is not allowed. \n–  Picture parameter sets shall have num_slice_groups_minus1 equal to 0 only. \n–  Picture parameter sets shall have redundant_pic_cnt_present_flag equal to 0 only. \n–  When the profile_idc is equal to 139 in a sequence parameter set, the frame_mbs_only_flag in the sequence parameter \nset shall be equal to 1. \n–  3D-AVC sequence parameter sets shall have chroma_format_idc equal to 0 only. \n–  3D-AVC sequence parameter sets shall have bit_depth_luma_minus8 equal to 0 only. \n–  3D-AVC sequence parameter sets shall have bit_depth_chroma_minus8 equal to 0 only. \n–  3D-AVC sequence parameter sets shall have qpprime_y_zero_transform_bypass_flag equal to 0 only. \n–  For each access unit, the value of level_idc for all active view 3D-AVC sequence parameter set RBSPs shall be the \nsame as the value of level_idc for the active 3D-AVC sequence parameter set RBSP. \n–  The level constraints specified for the Enhanced Multiview Depth High profile in clause I.10.2 shall be fulfilled. \nConformance of a bitstream to the Enhanced Multiview Depth High profile is indicated by profile_idc being equal to 139. \nDecoders conforming to the Enhanced Multiview Depth High profile at a specific level shall be capable of decoding all \nbitstreams in which both of the following conditions are true: \na)  All active 3D-AVC sequence parameter sets have one or more of the following conditions fulfilled: \n–  profile_idc is equal to 139, \n–  profile_idc is equal to 138, \n–  profile_idc is equal to 128, \n–  profile_idc is equal to 118 and constraint_set5_flag is equal to 1, \n–  profile_idc is equal to 100, \n–  profile_idc is equal to 77 or constraint_set1_flag is equal to 1. \nb)  All active 3D-AVC sequence parameter sets have one or more of the following conditions fulfilled: \n–  level_idc or (level_idc and constraint_set3_flag) represent a level less than or equal to the specific level, \n–  level_idc[ i ] or (level_idc[ i ] and constraint_set3_flag) represent a level less than or equal to the specific level. \nJ.10.2  Levels \nThe specification of clause I.10.2 applies. \nJ.10.2.1 Level limits for Enhanced Multiview Depth High profile \nThe specification of clause I.10.2.1 applies. \nJ.10.2.2 Profile specific level limits \na)  In bitstreams conforming to the Enhanced Multiview Depth High profile, 3D-AVC sequence parameter sets shall \nhave frame_mbs_only_flag equal to 1 for the levels specified in Table A-4. \nJ.11  Byte stream format \nThe specifications in Annex B apply. \nJ.12  3D-AVC hypothetical reference decoder \nThe specifications in Annex C apply with substituting 3D-AVC sequence parameter set for MVC sequence parameter set. \n    Rec. ITU-T H.264 (06/2019)  809 \n \nJ.13  3D-AVC SEI messages \nThe specifications in Annex D and clause I.13 together with the extensions and modifications specified in this clause apply. \nJ.13.1  SEI message syntax \nJ.13.1.1 Constrained depth parameter set identifier SEI message syntax \n \nconstrained_depth_parameter_set_identifier( payloadSize ) {  C  Descriptor \n  max_dps_id  5  ue(v) \n  max_dps_id_diff  5  ue(v) \n}     \n \nJ.13.2  SEI message semantics \nJ.13.2.1 Constrained depth parameter set identifier SEI message semantics \nWhen present, this message shall be associated with an IDR access unit. The semantics of the message are valid for the \ncurrent  coded  video  sequence.  A  constrained  depth  parameter  set  identifier  SEI  message  indicates  that \ndepth_parameter_set_id and dps_id values present in the coded video sequence are constrained as specified below. \nNOTE 1 – When a constrained depth parameter set identifier SEI message is present, decoders are able to conclude losses of depth \nparameter set NAL units. \nmax_dps_id plus 1 specifies the maximum allowed depth_range_parameter_set_id value. \nmax_dps_id_diff specifies the value range of depth_range_parameter_set_id values marked as \"used\". max_dps_id_diff \n* 2 shall be less than max_dps_id. \nFor each coded slice, the following applies: \n–  For the first coded slice of an IDR access unit, MaxUsedDpsId is set equal to \"no value\", UsedDpsIdSet is an empty \nset of values, and all depth range parameter set RBSPs included in the bitstream or made available to the decoding \nprocess through external means prior to the access unit containing the IDR picture are marked unavailable. \n–  When MaxUsedDpsId is not equal to \"no value\", the value of dps_id of the slice header is constrained and the variable \nupdateMaxUsedDpsIdFlag is set as follows. \n–  If dps_id is equal to 0, the variable updateMaxUsedDpsIdFlag is set equal to 0. \n–  Otherwise, the variable zeroBasedDpsId is equal to dps_id − 1 and dps_id is constrained so that zeroBasedDpsId \nfulfills the following: \n–  If  MaxUsedDpsId  >=  max_dps_id_diff  and  MaxUsedDpsId  <=  max_dps_id − max_dps_id_diff, \nzeroBasedDpsId  is  in  the  range  of  MaxUsedDpsId  −  max_dps_id_diff  to \nMaxUsedDpsId + max_dps_id_diff,  inclusive.  The  variable  updateMaxUsedDpsIdFlag  is  set  equal  to \n( zeroBasedDpsId > MaxUsedDpsId ). \n–  Otherwise,  if  MaxUsedDpsId  <  max_dps_id_diff,  zeroBasedDpsId  is  either  in  the  range  of  0  to \nMaxUsedDpsId + max_dps_id_diff,  inclusive,  or  in  the  range  of  max_dps_id  −  ( max_dps_id_diff  − \nMaxUsedDpsId  −  1 )  to  max_dps_id,  inclusive.  The  updateMaxUsedDpsIdFlag  is  set  equal  to \n( zeroBasedDpsId  >  MaxUsedDpsId    &&    zeroBasedDpsId  <  max_dps_id  −  ( max_dps_id_diff  − \nMaxUsedDpsId − 1 ) ). \n–  Otherwise (MaxUsedDpsId > max_dps_id − max_dps_id_diff), zeroBasedDpsId is either in the range of 0 \nto max_dps_id_diff − ( max_dps_id − MaxUsedDpsId ) − 1, inclusive, or in the range of MaxUsedDpsId − \nmax_dps_id_diff  to  max_dps_id,  inclusive.  The  updateMaxUsedDpsIdFlag  is  set  equal  to \n( zeroBasedDpsId  >  MaxUsedDpsId    | |    zeroBasedDpsId  <  max_dps_id_diff  −  ( max_dps_id  − \nMaxUsedDpsId ) ). \n–  When updateMaxUsedDpsIdFlag is equal to 1, depth range parameter set RBSPs are marked as unavailable as \nfollows: \n810  Rec. ITU-T H.264 (06/2019) \n \nprevMinUsedDpsId = MaxUsedDpsId − max_dps_id_diff \nif( prevMinUsedDpsId < 0 ) \n  prevMinUsedDpsId += max_dps_id \nminUsedDpsId = dps_id − 1 − max_dps_id_diff \nif( minUsedDpsId < 0 ) \n  minUsedDpsId += max_dps_id    (J-86) \ni = prevMinUsedDpsId \ndo { \n  Mark depth range parameter set RBSP with depth_range_parameter_set_id equal to i + 1,  \n  if present, as unavailable. \n  i = ( i + 1 ) % ( max_dps_id + 1 ) \n} while( i != minUsedDpsId ) \n–  When updateMaxUsedDpsIdFlag is equal to 1 or MaxUsedDpsId is equal to \"no value\", the following applies: \n–  MaxUsedDpsId is set equal to dps_id − 1. \n–  If MaxUsedDpsId is greater than or equal to max_dps_id_diff, UsedDpsIdSet is set to the values in the range of \nMaxUsedDpsId − max_dps_id_diff to MaxUsedDpsId, inclusive. \n–  Otherwise (MaxUsedDpsId is smaller than max_dps_id_diff), UsedDpsIdSet is set to the values in the range of \n0 to MaxUsedDpsId, inclusive, and in the range of max_dps_id − ( max_dps_id_diff − MaxUsedDpsId ) to \nmax_dps_id, inclusive. \nAny depth parameter set RBSP included in the bitstream or made available to the decoding process through external means \nand having depth_parameter_set_id equal to any value included in UsedDpsIdSet + 1 has the same content as the previous \ndepth parameter set RBSP included in the bitstream or made available to the decoding process through external means \nhaving the same depth_range_parameter_id value. \nNOTE 2 – If a slice header includes a dps_id value marked as unavailable, a decoder should infer an unintentional loss of a depth \nparameter set with depth_parameter_set_id value equal to the dps_id value of the slice header. \nJ.14  Video usability information \nThe specifications in clause I.14 apply. \n    Rec. ITU-T H.264 (06/2019)  811 \n \n \n \n \n \n \nSERIES OF ITU-T RECOMMENDATIONS \nSeries A  Organization of the work of ITU-T \nSeries D  Tariff and accounting principles and international telecommunication/ICT economic and \npolicy issues \nSeries E  Overall network operation, telephone service, service operation and human factors \nSeries F  Non-telephone telecommunication services \nSeries G  Transmission systems and media, digital systems and networks \nSeries H  Audiovisual and multimedia systems \nSeries I  Integrated services digital network \nSeries J  Cable networks and transmission of television, sound programme and other multimedia \nsignals \nSeries K  Protection against interference \nSeries L  Environment and ICTs, climate change, e-waste, energy efficiency; construction, installation \nand protection of cables and other elements of outside plant \nSeries M  Telecommunication management, including TMN and network maintenance \nSeries N  Maintenance: international sound programme and television transmission circuits \nSeries O  Specifications of measuring equipment \nSeries P  Telephone transmission quality, telephone installations, local line networks \nSeries Q  Switching and signalling, and associated measurements and tests \nSeries R  Telegraph transmission \nSeries S  Telegraph services terminal equipment \nSeries T  Terminals for telematic services \nSeries U  Telegraph switching \nSeries V  Data communication over the telephone network \nSeries X  Data networks, open system communications and security \nSeries Y  Global information infrastructure, Internet protocol aspects, next-generation networks, \nInternet of Things and smart cities \nSeries Z  Languages and general software aspects for telecommunication systems \n   \n \n \nPrinted in Switzerland \nGeneva, 2019",
      "page_number": -1,
      "images": [],
      "structure": [
        [
          "P",
          "Annex"
        ],
        [
          "A",
          "A"
        ]
      ],
      "type": "Annex"
    }
  ]
}